function _mergeNamespaces(n4, m2) {
  for (var i3 = 0; i3 < m2.length; i3++) {
    const e2 = m2[i3];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k4 in e2) {
        if (k4 !== "default" && !(k4 in n4)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k4);
          if (d2) {
            Object.defineProperty(n4, k4, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k4]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n4, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n4) {
  if (n4.__esModule)
    return n4;
  var f3 = n4.default;
  if (typeof f3 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f3, arguments, this.constructor);
      }
      return f3.apply(this, arguments);
    };
    a2.prototype = f3.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n4).forEach(function(k4) {
    var d2 = Object.getOwnPropertyDescriptor(n4, k4);
    Object.defineProperty(a2, k4, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n4[k4];
      }
    });
  });
  return a2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$8 = Symbol.for("react.element"), n$f = Symbol.for("react.portal"), p$9 = Symbol.for("react.fragment"), q$3 = Symbol.for("react.strict_mode"), r$i = Symbol.for("react.profiler"), t$9 = Symbol.for("react.provider"), u$5 = Symbol.for("react.context"), v$5 = Symbol.for("react.forward_ref"), w$4 = Symbol.for("react.suspense"), x$4 = Symbol.for("react.memo"), y$6 = Symbol.for("react.lazy"), z$4 = Symbol.iterator;
function A$5(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$4 && a2[z$4] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$2 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$4 = Object.assign, D$2 = {};
function E$3(a2, b3, e2) {
  this.props = a2;
  this.context = b3;
  this.refs = D$2;
  this.updater = e2 || B$2;
}
E$3.prototype.isReactComponent = {};
E$3.prototype.setState = function(a2, b3) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b3, "setState");
};
E$3.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$1() {
}
F$1.prototype = E$3.prototype;
function G$2(a2, b3, e2) {
  this.props = a2;
  this.context = b3;
  this.refs = D$2;
  this.updater = e2 || B$2;
}
var H$4 = G$2.prototype = new F$1();
H$4.constructor = G$2;
C$4(H$4, E$3.prototype);
H$4.isPureReactComponent = true;
var I$3 = Array.isArray, J$1 = Object.prototype.hasOwnProperty, K$3 = { current: null }, L$4 = { key: true, ref: true, __self: true, __source: true };
function M$3(a2, b3, e2) {
  var d2, c2 = {}, k4 = null, h4 = null;
  if (null != b3)
    for (d2 in void 0 !== b3.ref && (h4 = b3.ref), void 0 !== b3.key && (k4 = "" + b3.key), b3)
      J$1.call(b3, d2) && !L$4.hasOwnProperty(d2) && (c2[d2] = b3[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f3 = Array(g2), m2 = 0; m2 < g2; m2++)
      f3[m2] = arguments[m2 + 2];
    c2.children = f3;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$8, type: a2, key: k4, ref: h4, props: c2, _owner: K$3.current };
}
function N$4(a2, b3) {
  return { $$typeof: l$8, type: a2.type, key: b3, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$2(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$8;
}
function escape(a2) {
  var b3 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b3[a3];
  });
}
var P$5 = /\/+/g;
function Q$2(a2, b3) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b3.toString(36);
}
function R$4(a2, b3, e2, d2, c2) {
  var k4 = typeof a2;
  if ("undefined" === k4 || "boolean" === k4)
    a2 = null;
  var h4 = false;
  if (null === a2)
    h4 = true;
  else
    switch (k4) {
      case "string":
      case "number":
        h4 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$8:
          case n$f:
            h4 = true;
        }
    }
  if (h4)
    return h4 = a2, c2 = c2(h4), a2 = "" === d2 ? "." + Q$2(h4, 0) : d2, I$3(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$5, "$&/") + "/"), R$4(c2, b3, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O$2(c2) && (c2 = N$4(c2, e2 + (!c2.key || h4 && h4.key === c2.key ? "" : ("" + c2.key).replace(P$5, "$&/") + "/") + a2)), b3.push(c2)), 1;
  h4 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$3(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k4 = a2[g2];
      var f3 = d2 + Q$2(k4, g2);
      h4 += R$4(k4, b3, e2, f3, c2);
    }
  else if (f3 = A$5(a2), "function" === typeof f3)
    for (a2 = f3.call(a2), g2 = 0; !(k4 = a2.next()).done; )
      k4 = k4.value, f3 = d2 + Q$2(k4, g2++), h4 += R$4(k4, b3, e2, f3, c2);
  else if ("object" === k4)
    throw b3 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b3 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b3) + "). If you meant to render a collection of children, use an array instead.");
  return h4;
}
function S$6(a2, b3, e2) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$4(a2, d2, "", "", function(a3) {
    return b3.call(e2, a3, c2++);
  });
  return d2;
}
function T$4(a2) {
  if (-1 === a2._status) {
    var b3 = a2._result;
    b3 = b3();
    b3.then(function(b4) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b4;
    }, function(b4) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b4;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b3);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$2 = { current: null }, V$4 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$4, ReactCurrentOwner: K$3 };
react_production_min.Children = { map: S$6, forEach: function(a2, b3, e2) {
  S$6(a2, function() {
    b3.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b3 = 0;
  S$6(a2, function() {
    b3++;
  });
  return b3;
}, toArray: function(a2) {
  return S$6(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$2(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$3;
react_production_min.Fragment = p$9;
react_production_min.Profiler = r$i;
react_production_min.PureComponent = G$2;
react_production_min.StrictMode = q$3;
react_production_min.Suspense = w$4;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.cloneElement = function(a2, b3, e2) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$4({}, a2.props), c2 = a2.key, k4 = a2.ref, h4 = a2._owner;
  if (null != b3) {
    void 0 !== b3.ref && (k4 = b3.ref, h4 = K$3.current);
    void 0 !== b3.key && (c2 = "" + b3.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f3 in b3)
      J$1.call(b3, f3) && !L$4.hasOwnProperty(f3) && (d2[f3] = void 0 === b3[f3] && void 0 !== g2 ? g2[f3] : b3[f3]);
  }
  var f3 = arguments.length - 2;
  if (1 === f3)
    d2.children = e2;
  else if (1 < f3) {
    g2 = Array(f3);
    for (var m2 = 0; m2 < f3; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$8, type: a2.type, key: c2, ref: k4, props: d2, _owner: h4 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$5, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$9, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$3;
react_production_min.createFactory = function(a2) {
  var b3 = M$3.bind(null, a2);
  b3.type = a2;
  return b3;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$5, render: a2 };
};
react_production_min.isValidElement = O$2;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$6, _payload: { _status: -1, _result: a2 }, _init: T$4 };
};
react_production_min.memo = function(a2, b3) {
  return { $$typeof: x$4, type: a2, compare: void 0 === b3 ? null : b3 };
};
react_production_min.startTransition = function(a2) {
  var b3 = V$4.transition;
  V$4.transition = {};
  try {
    a2();
  } finally {
    V$4.transition = b3;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b3) {
  return U$2.current.useCallback(a2, b3);
};
react_production_min.useContext = function(a2) {
  return U$2.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$2.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b3) {
  return U$2.current.useEffect(a2, b3);
};
react_production_min.useId = function() {
  return U$2.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b3, e2) {
  return U$2.current.useImperativeHandle(a2, b3, e2);
};
react_production_min.useInsertionEffect = function(a2, b3) {
  return U$2.current.useInsertionEffect(a2, b3);
};
react_production_min.useLayoutEffect = function(a2, b3) {
  return U$2.current.useLayoutEffect(a2, b3);
};
react_production_min.useMemo = function(a2, b3) {
  return U$2.current.useMemo(a2, b3);
};
react_production_min.useReducer = function(a2, b3, e2) {
  return U$2.current.useReducer(a2, b3, e2);
};
react_production_min.useRef = function(a2) {
  return U$2.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$2.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b3, e2) {
  return U$2.current.useSyncExternalStore(a2, b3, e2);
};
react_production_min.useTransition = function() {
  return U$2.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const ReactExports = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: ReactExports
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$b = reactExports, k$5 = Symbol.for("react.element"), l$7 = Symbol.for("react.fragment"), m$6 = Object.prototype.hasOwnProperty, n$e = f$b.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$8 = { key: true, ref: true, __self: true, __source: true };
function q$2(c2, a2, g2) {
  var b3, d2 = {}, e2 = null, h4 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h4 = a2.ref);
  for (b3 in a2)
    m$6.call(a2, b3) && !p$8.hasOwnProperty(b3) && (d2[b3] = a2[b3]);
  if (c2 && c2.defaultProps)
    for (b3 in a2 = c2.defaultProps, a2)
      void 0 === d2[b3] && (d2[b3] = a2[b3]);
  return { $$typeof: k$5, type: c2, key: e2, ref: h4, props: d2, _owner: n$e.current };
}
reactJsxRuntime_production_min.Fragment = l$7;
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f3(a2, b3) {
    var c2 = a2.length;
    a2.push(b3);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b3))
          a2[d2] = b3, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h4(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k4(a2) {
    if (0 === a2.length)
      return null;
    var b3 = a2[0], c2 = a2.pop();
    if (c2 !== b3) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n4 = m2 + 1, x2 = a2[n4];
          if (0 > g2(C2, c2))
            n4 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n4] = c2, d2 = n4) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n4 < e2 && 0 > g2(x2, c2))
            a2[d2] = x2, a2[n4] = c2, d2 = n4;
          else
            break a;
        }
    }
    return b3;
  }
  function g2(a2, b3) {
    var c2 = a2.sortIndex - b3.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b3.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b3 = h4(t2); null !== b3; ) {
      if (null === b3.callback)
        k4(t2);
      else if (b3.startTime <= a2)
        k4(t2), b3.sortIndex = b3.expirationTime, f3(r2, b3);
      else
        break;
      b3 = h4(t2);
    }
  }
  function H4(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (null !== h4(r2))
        A2 = true, I3(J2);
      else {
        var b3 = h4(t2);
        null !== b3 && K2(H4, b3.startTime - a2);
      }
  }
  function J2(a2, b3) {
    A2 = false;
    B2 && (B2 = false, E2(L4), L4 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b3);
      for (v2 = h4(r2); null !== v2 && (!(v2.expirationTime > b3) || a2 && !M3()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b3);
          b3 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h4(r2) && k4(r2);
          G2(b3);
        } else
          k4(r2);
        v2 = h4(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h4(t2);
        null !== m2 && K2(H4, m2.startTime - b3);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L4 = -1, P2 = 5, Q2 = -1;
  function M3() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R3() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b3 = true;
      try {
        b3 = O2(true, a2);
      } finally {
        b3 ? S4() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S4;
  if ("function" === typeof F2)
    S4 = function() {
      F2(R3);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R3;
    S4 = function() {
      U2.postMessage(null);
    };
  } else
    S4 = function() {
      D2(R3, 0);
    };
  function I3(a2) {
    O2 = a2;
    N2 || (N2 = true, S4());
  }
  function K2(a2, b3) {
    L4 = D2(function() {
      a2(exports.unstable_now());
    }, b3);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I3(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h4(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b3 = 3;
        break;
      default:
        b3 = y2;
    }
    var c2 = y2;
    y2 = b3;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b3) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b3();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b3, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b3, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f3(t2, a2), null === h4(r2) && a2 === h4(t2) && (B2 ? (E2(L4), L4 = -1) : B2 = true, K2(H4, c2 - d2))) : (a2.sortIndex = e2, f3(r2, a2), A2 || z2 || (A2 = true, I3(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M3;
  exports.unstable_wrapCallback = function(a2) {
    var b3 = y2;
    return function() {
      var c2 = y2;
      y2 = b3;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$7(a2) {
  for (var b3 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b3 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b3 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b3) {
  ha(a2, b3);
  ha(a2 + "Capture", b3);
}
function ha(a2, b3) {
  ea[a2] = b3;
  for (a2 = 0; a2 < b3.length; a2++)
    da.add(b3[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b3, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b3) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b3, c2, d2) {
  if (null === b3 || "undefined" === typeof b3 || pa(a2, b3, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b3;
      case 4:
        return false === b3;
      case 5:
        return isNaN(b3);
      case 6:
        return isNaN(b3) || 1 > b3;
    }
  return false;
}
function v$4(a2, b3, c2, d2, e2, f3, g2) {
  this.acceptsBooleans = 2 === b3 || 3 === b3 || 4 === b3;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b3;
  this.sanitizeURL = f3;
  this.removeEmptyString = g2;
}
var z$3 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$3[a2] = new v$4(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b3 = a2[0];
  z$3[b3] = new v$4(b3, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$3[a2] = new v$4(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b3 = a2.replace(
    ra,
    sa
  );
  z$3[b3] = new v$4(b3, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b3 = a2.replace(ra, sa);
  z$3[b3] = new v$4(b3, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b3 = a2.replace(ra, sa);
  z$3[b3] = new v$4(b3, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$3.xlinkHref = new v$4("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b3, c2, d2) {
  var e2 = z$3.hasOwnProperty(b3) ? z$3[b3] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b3.length) || "o" !== b3[0] && "O" !== b3[0] || "n" !== b3[1] && "N" !== b3[1])
    qa(b3, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b3) && (null === c2 ? a2.removeAttribute(b3) : a2.setAttribute(b3, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b3 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b3) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b3, c2) : a2.setAttribute(b3, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$4 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b3 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b3 && b3[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b3) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b3)
      if (b3 = function() {
        throw Error();
      }, Object.defineProperty(b3.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b3, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b3);
      } else {
        try {
          b3.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b3.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f3 = d2.stack.split("\n"), g2 = e2.length - 1, h4 = f3.length - 1; 1 <= g2 && 0 <= h4 && e2[g2] !== f3[h4]; )
        h4--;
      for (; 1 <= g2 && 0 <= h4; g2--, h4--)
        if (e2[g2] !== f3[h4]) {
          if (1 !== g2 || 1 !== h4) {
            do
              if (g2--, h4--, 0 > h4 || e2[g2] !== f3[h4]) {
                var k4 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k4.includes("<anonymous>") && (k4 = k4.replace("<anonymous>", a2.displayName));
                return k4;
              }
            while (1 <= g2 && 0 <= h4);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b3 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b3.displayName || b3.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b3 = a2.displayName || null, null !== b3 ? b3 : Qa(a2.type) || "Memo";
      case Ha:
        b3 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b3));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b3 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b3.displayName || "Context") + ".Consumer";
    case 10:
      return (b3._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b3.render, a2 = a2.displayName || a2.name || "", b3.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b3;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b3);
    case 8:
      return b3 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b3)
        return b3.displayName || b3.name || null;
      if ("string" === typeof b3)
        return b3;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b3 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b3 || "radio" === b3);
}
function Ua(a2) {
  var b3 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b3), d2 = "" + a2[b3];
  if (!a2.hasOwnProperty(b3) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f3 = c2.set;
    Object.defineProperty(a2, b3, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f3.call(this, a3);
    } });
    Object.defineProperty(a2, b3, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b3];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b3 = a2._valueTracker;
  if (!b3)
    return true;
  var c2 = b3.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b3.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b3) {
    return a2.body;
  }
}
function Ya(a2, b3) {
  var c2 = b3.checked;
  return A$4({}, b3, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b3) {
  var c2 = null == b3.defaultValue ? "" : b3.defaultValue, d2 = null != b3.checked ? b3.checked : b3.defaultChecked;
  c2 = Sa(null != b3.value ? b3.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b3.type || "radio" === b3.type ? null != b3.checked : null != b3.value };
}
function ab(a2, b3) {
  b3 = b3.checked;
  null != b3 && ta(a2, "checked", b3, false);
}
function bb(a2, b3) {
  ab(a2, b3);
  var c2 = Sa(b3.value), d2 = b3.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b3.hasOwnProperty("value") ? cb(a2, b3.type, c2) : b3.hasOwnProperty("defaultValue") && cb(a2, b3.type, Sa(b3.defaultValue));
  null == b3.checked && null != b3.defaultChecked && (a2.defaultChecked = !!b3.defaultChecked);
}
function db(a2, b3, c2) {
  if (b3.hasOwnProperty("value") || b3.hasOwnProperty("defaultValue")) {
    var d2 = b3.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b3.value && null !== b3.value))
      return;
    b3 = "" + a2._wrapperState.initialValue;
    c2 || b3 === a2.value || (a2.value = b3);
    a2.defaultValue = b3;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b3, c2) {
  if ("number" !== b3 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b3, c2, d2) {
  a2 = a2.options;
  if (b3) {
    b3 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b3["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b3.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b3 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b3 || a2[e2].disabled || (b3 = a2[e2]);
    }
    null !== b3 && (b3.selected = true);
  }
}
function gb(a2, b3) {
  if (null != b3.dangerouslySetInnerHTML)
    throw Error(p$7(91));
  return A$4({}, b3, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b3) {
  var c2 = b3.value;
  if (null == c2) {
    c2 = b3.children;
    b3 = b3.defaultValue;
    if (null != c2) {
      if (null != b3)
        throw Error(p$7(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$7(93));
        c2 = c2[0];
      }
      b3 = c2;
    }
    null == b3 && (b3 = "");
    c2 = b3;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b3) {
  var c2 = Sa(b3.value), d2 = Sa(b3.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b3.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b3 = a2.textContent;
  b3 === a2._wrapperState.initialValue && "" !== b3 && null !== b3 && (a2.value = b3);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b3) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b3) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b3 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b3, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b3, c2, d2, e2);
    });
  } : a2;
}(function(a2, b3) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b3;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b3.valueOf().toString() + "</svg>";
    for (b3 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b3.firstChild; )
      a2.appendChild(b3.firstChild);
  }
});
function ob(a2, b3) {
  if (b3) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b3;
      return;
    }
  }
  a2.textContent = b3;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b3) {
    b3 = b3 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b3] = pb[a2];
  });
});
function rb(a2, b3, c2) {
  return null == b3 || "boolean" === typeof b3 || "" === b3 ? "" : c2 || "number" !== typeof b3 || 0 === b3 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b3).trim() : b3 + "px";
}
function sb(a2, b3) {
  a2 = a2.style;
  for (var c2 in b3)
    if (b3.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b3[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var tb = A$4({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b3) {
  if (b3) {
    if (tb[a2] && (null != b3.children || null != b3.dangerouslySetInnerHTML))
      throw Error(p$7(137, a2));
    if (null != b3.dangerouslySetInnerHTML) {
      if (null != b3.children)
        throw Error(p$7(60));
      if ("object" !== typeof b3.dangerouslySetInnerHTML || !("__html" in b3.dangerouslySetInnerHTML))
        throw Error(p$7(61));
    }
    if (null != b3.style && "object" !== typeof b3.style)
      throw Error(p$7(62));
  }
}
function vb(a2, b3) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b3.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$7(280));
    var b3 = a2.stateNode;
    b3 && (b3 = Db(b3), yb(a2.stateNode, a2.type, b3));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b3 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b3)
      for (a2 = 0; a2 < b3.length; a2++)
        Bb(b3[a2]);
  }
}
function Gb(a2, b3) {
  return a2(b3);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b3, c2) {
  if (Ib)
    return a2(b3, c2);
  Ib = true;
  try {
    return Gb(a2, b3, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b3) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b3];
  a:
    switch (b3) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$7(231, b3, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b3, c2, d2, e2, f3, g2, h4, k4) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b3.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b3, c2, d2, e2, f3, g2, h4, k4) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b3, c2, d2, e2, f3, g2, h4, k4) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$7(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b3 = a2, c2 = a2;
  if (a2.alternate)
    for (; b3.return; )
      b3 = b3.return;
  else {
    a2 = b3;
    do
      b3 = a2, 0 !== (b3.flags & 4098) && (c2 = b3.return), a2 = b3.return;
    while (a2);
  }
  return 3 === b3.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b3 = a2.memoizedState;
    null === b3 && (a2 = a2.alternate, null !== a2 && (b3 = a2.memoizedState));
    if (null !== b3)
      return b3.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$7(188));
}
function Yb(a2) {
  var b3 = a2.alternate;
  if (!b3) {
    b3 = Vb(a2);
    if (null === b3)
      throw Error(p$7(188));
    return b3 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b3; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f3 = e2.alternate;
    if (null === f3) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f3.child) {
      for (f3 = e2.child; f3; ) {
        if (f3 === c2)
          return Xb(e2), a2;
        if (f3 === d2)
          return Xb(e2), b3;
        f3 = f3.sibling;
      }
      throw Error(p$7(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f3;
    else {
      for (var g2 = false, h4 = e2.child; h4; ) {
        if (h4 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f3;
          break;
        }
        if (h4 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f3;
          break;
        }
        h4 = h4.sibling;
      }
      if (!g2) {
        for (h4 = f3.child; h4; ) {
          if (h4 === c2) {
            g2 = true;
            c2 = f3;
            d2 = e2;
            break;
          }
          if (h4 === d2) {
            g2 = true;
            d2 = f3;
            c2 = e2;
            break;
          }
          h4 = h4.sibling;
        }
        if (!g2)
          throw Error(p$7(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$7(190));
  }
  if (3 !== c2.tag)
    throw Error(p$7(188));
  return c2.stateNode.current === c2 ? a2 : b3;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b3 = $b(a2);
    if (null !== b3)
      return b3;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$1 = ca.unstable_now, ec$1 = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b3) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b3) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f3 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h4 = g2 & ~e2;
    0 !== h4 ? d2 = tc(h4) : (f3 &= g2, 0 !== f3 && (d2 = tc(f3)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f3 && (d2 = tc(f3));
  if (0 === d2)
    return 0;
  if (0 !== b3 && b3 !== d2 && 0 === (b3 & e2) && (e2 = d2 & -d2, f3 = b3 & -b3, e2 >= f3 || 16 === e2 && 0 !== (f3 & 4194240)))
    return b3;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b3 = a2.entangledLanes;
  if (0 !== b3)
    for (a2 = a2.entanglements, b3 &= d2; 0 < b3; )
      c2 = 31 - oc(b3), e2 = 1 << c2, d2 |= a2[c2], b3 &= ~e2;
  return d2;
}
function vc(a2, b3) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b3 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b3 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b3) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f3 = a2.pendingLanes; 0 < f3; ) {
    var g2 = 31 - oc(f3), h4 = 1 << g2, k4 = e2[g2];
    if (-1 === k4) {
      if (0 === (h4 & c2) || 0 !== (h4 & d2))
        e2[g2] = vc(h4, b3);
    } else
      k4 <= b3 && (a2.expiredLanes |= h4);
    f3 &= ~h4;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b3 = [], c2 = 0; 31 > c2; c2++)
    b3.push(a2);
  return b3;
}
function Ac(a2, b3, c2) {
  a2.pendingLanes |= b3;
  536870912 !== b3 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b3 = 31 - oc(b3);
  a2[b3] = c2;
}
function Bc(a2, b3) {
  var c2 = a2.pendingLanes & ~b3;
  a2.pendingLanes = b3;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b3;
  a2.mutableReadLanes &= b3;
  a2.entangledLanes &= b3;
  b3 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f3 = 1 << e2;
    b3[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f3;
  }
}
function Cc(a2, b3) {
  var c2 = a2.entangledLanes |= b3;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b3 | a2[d2] & b3 && (a2[d2] |= b3);
    c2 &= ~e2;
  }
}
var C$3 = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b3) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b3.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b3.pointerId);
  }
}
function Tc(a2, b3, c2, d2, e2, f3) {
  if (null === a2 || a2.nativeEvent !== f3)
    return a2 = { blockedOn: b3, domEventName: c2, eventSystemFlags: d2, nativeEvent: f3, targetContainers: [e2] }, null !== b3 && (b3 = Cb(b3), null !== b3 && Fc(b3)), a2;
  a2.eventSystemFlags |= d2;
  b3 = a2.targetContainers;
  null !== e2 && -1 === b3.indexOf(e2) && b3.push(e2);
  return a2;
}
function Uc(a2, b3, c2, d2, e2) {
  switch (b3) {
    case "focusin":
      return Lc = Tc(Lc, a2, b3, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b3, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b3, c2, d2, e2), true;
    case "pointerover":
      var f3 = e2.pointerId;
      Oc.set(f3, Tc(Oc.get(f3) || null, a2, b3, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f3 = e2.pointerId, Pc.set(f3, Tc(Pc.get(f3) || null, a2, b3, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b3 = Wc(a2.target);
  if (null !== b3) {
    var c2 = Vb(b3);
    if (null !== c2) {
      if (b3 = c2.tag, 13 === b3) {
        if (b3 = Wb(c2), null !== b3) {
          a2.blockedOn = b3;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b3 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b3 = a2.targetContainers; 0 < b3.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b3[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b3 = Cb(c2), null !== b3 && Fc(b3), a2.blockedOn = c2, false;
    b3.shift();
  }
  return true;
}
function Zc(a2, b3, c2) {
  Xc(a2) && c2.delete(b3);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b3) {
  a2.blockedOn === b3 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b3(b4) {
    return ad(b4, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b3);
  Pc.forEach(b3);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b3, c2, d2) {
  var e2 = C$3, f3 = cd.transition;
  cd.transition = null;
  try {
    C$3 = 1, fd(a2, b3, c2, d2);
  } finally {
    C$3 = e2, cd.transition = f3;
  }
}
function gd(a2, b3, c2, d2) {
  var e2 = C$3, f3 = cd.transition;
  cd.transition = null;
  try {
    C$3 = 4, fd(a2, b3, c2, d2);
  } finally {
    C$3 = e2, cd.transition = f3;
  }
}
function fd(a2, b3, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b3, c2, d2);
    if (null === e2)
      hd(a2, b3, d2, id$2, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b3, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b3 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f3 = Cb(e2);
        null !== f3 && Ec(f3);
        f3 = Yc(a2, b3, c2, d2);
        null === f3 && hd(a2, b3, d2, id$2, c2);
        if (f3 === e2)
          break;
        e2 = f3;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a2, b3, d2, null, c2);
  }
}
var id$2 = null;
function Yc(a2, b3, c2, d2) {
  id$2 = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b3 = Vb(a2), null === b3)
      a2 = null;
    else if (c2 = b3.tag, 13 === c2) {
      a2 = Wb(b3);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b3.stateNode.current.memoizedState.isDehydrated)
        return 3 === b3.tag ? b3.stateNode.containerInfo : null;
      a2 = null;
    } else
      b3 !== a2 && (a2 = null);
  id$2 = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec$1()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b3 = ld, c2 = b3.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f3 = e2.length;
  for (a2 = 0; a2 < c2 && b3[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b3[c2 - d2] === e2[f3 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b3 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b3 && (a2 = 13)) : a2 = b3;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b3(b4, d2, e2, f3, g2) {
    this._reactName = b4;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f3;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b4 = a2[c2], this[c2] = b4 ? b4(f3) : f3[c2]);
    this.isDefaultPrevented = (null != f3.defaultPrevented ? f3.defaultPrevented : false === f3.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$4(b3.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b3;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$4({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$4({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$4({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$4({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$4({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$4({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$4({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b3 = this.nativeEvent;
  return b3.getModifierState ? b3.getModifierState(a2) : (a2 = Od[a2]) ? !!b3[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$4({}, ud, { key: function(a2) {
  if (a2.key) {
    var b3 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b3)
      return b3;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$4({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$4({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$4({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$4({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$1 = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce$1 = ia && "TextEvent" in window && !be, de = ia && (!ae$1 || be && 8 < be && 11 >= be), ee$1 = String.fromCharCode(32), fe = false;
function ge(a2, b3) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b3.keyCode);
    case "keydown":
      return 229 !== b3.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie$1 = false;
function je$1(a2, b3) {
  switch (a2) {
    case "compositionend":
      return he(b3);
    case "keypress":
      if (32 !== b3.which)
        return null;
      fe = true;
      return ee$1;
    case "textInput":
      return a2 = b3.data, a2 === ee$1 && fe ? null : a2;
    default:
      return null;
  }
}
function ke$1(a2, b3) {
  if (ie$1)
    return "compositionend" === a2 || !ae$1 && ge(a2, b3) ? (a2 = nd(), md = ld = kd = null, ie$1 = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b3.ctrlKey || b3.altKey || b3.metaKey) || b3.ctrlKey && b3.altKey) {
        if (b3.char && 1 < b3.char.length)
          return b3.char;
        if (b3.which)
          return String.fromCharCode(b3.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b3.locale ? null : b3.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a2) {
  var b3 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b3 ? !!le[a2.type] : "textarea" === b3 ? true : false;
}
function ne(a2, b3, c2, d2) {
  Eb(d2);
  b3 = oe$1(b3, "onChange");
  0 < b3.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b3 }));
}
var pe = null, qe$1 = null;
function re$1(a2) {
  se$1(a2, 0);
}
function te$1(a2) {
  var b3 = ue(a2);
  if (Wa(b3))
    return a2;
}
function ve$1(a2, b3) {
  if ("change" === a2)
    return b3;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze$1 = document.createElement("div");
      ze$1.setAttribute("oninput", "return;");
      ye = "function" === typeof ze$1.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe && (pe.detachEvent("onpropertychange", Be$1), qe$1 = pe = null);
}
function Be$1(a2) {
  if ("value" === a2.propertyName && te$1(qe$1)) {
    var b3 = [];
    ne(b3, qe$1, a2, xb(a2));
    Jb(re$1, b3);
  }
}
function Ce$1(a2, b3, c2) {
  "focusin" === a2 ? (Ae$1(), pe = b3, qe$1 = c2, pe.attachEvent("onpropertychange", Be$1)) : "focusout" === a2 && Ae$1();
}
function De$1(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te$1(qe$1);
}
function Ee(a2, b3) {
  if ("click" === a2)
    return te$1(b3);
}
function Fe(a2, b3) {
  if ("input" === a2 || "change" === a2)
    return te$1(b3);
}
function Ge$1(a2, b3) {
  return a2 === b3 && (0 !== a2 || 1 / a2 === 1 / b3) || a2 !== a2 && b3 !== b3;
}
var He$1 = "function" === typeof Object.is ? Object.is : Ge$1;
function Ie(a2, b3) {
  if (He$1(a2, b3))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b3 || null === b3)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b3);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b3, e2) || !He$1(a2[e2], b3[e2]))
      return false;
  }
  return true;
}
function Je$1(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke$1(a2, b3) {
  var c2 = Je$1(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b3 && d2 >= b3)
        return { node: c2, offset: b3 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je$1(c2);
  }
}
function Le(a2, b3) {
  return a2 && b3 ? a2 === b3 ? true : a2 && 3 === a2.nodeType ? false : b3 && 3 === b3.nodeType ? Le(a2, b3.parentNode) : "contains" in a2 ? a2.contains(b3) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b3) & 16) : false : false;
}
function Me$1() {
  for (var a2 = window, b3 = Xa(); b3 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b3.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b3.contentWindow;
    else
      break;
    b3 = Xa(a2.document);
  }
  return b3;
}
function Ne(a2) {
  var b3 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b3 && ("input" === b3 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b3 || "true" === a2.contentEditable);
}
function Oe(a2) {
  var b3 = Me$1(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b3 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b3 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b3), "selectionStart" in c2)
        c2.selectionStart = b3, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b3 = c2.ownerDocument || document) && b3.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f3 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f3 : Math.min(d2.end, e2);
        !a2.extend && f3 > d2 && (e2 = d2, d2 = f3, f3 = e2);
        e2 = Ke$1(c2, f3);
        var g2 = Ke$1(
          c2,
          d2
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b3 = b3.createRange(), b3.setStart(e2.node, e2.offset), a2.removeAllRanges(), f3 > d2 ? (a2.addRange(b3), a2.extend(g2.node, g2.offset)) : (b3.setEnd(g2.node, g2.offset), a2.addRange(b3)));
      }
    }
    b3 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b3.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b3.length; c2++)
      a2 = b3[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe$1 = ia && "documentMode" in document && 11 >= document.documentMode, Qe$1 = null, Re$1 = null, Se = null, Te$1 = false;
function Ue$1(a2, b3, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te$1 || null == Qe$1 || Qe$1 !== Xa(d2) || (d2 = Qe$1, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe$1(Re$1, "onSelect"), 0 < d2.length && (b3 = new td("onSelect", "select", null, b3, c2), a2.push({ event: b3, listeners: d2 }), b3.target = Qe$1)));
}
function Ve$1(a2, b3) {
  var c2 = {};
  c2[a2.toLowerCase()] = b3.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b3;
  c2["Moz" + a2] = "moz" + b3;
  return c2;
}
var We$1 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe$1 = {}, Ye$1 = {};
ia && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
function Ze$1(a2) {
  if (Xe$1[a2])
    return Xe$1[a2];
  if (!We$1[a2])
    return a2;
  var b3 = We$1[a2], c2;
  for (c2 in b3)
    if (b3.hasOwnProperty(c2) && c2 in Ye$1)
      return Xe$1[a2] = b3[c2];
  return a2;
}
var $e = Ze$1("animationend"), af = Ze$1("animationiteration"), bf = Ze$1("animationstart"), cf = Ze$1("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b3) {
  df.set(a2, b3);
  fa(b3, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b3, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b3, void 0, a2);
  a2.currentTarget = null;
}
function se$1(a2, b3) {
  b3 = 0 !== (b3 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f3 = void 0;
      if (b3)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h4 = d2[g2], k4 = h4.instance, l2 = h4.currentTarget;
          h4 = h4.listener;
          if (k4 !== f3 && e2.isPropagationStopped())
            break a;
          nf(e2, h4, l2);
          f3 = k4;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h4 = d2[g2];
          k4 = h4.instance;
          l2 = h4.currentTarget;
          h4 = h4.listener;
          if (k4 !== f3 && e2.isPropagationStopped())
            break a;
          nf(e2, h4, l2);
          f3 = k4;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$1(a2, b3) {
  var c2 = b3[of];
  void 0 === c2 && (c2 = b3[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b3, a2, 2, false), c2.add(d2));
}
function qf(a2, b3, c2) {
  var d2 = 0;
  b3 && (d2 |= 4);
  pf(c2, a2, d2, b3);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b4) {
      "selectionchange" !== b4 && (mf.has(b4) || qf(b4, false, a2), qf(b4, true, a2));
    });
    var b3 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b3 || b3[rf] || (b3[rf] = true, qf("selectionchange", false, b3));
  }
}
function pf(a2, b3, c2, d2) {
  switch (jd(b3)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b3, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b3 && "touchmove" !== b3 && "wheel" !== b3 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b3, c2, { capture: true, passive: e2 }) : a2.addEventListener(b3, c2, true) : void 0 !== e2 ? a2.addEventListener(b3, c2, { passive: e2 }) : a2.addEventListener(b3, c2, false);
}
function hd(a2, b3, c2, d2, e2) {
  var f3 = d2;
  if (0 === (b3 & 1) && 0 === (b3 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h4 = d2.stateNode.containerInfo;
          if (h4 === e2 || 8 === h4.nodeType && h4.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k4 = g2.tag;
              if (3 === k4 || 4 === k4) {
                if (k4 = g2.stateNode.containerInfo, k4 === e2 || 8 === k4.nodeType && k4.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h4; ) {
            g2 = Wc(h4);
            if (null === g2)
              return;
            k4 = g2.tag;
            if (5 === k4 || 6 === k4) {
              d2 = f3 = g2;
              continue a;
            }
            h4 = h4.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f3, e3 = xb(c2), g3 = [];
    a: {
      var h5 = df.get(a2);
      if (void 0 !== h5) {
        var k5 = td, n4 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k5 = Rd;
            break;
          case "focusin":
            n4 = "focus";
            k5 = Fd;
            break;
          case "focusout":
            n4 = "blur";
            k5 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k5 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k5 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k5 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k5 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k5 = Hd;
            break;
          case cf:
            k5 = Xd;
            break;
          case "scroll":
            k5 = vd;
            break;
          case "wheel":
            k5 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k5 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k5 = Td;
        }
        var t2 = 0 !== (b3 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h5 ? h5 + "Capture" : null : h5;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h5 = new k5(h5, n4, null, c2, e3), g3.push({ event: h5, listeners: t2 }));
      }
    }
    if (0 === (b3 & 7)) {
      a: {
        h5 = "mouseover" === a2 || "pointerover" === a2;
        k5 = "mouseout" === a2 || "pointerout" === a2;
        if (h5 && c2 !== wb && (n4 = c2.relatedTarget || c2.fromElement) && (Wc(n4) || n4[uf]))
          break a;
        if (k5 || h5) {
          h5 = e3.window === e3 ? e3 : (h5 = e3.ownerDocument) ? h5.defaultView || h5.parentWindow : window;
          if (k5) {
            if (n4 = c2.relatedTarget || c2.toElement, k5 = d3, n4 = n4 ? Wc(n4) : null, null !== n4 && (J2 = Vb(n4), n4 !== J2 || 5 !== n4.tag && 6 !== n4.tag))
              n4 = null;
          } else
            k5 = null, n4 = d3;
          if (k5 !== n4) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k5 ? h5 : ue(k5);
            u2 = null == n4 ? h5 : ue(n4);
            h5 = new t2(F2, w2 + "leave", k5, c2, e3);
            h5.target = J2;
            h5.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n4, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k5 && n4)
              b: {
                t2 = k5;
                x2 = n4;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k5 && wf(g3, h5, k5, t2, false);
            null !== n4 && null !== J2 && wf(g3, J2, n4, t2, true);
          }
        }
      }
      a: {
        h5 = d3 ? ue(d3) : window;
        k5 = h5.nodeName && h5.nodeName.toLowerCase();
        if ("select" === k5 || "input" === k5 && "file" === h5.type)
          var na = ve$1;
        else if (me(h5))
          if (we)
            na = Fe;
          else {
            na = De$1;
            var xa = Ce$1;
          }
        else
          (k5 = h5.nodeName) && "input" === k5.toLowerCase() && ("checkbox" === h5.type || "radio" === h5.type) && (na = Ee);
        if (na && (na = na(a2, d3))) {
          ne(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h5, d3);
        "focusout" === a2 && (xa = h5._wrapperState) && xa.controlled && "number" === h5.type && cb(h5, "number", h5.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a2) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable)
            Qe$1 = xa, Re$1 = d3, Se = null;
          break;
        case "focusout":
          Se = Re$1 = Qe$1 = null;
          break;
        case "mousedown":
          Te$1 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$1 = false;
          Ue$1(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe$1)
            break;
        case "keydown":
        case "keyup":
          Ue$1(g3, c2, e3);
      }
      var $a;
      if (ae$1)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie$1 ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c2.locale && (ie$1 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$1 && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie$1 = true)), xa = oe$1(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
      if ($a = ce$1 ? je$1(a2, c2) : ke$1(a2, c2))
        d3 = oe$1(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se$1(g3, b3);
  });
}
function tf(a2, b3, c2) {
  return { instance: a2, listener: b3, currentTarget: c2 };
}
function oe$1(a2, b3) {
  for (var c2 = b3 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f3 = e2.stateNode;
    5 === e2.tag && null !== f3 && (e2 = f3, f3 = Kb(a2, c2), null != f3 && d2.unshift(tf(a2, f3, e2)), f3 = Kb(a2, b3), null != f3 && d2.push(tf(a2, f3, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b3, c2, d2, e2) {
  for (var f3 = b3._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h4 = c2, k4 = h4.alternate, l2 = h4.stateNode;
    if (null !== k4 && k4 === d2)
      break;
    5 === h4.tag && null !== l2 && (h4 = l2, e2 ? (k4 = Kb(c2, f3), null != k4 && g2.unshift(tf(c2, k4, h4))) : e2 || (k4 = Kb(c2, f3), null != k4 && g2.push(tf(c2, k4, h4))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b3, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b3, c2) {
  b3 = zf(b3);
  if (zf(a2) !== b3 && c2)
    throw Error(p$7(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b3) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b3.children || "number" === typeof b3.children || "object" === typeof b3.dangerouslySetInnerHTML && null !== b3.dangerouslySetInnerHTML && null != b3.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b3) {
  var c2 = b3, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e2);
          bd(b3);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b3);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b3 = a2.nodeType;
    if (1 === b3 || 3 === b3)
      break;
    if (8 === b3) {
      b3 = a2.data;
      if ("$" === b3 || "$!" === b3 || "$?" === b3)
        break;
      if ("/$" === b3)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b3 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b3)
          return a2;
        b3--;
      } else
        "/$" === c2 && b3++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b3 = a2[Of];
  if (b3)
    return b3;
  for (var c2 = a2.parentNode; c2; ) {
    if (b3 = c2[uf] || c2[Of]) {
      c2 = b3.alternate;
      if (null !== b3.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b3;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$7(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E$2(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$1(a2, b3) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b3;
}
var Vf = {}, H$3 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b3) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b3)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f3;
  for (f3 in c2)
    e2[f3] = b3[f3];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b3, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$2(Wf);
  E$2(H$3);
}
function ag(a2, b3, c2) {
  if (H$3.current !== Vf)
    throw Error(p$7(168));
  G$1(H$3, b3);
  G$1(Wf, c2);
}
function bg(a2, b3, c2) {
  var d2 = a2.stateNode;
  b3 = b3.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b3))
      throw Error(p$7(108, Ra(a2) || "Unknown", e2));
  return A$4({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$3.current;
  G$1(H$3, a2);
  G$1(Wf, Wf.current);
  return true;
}
function dg(a2, b3, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$7(169));
  c2 ? (a2 = bg(a2, b3, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$2(Wf), E$2(H$3), G$1(H$3, a2)) : E$2(Wf);
  G$1(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b3 = C$3;
    try {
      var c2 = eg;
      for (C$3 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C$3 = b3, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b3) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b3;
}
function ug(a2, b3, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f3 = 32 - oc(b3) + e2;
  if (30 < f3) {
    var g2 = e2 - e2 % 5;
    f3 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b3) + e2 | c2 << e2 | d2;
    sg = f3 + a2;
  } else
    rg = 1 << f3 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$2 = false, zg = null;
function Ag(a2, b3) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b3;
  c2.return = a2;
  b3 = a2.deletions;
  null === b3 ? (a2.deletions = [c2], a2.flags |= 16) : b3.push(c2);
}
function Cg(a2, b3) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b3 = 1 !== b3.nodeType || c2.toLowerCase() !== b3.nodeName.toLowerCase() ? null : b3;
      return null !== b3 ? (a2.stateNode = b3, xg = a2, yg = Lf(b3.firstChild), true) : false;
    case 6:
      return b3 = "" === a2.pendingProps || 3 !== b3.nodeType ? null : b3, null !== b3 ? (a2.stateNode = b3, xg = a2, yg = null, true) : false;
    case 13:
      return b3 = 8 !== b3.nodeType ? null : b3, null !== b3 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b3, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b3, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I$2) {
    var b3 = yg;
    if (b3) {
      var c2 = b3;
      if (!Cg(a2, b3)) {
        if (Dg(a2))
          throw Error(p$7(418));
        b3 = Lf(c2.nextSibling);
        var d2 = xg;
        b3 && Cg(a2, b3) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$2 = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$7(418));
      a2.flags = a2.flags & -4097 | 2;
      I$2 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I$2)
    return Fg(a2), I$2 = true, false;
  var b3;
  (b3 = 3 !== a2.tag) && !(b3 = 5 !== a2.tag) && (b3 = a2.type, b3 = "head" !== b3 && "body" !== b3 && !Ef(a2.type, a2.memoizedProps));
  if (b3 && (b3 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$7(418));
    for (; b3; )
      Ag(a2, b3), b3 = Lf(b3.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$7(317));
    a: {
      a2 = a2.nextSibling;
      for (b3 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b3) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b3--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b3++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$2 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b3) {
  if (a2 && a2.defaultProps) {
    b3 = A$4({}, b3);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b3[c2] && (b3[c2] = a2[c2]);
    return b3;
  }
  return b3;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b3 = Mg.current;
  E$2(Mg);
  a2._currentValue = b3;
}
function Sg(a2, b3, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b3) !== b3 ? (a2.childLanes |= b3, null !== d2 && (d2.childLanes |= b3)) : null !== d2 && (d2.childLanes & b3) !== b3 && (d2.childLanes |= b3);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b3) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b3) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b3 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b3, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$7(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b3;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b3, c2, d2) {
  var e2 = b3.interleaved;
  null === e2 ? (c2.next = c2, Xg(b3)) : (c2.next = e2.next, e2.next = c2);
  b3.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b3) {
  a2.lanes |= b3;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b3);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b3, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b3), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g$1 = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b3) {
  a2 = a2.updateQueue;
  b3.updateQueue === a2 && (b3.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b3) {
  return { eventTime: a2, lane: b3, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b3, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K$2 & 2)) {
    var e2 = d2.pending;
    null === e2 ? b3.next = b3 : (b3.next = e2.next, e2.next = b3);
    d2.pending = b3;
    return Zg(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b3.next = b3, Xg(d2)) : (b3.next = e2.next, e2.next = b3);
  d2.interleaved = b3;
  return Zg(a2, c2);
}
function eh(a2, b3, c2) {
  b3 = b3.updateQueue;
  if (null !== b3 && (b3 = b3.shared, 0 !== (c2 & 4194240))) {
    var d2 = b3.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b3.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b3) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f3 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f3 ? e2 = f3 = g2 : f3 = f3.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f3 ? e2 = f3 = b3 : f3 = f3.next = b3;
    } else
      e2 = f3 = b3;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f3, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b3 : a2.next = b3;
  c2.lastBaseUpdate = b3;
}
function gh(a2, b3, c2, d2) {
  var e2 = a2.updateQueue;
  $g$1 = false;
  var f3 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h4 = e2.shared.pending;
  if (null !== h4) {
    e2.shared.pending = null;
    var k4 = h4, l2 = k4.next;
    k4.next = null;
    null === g2 ? f3 = l2 : g2.next = l2;
    g2 = k4;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h4 = m2.lastBaseUpdate, h4 !== g2 && (null === h4 ? m2.firstBaseUpdate = l2 : h4.next = l2, m2.lastBaseUpdate = k4));
  }
  if (null !== f3) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k4 = null;
    h4 = f3;
    do {
      var r2 = h4.lane, y2 = h4.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h4.tag,
          payload: h4.payload,
          callback: h4.callback,
          next: null
        });
        a: {
          var n4 = a2, t2 = h4;
          r2 = b3;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n4 = t2.payload;
              if ("function" === typeof n4) {
                q2 = n4.call(y2, q2, r2);
                break a;
              }
              q2 = n4;
              break a;
            case 3:
              n4.flags = n4.flags & -65537 | 128;
            case 0:
              n4 = t2.payload;
              r2 = "function" === typeof n4 ? n4.call(y2, q2, r2) : n4;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$4({}, q2, r2);
              break a;
            case 2:
              $g$1 = true;
          }
        }
        null !== h4.callback && 0 !== h4.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h4] : r2.push(h4));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h4.tag, payload: h4.payload, callback: h4.callback, next: null }, null === m2 ? (l2 = m2 = y2, k4 = q2) : m2 = m2.next = y2, g2 |= r2;
      h4 = h4.next;
      if (null === h4)
        if (h4 = e2.shared.pending, null === h4)
          break;
        else
          r2 = h4, h4 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k4 = q2);
    e2.baseState = k4;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b3 = e2.shared.interleaved;
    if (null !== b3) {
      e2 = b3;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b3);
    } else
      null === f3 && (e2.shared.lanes = 0);
    hh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function ih(a2, b3, c2) {
  a2 = b3.effects;
  b3.effects = null;
  if (null !== a2)
    for (b3 = 0; b3 < a2.length; b3++) {
      var d2 = a2[b3], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$7(191, e2));
        e2.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a2, b3, c2, d2) {
  b3 = a2.memoizedState;
  c2 = c2(d2, b3);
  c2 = null === c2 || void 0 === c2 ? b3 : A$4({}, b3, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b3, c2) {
  a2 = a2._reactInternals;
  var d2 = L$3(), e2 = lh(a2), f3 = ch(d2, e2);
  f3.payload = b3;
  void 0 !== c2 && null !== c2 && (f3.callback = c2);
  b3 = dh(a2, f3, e2);
  null !== b3 && (mh(b3, a2, e2, d2), eh(b3, a2, e2));
}, enqueueReplaceState: function(a2, b3, c2) {
  a2 = a2._reactInternals;
  var d2 = L$3(), e2 = lh(a2), f3 = ch(d2, e2);
  f3.tag = 1;
  f3.payload = b3;
  void 0 !== c2 && null !== c2 && (f3.callback = c2);
  b3 = dh(a2, f3, e2);
  null !== b3 && (mh(b3, a2, e2, d2), eh(b3, a2, e2));
}, enqueueForceUpdate: function(a2, b3) {
  a2 = a2._reactInternals;
  var c2 = L$3(), d2 = lh(a2), e2 = ch(c2, d2);
  e2.tag = 2;
  void 0 !== b3 && null !== b3 && (e2.callback = b3);
  b3 = dh(a2, e2, d2);
  null !== b3 && (mh(b3, a2, d2, c2), eh(b3, a2, d2));
} };
function oh(a2, b3, c2, d2, e2, f3, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f3, g2) : b3.prototype && b3.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f3) : true;
}
function ph(a2, b3, c2) {
  var d2 = false, e2 = Vf;
  var f3 = b3.contextType;
  "object" === typeof f3 && null !== f3 ? f3 = Vg(f3) : (e2 = Zf(b3) ? Xf : H$3.current, d2 = b3.contextTypes, f3 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b3 = new b3(c2, f3);
  a2.memoizedState = null !== b3.state && void 0 !== b3.state ? b3.state : null;
  b3.updater = nh;
  a2.stateNode = b3;
  b3._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f3);
  return b3;
}
function qh(a2, b3, c2, d2) {
  a2 = b3.state;
  "function" === typeof b3.componentWillReceiveProps && b3.componentWillReceiveProps(c2, d2);
  "function" === typeof b3.UNSAFE_componentWillReceiveProps && b3.UNSAFE_componentWillReceiveProps(c2, d2);
  b3.state !== a2 && nh.enqueueReplaceState(b3, b3.state, null);
}
function rh$1(a2, b3, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = jh;
  ah(a2);
  var f3 = b3.contextType;
  "object" === typeof f3 && null !== f3 ? e2.context = Vg(f3) : (f3 = Zf(b3) ? Xf : H$3.current, e2.context = Yf(a2, f3));
  e2.state = a2.memoizedState;
  f3 = b3.getDerivedStateFromProps;
  "function" === typeof f3 && (kh(a2, b3, f3, c2), e2.state = a2.memoizedState);
  "function" === typeof b3.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b3 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b3 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function sh$1(a2, b3, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$7(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$7(147, a2));
      var e2 = d2, f3 = "" + a2;
      if (null !== b3 && null !== b3.ref && "function" === typeof b3.ref && b3.ref._stringRef === f3)
        return b3.ref;
      b3 = function(a3) {
        var b4 = e2.refs;
        b4 === jh && (b4 = e2.refs = {});
        null === a3 ? delete b4[f3] : b4[f3] = a3;
      };
      b3._stringRef = f3;
      return b3;
    }
    if ("string" !== typeof a2)
      throw Error(p$7(284));
    if (!c2._owner)
      throw Error(p$7(290, a2));
  }
  return a2;
}
function th(a2, b3) {
  a2 = Object.prototype.toString.call(b3);
  throw Error(p$7(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b3).join(", ") + "}" : a2));
}
function uh(a2) {
  var b3 = a2._init;
  return b3(a2._payload);
}
function vh(a2) {
  function b3(b4, c3) {
    if (a2) {
      var d3 = b4.deletions;
      null === d3 ? (b4.deletions = [c3], b4.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b3(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b4) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b4; )
      null !== b4.key ? a3.set(b4.key, b4) : a3.set(b4.index, b4), b4 = b4.sibling;
    return a3;
  }
  function e2(a3, b4) {
    a3 = wh(a3, b4);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f3(b4, c3, d3) {
    b4.index = d3;
    if (!a2)
      return b4.flags |= 1048576, c3;
    d3 = b4.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b4.flags |= 2, c3) : d3;
    b4.flags |= 2;
    return c3;
  }
  function g2(b4) {
    a2 && null === b4.alternate && (b4.flags |= 2);
    return b4;
  }
  function h4(a3, b4, c3, d3) {
    if (null === b4 || 6 !== b4.tag)
      return b4 = xh(c3, a3.mode, d3), b4.return = a3, b4;
    b4 = e2(b4, c3);
    b4.return = a3;
    return b4;
  }
  function k4(a3, b4, c3, d3) {
    var f4 = c3.type;
    if (f4 === ya)
      return m2(a3, b4, c3.props.children, d3, c3.key);
    if (null !== b4 && (b4.elementType === f4 || "object" === typeof f4 && null !== f4 && f4.$$typeof === Ha && uh(f4) === b4.type))
      return d3 = e2(b4, c3.props), d3.ref = sh$1(a3, b4, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh$1(a3, b4, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b4, c3, d3) {
    if (null === b4 || 4 !== b4.tag || b4.stateNode.containerInfo !== c3.containerInfo || b4.stateNode.implementation !== c3.implementation)
      return b4 = zh(c3, a3.mode, d3), b4.return = a3, b4;
    b4 = e2(b4, c3.children || []);
    b4.return = a3;
    return b4;
  }
  function m2(a3, b4, c3, d3, f4) {
    if (null === b4 || 7 !== b4.tag)
      return b4 = Ah(c3, a3.mode, d3, f4), b4.return = a3, b4;
    b4 = e2(b4, c3);
    b4.return = a3;
    return b4;
  }
  function q2(a3, b4, c3) {
    if ("string" === typeof b4 && "" !== b4 || "number" === typeof b4)
      return b4 = xh("" + b4, a3.mode, c3), b4.return = a3, b4;
    if ("object" === typeof b4 && null !== b4) {
      switch (b4.$$typeof) {
        case va:
          return c3 = yh(b4.type, b4.key, b4.props, null, a3.mode, c3), c3.ref = sh$1(a3, null, b4), c3.return = a3, c3;
        case wa:
          return b4 = zh(b4, a3.mode, c3), b4.return = a3, b4;
        case Ha:
          var d3 = b4._init;
          return q2(a3, d3(b4._payload), c3);
      }
      if (eb(b4) || Ka(b4))
        return b4 = Ah(b4, a3.mode, c3, null), b4.return = a3, b4;
      th(a3, b4);
    }
    return null;
  }
  function r2(a3, b4, c3, d3) {
    var e3 = null !== b4 ? b4.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h4(a3, b4, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k4(a3, b4, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b4, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b4,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a3, b4, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b4, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h4(b4, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k4(b4, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b4, a3, d3, e3);
        case Ha:
          var f4 = d3._init;
          return y2(a3, b4, c3, f4(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b4, a3, d3, e3, null);
      th(b4, d3);
    }
    return null;
  }
  function n4(e3, g3, h5, k5) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h5.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n5 = r2(e3, u2, h5[w2], k5);
      if (null === n5) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n5.alternate && b3(e3, u2);
      g3 = f3(n5, g3, w2);
      null === m3 ? l3 = n5 : m3.sibling = n5;
      m3 = n5;
      u2 = x2;
    }
    if (w2 === h5.length)
      return c2(e3, u2), I$2 && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h5.length; w2++)
        u2 = q2(e3, h5[w2], k5), null !== u2 && (g3 = f3(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$2 && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h5.length; w2++)
      x2 = y2(u2, e3, w2, h5[w2], k5), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f3(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b3(e3, a3);
    });
    I$2 && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h5, k5) {
    var l3 = Ka(h5);
    if ("function" !== typeof l3)
      throw Error(p$7(150));
    h5 = l3.call(h5);
    if (null == h5)
      throw Error(p$7(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n5 = h5.next(); null !== m3 && !n5.done; w2++, n5 = h5.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n5.value, k5);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b3(e3, m3);
      g3 = f3(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n5.done)
      return c2(
        e3,
        m3
      ), I$2 && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n5.done; w2++, n5 = h5.next())
        n5 = q2(e3, n5.value, k5), null !== n5 && (g3 = f3(n5, g3, w2), null === u2 ? l3 = n5 : u2.sibling = n5, u2 = n5);
      I$2 && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n5.done; w2++, n5 = h5.next())
      n5 = y2(m3, e3, w2, n5.value, k5), null !== n5 && (a2 && null !== n5.alternate && m3.delete(null === n5.key ? w2 : n5.key), g3 = f3(n5, g3, w2), null === u2 ? l3 = n5 : u2.sibling = n5, u2 = n5);
    a2 && m3.forEach(function(a3) {
      return b3(e3, a3);
    });
    I$2 && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f4, h5) {
    "object" === typeof f4 && null !== f4 && f4.type === ya && null === f4.key && (f4 = f4.props.children);
    if ("object" === typeof f4 && null !== f4) {
      switch (f4.$$typeof) {
        case va:
          a: {
            for (var k5 = f4.key, l3 = d3; null !== l3; ) {
              if (l3.key === k5) {
                k5 = f4.type;
                if (k5 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f4.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k5 || "object" === typeof k5 && null !== k5 && k5.$$typeof === Ha && uh(k5) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f4.props);
                  d3.ref = sh$1(a3, l3, f4);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b3(a3, l3);
              l3 = l3.sibling;
            }
            f4.type === ya ? (d3 = Ah(f4.props.children, a3.mode, h5, f4.key), d3.return = a3, a3 = d3) : (h5 = yh(f4.type, f4.key, f4.props, null, a3.mode, h5), h5.ref = sh$1(a3, d3, f4), h5.return = a3, a3 = h5);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f4.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f4.containerInfo && d3.stateNode.implementation === f4.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f4.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b3(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f4, a3.mode, h5);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f4._init, J2(a3, d3, l3(f4._payload), h5);
      }
      if (eb(f4))
        return n4(a3, d3, f4, h5);
      if (Ka(f4))
        return t2(a3, d3, f4, h5);
      th(a3, f4);
    }
    return "string" === typeof f4 && "" !== f4 || "number" === typeof f4 ? (f4 = "" + f4, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f4), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f4, a3.mode, h5), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$7(174));
  return a2;
}
function Ih(a2, b3) {
  G$1(Gh, b3);
  G$1(Fh, a2);
  G$1(Eh, Dh);
  a2 = b3.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b3 = (b3 = b3.documentElement) ? b3.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b3.parentNode : b3, b3 = a2.namespaceURI || null, a2 = a2.tagName, b3 = lb(b3, a2);
  }
  E$2(Eh);
  G$1(Eh, b3);
}
function Jh() {
  E$2(Eh);
  E$2(Fh);
  E$2(Gh);
}
function Kh$1(a2) {
  Hh(Gh.current);
  var b3 = Hh(Eh.current);
  var c2 = lb(b3, a2.type);
  b3 !== c2 && (G$1(Fh, a2), G$1(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E$2(Eh), E$2(Fh));
}
var M$2 = Uf(0);
function Mh(a2) {
  for (var b3 = a2; null !== b3; ) {
    if (13 === b3.tag) {
      var c2 = b3.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b3;
    } else if (19 === b3.tag && void 0 !== b3.memoizedProps.revealOrder) {
      if (0 !== (b3.flags & 128))
        return b3;
    } else if (null !== b3.child) {
      b3.child.return = b3;
      b3 = b3.child;
      continue;
    }
    if (b3 === a2)
      break;
    for (; null === b3.sibling; ) {
      if (null === b3.return || b3.return === a2)
        return null;
      b3 = b3.return;
    }
    b3.sibling.return = b3.return;
    b3 = b3.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$3 = null, O$1 = null, P$4 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q$1() {
  throw Error(p$7(321));
}
function Wh(a2, b3) {
  if (null === b3)
    return false;
  for (var c2 = 0; c2 < b3.length && c2 < a2.length; c2++)
    if (!He$1(a2[c2], b3[c2]))
      return false;
  return true;
}
function Xh(a2, b3, c2, d2, e2, f3) {
  Rh = f3;
  N$3 = b3;
  b3.memoizedState = null;
  b3.updateQueue = null;
  b3.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e2);
  if (Th) {
    f3 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f3)
        throw Error(p$7(301));
      f3 += 1;
      P$4 = O$1 = null;
      b3.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e2);
    } while (Th);
  }
  Ph.current = ai;
  b3 = null !== O$1 && null !== O$1.next;
  Rh = 0;
  P$4 = O$1 = N$3 = null;
  Sh = false;
  if (b3)
    throw Error(p$7(300));
  return a2;
}
function bi() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$4 ? N$3.memoizedState = P$4 = a2 : P$4 = P$4.next = a2;
  return P$4;
}
function di() {
  if (null === O$1) {
    var a2 = N$3.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O$1.next;
  var b3 = null === P$4 ? N$3.memoizedState : P$4.next;
  if (null !== b3)
    P$4 = b3, O$1 = a2;
  else {
    if (null === a2)
      throw Error(p$7(310));
    O$1 = a2;
    a2 = { memoizedState: O$1.memoizedState, baseState: O$1.baseState, baseQueue: O$1.baseQueue, queue: O$1.queue, next: null };
    null === P$4 ? N$3.memoizedState = P$4 = a2 : P$4 = P$4.next = a2;
  }
  return P$4;
}
function ei(a2, b3) {
  return "function" === typeof b3 ? b3(a2) : b3;
}
function fi(a2) {
  var b3 = di(), c2 = b3.queue;
  if (null === c2)
    throw Error(p$7(311));
  c2.lastRenderedReducer = a2;
  var d2 = O$1, e2 = d2.baseQueue, f3 = c2.pending;
  if (null !== f3) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f3.next;
      f3.next = g2;
    }
    d2.baseQueue = e2 = f3;
    c2.pending = null;
  }
  if (null !== e2) {
    f3 = e2.next;
    d2 = d2.baseState;
    var h4 = g2 = null, k4 = null, l2 = f3;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k4 && (k4 = k4.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k4 ? (h4 = k4 = q2, g2 = d2) : k4 = k4.next = q2;
        N$3.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f3);
    null === k4 ? g2 = d2 : k4.next = h4;
    He$1(d2, b3.memoizedState) || (Ug = true);
    b3.memoizedState = d2;
    b3.baseState = g2;
    b3.baseQueue = k4;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f3 = e2.lane, N$3.lanes |= f3, hh |= f3, e2 = e2.next;
    while (e2 !== a2);
  } else
    null === e2 && (c2.lanes = 0);
  return [b3.memoizedState, c2.dispatch];
}
function gi(a2) {
  var b3 = di(), c2 = b3.queue;
  if (null === c2)
    throw Error(p$7(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f3 = b3.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f3 = a2(f3, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He$1(f3, b3.memoizedState) || (Ug = true);
    b3.memoizedState = f3;
    null === b3.baseQueue && (b3.baseState = f3);
    c2.lastRenderedState = f3;
  }
  return [f3, d2];
}
function hi() {
}
function ii(a2, b3) {
  var c2 = N$3, d2 = di(), e2 = b3(), f3 = !He$1(d2.memoizedState, e2);
  f3 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji(ki.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b3 || f3 || null !== P$4 && P$4.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d2, e2, b3), void 0, null);
    if (null === R$3)
      throw Error(p$7(349));
    0 !== (Rh & 30) || ni(c2, b3, e2);
  }
  return e2;
}
function ni(a2, b3, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b3, value: c2 };
  b3 = N$3.updateQueue;
  null === b3 ? (b3 = { lastEffect: null, stores: null }, N$3.updateQueue = b3, b3.stores = [a2]) : (c2 = b3.stores, null === c2 ? b3.stores = [a2] : c2.push(a2));
}
function mi(a2, b3, c2, d2) {
  b3.value = c2;
  b3.getSnapshot = d2;
  oi(b3) && pi(a2);
}
function ki(a2, b3, c2) {
  return c2(function() {
    oi(b3) && pi(a2);
  });
}
function oi(a2) {
  var b3 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b3();
    return !He$1(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi(a2) {
  var b3 = Zg(a2, 1);
  null !== b3 && mh(b3, a2, 1, -1);
}
function qi(a2) {
  var b3 = ci();
  "function" === typeof a2 && (a2 = a2());
  b3.memoizedState = b3.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 };
  b3.queue = a2;
  a2 = a2.dispatch = ri.bind(null, N$3, a2);
  return [b3.memoizedState, a2];
}
function li(a2, b3, c2, d2) {
  a2 = { tag: a2, create: b3, destroy: c2, deps: d2, next: null };
  b3 = N$3.updateQueue;
  null === b3 ? (b3 = { lastEffect: null, stores: null }, N$3.updateQueue = b3, b3.lastEffect = a2.next = a2) : (c2 = b3.lastEffect, null === c2 ? b3.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b3.lastEffect = a2));
  return a2;
}
function si() {
  return di().memoizedState;
}
function ti(a2, b3, c2, d2) {
  var e2 = ci();
  N$3.flags |= a2;
  e2.memoizedState = li(1 | b3, c2, void 0, void 0 === d2 ? null : d2);
}
function ui(a2, b3, c2, d2) {
  var e2 = di();
  d2 = void 0 === d2 ? null : d2;
  var f3 = void 0;
  if (null !== O$1) {
    var g2 = O$1.memoizedState;
    f3 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e2.memoizedState = li(b3, c2, f3, d2);
      return;
    }
  }
  N$3.flags |= a2;
  e2.memoizedState = li(1 | b3, c2, f3, d2);
}
function vi(a2, b3) {
  return ti(8390656, 8, a2, b3);
}
function ji(a2, b3) {
  return ui(2048, 8, a2, b3);
}
function wi(a2, b3) {
  return ui(4, 2, a2, b3);
}
function xi(a2, b3) {
  return ui(4, 4, a2, b3);
}
function yi(a2, b3) {
  if ("function" === typeof b3)
    return a2 = a2(), b3(a2), function() {
      b3(null);
    };
  if (null !== b3 && void 0 !== b3)
    return a2 = a2(), b3.current = a2, function() {
      b3.current = null;
    };
}
function zi(a2, b3, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui(4, 4, yi.bind(null, b3, a2), c2);
}
function Ai() {
}
function Bi(a2, b3) {
  var c2 = di();
  b3 = void 0 === b3 ? null : b3;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b3 && Wh(b3, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b3];
  return a2;
}
function Ci(a2, b3) {
  var c2 = di();
  b3 = void 0 === b3 ? null : b3;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b3 && Wh(b3, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b3];
  return a2;
}
function Di(a2, b3, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He$1(c2, b3) || (c2 = yc(), N$3.lanes |= c2, hh |= c2, a2.baseState = true);
  return b3;
}
function Ei(a2, b3) {
  var c2 = C$3;
  C$3 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b3();
  } finally {
    C$3 = c2, Qh.transition = d2;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a2, b3, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b3, c2);
  else if (c2 = Yg(a2, b3, c2, d2), null !== c2) {
    var e2 = L$3();
    mh(c2, a2, d2, e2);
    Ji(c2, b3, d2);
  }
}
function ri(a2, b3, c2) {
  var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b3, e2);
  else {
    var f3 = a2.alternate;
    if (0 === a2.lanes && (null === f3 || 0 === f3.lanes) && (f3 = b3.lastRenderedReducer, null !== f3))
      try {
        var g2 = b3.lastRenderedState, h4 = f3(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h4;
        if (He$1(h4, g2)) {
          var k4 = b3.interleaved;
          null === k4 ? (e2.next = e2, Xg(b3)) : (e2.next = k4.next, k4.next = e2);
          b3.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b3, e2, d2);
    null !== c2 && (e2 = L$3(), mh(c2, a2, d2, e2), Ji(c2, b3, d2));
  }
}
function Hi(a2) {
  var b3 = a2.alternate;
  return a2 === N$3 || null !== b3 && b3 === N$3;
}
function Ii(a2, b3) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b3.next = b3 : (b3.next = c2.next, c2.next = b3);
  a2.pending = b3;
}
function Ji(a2, b3, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b3.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b3.lanes = c2;
    Cc(a2, c2);
  }
}
var ai = { readContext: Vg, useCallback: Q$1, useContext: Q$1, useEffect: Q$1, useImperativeHandle: Q$1, useInsertionEffect: Q$1, useLayoutEffect: Q$1, useMemo: Q$1, useReducer: Q$1, useRef: Q$1, useState: Q$1, useDebugValue: Q$1, useDeferredValue: Q$1, useTransition: Q$1, useMutableSource: Q$1, useSyncExternalStore: Q$1, useId: Q$1, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b3) {
  ci().memoizedState = [a2, void 0 === b3 ? null : b3];
  return a2;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b3, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b3, a2),
    c2
  );
}, useLayoutEffect: function(a2, b3) {
  return ti(4194308, 4, a2, b3);
}, useInsertionEffect: function(a2, b3) {
  return ti(4, 2, a2, b3);
}, useMemo: function(a2, b3) {
  var c2 = ci();
  b3 = void 0 === b3 ? null : b3;
  a2 = a2();
  c2.memoizedState = [a2, b3];
  return a2;
}, useReducer: function(a2, b3, c2) {
  var d2 = ci();
  b3 = void 0 !== c2 ? c2(b3) : b3;
  d2.memoizedState = d2.baseState = b3;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b3 };
  d2.queue = a2;
  a2 = a2.dispatch = Gi.bind(null, N$3, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b3 = ci();
  a2 = { current: a2 };
  return b3.memoizedState = a2;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
  return ci().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi(false), b3 = a2[0];
  a2 = Ei.bind(null, a2[1]);
  ci().memoizedState = a2;
  return [b3, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b3, c2) {
  var d2 = N$3, e2 = ci();
  if (I$2) {
    if (void 0 === c2)
      throw Error(p$7(407));
    c2 = c2();
  } else {
    c2 = b3();
    if (null === R$3)
      throw Error(p$7(349));
    0 !== (Rh & 30) || ni(d2, b3, c2);
  }
  e2.memoizedState = c2;
  var f3 = { value: c2, getSnapshot: b3 };
  e2.queue = f3;
  vi(ki.bind(
    null,
    d2,
    f3,
    a2
  ), [a2]);
  d2.flags |= 2048;
  li(9, mi.bind(null, d2, f3, c2, b3), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci(), b3 = R$3.identifierPrefix;
  if (I$2) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b3 = ":" + b3 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b3 += "H" + c2.toString(32));
    b3 += ":";
  } else
    c2 = Vh++, b3 = ":" + b3 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b3;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a2) {
    var b3 = di();
    return Di(b3, O$1.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi(ei)[0], b3 = di().memoizedState;
    return [a2, b3];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a2) {
  var b3 = di();
  return null === O$1 ? b3.memoizedState = a2 : Di(b3, O$1.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi(ei)[0], b3 = di().memoizedState;
  return [a2, b3];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a2, b3) {
  try {
    var c2 = "", d2 = b3;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f3) {
    e2 = "\nError generating stack: " + f3.message + "\n" + f3.stack;
  }
  return { value: a2, source: b3, stack: e2, digest: null };
}
function Li(a2, b3, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b3 ? b3 : null };
}
function Mi(a2, b3) {
  try {
    console.error(b3.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a2, b3, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b3.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d2);
    Mi(a2, b3);
  };
  return c2;
}
function Ri(a2, b3, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b3.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Mi(a2, b3);
    };
  }
  var f3 = a2.stateNode;
  null !== f3 && "function" === typeof f3.componentDidCatch && (c2.callback = function() {
    Mi(a2, b3);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b3.stack;
    this.componentDidCatch(b3.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a2, b3, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b3, e2);
  } else
    e2 = d2.get(b3), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b3, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b3, c2), b3.then(a2, a2));
}
function Vi(a2) {
  do {
    var b3;
    if (b3 = 13 === a2.tag)
      b3 = a2.memoizedState, b3 = null !== b3 ? null !== b3.dehydrated ? true : false : true;
    if (b3)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi(a2, b3, c2, d2, e2) {
  if (0 === (a2.mode & 1))
    return a2 === b3 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b3 = ch(-1, 1), b3.tag = 2, dh(c2, b3, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a2, b3, c2, d2) {
  b3.child = null === a2 ? Ch(b3, null, c2, d2) : Bh(b3, a2.child, c2, d2);
}
function Zi(a2, b3, c2, d2, e2) {
  c2 = c2.render;
  var f3 = b3.ref;
  Tg(b3, e2);
  d2 = Xh(a2, b3, c2, d2, f3, e2);
  c2 = bi();
  if (null !== a2 && !Ug)
    return b3.updateQueue = a2.updateQueue, b3.flags &= -2053, a2.lanes &= ~e2, $i(a2, b3, e2);
  I$2 && c2 && vg(b3);
  b3.flags |= 1;
  Yi(a2, b3, d2, e2);
  return b3.child;
}
function aj(a2, b3, c2, d2, e2) {
  if (null === a2) {
    var f3 = c2.type;
    if ("function" === typeof f3 && !bj(f3) && void 0 === f3.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b3.tag = 15, b3.type = f3, cj(a2, b3, f3, d2, e2);
    a2 = yh(c2.type, null, d2, b3, b3.mode, e2);
    a2.ref = b3.ref;
    a2.return = b3;
    return b3.child = a2;
  }
  f3 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f3.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a2.ref === b3.ref)
      return $i(a2, b3, e2);
  }
  b3.flags |= 1;
  a2 = wh(f3, d2);
  a2.ref = b3.ref;
  a2.return = b3;
  return b3.child = a2;
}
function cj(a2, b3, c2, d2, e2) {
  if (null !== a2) {
    var f3 = a2.memoizedProps;
    if (Ie(f3, d2) && a2.ref === b3.ref)
      if (Ug = false, b3.pendingProps = d2 = f3, 0 !== (a2.lanes & e2))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b3.lanes = a2.lanes, $i(a2, b3, e2);
  }
  return dj(a2, b3, c2, d2, e2);
}
function ej(a2, b3, c2) {
  var d2 = b3.pendingProps, e2 = d2.children, f3 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b3.mode & 1))
      b3.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$1(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f3 ? f3.baseLanes | c2 : c2, b3.lanes = b3.childLanes = 1073741824, b3.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b3.updateQueue = null, G$1(fj, gj), gj |= a2, null;
      b3.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f3 ? f3.baseLanes : c2;
      G$1(fj, gj);
      gj |= d2;
    }
  else
    null !== f3 ? (d2 = f3.baseLanes | c2, b3.memoizedState = null) : d2 = c2, G$1(fj, gj), gj |= d2;
  Yi(a2, b3, e2, c2);
  return b3.child;
}
function hj(a2, b3) {
  var c2 = b3.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b3.flags |= 512, b3.flags |= 2097152;
}
function dj(a2, b3, c2, d2, e2) {
  var f3 = Zf(c2) ? Xf : H$3.current;
  f3 = Yf(b3, f3);
  Tg(b3, e2);
  c2 = Xh(a2, b3, c2, d2, f3, e2);
  d2 = bi();
  if (null !== a2 && !Ug)
    return b3.updateQueue = a2.updateQueue, b3.flags &= -2053, a2.lanes &= ~e2, $i(a2, b3, e2);
  I$2 && d2 && vg(b3);
  b3.flags |= 1;
  Yi(a2, b3, c2, e2);
  return b3.child;
}
function ij(a2, b3, c2, d2, e2) {
  if (Zf(c2)) {
    var f3 = true;
    cg(b3);
  } else
    f3 = false;
  Tg(b3, e2);
  if (null === b3.stateNode)
    jj(a2, b3), ph(b3, c2, d2), rh$1(b3, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b3.stateNode, h4 = b3.memoizedProps;
    g2.props = h4;
    var k4 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$3.current, l2 = Yf(b3, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h4 !== d2 || k4 !== l2) && qh(b3, g2, d2, l2);
    $g$1 = false;
    var r2 = b3.memoizedState;
    g2.state = r2;
    gh(b3, d2, g2, e2);
    k4 = b3.memoizedState;
    h4 !== d2 || r2 !== k4 || Wf.current || $g$1 ? ("function" === typeof m2 && (kh(b3, c2, m2, d2), k4 = b3.memoizedState), (h4 = $g$1 || oh(b3, c2, h4, d2, r2, k4, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b3.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b3.flags |= 4194308), b3.memoizedProps = d2, b3.memoizedState = k4), g2.props = d2, g2.state = k4, g2.context = l2, d2 = h4) : ("function" === typeof g2.componentDidMount && (b3.flags |= 4194308), d2 = false);
  } else {
    g2 = b3.stateNode;
    bh(a2, b3);
    h4 = b3.memoizedProps;
    l2 = b3.type === b3.elementType ? h4 : Lg(b3.type, h4);
    g2.props = l2;
    q2 = b3.pendingProps;
    r2 = g2.context;
    k4 = c2.contextType;
    "object" === typeof k4 && null !== k4 ? k4 = Vg(k4) : (k4 = Zf(c2) ? Xf : H$3.current, k4 = Yf(b3, k4));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h4 !== q2 || r2 !== k4) && qh(b3, g2, d2, k4);
    $g$1 = false;
    r2 = b3.memoizedState;
    g2.state = r2;
    gh(b3, d2, g2, e2);
    var n4 = b3.memoizedState;
    h4 !== q2 || r2 !== n4 || Wf.current || $g$1 ? ("function" === typeof y2 && (kh(b3, c2, y2, d2), n4 = b3.memoizedState), (l2 = $g$1 || oh(b3, c2, l2, d2, r2, n4, k4) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n4, k4), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n4, k4)), "function" === typeof g2.componentDidUpdate && (b3.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b3.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h4 === a2.memoizedProps && r2 === a2.memoizedState || (b3.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h4 === a2.memoizedProps && r2 === a2.memoizedState || (b3.flags |= 1024), b3.memoizedProps = d2, b3.memoizedState = n4), g2.props = d2, g2.state = n4, g2.context = k4, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h4 === a2.memoizedProps && r2 === a2.memoizedState || (b3.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h4 === a2.memoizedProps && r2 === a2.memoizedState || (b3.flags |= 1024), d2 = false);
  }
  return kj(a2, b3, c2, d2, f3, e2);
}
function kj(a2, b3, c2, d2, e2, f3) {
  hj(a2, b3);
  var g2 = 0 !== (b3.flags & 128);
  if (!d2 && !g2)
    return e2 && dg(b3, c2, false), $i(a2, b3, f3);
  d2 = b3.stateNode;
  Xi.current = b3;
  var h4 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b3.flags |= 1;
  null !== a2 && g2 ? (b3.child = Bh(b3, a2.child, null, f3), b3.child = Bh(b3, null, h4, f3)) : Yi(a2, b3, h4, f3);
  b3.memoizedState = d2.state;
  e2 && dg(b3, c2, true);
  return b3.child;
}
function lj(a2) {
  var b3 = a2.stateNode;
  b3.pendingContext ? ag(a2, b3.pendingContext, b3.pendingContext !== b3.context) : b3.context && ag(a2, b3.context, false);
  Ih(a2, b3.containerInfo);
}
function mj(a2, b3, c2, d2, e2) {
  Ig();
  Jg(e2);
  b3.flags |= 256;
  Yi(a2, b3, c2, d2);
  return b3.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b3, c2) {
  var d2 = b3.pendingProps, e2 = M$2.current, f3 = false, g2 = 0 !== (b3.flags & 128), h4;
  (h4 = g2) || (h4 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h4)
    f3 = true, b3.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e2 |= 1;
  G$1(M$2, e2 & 1);
  if (null === a2) {
    Eg(b3);
    a2 = b3.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b3.mode & 1) ? b3.lanes = 1 : "$!" === a2.data ? b3.lanes = 8 : b3.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f3 ? (d2 = b3.mode, f3 = b3.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f3 ? (f3.childLanes = 0, f3.pendingProps = g2) : f3 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f3.return = b3, a2.return = b3, f3.sibling = a2, b3.child = f3, b3.child.memoizedState = oj(c2), b3.memoizedState = nj, a2) : rj(b3, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h4 = e2.dehydrated, null !== h4))
    return sj(a2, b3, g2, d2, h4, e2, c2);
  if (f3) {
    f3 = d2.fallback;
    g2 = b3.mode;
    e2 = a2.child;
    h4 = e2.sibling;
    var k4 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b3.child !== e2 ? (d2 = b3.child, d2.childLanes = 0, d2.pendingProps = k4, b3.deletions = null) : (d2 = wh(e2, k4), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h4 ? f3 = wh(h4, f3) : (f3 = Ah(f3, g2, c2, null), f3.flags |= 2);
    f3.return = b3;
    d2.return = b3;
    d2.sibling = f3;
    b3.child = d2;
    d2 = f3;
    f3 = b3.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f3.memoizedState = g2;
    f3.childLanes = a2.childLanes & ~c2;
    b3.memoizedState = nj;
    return d2;
  }
  f3 = a2.child;
  a2 = f3.sibling;
  d2 = wh(f3, { mode: "visible", children: d2.children });
  0 === (b3.mode & 1) && (d2.lanes = c2);
  d2.return = b3;
  d2.sibling = null;
  null !== a2 && (c2 = b3.deletions, null === c2 ? (b3.deletions = [a2], b3.flags |= 16) : c2.push(a2));
  b3.child = d2;
  b3.memoizedState = null;
  return d2;
}
function rj(a2, b3) {
  b3 = qj({ mode: "visible", children: b3 }, a2.mode, 0, null);
  b3.return = a2;
  return a2.child = b3;
}
function tj(a2, b3, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b3, a2.child, null, c2);
  a2 = rj(b3, b3.pendingProps.children);
  a2.flags |= 2;
  b3.memoizedState = null;
  return a2;
}
function sj(a2, b3, c2, d2, e2, f3, g2) {
  if (c2) {
    if (b3.flags & 256)
      return b3.flags &= -257, d2 = Li(Error(p$7(422))), tj(a2, b3, g2, d2);
    if (null !== b3.memoizedState)
      return b3.child = a2.child, b3.flags |= 128, null;
    f3 = d2.fallback;
    e2 = b3.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f3 = Ah(f3, e2, g2, null);
    f3.flags |= 2;
    d2.return = b3;
    f3.return = b3;
    d2.sibling = f3;
    b3.child = d2;
    0 !== (b3.mode & 1) && Bh(b3, a2.child, null, g2);
    b3.child.memoizedState = oj(g2);
    b3.memoizedState = nj;
    return f3;
  }
  if (0 === (b3.mode & 1))
    return tj(a2, b3, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h4 = d2.dgst;
    d2 = h4;
    f3 = Error(p$7(419));
    d2 = Li(f3, d2, void 0);
    return tj(a2, b3, g2, d2);
  }
  h4 = 0 !== (g2 & a2.childLanes);
  if (Ug || h4) {
    d2 = R$3;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f3.retryLane && (f3.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
    }
    uj();
    d2 = Li(Error(p$7(421)));
    return tj(a2, b3, g2, d2);
  }
  if ("$?" === e2.data)
    return b3.flags |= 128, b3.child = a2.child, b3 = vj.bind(null, a2), e2._reactRetry = b3, null;
  a2 = f3.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b3;
  I$2 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b3);
  b3 = rj(b3, d2.children);
  b3.flags |= 4096;
  return b3;
}
function wj(a2, b3, c2) {
  a2.lanes |= b3;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b3);
  Sg(a2.return, b3, c2);
}
function xj(a2, b3, c2, d2, e2) {
  var f3 = a2.memoizedState;
  null === f3 ? a2.memoizedState = { isBackwards: b3, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f3.isBackwards = b3, f3.rendering = null, f3.renderingStartTime = 0, f3.last = d2, f3.tail = c2, f3.tailMode = e2);
}
function yj(a2, b3, c2) {
  var d2 = b3.pendingProps, e2 = d2.revealOrder, f3 = d2.tail;
  Yi(a2, b3, d2.children, c2);
  d2 = M$2.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b3.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b3.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b3);
          else if (19 === a2.tag)
            wj(a2, c2, b3);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b3)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b3)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G$1(M$2, d2);
  if (0 === (b3.mode & 1))
    b3.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b3.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b3.child, b3.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b3, false, e2, c2, f3);
        break;
      case "backwards":
        c2 = null;
        e2 = b3.child;
        for (b3.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b3.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        xj(b3, true, c2, null, f3);
        break;
      case "together":
        xj(b3, false, null, null, void 0);
        break;
      default:
        b3.memoizedState = null;
    }
  return b3.child;
}
function jj(a2, b3) {
  0 === (b3.mode & 1) && null !== a2 && (a2.alternate = null, b3.alternate = null, b3.flags |= 2);
}
function $i(a2, b3, c2) {
  null !== a2 && (b3.dependencies = a2.dependencies);
  hh |= b3.lanes;
  if (0 === (c2 & b3.childLanes))
    return null;
  if (null !== a2 && b3.child !== a2.child)
    throw Error(p$7(153));
  if (null !== b3.child) {
    a2 = b3.child;
    c2 = wh(a2, a2.pendingProps);
    b3.child = c2;
    for (c2.return = b3; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b3;
    c2.sibling = null;
  }
  return b3.child;
}
function zj(a2, b3, c2) {
  switch (b3.tag) {
    case 3:
      lj(b3);
      Ig();
      break;
    case 5:
      Kh$1(b3);
      break;
    case 1:
      Zf(b3.type) && cg(b3);
      break;
    case 4:
      Ih(b3, b3.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b3.type._context, e2 = b3.memoizedProps.value;
      G$1(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b3.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G$1(M$2, M$2.current & 1), b3.flags |= 128, null;
        if (0 !== (c2 & b3.child.childLanes))
          return pj(a2, b3, c2);
        G$1(M$2, M$2.current & 1);
        a2 = $i(a2, b3, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G$1(M$2, M$2.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b3.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b3, c2);
        b3.flags |= 128;
      }
      e2 = b3.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G$1(M$2, M$2.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b3.lanes = 0, ej(a2, b3, c2);
  }
  return $i(a2, b3, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b3) {
  for (var c2 = b3.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b3)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b3)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b3, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b3.stateNode;
    Hh(Eh.current);
    var f3 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f3 = [];
        break;
      case "select":
        e2 = A$4({}, e2, { value: void 0 });
        d2 = A$4({}, d2, { value: void 0 });
        f3 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f3 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h4 = e2[l2];
          for (g2 in h4)
            h4.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f3 || (f3 = []) : (f3 = f3 || []).push(l2, null));
    for (l2 in d2) {
      var k4 = d2[l2];
      h4 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k4 !== h4 && (null != k4 || null != h4))
        if ("style" === l2)
          if (h4) {
            for (g2 in h4)
              !h4.hasOwnProperty(g2) || k4 && k4.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k4)
              k4.hasOwnProperty(g2) && h4[g2] !== k4[g2] && (c2 || (c2 = {}), c2[g2] = k4[g2]);
          } else
            c2 || (f3 || (f3 = []), f3.push(
              l2,
              c2
            )), c2 = k4;
        else
          "dangerouslySetInnerHTML" === l2 ? (k4 = k4 ? k4.__html : void 0, h4 = h4 ? h4.__html : void 0, null != k4 && h4 !== k4 && (f3 = f3 || []).push(l2, k4)) : "children" === l2 ? "string" !== typeof k4 && "number" !== typeof k4 || (f3 = f3 || []).push(l2, "" + k4) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k4 && "onScroll" === l2 && D$1("scroll", a2), f3 || h4 === k4 || (f3 = [])) : (f3 = f3 || []).push(l2, k4));
    }
    c2 && (f3 = f3 || []).push("style", c2);
    var l2 = f3;
    if (b3.updateQueue = l2)
      b3.flags |= 4;
  }
};
Dj = function(a2, b3, c2, d2) {
  c2 !== d2 && (b3.flags |= 4);
};
function Ej(a2, b3) {
  if (!I$2)
    switch (a2.tailMode) {
      case "hidden":
        b3 = a2.tail;
        for (var c2 = null; null !== b3; )
          null !== b3.alternate && (c2 = b3), b3 = b3.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b3 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S$5(a2) {
  var b3 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b3)
    for (var e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b3;
}
function Fj(a2, b3, c2) {
  var d2 = b3.pendingProps;
  wg(b3);
  switch (b3.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$5(b3), null;
    case 1:
      return Zf(b3.type) && $f(), S$5(b3), null;
    case 3:
      d2 = b3.stateNode;
      Jh();
      E$2(Wf);
      E$2(H$3);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b3) ? b3.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b3.flags & 256) || (b3.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b3);
      S$5(b3);
      return null;
    case 5:
      Lh(b3);
      var e2 = Hh(Gh.current);
      c2 = b3.type;
      if (null !== a2 && null != b3.stateNode)
        Cj(a2, b3, c2, d2, e2), a2.ref !== b3.ref && (b3.flags |= 512, b3.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b3.stateNode)
            throw Error(p$7(166));
          S$5(b3);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b3)) {
          d2 = b3.stateNode;
          c2 = b3.type;
          var f3 = b3.memoizedProps;
          d2[Of] = b3;
          d2[Pf] = f3;
          a2 = 0 !== (b3.mode & 1);
          switch (c2) {
            case "dialog":
              D$1("cancel", d2);
              D$1("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$1("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D$1(lf[e2], d2);
              break;
            case "source":
              D$1("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$1(
                "error",
                d2
              );
              D$1("load", d2);
              break;
            case "details":
              D$1("toggle", d2);
              break;
            case "input":
              Za(d2, f3);
              D$1("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f3.multiple };
              D$1("invalid", d2);
              break;
            case "textarea":
              hb(d2, f3), D$1("invalid", d2);
          }
          ub(c2, f3);
          e2 = null;
          for (var g2 in f3)
            if (f3.hasOwnProperty(g2)) {
              var h4 = f3[g2];
              "children" === g2 ? "string" === typeof h4 ? d2.textContent !== h4 && (true !== f3.suppressHydrationWarning && Af(d2.textContent, h4, a2), e2 = ["children", h4]) : "number" === typeof h4 && d2.textContent !== "" + h4 && (true !== f3.suppressHydrationWarning && Af(
                d2.textContent,
                h4,
                a2
              ), e2 = ["children", "" + h4]) : ea.hasOwnProperty(g2) && null != h4 && "onScroll" === g2 && D$1("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f3, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f3.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b3.updateQueue = d2;
          null !== d2 && (b3.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b3;
          a2[Pf] = d2;
          Aj(a2, b3, false, false);
          b3.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$1("cancel", a2);
                D$1("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$1("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D$1(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D$1("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$1(
                  "error",
                  a2
                );
                D$1("load", a2);
                e2 = d2;
                break;
              case "details":
                D$1("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D$1("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$4({}, d2, { value: void 0 });
                D$1("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D$1("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h4 = e2;
            for (f3 in h4)
              if (h4.hasOwnProperty(f3)) {
                var k4 = h4[f3];
                "style" === f3 ? sb(a2, k4) : "dangerouslySetInnerHTML" === f3 ? (k4 = k4 ? k4.__html : void 0, null != k4 && nb(a2, k4)) : "children" === f3 ? "string" === typeof k4 ? ("textarea" !== c2 || "" !== k4) && ob(a2, k4) : "number" === typeof k4 && ob(a2, "" + k4) : "suppressContentEditableWarning" !== f3 && "suppressHydrationWarning" !== f3 && "autoFocus" !== f3 && (ea.hasOwnProperty(f3) ? null != k4 && "onScroll" === f3 && D$1("scroll", a2) : null != k4 && ta(a2, f3, k4, g2));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f3 = d2.value;
                null != f3 ? fb(a2, !!d2.multiple, f3, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b3.flags |= 4);
        }
        null !== b3.ref && (b3.flags |= 512, b3.flags |= 2097152);
      }
      S$5(b3);
      return null;
    case 6:
      if (a2 && null != b3.stateNode)
        Dj(a2, b3, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b3.stateNode)
          throw Error(p$7(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b3)) {
          d2 = b3.stateNode;
          c2 = b3.memoizedProps;
          d2[Of] = b3;
          if (f3 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f3 && (b3.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b3, b3.stateNode = d2;
      }
      S$5(b3);
      return null;
    case 13:
      E$2(M$2);
      d2 = b3.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I$2 && null !== yg && 0 !== (b3.mode & 1) && 0 === (b3.flags & 128))
          Hg(), Ig(), b3.flags |= 98560, f3 = false;
        else if (f3 = Gg(b3), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f3)
              throw Error(p$7(318));
            f3 = b3.memoizedState;
            f3 = null !== f3 ? f3.dehydrated : null;
            if (!f3)
              throw Error(p$7(317));
            f3[Of] = b3;
          } else
            Ig(), 0 === (b3.flags & 128) && (b3.memoizedState = null), b3.flags |= 4;
          S$5(b3);
          f3 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f3 = true;
        if (!f3)
          return b3.flags & 65536 ? b3 : null;
      }
      if (0 !== (b3.flags & 128))
        return b3.lanes = c2, b3;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b3.child.flags |= 8192, 0 !== (b3.mode & 1) && (null === a2 || 0 !== (M$2.current & 1) ? 0 === T$3 && (T$3 = 3) : uj()));
      null !== b3.updateQueue && (b3.flags |= 4);
      S$5(b3);
      return null;
    case 4:
      return Jh(), Bj(a2, b3), null === a2 && sf(b3.stateNode.containerInfo), S$5(b3), null;
    case 10:
      return Rg(b3.type._context), S$5(b3), null;
    case 17:
      return Zf(b3.type) && $f(), S$5(b3), null;
    case 19:
      E$2(M$2);
      f3 = b3.memoizedState;
      if (null === f3)
        return S$5(b3), null;
      d2 = 0 !== (b3.flags & 128);
      g2 = f3.rendering;
      if (null === g2)
        if (d2)
          Ej(f3, false);
        else {
          if (0 !== T$3 || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b3.child; null !== a2; ) {
              g2 = Mh(a2);
              if (null !== g2) {
                b3.flags |= 128;
                Ej(f3, false);
                d2 = g2.updateQueue;
                null !== d2 && (b3.updateQueue = d2, b3.flags |= 4);
                b3.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b3.child; null !== c2; )
                  f3 = c2, a2 = d2, f3.flags &= 14680066, g2 = f3.alternate, null === g2 ? (f3.childLanes = 0, f3.lanes = a2, f3.child = null, f3.subtreeFlags = 0, f3.memoizedProps = null, f3.memoizedState = null, f3.updateQueue = null, f3.dependencies = null, f3.stateNode = null) : (f3.childLanes = g2.childLanes, f3.lanes = g2.lanes, f3.child = g2.child, f3.subtreeFlags = 0, f3.deletions = null, f3.memoizedProps = g2.memoizedProps, f3.memoizedState = g2.memoizedState, f3.updateQueue = g2.updateQueue, f3.type = g2.type, a2 = g2.dependencies, f3.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G$1(M$2, M$2.current & 1 | 2);
                return b3.child;
              }
              a2 = a2.sibling;
            }
          null !== f3.tail && B$1() > Hj && (b3.flags |= 128, d2 = true, Ej(f3, false), b3.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g2), null !== a2) {
            if (b3.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b3.updateQueue = c2, b3.flags |= 4), Ej(f3, true), null === f3.tail && "hidden" === f3.tailMode && !g2.alternate && !I$2)
              return S$5(b3), null;
          } else
            2 * B$1() - f3.renderingStartTime > Hj && 1073741824 !== c2 && (b3.flags |= 128, d2 = true, Ej(f3, false), b3.lanes = 4194304);
        f3.isBackwards ? (g2.sibling = b3.child, b3.child = g2) : (c2 = f3.last, null !== c2 ? c2.sibling = g2 : b3.child = g2, f3.last = g2);
      }
      if (null !== f3.tail)
        return b3 = f3.tail, f3.rendering = b3, f3.tail = b3.sibling, f3.renderingStartTime = B$1(), b3.sibling = null, c2 = M$2.current, G$1(M$2, d2 ? c2 & 1 | 2 : c2 & 1), b3;
      S$5(b3);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b3.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b3.flags |= 8192), d2 && 0 !== (b3.mode & 1) ? 0 !== (gj & 1073741824) && (S$5(b3), b3.subtreeFlags & 6 && (b3.flags |= 8192)) : S$5(b3), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$7(156, b3.tag));
}
function Jj(a2, b3) {
  wg(b3);
  switch (b3.tag) {
    case 1:
      return Zf(b3.type) && $f(), a2 = b3.flags, a2 & 65536 ? (b3.flags = a2 & -65537 | 128, b3) : null;
    case 3:
      return Jh(), E$2(Wf), E$2(H$3), Oh(), a2 = b3.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b3.flags = a2 & -65537 | 128, b3) : null;
    case 5:
      return Lh(b3), null;
    case 13:
      E$2(M$2);
      a2 = b3.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b3.alternate)
          throw Error(p$7(340));
        Ig();
      }
      a2 = b3.flags;
      return a2 & 65536 ? (b3.flags = a2 & -65537 | 128, b3) : null;
    case 19:
      return E$2(M$2), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b3.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U$1 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$3 = null;
function Mj(a2, b3) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W(a2, b3, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b3, c2) {
  try {
    c2();
  } catch (d2) {
    W(a2, b3, d2);
  }
}
var Oj = false;
function Pj(a2, b3) {
  Cf = dd;
  a2 = Me$1();
  if (Ne(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f3 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f3.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h4 = -1, k4 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h4 = g2 + e2);
                q2 !== f3 || 0 !== d2 && 3 !== q2.nodeType || (k4 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e2 && (h4 = g2);
                r2 === f3 && ++m2 === d2 && (k4 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h4 || -1 === k4 ? null : { start: h4, end: k4 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V$3 = b3; null !== V$3; )
    if (b3 = V$3, a2 = b3.child, 0 !== (b3.subtreeFlags & 1028) && null !== a2)
      a2.return = b3, V$3 = a2;
    else
      for (; null !== V$3; ) {
        b3 = V$3;
        try {
          var n4 = b3.alternate;
          if (0 !== (b3.flags & 1024))
            switch (b3.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n4) {
                  var t2 = n4.memoizedProps, J2 = n4.memoizedState, x2 = b3.stateNode, w2 = x2.getSnapshotBeforeUpdate(b3.elementType === b3.type ? t2 : Lg(b3.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b3.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$7(163));
            }
        } catch (F2) {
          W(b3, b3.return, F2);
        }
        a2 = b3.sibling;
        if (null !== a2) {
          a2.return = b3.return;
          V$3 = a2;
          break;
        }
        V$3 = b3.return;
      }
  n4 = Oj;
  Oj = false;
  return n4;
}
function Qj(a2, b3, c2) {
  var d2 = b3.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f3 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f3 && Nj(b3, c2, f3);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a2, b3) {
  b3 = b3.updateQueue;
  b3 = null !== b3 ? b3.lastEffect : null;
  if (null !== b3) {
    var c2 = b3 = b3.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b3);
  }
}
function Sj(a2) {
  var b3 = a2.ref;
  if (null !== b3) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b3 ? b3(a2) : b3.current = a2;
  }
}
function Tj(a2) {
  var b3 = a2.alternate;
  null !== b3 && (a2.alternate = null, Tj(b3));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b3 = a2.stateNode, null !== b3 && (delete b3[Of], delete b3[Pf], delete b3[of], delete b3[Qf], delete b3[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b3, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b3 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b3) : c2.insertBefore(a2, b3) : (8 === c2.nodeType ? (b3 = c2.parentNode, b3.insertBefore(a2, c2)) : (b3 = c2, b3.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b3.onclick || (b3.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b3, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b3, c2), a2 = a2.sibling;
}
function Xj(a2, b3, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b3 ? c2.insertBefore(a2, b3) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b3, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b3, c2), a2 = a2.sibling;
}
var X$1 = null, Yj = false;
function Zj(a2, b3, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b3, c2), c2 = c2.sibling;
}
function ak(a2, b3, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h4) {
    }
  switch (c2.tag) {
    case 5:
      U$1 || Mj(c2, b3);
    case 6:
      var d2 = X$1, e2 = Yj;
      X$1 = null;
      Zj(a2, b3, c2);
      X$1 = d2;
      Yj = e2;
      null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$1.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$1, c2.stateNode));
      break;
    case 4:
      d2 = X$1;
      e2 = Yj;
      X$1 = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b3, c2);
      X$1 = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$1 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f3 = e2, g2 = f3.destroy;
          f3 = f3.tag;
          void 0 !== g2 && (0 !== (f3 & 2) ? Nj(c2, b3, g2) : 0 !== (f3 & 4) && Nj(c2, b3, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a2, b3, c2);
      break;
    case 1:
      if (!U$1 && (Mj(c2, b3), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h4) {
          W(c2, b3, h4);
        }
      Zj(a2, b3, c2);
      break;
    case 21:
      Zj(a2, b3, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$1 = (d2 = U$1) || null !== c2.memoizedState, Zj(a2, b3, c2), U$1 = d2) : Zj(a2, b3, c2);
      break;
    default:
      Zj(a2, b3, c2);
  }
}
function bk(a2) {
  var b3 = a2.updateQueue;
  if (null !== b3) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b3.forEach(function(b4) {
      var d2 = ck.bind(null, a2, b4);
      c2.has(b4) || (c2.add(b4), b4.then(d2, d2));
    });
  }
}
function dk(a2, b3) {
  var c2 = b3.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f3 = a2, g2 = b3, h4 = g2;
        a:
          for (; null !== h4; ) {
            switch (h4.tag) {
              case 5:
                X$1 = h4.stateNode;
                Yj = false;
                break a;
              case 3:
                X$1 = h4.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$1 = h4.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h4 = h4.return;
          }
        if (null === X$1)
          throw Error(p$7(160));
        ak(f3, g2, e2);
        X$1 = null;
        Yj = false;
        var k4 = e2.alternate;
        null !== k4 && (k4.return = null);
        e2.return = null;
      } catch (l2) {
        W(e2, b3, l2);
      }
    }
  if (b3.subtreeFlags & 12854)
    for (b3 = b3.child; null !== b3; )
      ek(b3, a2), b3 = b3.sibling;
}
function ek(a2, b3) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b3, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      dk(b3, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b3, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f3 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f3, h4 = a2.type, k4 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k4)
          try {
            "input" === h4 && "radio" === f3.type && null != f3.name && ab(e2, f3);
            vb(h4, g2);
            var l2 = vb(h4, f3);
            for (g2 = 0; g2 < k4.length; g2 += 2) {
              var m2 = k4[g2], q2 = k4[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h4) {
              case "input":
                bb(e2, f3);
                break;
              case "textarea":
                ib(e2, f3);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f3.multiple;
                var y2 = f3.value;
                null != y2 ? fb(e2, !!f3.multiple, y2, false) : r2 !== !!f3.multiple && (null != f3.defaultValue ? fb(
                  e2,
                  !!f3.multiple,
                  f3.defaultValue,
                  true
                ) : fb(e2, !!f3.multiple, f3.multiple ? [] : "", false));
            }
            e2[Pf] = f3;
          } catch (t2) {
            W(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      dk(b3, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$7(162));
        e2 = a2.stateNode;
        f3 = a2.memoizedProps;
        try {
          e2.nodeValue = f3;
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      dk(b3, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b3.containerInfo);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      break;
    case 4:
      dk(b3, a2);
      fk(a2);
      break;
    case 13:
      dk(b3, a2);
      fk(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f3 = null !== e2.memoizedState, e2.stateNode.isHidden = f3, !f3 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B$1()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U$1 = (l2 = U$1) || m2, dk(b3, a2), U$1 = l2) : dk(b3, a2);
      fk(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V$3 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V$3 = m2; null !== V$3; ) {
              r2 = V$3;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n4 = r2.stateNode;
                  if ("function" === typeof n4.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b3 = d2, n4.props = b3.memoizedProps, n4.state = b3.memoizedState, n4.componentWillUnmount();
                    } catch (t2) {
                      W(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V$3 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f3 = e2.style, "function" === typeof f3.setProperty ? f3.setProperty("display", "none", "important") : f3.display = "none") : (h4 = q2.stateNode, k4 = q2.memoizedProps.style, g2 = void 0 !== k4 && null !== k4 && k4.hasOwnProperty("display") ? k4.display : null, h4.style.display = rb("display", g2));
                } catch (t2) {
                  W(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W(a2, a2.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b3, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b3,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b3 = a2.flags;
  if (b3 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$7(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f3 = Vj(a2);
          Xj(a2, f3, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h4 = Vj(a2);
          Wj(a2, h4, g2);
          break;
        default:
          throw Error(p$7(161));
      }
    } catch (k4) {
      W(a2, a2.return, k4);
    }
    a2.flags &= -3;
  }
  b3 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b3, c2) {
  V$3 = a2;
  jk(a2);
}
function jk(a2, b3, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V$3; ) {
    var e2 = V$3, f3 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Kj;
      if (!g2) {
        var h4 = e2.alternate, k4 = null !== h4 && null !== h4.memoizedState || U$1;
        h4 = Kj;
        var l2 = U$1;
        Kj = g2;
        if ((U$1 = k4) && !l2)
          for (V$3 = e2; null !== V$3; )
            g2 = V$3, k4 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k4 ? (k4.return = g2, V$3 = k4) : kk(e2);
        for (; null !== f3; )
          V$3 = f3, jk(f3), f3 = f3.sibling;
        V$3 = e2;
        Kj = h4;
        U$1 = l2;
      }
      lk(a2);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f3 ? (f3.return = e2, V$3 = f3) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V$3; ) {
    var b3 = V$3;
    if (0 !== (b3.flags & 8772)) {
      var c2 = b3.alternate;
      try {
        if (0 !== (b3.flags & 8772))
          switch (b3.tag) {
            case 0:
            case 11:
            case 15:
              U$1 || Rj(5, b3);
              break;
            case 1:
              var d2 = b3.stateNode;
              if (b3.flags & 4 && !U$1)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b3.elementType === b3.type ? c2.memoizedProps : Lg(b3.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f3 = b3.updateQueue;
              null !== f3 && ih(b3, f3, d2);
              break;
            case 3:
              var g2 = b3.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b3.child)
                  switch (b3.child.tag) {
                    case 5:
                      c2 = b3.child.stateNode;
                      break;
                    case 1:
                      c2 = b3.child.stateNode;
                  }
                ih(b3, g2, c2);
              }
              break;
            case 5:
              var h4 = b3.stateNode;
              if (null === c2 && b3.flags & 4) {
                c2 = h4;
                var k4 = b3.memoizedProps;
                switch (b3.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k4.autoFocus && c2.focus();
                    break;
                  case "img":
                    k4.src && (c2.src = k4.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b3.memoizedState) {
                var l2 = b3.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$7(163));
          }
        U$1 || b3.flags & 512 && Sj(b3);
      } catch (r2) {
        W(b3, b3.return, r2);
      }
    }
    if (b3 === a2) {
      V$3 = null;
      break;
    }
    c2 = b3.sibling;
    if (null !== c2) {
      c2.return = b3.return;
      V$3 = c2;
      break;
    }
    V$3 = b3.return;
  }
}
function hk(a2) {
  for (; null !== V$3; ) {
    var b3 = V$3;
    if (b3 === a2) {
      V$3 = null;
      break;
    }
    var c2 = b3.sibling;
    if (null !== c2) {
      c2.return = b3.return;
      V$3 = c2;
      break;
    }
    V$3 = b3.return;
  }
}
function kk(a2) {
  for (; null !== V$3; ) {
    var b3 = V$3;
    try {
      switch (b3.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b3.return;
          try {
            Rj(4, b3);
          } catch (k4) {
            W(b3, c2, k4);
          }
          break;
        case 1:
          var d2 = b3.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b3.return;
            try {
              d2.componentDidMount();
            } catch (k4) {
              W(b3, e2, k4);
            }
          }
          var f3 = b3.return;
          try {
            Sj(b3);
          } catch (k4) {
            W(b3, f3, k4);
          }
          break;
        case 5:
          var g2 = b3.return;
          try {
            Sj(b3);
          } catch (k4) {
            W(b3, g2, k4);
          }
      }
    } catch (k4) {
      W(b3, b3.return, k4);
    }
    if (b3 === a2) {
      V$3 = null;
      break;
    }
    var h4 = b3.sibling;
    if (null !== h4) {
      h4.return = b3.return;
      V$3 = h4;
      break;
    }
    V$3 = b3.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$2 = 0, R$3 = null, Y = null, Z$3 = 0, gj = 0, fj = Uf(0), T$3 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$3() {
  return 0 !== (K$2 & 6) ? B$1() : -1 !== Bk ? Bk : Bk = B$1();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K$2 & 2) && 0 !== Z$3)
    return Z$3 & -Z$3;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C$3;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b3, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$7(185));
  Ac(a2, c2, d2);
  if (0 === (K$2 & 2) || a2 !== R$3)
    a2 === R$3 && (0 === (K$2 & 2) && (rk |= c2), 4 === T$3 && Dk(a2, Z$3)), Ek(a2, d2), 1 === c2 && 0 === K$2 && 0 === (b3.mode & 1) && (Hj = B$1() + 500, fg && jg());
}
function Ek(a2, b3) {
  var c2 = a2.callbackNode;
  wc(a2, b3);
  var d2 = uc(a2, a2 === R$3 ? Z$3 : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b3 = d2 & -d2, a2.callbackPriority !== b3) {
    null != c2 && bc(c2);
    if (1 === b3)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K$2 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b3;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b3) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$2 & 6))
    throw Error(p$7(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R$3 ? Z$3 : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b3)
    b3 = Jk(a2, d2);
  else {
    b3 = d2;
    var e2 = K$2;
    K$2 |= 2;
    var f3 = Kk();
    if (R$3 !== a2 || Z$3 !== b3)
      vk = null, Hj = B$1() + 500, Lk(a2, b3);
    do
      try {
        Mk();
        break;
      } catch (h4) {
        Nk(a2, h4);
      }
    while (1);
    Qg();
    nk.current = f3;
    K$2 = e2;
    null !== Y ? b3 = 0 : (R$3 = null, Z$3 = 0, b3 = T$3);
  }
  if (0 !== b3) {
    2 === b3 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b3 = Ok(a2, e2)));
    if (1 === b3)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$1()), c2;
    if (6 === b3)
      Dk(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b3 = Jk(a2, d2), 2 === b3 && (f3 = xc(a2), 0 !== f3 && (d2 = f3, b3 = Ok(a2, f3))), 1 === b3))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$1()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b3) {
        case 0:
        case 1:
          throw Error(p$7(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b3 = gk + 500 - B$1(), 10 < b3)) {
            if (0 !== uc(a2, 0))
              break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L$3();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b3);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b3 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f3 = 1 << g2;
            g2 = b3[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f3;
          }
          d2 = e2;
          d2 = B$1() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$7(329));
      }
    }
  }
  Ek(a2, B$1());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b3) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b3).flags |= 256);
  a2 = Jk(a2, b3);
  2 !== a2 && (b3 = uk, uk = c2, null !== b3 && Gj(b3));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b3 = a2; ; ) {
    if (b3.flags & 16384) {
      var c2 = b3.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f3 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He$1(f3(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b3.child;
    if (b3.subtreeFlags & 16384 && null !== c2)
      c2.return = b3, b3 = c2;
    else {
      if (b3 === a2)
        break;
      for (; null === b3.sibling; ) {
        if (null === b3.return || b3.return === a2)
          return true;
        b3 = b3.return;
      }
      b3.sibling.return = b3.return;
      b3 = b3.sibling;
    }
  }
  return true;
}
function Dk(a2, b3) {
  b3 &= ~sk;
  b3 &= ~rk;
  a2.suspendedLanes |= b3;
  a2.pingedLanes &= ~b3;
  for (a2 = a2.expirationTimes; 0 < b3; ) {
    var c2 = 31 - oc(b3), d2 = 1 << c2;
    a2[c2] = -1;
    b3 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K$2 & 6))
    throw Error(p$7(327));
  Ik();
  var b3 = uc(a2, 0);
  if (0 === (b3 & 1))
    return Ek(a2, B$1()), null;
  var c2 = Jk(a2, b3);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b3 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b3), Ek(a2, B$1()), c2;
  if (6 === c2)
    throw Error(p$7(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b3;
  Qk(a2, uk, vk);
  Ek(a2, B$1());
  return null;
}
function Rk(a2, b3) {
  var c2 = K$2;
  K$2 |= 1;
  try {
    return a2(b3);
  } finally {
    K$2 = c2, 0 === K$2 && (Hj = B$1() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K$2 & 6) && Ik();
  var b3 = K$2;
  K$2 |= 1;
  var c2 = pk.transition, d2 = C$3;
  try {
    if (pk.transition = null, C$3 = 1, a2)
      return a2();
  } finally {
    C$3 = d2, pk.transition = c2, K$2 = b3, 0 === (K$2 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$2(fj);
}
function Lk(a2, b3) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y)
    for (c2 = Y.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E$2(Wf);
          E$2(H$3);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$2(M$2);
          break;
        case 19:
          E$2(M$2);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R$3 = a2;
  Y = a2 = wh(a2.current, null);
  Z$3 = gj = b3;
  T$3 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b3 = 0; b3 < Wg.length; b3++)
      if (c2 = Wg[b3], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f3 = c2.pending;
        if (null !== f3) {
          var g2 = f3.next;
          f3.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b3) {
  do {
    var c2 = Y;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d2 = N$3.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$4 = O$1 = N$3 = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T$3 = 1;
        qk = b3;
        Y = null;
        break;
      }
      a: {
        var f3 = a2, g2 = c2.return, h4 = c2, k4 = b3;
        b3 = Z$3;
        h4.flags |= 32768;
        if (null !== k4 && "object" === typeof k4 && "function" === typeof k4.then) {
          var l2 = k4, m2 = h4, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g2, h4, f3, b3);
            y2.mode & 1 && Ti(f3, l2, b3);
            b3 = y2;
            k4 = l2;
            var n4 = b3.updateQueue;
            if (null === n4) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k4);
              b3.updateQueue = t2;
            } else
              n4.add(k4);
            break a;
          } else {
            if (0 === (b3 & 1)) {
              Ti(f3, l2, b3);
              uj();
              break a;
            }
            k4 = Error(p$7(426));
          }
        } else if (I$2 && h4.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h4, f3, b3);
            Jg(Ki(k4, h4));
            break a;
          }
        }
        f3 = k4 = Ki(k4, h4);
        4 !== T$3 && (T$3 = 2);
        null === tk ? tk = [f3] : tk.push(f3);
        f3 = g2;
        do {
          switch (f3.tag) {
            case 3:
              f3.flags |= 65536;
              b3 &= -b3;
              f3.lanes |= b3;
              var x2 = Oi(f3, k4, b3);
              fh(f3, x2);
              break a;
            case 1:
              h4 = k4;
              var w2 = f3.type, u2 = f3.stateNode;
              if (0 === (f3.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f3.flags |= 65536;
                b3 &= -b3;
                f3.lanes |= b3;
                var F2 = Ri(f3, h4, b3);
                fh(f3, F2);
                break a;
              }
          }
          f3 = f3.return;
        } while (null !== f3);
      }
      Tk(c2);
    } catch (na) {
      b3 = na;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai;
  return null === a2 ? ai : a2;
}
function uj() {
  if (0 === T$3 || 3 === T$3 || 2 === T$3)
    T$3 = 4;
  null === R$3 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$3, Z$3);
}
function Jk(a2, b3) {
  var c2 = K$2;
  K$2 |= 2;
  var d2 = Kk();
  if (R$3 !== a2 || Z$3 !== b3)
    vk = null, Lk(a2, b3);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a2, e2);
    }
  while (1);
  Qg();
  K$2 = c2;
  nk.current = d2;
  if (null !== Y)
    throw Error(p$7(261));
  R$3 = null;
  Z$3 = 0;
  return T$3;
}
function Uk() {
  for (; null !== Y; )
    Vk(Y);
}
function Mk() {
  for (; null !== Y && !cc(); )
    Vk(Y);
}
function Vk(a2) {
  var b3 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b3 ? Tk(a2) : Y = b3;
  ok.current = null;
}
function Tk(a2) {
  var b3 = a2;
  do {
    var c2 = b3.alternate;
    a2 = b3.return;
    if (0 === (b3.flags & 32768)) {
      if (c2 = Fj(c2, b3, gj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b3);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$3 = 6;
        Y = null;
        return;
      }
    }
    b3 = b3.sibling;
    if (null !== b3) {
      Y = b3;
      return;
    }
    Y = b3 = a2;
  } while (null !== b3);
  0 === T$3 && (T$3 = 5);
}
function Qk(a2, b3, c2) {
  var d2 = C$3, e2 = pk.transition;
  try {
    pk.transition = null, C$3 = 1, Xk(a2, b3, c2, d2);
  } finally {
    pk.transition = e2, C$3 = d2;
  }
  return null;
}
function Xk(a2, b3, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$2 & 6))
    throw Error(p$7(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$7(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f3 = c2.lanes | c2.childLanes;
  Bc(a2, f3);
  a2 === R$3 && (Y = R$3 = null, Z$3 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f3 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f3) {
    f3 = pk.transition;
    pk.transition = null;
    var g2 = C$3;
    C$3 = 1;
    var h4 = K$2;
    K$2 |= 4;
    ok.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K$2 = h4;
    C$3 = g2;
    pk.transition = f3;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e2);
  f3 = a2.pendingLanes;
  0 === f3 && (Si = null);
  mc(c2.stateNode);
  Ek(a2, B$1());
  if (null !== b3)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b3.length; c2++)
      e2 = b3[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a2 = Qi, Qi = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f3 = a2.pendingLanes;
  0 !== (f3 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b3 = pk.transition, c2 = C$3;
    try {
      pk.transition = null;
      C$3 = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$2 & 6))
          throw Error(p$7(331));
        var e2 = K$2;
        K$2 |= 4;
        for (V$3 = a2.current; null !== V$3; ) {
          var f3 = V$3, g2 = f3.child;
          if (0 !== (V$3.flags & 16)) {
            var h4 = f3.deletions;
            if (null !== h4) {
              for (var k4 = 0; k4 < h4.length; k4++) {
                var l2 = h4[k4];
                for (V$3 = l2; null !== V$3; ) {
                  var m2 = V$3;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f3);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V$3 = q2;
                  else
                    for (; null !== V$3; ) {
                      m2 = V$3;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V$3 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V$3 = r2;
                        break;
                      }
                      V$3 = y2;
                    }
                }
              }
              var n4 = f3.alternate;
              if (null !== n4) {
                var t2 = n4.child;
                if (null !== t2) {
                  n4.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$3 = f3;
            }
          }
          if (0 !== (f3.subtreeFlags & 2064) && null !== g2)
            g2.return = f3, V$3 = g2;
          else
            b:
              for (; null !== V$3; ) {
                f3 = V$3;
                if (0 !== (f3.flags & 2048))
                  switch (f3.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f3, f3.return);
                  }
                var x2 = f3.sibling;
                if (null !== x2) {
                  x2.return = f3.return;
                  V$3 = x2;
                  break b;
                }
                V$3 = f3.return;
              }
        }
        var w2 = a2.current;
        for (V$3 = w2; null !== V$3; ) {
          g2 = V$3;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V$3 = u2;
          else
            b:
              for (g2 = w2; null !== V$3; ) {
                h4 = V$3;
                if (0 !== (h4.flags & 2048))
                  try {
                    switch (h4.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h4);
                    }
                  } catch (na) {
                    W(h4, h4.return, na);
                  }
                if (h4 === g2) {
                  V$3 = null;
                  break b;
                }
                var F2 = h4.sibling;
                if (null !== F2) {
                  F2.return = h4.return;
                  V$3 = F2;
                  break b;
                }
                V$3 = h4.return;
              }
        }
        K$2 = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C$3 = c2, pk.transition = b3;
    }
  }
  return false;
}
function Yk(a2, b3, c2) {
  b3 = Ki(c2, b3);
  b3 = Oi(a2, b3, 1);
  a2 = dh(a2, b3, 1);
  b3 = L$3();
  null !== a2 && (Ac(a2, 1, b3), Ek(a2, b3));
}
function W(a2, b3, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b3; ) {
      if (3 === b3.tag) {
        Yk(b3, a2, c2);
        break;
      } else if (1 === b3.tag) {
        var d2 = b3.stateNode;
        if ("function" === typeof b3.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a2 = Ki(c2, a2);
          a2 = Ri(b3, a2, 1);
          b3 = dh(b3, a2, 1);
          a2 = L$3();
          null !== b3 && (Ac(b3, 1, a2), Ek(b3, a2));
          break;
        }
      }
      b3 = b3.return;
    }
}
function Ui(a2, b3, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b3);
  b3 = L$3();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R$3 === a2 && (Z$3 & c2) === c2 && (4 === T$3 || 3 === T$3 && (Z$3 & 130023424) === Z$3 && 500 > B$1() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b3);
}
function Zk(a2, b3) {
  0 === b3 && (0 === (a2.mode & 1) ? b3 = 1 : (b3 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L$3();
  a2 = Zg(a2, b3);
  null !== a2 && (Ac(a2, b3, c2), Ek(a2, c2));
}
function vj(a2) {
  var b3 = a2.memoizedState, c2 = 0;
  null !== b3 && (c2 = b3.retryLane);
  Zk(a2, c2);
}
function ck(a2, b3) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$7(314));
  }
  null !== d2 && d2.delete(b3);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b3, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b3.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b3.flags & 128))
        return Ug = false, zj(a2, b3, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$2 && 0 !== (b3.flags & 1048576) && ug(b3, ng, b3.index);
  b3.lanes = 0;
  switch (b3.tag) {
    case 2:
      var d2 = b3.type;
      jj(a2, b3);
      a2 = b3.pendingProps;
      var e2 = Yf(b3, H$3.current);
      Tg(b3, c2);
      e2 = Xh(null, b3, d2, a2, e2, c2);
      var f3 = bi();
      b3.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b3.tag = 1, b3.memoizedState = null, b3.updateQueue = null, Zf(d2) ? (f3 = true, cg(b3)) : f3 = false, b3.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b3), e2.updater = nh, b3.stateNode = e2, e2._reactInternals = b3, rh$1(b3, d2, a2, c2), b3 = kj(null, b3, d2, true, f3, c2)) : (b3.tag = 0, I$2 && f3 && vg(b3), Yi(null, b3, e2, c2), b3 = b3.child);
      return b3;
    case 16:
      d2 = b3.elementType;
      a: {
        jj(a2, b3);
        a2 = b3.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b3.type = d2;
        e2 = b3.tag = $k(d2);
        a2 = Lg(d2, a2);
        switch (e2) {
          case 0:
            b3 = dj(null, b3, d2, a2, c2);
            break a;
          case 1:
            b3 = ij(null, b3, d2, a2, c2);
            break a;
          case 11:
            b3 = Zi(null, b3, d2, a2, c2);
            break a;
          case 14:
            b3 = aj(null, b3, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$7(
          306,
          d2,
          ""
        ));
      }
      return b3;
    case 0:
      return d2 = b3.type, e2 = b3.pendingProps, e2 = b3.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b3, d2, e2, c2);
    case 1:
      return d2 = b3.type, e2 = b3.pendingProps, e2 = b3.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b3, d2, e2, c2);
    case 3:
      a: {
        lj(b3);
        if (null === a2)
          throw Error(p$7(387));
        d2 = b3.pendingProps;
        f3 = b3.memoizedState;
        e2 = f3.element;
        bh(a2, b3);
        gh(b3, d2, null, c2);
        var g2 = b3.memoizedState;
        d2 = g2.element;
        if (f3.isDehydrated)
          if (f3 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b3.updateQueue.baseState = f3, b3.memoizedState = f3, b3.flags & 256) {
            e2 = Ki(Error(p$7(423)), b3);
            b3 = mj(a2, b3, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki(Error(p$7(424)), b3);
            b3 = mj(a2, b3, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b3.stateNode.containerInfo.firstChild), xg = b3, I$2 = true, zg = null, c2 = Ch(b3, null, d2, c2), b3.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b3 = $i(a2, b3, c2);
            break a;
          }
          Yi(a2, b3, d2, c2);
        }
        b3 = b3.child;
      }
      return b3;
    case 5:
      return Kh$1(b3), null === a2 && Eg(b3), d2 = b3.type, e2 = b3.pendingProps, f3 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f3 && Ef(d2, f3) && (b3.flags |= 32), hj(a2, b3), Yi(a2, b3, g2, c2), b3.child;
    case 6:
      return null === a2 && Eg(b3), null;
    case 13:
      return pj(a2, b3, c2);
    case 4:
      return Ih(b3, b3.stateNode.containerInfo), d2 = b3.pendingProps, null === a2 ? b3.child = Bh(b3, null, d2, c2) : Yi(a2, b3, d2, c2), b3.child;
    case 11:
      return d2 = b3.type, e2 = b3.pendingProps, e2 = b3.elementType === d2 ? e2 : Lg(d2, e2), Zi(a2, b3, d2, e2, c2);
    case 7:
      return Yi(a2, b3, b3.pendingProps, c2), b3.child;
    case 8:
      return Yi(a2, b3, b3.pendingProps.children, c2), b3.child;
    case 12:
      return Yi(a2, b3, b3.pendingProps.children, c2), b3.child;
    case 10:
      a: {
        d2 = b3.type._context;
        e2 = b3.pendingProps;
        f3 = b3.memoizedProps;
        g2 = e2.value;
        G$1(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f3)
          if (He$1(f3.value, g2)) {
            if (f3.children === e2.children && !Wf.current) {
              b3 = $i(a2, b3, c2);
              break a;
            }
          } else
            for (f3 = b3.child, null !== f3 && (f3.return = b3); null !== f3; ) {
              var h4 = f3.dependencies;
              if (null !== h4) {
                g2 = f3.child;
                for (var k4 = h4.firstContext; null !== k4; ) {
                  if (k4.context === d2) {
                    if (1 === f3.tag) {
                      k4 = ch(-1, c2 & -c2);
                      k4.tag = 2;
                      var l2 = f3.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k4.next = k4 : (k4.next = m2.next, m2.next = k4);
                        l2.pending = k4;
                      }
                    }
                    f3.lanes |= c2;
                    k4 = f3.alternate;
                    null !== k4 && (k4.lanes |= c2);
                    Sg(
                      f3.return,
                      c2,
                      b3
                    );
                    h4.lanes |= c2;
                    break;
                  }
                  k4 = k4.next;
                }
              } else if (10 === f3.tag)
                g2 = f3.type === b3.type ? null : f3.child;
              else if (18 === f3.tag) {
                g2 = f3.return;
                if (null === g2)
                  throw Error(p$7(341));
                g2.lanes |= c2;
                h4 = g2.alternate;
                null !== h4 && (h4.lanes |= c2);
                Sg(g2, c2, b3);
                g2 = f3.sibling;
              } else
                g2 = f3.child;
              if (null !== g2)
                g2.return = f3;
              else
                for (g2 = f3; null !== g2; ) {
                  if (g2 === b3) {
                    g2 = null;
                    break;
                  }
                  f3 = g2.sibling;
                  if (null !== f3) {
                    f3.return = g2.return;
                    g2 = f3;
                    break;
                  }
                  g2 = g2.return;
                }
              f3 = g2;
            }
        Yi(a2, b3, e2.children, c2);
        b3 = b3.child;
      }
      return b3;
    case 9:
      return e2 = b3.type, d2 = b3.pendingProps.children, Tg(b3, c2), e2 = Vg(e2), d2 = d2(e2), b3.flags |= 1, Yi(a2, b3, d2, c2), b3.child;
    case 14:
      return d2 = b3.type, e2 = Lg(d2, b3.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b3, d2, e2, c2);
    case 15:
      return cj(a2, b3, b3.type, b3.pendingProps, c2);
    case 17:
      return d2 = b3.type, e2 = b3.pendingProps, e2 = b3.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b3), b3.tag = 1, Zf(d2) ? (a2 = true, cg(b3)) : a2 = false, Tg(b3, c2), ph(b3, d2, e2), rh$1(b3, d2, e2, c2), kj(null, b3, d2, true, a2, c2);
    case 19:
      return yj(a2, b3, c2);
    case 22:
      return ej(a2, b3, c2);
  }
  throw Error(p$7(156, b3.tag));
};
function Gk(a2, b3) {
  return ac(a2, b3);
}
function al(a2, b3, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b3;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b3, c2, d2) {
  return new al(a2, b3, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b3) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b3, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b3, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b3 = a2.dependencies;
  c2.dependencies = null === b3 ? null : { lanes: b3.lanes, firstContext: b3.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b3, c2, d2, e2, f3) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e2, f3, b3);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b3, e2 | 2), a2.elementType = Aa, a2.lanes = f3, a2;
        case Ea:
          return a2 = Bg(13, c2, b3, e2), a2.elementType = Ea, a2.lanes = f3, a2;
        case Fa:
          return a2 = Bg(19, c2, b3, e2), a2.elementType = Fa, a2.lanes = f3, a2;
        case Ia:
          return qj(c2, e2, f3, b3);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$7(130, null == a2 ? a2 : typeof a2, ""));
      }
  b3 = Bg(g2, c2, b3, e2);
  b3.elementType = a2;
  b3.type = d2;
  b3.lanes = f3;
  return b3;
}
function Ah(a2, b3, c2, d2) {
  a2 = Bg(7, a2, d2, b3);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b3, c2, d2) {
  a2 = Bg(22, a2, d2, b3);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b3, c2) {
  a2 = Bg(6, a2, null, b3);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b3, c2) {
  b3 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b3);
  b3.lanes = c2;
  b3.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b3;
}
function bl(a2, b3, c2, d2, e2) {
  this.tag = b3;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b3, c2, d2, e2, f3, g2, h4, k4) {
  a2 = new bl(a2, b3, c2, h4, k4);
  1 === b3 ? (b3 = 1, true === f3 && (b3 |= 8)) : b3 = 0;
  f3 = Bg(3, null, null, b3);
  a2.current = f3;
  f3.stateNode = a2;
  f3.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f3);
  return a2;
}
function dl(a2, b3, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b3, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$7(170));
    var b3 = a2;
    do {
      switch (b3.tag) {
        case 3:
          b3 = b3.stateNode.context;
          break a;
        case 1:
          if (Zf(b3.type)) {
            b3 = b3.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b3 = b3.return;
    } while (null !== b3);
    throw Error(p$7(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b3);
  }
  return b3;
}
function fl(a2, b3, c2, d2, e2, f3, g2, h4, k4) {
  a2 = cl(c2, d2, true, a2, e2, f3, g2, h4, k4);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L$3();
  e2 = lh(c2);
  f3 = ch(d2, e2);
  f3.callback = void 0 !== b3 && null !== b3 ? b3 : null;
  dh(c2, f3, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b3, c2, d2) {
  var e2 = b3.current, f3 = L$3(), g2 = lh(e2);
  c2 = el(c2);
  null === b3.context ? b3.context = c2 : b3.pendingContext = c2;
  b3 = ch(f3, g2);
  b3.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b3.callback = d2);
  a2 = dh(e2, b3, g2);
  null !== a2 && (mh(a2, e2, g2, f3), eh(a2, e2, g2));
  return g2;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b3) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b3 ? c2 : b3;
  }
}
function jl(a2, b3) {
  il(a2, b3);
  (a2 = a2.alternate) && il(a2, b3);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b3 = this._internalRoot;
  if (null === b3)
    throw Error(p$7(409));
  gl(a2, b3, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b3 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b3[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b3 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b3 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b3 && b3 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b3, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f3 = d2;
      d2 = function() {
        var a3 = hl(g2);
        f3.call(a3);
      };
    }
    var g2 = fl(b3, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g2;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h4 = d2;
    d2 = function() {
      var a3 = hl(k4);
      h4.call(a3);
    };
  }
  var k4 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k4;
  a2[uf] = k4.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b3, k4, c2, d2);
  });
  return k4;
}
function sl(a2, b3, c2, d2, e2) {
  var f3 = c2._reactRootContainer;
  if (f3) {
    var g2 = f3;
    if ("function" === typeof e2) {
      var h4 = e2;
      e2 = function() {
        var a3 = hl(g2);
        h4.call(a3);
      };
    }
    gl(b3, g2, a2, e2);
  } else
    g2 = rl(c2, b3, a2, e2, d2);
  return hl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b3 = a2.stateNode;
      if (b3.current.memoizedState.isDehydrated) {
        var c2 = tc(b3.pendingLanes);
        0 !== c2 && (Cc(b3, c2 | 1), Ek(b3, B$1()), 0 === (K$2 & 6) && (Hj = B$1() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b4 = Zg(a2, 1);
        if (null !== b4) {
          var c3 = L$3();
          mh(b4, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b3 = Zg(a2, 134217728);
    if (null !== b3) {
      var c2 = L$3();
      mh(b3, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b3 = lh(a2), c2 = Zg(a2, b3);
    if (null !== c2) {
      var d2 = L$3();
      mh(c2, a2, b3, d2);
    }
    jl(a2, b3);
  }
};
Hc = function() {
  return C$3;
};
Ic = function(a2, b3) {
  var c2 = C$3;
  try {
    return C$3 = a2, b3();
  } finally {
    C$3 = c2;
  }
};
yb = function(a2, b3, c2) {
  switch (b3) {
    case "input":
      bb(a2, c2);
      b3 = c2.name;
      if ("radio" === c2.type && null != b3) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b3) + '][type="radio"]');
        for (b3 = 0; b3 < c2.length; b3++) {
          var d2 = c2[b3];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$7(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b3 = c2.value, null != b3 && fb(a2, !!c2.multiple, b3, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b3) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b3))
    throw Error(p$7(200));
  return dl(a2, b3, null, c2);
};
reactDom_production_min.createRoot = function(a2, b3) {
  if (!ol(a2))
    throw Error(p$7(299));
  var c2 = false, d2 = "", e2 = ll;
  null !== b3 && void 0 !== b3 && (true === b3.unstable_strictMode && (c2 = true), void 0 !== b3.identifierPrefix && (d2 = b3.identifierPrefix), void 0 !== b3.onRecoverableError && (e2 = b3.onRecoverableError));
  b3 = cl(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf] = b3.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b3);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b3 = a2._reactInternals;
  if (void 0 === b3) {
    if ("function" === typeof a2.render)
      throw Error(p$7(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$7(268, a2));
  }
  a2 = Zb(b3);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b3, c2) {
  if (!pl(b3))
    throw Error(p$7(200));
  return sl(null, a2, b3, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b3, c2) {
  if (!ol(a2))
    throw Error(p$7(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f3 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f3 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b3 = fl(b3, null, a2, 1, null != c2 ? c2 : null, e2, false, f3, g2);
  a2[uf] = b3.current;
  sf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b3.mutableSourceEagerHydrationData ? b3.mutableSourceEagerHydrationData = [c2, e2] : b3.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b3);
};
reactDom_production_min.render = function(a2, b3, c2) {
  if (!pl(b3))
    throw Error(p$7(200));
  return sl(null, a2, b3, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$7(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b3, c2, d2) {
  if (!pl(c2))
    throw Error(p$7(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$7(38));
  return sl(a2, b3, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var m$5 = reactDomExports;
{
  client.createRoot = m$5.createRoot;
  client.hydrateRoot = m$5.hydrateRoot;
}
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i3 = 0; i3 < document.styleSheets.length; i3++) {
    if (document.styleSheets[i3].ownerNode === tag) {
      return document.styleSheets[i3];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from$1 = String.fromCharCode;
var assign = Object.assign;
function hash$5(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim$2(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace$1(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node$1(value, root, parent2, type, props, children, length2) {
  return { value, root, parent: parent2, type, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign(node$1("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice$1(begin, end) {
  return substr(characters, begin, end);
}
function token$1(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim$2(slice$1(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token$1(type) > 2 || token$1(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice$1(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice$1(index2, position - 1) + "*" + from$1(type === 47 ? type : next());
}
function identifier(index2) {
  while (!token$1(peek()))
    next();
  return slice$1(index2, position);
}
function compile(value) {
  return dealloc(parse$2("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$2(value, root, parent2, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace$1(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent2), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1)
              characters2 = replace$1(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent2, length2 - 1) : declaration(replace$1(characters2, " ", "") + ";", rule, parent2, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent2, index2, offset, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse$2(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$2(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$2(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from$1(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent2, index2, offset, rules, points, type, props, children, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size2 = sizeof(rule);
  for (var i3 = 0, j2 = 0, k4 = 0; i3 < index2; ++i3)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i3])), z2 = value; x2 < size2; ++x2)
      if (z2 = trim$2(j2 > 0 ? rule[x2] + " " + y2 : replace$1(y2, /&\f/g, rule[x2])))
        props[k4++] = z2;
  return node$1(value, root, parent2, offset === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent2) {
  return node$1(value, root, parent2, COMMENT, from$1(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent2, length2) {
  return node$1(value, root, parent2, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize$1(children, callback) {
  var output2 = "";
  var length2 = sizeof(children);
  for (var i3 = 0; i3 < length2; i3++)
    output2 += callback(children[i3], i3, children, callback) || "";
  return output2;
}
function stringify$2(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize$1(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize$1(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output2 = "";
    for (var i3 = 0; i3 < length2; i3++)
      output2 += collection[i3](element, index2, children, callback) || "";
    return output2;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
var weakMemoize = function weakMemoize2(func) {
  var cache = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache.has(arg)) {
      return cache.get(arg);
    }
    var ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
};
function memoize$1(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn2(arg);
    return cache[arg];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token$1(character2)) {
      break;
    }
    next();
  }
  return slice$1(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token$1(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from$1(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent2 = element.parent;
  var isImplicitRule = element.column === parent2.column && element.line === parent2.line;
  while (parent2.type !== "rule") {
    parent2 = parent2.parent;
    if (!parent2)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent2)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent2.props;
  for (var i3 = 0, k4 = 0; i3 < rules.length; i3++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k4++) {
      element.props[k4] = points[i3] ? rules[i3].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i3];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix$1(value, length2) {
  switch (hash$5(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace$1(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace$1(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace$1(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace$1(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace$1(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace$1(value, "-grow", "") + WEBKIT + value + MS + replace$1(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace$1(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace$1(replace$1(replace$1(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace$1(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace$1(replace$1(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace$1(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace$1(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix$1(replace$1(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace$1(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace$1(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix$1(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize$1([copy(element, {
            value: replace$1(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length)
            return combine(element.props, function(value) {
              switch (match(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize$1([copy(element, {
                    props: [replace$1(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize$1([copy(element, {
                    props: [replace$1(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy(element, {
                    props: [replace$1(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy(element, {
                    props: [replace$1(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key2 = options.key;
  if (key2 === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key2 + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i3 = 1; i3 < attrib.length; i3++) {
          inserted[attrib[i3]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify$2, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize$1(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key: key2,
    sheet: new StyleSheet({
      key: key2,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
var reactIs$1 = { exports: {} };
var reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$4 = "function" === typeof Symbol && Symbol.for, c$a = b$4 ? Symbol.for("react.element") : 60103, d$5 = b$4 ? Symbol.for("react.portal") : 60106, e$c = b$4 ? Symbol.for("react.fragment") : 60107, f$a = b$4 ? Symbol.for("react.strict_mode") : 60108, g$3 = b$4 ? Symbol.for("react.profiler") : 60114, h$b = b$4 ? Symbol.for("react.provider") : 60109, k$4 = b$4 ? Symbol.for("react.context") : 60110, l$6 = b$4 ? Symbol.for("react.async_mode") : 60111, m$4 = b$4 ? Symbol.for("react.concurrent_mode") : 60111, n$d = b$4 ? Symbol.for("react.forward_ref") : 60112, p$6 = b$4 ? Symbol.for("react.suspense") : 60113, q$1 = b$4 ? Symbol.for("react.suspense_list") : 60120, r$h = b$4 ? Symbol.for("react.memo") : 60115, t$8 = b$4 ? Symbol.for("react.lazy") : 60116, v$3 = b$4 ? Symbol.for("react.block") : 60121, w$3 = b$4 ? Symbol.for("react.fundamental") : 60117, x$3 = b$4 ? Symbol.for("react.responder") : 60118, y$5 = b$4 ? Symbol.for("react.scope") : 60119;
function z$2(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$a:
        switch (a2 = a2.type, a2) {
          case l$6:
          case m$4:
          case e$c:
          case g$3:
          case f$a:
          case p$6:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$4:
              case n$d:
              case t$8:
              case r$h:
              case h$b:
                return a2;
              default:
                return u2;
            }
        }
      case d$5:
        return u2;
    }
  }
}
function A$3(a2) {
  return z$2(a2) === m$4;
}
reactIs_production_min$1.AsyncMode = l$6;
reactIs_production_min$1.ConcurrentMode = m$4;
reactIs_production_min$1.ContextConsumer = k$4;
reactIs_production_min$1.ContextProvider = h$b;
reactIs_production_min$1.Element = c$a;
reactIs_production_min$1.ForwardRef = n$d;
reactIs_production_min$1.Fragment = e$c;
reactIs_production_min$1.Lazy = t$8;
reactIs_production_min$1.Memo = r$h;
reactIs_production_min$1.Portal = d$5;
reactIs_production_min$1.Profiler = g$3;
reactIs_production_min$1.StrictMode = f$a;
reactIs_production_min$1.Suspense = p$6;
reactIs_production_min$1.isAsyncMode = function(a2) {
  return A$3(a2) || z$2(a2) === l$6;
};
reactIs_production_min$1.isConcurrentMode = A$3;
reactIs_production_min$1.isContextConsumer = function(a2) {
  return z$2(a2) === k$4;
};
reactIs_production_min$1.isContextProvider = function(a2) {
  return z$2(a2) === h$b;
};
reactIs_production_min$1.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$a;
};
reactIs_production_min$1.isForwardRef = function(a2) {
  return z$2(a2) === n$d;
};
reactIs_production_min$1.isFragment = function(a2) {
  return z$2(a2) === e$c;
};
reactIs_production_min$1.isLazy = function(a2) {
  return z$2(a2) === t$8;
};
reactIs_production_min$1.isMemo = function(a2) {
  return z$2(a2) === r$h;
};
reactIs_production_min$1.isPortal = function(a2) {
  return z$2(a2) === d$5;
};
reactIs_production_min$1.isProfiler = function(a2) {
  return z$2(a2) === g$3;
};
reactIs_production_min$1.isStrictMode = function(a2) {
  return z$2(a2) === f$a;
};
reactIs_production_min$1.isSuspense = function(a2) {
  return z$2(a2) === p$6;
};
reactIs_production_min$1.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e$c || a2 === m$4 || a2 === g$3 || a2 === f$a || a2 === p$6 || a2 === q$1 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t$8 || a2.$$typeof === r$h || a2.$$typeof === h$b || a2.$$typeof === k$4 || a2.$$typeof === n$d || a2.$$typeof === w$3 || a2.$$typeof === x$3 || a2.$$typeof === y$5 || a2.$$typeof === v$3);
};
reactIs_production_min$1.typeOf = z$2;
{
  reactIs$1.exports = reactIs_production_min$1;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
  registerStyles(cache, serialized, isStringTag2);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h4 = 0;
  var k4, i3 = 0, len = str.length;
  for (; len >= 4; ++i3, len -= 4) {
    k4 = str.charCodeAt(i3) & 255 | (str.charCodeAt(++i3) & 255) << 8 | (str.charCodeAt(++i3) & 255) << 16 | (str.charCodeAt(++i3) & 255) << 24;
    k4 = /* Math.imul(k, m): */
    (k4 & 65535) * 1540483477 + ((k4 >>> 16) * 59797 << 16);
    k4 ^= /* k >>> r: */
    k4 >>> 24;
    h4 = /* Math.imul(k, m): */
    (k4 & 65535) * 1540483477 + ((k4 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h4 ^= (str.charCodeAt(i3 + 2) & 255) << 16;
    case 2:
      h4 ^= (str.charCodeAt(i3 + 1) & 255) << 8;
    case 1:
      h4 ^= str.charCodeAt(i3) & 255;
      h4 = /* Math.imul(h, m): */
      (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
  }
  h4 ^= h4 >>> 13;
  h4 = /* Math.imul(h, m): */
  (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
  return ((h4 ^ h4 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key2, value) {
  switch (key2) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key2] !== 1 && !isCustomProperty(key2) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string2 = "";
  if (Array.isArray(obj)) {
    for (var i3 = 0; i3 < obj.length; i3++) {
      string2 += handleInterpolation(mergedProps, registered, obj[i3]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string2 += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string2 += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string2 += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string2 += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string2 += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string2;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    styles2 += strings[0];
  }
  for (var i3 = 1; i3 < args.length; i3++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i3]);
    if (stringMode) {
      styles2 += strings[i3];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  }
  var name2 = murmur2(styles2) + identifierName;
  return {
    name: name2,
    styles: styles2,
    next: cursor
  };
};
var syncFallback = function syncFallback2(create3) {
  return create3();
};
var useInsertionEffect = React["useInsertionEffect"] ? React["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref2) {
    var cache = reactExports.useContext(EmotionCacheContext);
    return func(props, cache, ref2);
  });
};
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
var getTheme = function getTheme2(outerTheme, theme2) {
  if (typeof theme2 === "function") {
    var mergedTheme = theme2(outerTheme);
    return mergedTheme;
  }
  return _extends$4({}, outerTheme, theme2);
};
var createCacheWithTheme = /* @__PURE__ */ weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme2) {
    return getTheme(outerTheme, theme2);
  });
});
var ThemeProvider = function ThemeProvider2(props) {
  var theme2 = reactExports.useContext(ThemeContext);
  if (props.theme !== theme2) {
    theme2 = createCacheWithTheme(theme2)(props.theme);
  }
  return /* @__PURE__ */ reactExports.createElement(ThemeContext.Provider, {
    value: theme2
  }, props.children);
};
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key2 = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key: key2,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key2 + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key2);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css.apply(void 0, arguments);
  var name2 = "animation-" + insertable.name;
  return {
    name: name2,
    styles: "@keyframes " + name2 + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString2() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
const common$6 = {
  black: "#000",
  white: "#fff"
};
const common$7 = common$6;
const red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
};
const red$1 = red;
const purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
};
const purple$1 = purple;
const blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
};
const blue$1 = blue;
const lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
};
const lightBlue$1 = lightBlue;
const green = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
};
const green$1 = green;
const orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
};
const orange$1 = orange;
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
const grey$1 = grey;
function formatMuiErrorMessage(code2) {
  let url = "https://mui.com/production-error/?code=" + code2;
  for (let i3 = 1; i3 < arguments.length; i3 += 1) {
    url += "&args[]=" + encodeURIComponent(arguments[i3]);
  }
  return "Minified MUI error #" + code2 + "; visit " + url + " for the full message.";
}
const THEME_ID = "$$material";
function _objectWithoutPropertiesLoose$1(source, excluded2) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key2 = sourceKeys[i3];
    if (excluded2.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$1(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key2) {
  return key2 !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion = function Insertion2(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var createStyled$1 = function createStyled2(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      styles2.push(args[0][0]);
      var len = args.length;
      var i3 = 1;
      for (; i3 < len; i3++) {
        styles2.push(args[i3], args[0][i3]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref2) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key2 in props) {
          mergedProps[key2] = props[key2];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as")
          continue;
        if (
          // $FlowFixMe
          finalShouldForwardProp(_key)
        ) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref2;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && false) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled2(nextTag, _extends$4({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags$1 = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled$1.bind();
tags$1.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
function isEmpty$4(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
function GlobalStyles$2(props) {
  const {
    styles: styles2,
    defaultTheme: defaultTheme2 = {}
  } = props;
  const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$4(themeInput) ? defaultTheme2 : themeInput) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
    styles: globalStyles
  });
}
function styled$2(tag, options) {
  const stylesFactory = newStyled(tag, options);
  return stylesFactory;
}
const internal_processStyles = (tag, processor) => {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
};
function isPlainObject$1(item) {
  if (typeof item !== "object" || item === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(item);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone(source) {
  if (!isPlainObject$1(source)) {
    return source;
  }
  const output2 = {};
  Object.keys(source).forEach((key2) => {
    output2[key2] = deepClone(source[key2]);
  });
  return output2;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output2 = options.clone ? _extends$4({}, target) : target;
  if (isPlainObject$1(target) && isPlainObject$1(source)) {
    Object.keys(source).forEach((key2) => {
      if (key2 === "__proto__") {
        return;
      }
      if (isPlainObject$1(source[key2]) && key2 in target && isPlainObject$1(target[key2])) {
        output2[key2] = deepmerge(target[key2], source[key2], options);
      } else if (options.clone) {
        output2[key2] = isPlainObject$1(source[key2]) ? deepClone(source[key2]) : source[key2];
      } else {
        output2[key2] = source[key2];
      }
    });
  }
  return output2;
}
var reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$3 = Symbol.for("react.element"), c$9 = Symbol.for("react.portal"), d$4 = Symbol.for("react.fragment"), e$b = Symbol.for("react.strict_mode"), f$9 = Symbol.for("react.profiler"), g$2 = Symbol.for("react.provider"), h$a = Symbol.for("react.context"), k$3 = Symbol.for("react.server_context"), l$5 = Symbol.for("react.forward_ref"), m$3 = Symbol.for("react.suspense"), n$c = Symbol.for("react.suspense_list"), p$5 = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t$7 = Symbol.for("react.offscreen"), u$4;
u$4 = Symbol.for("react.module.reference");
function v$2(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var r2 = a2.$$typeof;
    switch (r2) {
      case b$3:
        switch (a2 = a2.type, a2) {
          case d$4:
          case f$9:
          case e$b:
          case m$3:
          case n$c:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$3:
              case h$a:
              case l$5:
              case q:
              case p$5:
              case g$2:
                return a2;
              default:
                return r2;
            }
        }
      case c$9:
        return r2;
    }
  }
}
reactIs_production_min.ContextConsumer = h$a;
reactIs_production_min.ContextProvider = g$2;
reactIs_production_min.Element = b$3;
reactIs_production_min.ForwardRef = l$5;
reactIs_production_min.Fragment = d$4;
reactIs_production_min.Lazy = q;
reactIs_production_min.Memo = p$5;
reactIs_production_min.Portal = c$9;
reactIs_production_min.Profiler = f$9;
reactIs_production_min.StrictMode = e$b;
reactIs_production_min.Suspense = m$3;
reactIs_production_min.SuspenseList = n$c;
reactIs_production_min.isAsyncMode = function() {
  return false;
};
reactIs_production_min.isConcurrentMode = function() {
  return false;
};
reactIs_production_min.isContextConsumer = function(a2) {
  return v$2(a2) === h$a;
};
reactIs_production_min.isContextProvider = function(a2) {
  return v$2(a2) === g$2;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === b$3;
};
reactIs_production_min.isForwardRef = function(a2) {
  return v$2(a2) === l$5;
};
reactIs_production_min.isFragment = function(a2) {
  return v$2(a2) === d$4;
};
reactIs_production_min.isLazy = function(a2) {
  return v$2(a2) === q;
};
reactIs_production_min.isMemo = function(a2) {
  return v$2(a2) === p$5;
};
reactIs_production_min.isPortal = function(a2) {
  return v$2(a2) === c$9;
};
reactIs_production_min.isProfiler = function(a2) {
  return v$2(a2) === f$9;
};
reactIs_production_min.isStrictMode = function(a2) {
  return v$2(a2) === e$b;
};
reactIs_production_min.isSuspense = function(a2) {
  return v$2(a2) === m$3;
};
reactIs_production_min.isSuspenseList = function(a2) {
  return v$2(a2) === n$c;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === d$4 || a2 === f$9 || a2 === e$b || a2 === m$3 || a2 === n$c || a2 === t$7 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q || a2.$$typeof === p$5 || a2.$$typeof === g$2 || a2.$$typeof === h$a || a2.$$typeof === l$5 || a2.$$typeof === u$4 || void 0 !== a2.getModuleId) ? true : false;
};
reactIs_production_min.typeOf = v$2;
function capitalize(string2) {
  if (typeof string2 !== "string") {
    throw new Error(formatMuiErrorMessage(7));
  }
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    return function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, () => {
  });
}
function debounce(func, wait2 = 166) {
  let timeout;
  function debounced(...args) {
    const later = () => {
      func.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait2);
  }
  debounced.clear = () => {
    clearTimeout(timeout);
  };
  return debounced;
}
function isMuiElement(element, muiNames) {
  var _muiName, _element$type;
  return /* @__PURE__ */ reactExports.isValidElement(element) && muiNames.indexOf(
    // For server components `muiName` is avaialble in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    (_muiName = element.type.muiName) != null ? _muiName : (_element$type = element.type) == null || (_element$type = _element$type._payload) == null || (_element$type = _element$type.value) == null ? void 0 : _element$type.muiName
  ) !== -1;
}
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}
function ownerWindow(node2) {
  const doc = ownerDocument(node2);
  return doc.defaultView || window;
}
function setRef(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
  } else if (ref2) {
    ref2.current = value;
  }
}
const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
let globalId = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = reactExports.useState(idOverride);
  const id2 = idOverride || defaultId;
  reactExports.useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id2;
}
const maybeReactUseId = React["useId".toString()];
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride != null ? idOverride : reactId;
  }
  return useGlobalId(idOverride);
}
function useControlled({
  controlled,
  default: defaultProp,
  name: name2,
  state: state2 = "value"
}) {
  const {
    current: isControlled
  } = reactExports.useRef(controlled !== void 0);
  const [valueState, setValue] = reactExports.useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}
function useEventCallback(fn2) {
  const ref2 = reactExports.useRef(fn2);
  useEnhancedEffect(() => {
    ref2.current = fn2;
  });
  return reactExports.useRef((...args) => (
    // @ts-expect-error hide `this`
    (0, ref2.current)(...args)
  )).current;
}
function useForkRef(...refs) {
  return reactExports.useMemo(() => {
    if (refs.every((ref2) => ref2 == null)) {
      return null;
    }
    return (instance) => {
      refs.forEach((ref2) => {
        setRef(ref2, instance);
      });
    };
  }, refs);
}
let hadKeyboardEvent = true;
let hadFocusVisibleRecently = false;
let hadFocusVisibleRecentlyTimeout;
const inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  "datetime-local": true
};
function focusTriggersKeyboardModality(node2) {
  const {
    type,
    tagName
  } = node2;
  if (tagName === "INPUT" && inputTypesWhitelist[type] && !node2.readOnly) {
    return true;
  }
  if (tagName === "TEXTAREA" && !node2.readOnly) {
    return true;
  }
  if (node2.isContentEditable) {
    return true;
  }
  return false;
}
function handleKeyDown(event) {
  if (event.metaKey || event.altKey || event.ctrlKey) {
    return;
  }
  hadKeyboardEvent = true;
}
function handlePointerDown() {
  hadKeyboardEvent = false;
}
function handleVisibilityChange() {
  if (this.visibilityState === "hidden") {
    if (hadFocusVisibleRecently) {
      hadKeyboardEvent = true;
    }
  }
}
function prepare(doc) {
  doc.addEventListener("keydown", handleKeyDown, true);
  doc.addEventListener("mousedown", handlePointerDown, true);
  doc.addEventListener("pointerdown", handlePointerDown, true);
  doc.addEventListener("touchstart", handlePointerDown, true);
  doc.addEventListener("visibilitychange", handleVisibilityChange, true);
}
function isFocusVisible(event) {
  const {
    target
  } = event;
  try {
    return target.matches(":focus-visible");
  } catch (error) {
  }
  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}
function useIsFocusVisible() {
  const ref2 = reactExports.useCallback((node2) => {
    if (node2 != null) {
      prepare(node2.ownerDocument);
    }
  }, []);
  const isFocusVisibleRef = reactExports.useRef(false);
  function handleBlurVisible() {
    if (isFocusVisibleRef.current) {
      hadFocusVisibleRecently = true;
      window.clearTimeout(hadFocusVisibleRecentlyTimeout);
      hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
        hadFocusVisibleRecently = false;
      }, 100);
      isFocusVisibleRef.current = false;
      return true;
    }
    return false;
  }
  function handleFocusVisible(event) {
    if (isFocusVisible(event)) {
      isFocusVisibleRef.current = true;
      return true;
    }
    return false;
  }
  return {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: ref2
  };
}
function getScrollbarSize(doc) {
  const documentWidth = doc.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
}
function resolveProps(defaultProps2, props) {
  const output2 = _extends$4({}, props);
  Object.keys(defaultProps2).forEach((propName) => {
    if (propName.toString().match(/^(components|slots)$/)) {
      output2[propName] = _extends$4({}, defaultProps2[propName], output2[propName]);
    } else if (propName.toString().match(/^(componentsProps|slotProps)$/)) {
      const defaultSlotProps = defaultProps2[propName] || {};
      const slotProps = props[propName];
      output2[propName] = {};
      if (!slotProps || !Object.keys(slotProps)) {
        output2[propName] = defaultSlotProps;
      } else if (!defaultSlotProps || !Object.keys(defaultSlotProps)) {
        output2[propName] = slotProps;
      } else {
        output2[propName] = _extends$4({}, slotProps);
        Object.keys(defaultSlotProps).forEach((slotPropName) => {
          output2[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
        });
      }
    } else if (output2[propName] === void 0) {
      output2[propName] = defaultProps2[propName];
    }
  });
  return output2;
}
function composeClasses(slots, getUtilityClass, classes = void 0) {
  const output2 = {};
  Object.keys(slots).forEach(
    // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
    // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
    (slot) => {
      output2[slot] = slots[slot].reduce((acc, key2) => {
        if (key2) {
          const utilityClass = getUtilityClass(key2);
          if (utilityClass !== "") {
            acc.push(utilityClass);
          }
          if (classes && classes[key2]) {
            acc.push(classes[key2]);
          }
        }
        return acc;
      }, []).join(" ");
    }
  );
  return output2;
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate2 = defaultGenerator;
  return {
    configure(generator) {
      generate2 = generator;
    },
    generate(componentName) {
      return generate2(componentName);
    },
    reset() {
      generate2 = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
const globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
function clamp(val, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) {
  return Math.max(min, Math.min(val, max));
}
const _excluded$H = ["values", "unit", "step"];
const sortBreakpointsValues = (values2) => {
  const breakpointsAsArray = Object.keys(values2).map((key2) => ({
    key: key2,
    val: values2[key2]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return _extends$4({}, acc, {
      [obj.key]: obj.val
    });
  }, {});
};
function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: values2 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit = "px",
    step = 5
  } = breakpoints, other = _objectWithoutPropertiesLoose$1(breakpoints, _excluded$H);
  const sortedValues = sortBreakpointsValues(values2);
  const keys = Object.keys(sortedValues);
  function up(key2) {
    const value = typeof values2[key2] === "number" ? values2[key2] : key2;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key2) {
    const value = typeof values2[key2] === "number" ? values2[key2] : key2;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between(start, end) {
    const endIndex = keys.indexOf(end);
    return `@media (min-width:${typeof values2[start] === "number" ? values2[start] : start}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end) - step / 100}${unit})`;
  }
  function only(key2) {
    if (keys.indexOf(key2) + 1 < keys.length) {
      return between(key2, keys[keys.indexOf(key2) + 1]);
    }
    return up(key2);
  }
  function not(key2) {
    const keyIndex = keys.indexOf(key2);
    if (keyIndex === 0) {
      return up(keys[1]);
    }
    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }
    return between(key2, keys[keys.indexOf(key2) + 1]).replace("@media", "@media not all and");
  }
  return _extends$4({
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit
  }, other);
}
const shape = {
  borderRadius: 4
};
const shape$1 = shape;
function merge$1(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
const values$1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key2) => `@media (min-width:${values$1[key2]}px)`
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme2 = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme2.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index2) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index2])] = styleFromPropValue(propValue[index2]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme2.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output2 = styleFromPropValue(propValue);
  return output2;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _breakpointsInput$key;
  const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key2) => {
    const breakpointStyleKey = breakpointsInput.up(key2);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key2) => {
    const breakpointOutput = acc[key2];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key2];
    }
    return acc;
  }, style2);
}
function mergeBreakpointsInOrder(breakpointsInput, ...styles2) {
  const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
  const mergedOutput = [emptyBreakpoints, ...styles2].reduce((prev2, next2) => deepmerge(prev2, next2), {});
  return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
}
function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
  if (typeof breakpointValues !== "object") {
    return {};
  }
  const base3 = {};
  const breakpointsKeys = Object.keys(themeBreakpoints);
  if (Array.isArray(breakpointValues)) {
    breakpointsKeys.forEach((breakpoint, i3) => {
      if (i3 < breakpointValues.length) {
        base3[breakpoint] = true;
      }
    });
  } else {
    breakpointsKeys.forEach((breakpoint) => {
      if (breakpointValues[breakpoint] != null) {
        base3[breakpoint] = true;
      }
    });
  }
  return base3;
}
function resolveBreakpointValues({
  values: breakpointValues,
  breakpoints: themeBreakpoints,
  base: customBase
}) {
  const base3 = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
  const keys = Object.keys(base3);
  if (keys.length === 0) {
    return breakpointValues;
  }
  let previous;
  return keys.reduce((acc, breakpoint, i3) => {
    if (Array.isArray(breakpointValues)) {
      acc[breakpoint] = breakpointValues[i3] != null ? breakpointValues[i3] : breakpointValues[previous];
      previous = i3;
    } else if (typeof breakpointValues === "object") {
      acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
      previous = breakpoint;
    } else {
      acc[breakpoint] = breakpointValues;
    }
    return acc;
  }, {});
}
function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform) {
    value = transform(value, userValue, themeMapping);
  }
  return value;
}
function style$2(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;
  const fn2 = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme2 = props.theme;
    const themeMapping = getPath(theme2, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn2.propTypes = {};
  fn2.filterProps = [prop];
  return fn2;
}
function memoize(fn2) {
  const cache = {};
  return (arg) => {
    if (cache[arg] === void 0) {
      cache[arg] = fn2(arg);
    }
    return cache[arg];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a2, b3] = prop.split("");
  const property = properties[a2];
  const direction = directions[b3] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(theme2, themeKey, defaultValue, propName) {
  var _getPath;
  const themeSpacing = (_getPath = getPath(theme2, themeKey, false)) != null ? _getPath : defaultValue;
  if (typeof themeSpacing === "number") {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing * abs2;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing[abs2];
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
function createUnarySpacing(theme2) {
  return createUnaryUnit(theme2, "spacing", 8);
}
function getValue(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  const abs2 = Math.abs(propValue);
  const transformed = transformer(abs2);
  if (propValue >= 0) {
    return transformed;
  }
  if (typeof transformed === "number") {
    return -transformed;
  }
  return `-${transformed}`;
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys, prop, transformer) {
  if (keys.indexOf(prop) === -1) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style$1(props, keys) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge$1, {});
}
function margin(props) {
  return style$1(props, marginKeys);
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding$1(props) {
  return style$1(props, paddingKeys);
}
padding$1.propTypes = {};
padding$1.filterProps = paddingKeys;
function createSpacing(spacingInput = 8) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const transform = createUnarySpacing({
    spacing: spacingInput
  });
  const spacing = (...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output2 = transform(argument);
      return typeof output2 === "number" ? `${output2}px` : output2;
    }).join(" ");
  };
  spacing.mui = true;
  return spacing;
}
function compose(...styles2) {
  const handlers = styles2.reduce((acc, style2) => {
    style2.filterProps.forEach((prop) => {
      acc[prop] = style2;
    });
    return acc;
  }, {});
  const fn2 = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge$1(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn2.propTypes = {};
  fn2.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn2;
}
function borderTransform(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
function createBorderStyle(prop, transform) {
  return style$2({
    prop,
    themeKey: "borders",
    transform
  });
}
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      gap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$2({
  prop: "gridColumn"
});
const gridRow = style$2({
  prop: "gridRow"
});
const gridAutoFlow = style$2({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$2({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$2({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$2({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$2({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$2({
  prop: "gridTemplateAreas"
});
const gridArea = style$2({
  prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value;
}
const color = style$2({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
const bgcolor = style$2({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
const backgroundColor = style$2({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);
function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$2({
  prop: "width",
  transform: sizingTransform
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      var _props$theme, _props$theme2;
      const breakpoint = ((_props$theme = props.theme) == null || (_props$theme = _props$theme.breakpoints) == null || (_props$theme = _props$theme.values) == null ? void 0 : _props$theme[propValue]) || values$1[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (((_props$theme2 = props.theme) == null || (_props$theme2 = _props$theme2.breakpoints) == null ? void 0 : _props$theme2.unit) !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$2({
  prop: "minWidth",
  transform: sizingTransform
});
const height = style$2({
  prop: "height",
  transform: sizingTransform
});
const maxHeight = style$2({
  prop: "maxHeight",
  transform: sizingTransform
});
const minHeight = style$2({
  prop: "minHeight",
  transform: sizingTransform
});
style$2({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$2({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$2({
  prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding$1
  },
  pt: {
    style: padding$1
  },
  pr: {
    style: padding$1
  },
  pb: {
    style: padding$1
  },
  pl: {
    style: padding$1
  },
  px: {
    style: padding$1
  },
  py: {
    style: padding$1
  },
  padding: {
    style: padding$1
  },
  paddingTop: {
    style: padding$1
  },
  paddingRight: {
    style: padding$1
  },
  paddingBottom: {
    style: padding$1
  },
  paddingLeft: {
    style: padding$1
  },
  paddingX: {
    style: padding$1
  },
  paddingY: {
    style: padding$1
  },
  paddingInline: {
    style: padding$1
  },
  paddingInlineStart: {
    style: padding$1
  },
  paddingInlineEnd: {
    style: padding$1
  },
  paddingBlock: {
    style: padding$1
  },
  paddingBlockStart: {
    style: padding$1
  },
  paddingBlockEnd: {
    style: padding$1
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value) => ({
      "@media print": {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
const defaultSxConfig$1 = defaultSxConfig;
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects.every((object) => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg) {
  return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
}
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme2, config2) {
    const props = {
      [prop]: val,
      theme: theme2
    };
    const options = config2[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform,
      style: style2
    } = options;
    if (val == null) {
      return null;
    }
    if (themeKey === "typography" && val === "inherit") {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme2, themeKey) || {};
    if (style2) {
      return style2(props);
    }
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx2(props) {
    var _theme$unstable_sxCon;
    const {
      sx,
      theme: theme2 = {}
    } = props || {};
    if (!sx) {
      return null;
    }
    const config2 = (_theme$unstable_sxCon = theme2.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig$1;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme2);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme2.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme2);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (config2[styleKey]) {
              css2 = merge$1(css2, getThemeValue(styleKey, value, theme2, config2));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme: theme2
              }, value, (x2) => ({
                [styleKey]: x2
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme: theme2
                });
              } else {
                css2 = merge$1(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge$1(css2, getThemeValue(styleKey, value, theme2, config2));
          }
        }
      });
      return removeUnusedBreakpoints(breakpointsKeys, css2);
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
const _excluded$G = ["breakpoints", "palette", "spacing", "shape"];
function createTheme$1(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {}
  } = options, other = _objectWithoutPropertiesLoose$1(options, _excluded$G);
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: _extends$4({
      mode: "light"
    }, paletteInput),
    spacing,
    shape: _extends$4({}, shape$1, shapeInput)
  }, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = _extends$4({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
function isObjectEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$2(defaultTheme2 = null) {
  const contextTheme = reactExports.useContext(ThemeContext);
  return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme$1 = createTheme$1();
function useTheme$1(defaultTheme2 = systemDefaultTheme$1) {
  return useTheme$2(defaultTheme2);
}
function GlobalStyles$1({
  styles: styles2,
  themeId,
  defaultTheme: defaultTheme2 = {}
}) {
  const upperTheme = useTheme$1(defaultTheme2);
  const globalStyles = typeof styles2 === "function" ? styles2(themeId ? upperTheme[themeId] || upperTheme : upperTheme) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
    styles: globalStyles
  });
}
const _excluded$F = ["sx"];
const splitProps = (props) => {
  var _props$theme$unstable, _props$theme;
  const result = {
    systemProps: {},
    otherProps: {}
  };
  const config2 = (_props$theme$unstable = props == null || (_props$theme = props.theme) == null ? void 0 : _props$theme.unstable_sxConfig) != null ? _props$theme$unstable : defaultSxConfig$1;
  Object.keys(props).forEach((prop) => {
    if (config2[prop]) {
      result.systemProps[prop] = props[prop];
    } else {
      result.otherProps[prop] = props[prop];
    }
  });
  return result;
};
function extendSxProp(props) {
  const {
    sx: inSx
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$F);
  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;
  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === "function") {
    finalSx = (...args) => {
      const result = inSx(...args);
      if (!isPlainObject$1(result)) {
        return systemProps;
      }
      return _extends$4({}, systemProps, result);
    };
  } else {
    finalSx = _extends$4({}, systemProps, inSx);
  }
  return _extends$4({}, otherProps, {
    sx: finalSx
  });
}
function r$g(e2) {
  var t2, f3, n4 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n4 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2)) {
      var o2 = e2.length;
      for (t2 = 0; t2 < o2; t2++)
        e2[t2] && (f3 = r$g(e2[t2])) && (n4 && (n4 += " "), n4 += f3);
    } else
      for (f3 in e2)
        e2[f3] && (n4 && (n4 += " "), n4 += f3);
  return n4;
}
function clsx() {
  for (var e2, t2, f3 = 0, n4 = "", o2 = arguments.length; f3 < o2; f3++)
    (e2 = arguments[f3]) && (t2 = r$g(e2)) && (n4 && (n4 += " "), n4 += t2);
  return n4;
}
const _excluded$E = ["variant"];
function isEmpty$3(string2) {
  return string2.length === 0;
}
function propsToClassKey(props) {
  const {
    variant
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$E);
  let classKey = variant || "";
  Object.keys(other).sort().forEach((key2) => {
    if (key2 === "color") {
      classKey += isEmpty$3(classKey) ? props[key2] : capitalize(props[key2]);
    } else {
      classKey += `${isEmpty$3(classKey) ? key2 : capitalize(key2)}${capitalize(props[key2].toString())}`;
    }
  });
  return classKey;
}
const _excluded$D = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function isEmpty$2(obj) {
  return Object.keys(obj).length === 0;
}
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
const getStyleOverrides = (name2, theme2) => {
  if (theme2.components && theme2.components[name2] && theme2.components[name2].styleOverrides) {
    return theme2.components[name2].styleOverrides;
  }
  return null;
};
const transformVariants = (variants) => {
  let numOfCallbacks = 0;
  const variantsStyles = {};
  if (variants) {
    variants.forEach((definition) => {
      let key2 = "";
      if (typeof definition.props === "function") {
        key2 = `callback${numOfCallbacks}`;
        numOfCallbacks += 1;
      } else {
        key2 = propsToClassKey(definition.props);
      }
      variantsStyles[key2] = definition.style;
    });
  }
  return variantsStyles;
};
const getVariantStyles = (name2, theme2) => {
  let variants = [];
  if (theme2 && theme2.components && theme2.components[name2] && theme2.components[name2].variants) {
    variants = theme2.components[name2].variants;
  }
  return transformVariants(variants);
};
const variantsResolver = (props, styles2, variants) => {
  const {
    ownerState = {}
  } = props;
  const variantsStyles = [];
  let numOfCallbacks = 0;
  if (variants) {
    variants.forEach((variant) => {
      let isMatch = true;
      if (typeof variant.props === "function") {
        const propsToCheck = _extends$4({}, props, ownerState);
        isMatch = variant.props(propsToCheck);
      } else {
        Object.keys(variant.props).forEach((key2) => {
          if (ownerState[key2] !== variant.props[key2] && props[key2] !== variant.props[key2]) {
            isMatch = false;
          }
        });
      }
      if (isMatch) {
        if (typeof variant.props === "function") {
          variantsStyles.push(styles2[`callback${numOfCallbacks}`]);
        } else {
          variantsStyles.push(styles2[propsToClassKey(variant.props)]);
        }
      }
      if (typeof variant.props === "function") {
        numOfCallbacks += 1;
      }
    });
  }
  return variantsStyles;
};
const themeVariantsResolver = (props, styles2, theme2, name2) => {
  var _theme$components;
  const themeVariants = theme2 == null || (_theme$components = theme2.components) == null || (_theme$components = _theme$components[name2]) == null ? void 0 : _theme$components.variants;
  return variantsResolver(props, styles2, themeVariants);
};
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const systemDefaultTheme = createTheme$1();
const lowercaseFirstLetter = (string2) => {
  if (!string2) {
    return string2;
  }
  return string2.charAt(0).toLowerCase() + string2.slice(1);
};
function resolveTheme({
  defaultTheme: defaultTheme2,
  theme: theme2,
  themeId
}) {
  return isEmpty$2(theme2) ? defaultTheme2 : theme2[themeId] || theme2;
}
function defaultOverridesResolver(slot) {
  if (!slot) {
    return null;
  }
  return (props, styles2) => styles2[slot];
}
const muiStyledFunctionResolver = ({
  styledArg,
  props,
  defaultTheme: defaultTheme2,
  themeId
}) => {
  const resolvedStyles = styledArg(_extends$4({}, props, {
    theme: resolveTheme(_extends$4({}, props, {
      defaultTheme: defaultTheme2,
      themeId
    }))
  }));
  let optionalVariants;
  if (resolvedStyles && resolvedStyles.variants) {
    optionalVariants = resolvedStyles.variants;
    delete resolvedStyles.variants;
  }
  if (optionalVariants) {
    const variantsStyles = variantsResolver(props, transformVariants(optionalVariants), optionalVariants);
    return [resolvedStyles, ...variantsStyles];
  }
  return resolvedStyles;
};
function createStyled(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
  } = input;
  const systemSx = (props) => {
    return styleFunctionSx(_extends$4({}, props, {
      theme: resolveTheme(_extends$4({}, props, {
        defaultTheme: defaultTheme2,
        themeId
      }))
    }));
  };
  systemSx.__mui_systemSx = true;
  return (tag, inputOptions = {}) => {
    internal_processStyles(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: overridesResolver2 = defaultOverridesResolver(lowercaseFirstLetter(componentSlot))
    } = inputOptions, options = _objectWithoutPropertiesLoose$1(inputOptions, _excluded$D);
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let label;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$2(tag, _extends$4({
      shouldForwardProp: shouldForwardPropOption,
      label
    }, options));
    const muiStyledResolver = (styleArg, ...expressions) => {
      const expressionsWithDefaultTheme = expressions ? expressions.map((stylesArg) => {
        if (typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg) {
          return (props) => muiStyledFunctionResolver({
            styledArg: stylesArg,
            props,
            defaultTheme: defaultTheme2,
            themeId
          });
        }
        if (isPlainObject$1(stylesArg)) {
          let transformedStylesArg = stylesArg;
          let styledArgVariants;
          if (stylesArg && stylesArg.variants) {
            styledArgVariants = stylesArg.variants;
            delete transformedStylesArg.variants;
            transformedStylesArg = (props) => {
              let result = stylesArg;
              const variantStyles = variantsResolver(props, transformVariants(styledArgVariants), styledArgVariants);
              variantStyles.forEach((variantStyle) => {
                result = deepmerge(result, variantStyle);
              });
              return result;
            };
          }
          return transformedStylesArg;
        }
        return stylesArg;
      }) : [];
      let transformedStyleArg = styleArg;
      if (isPlainObject$1(styleArg)) {
        let styledArgVariants;
        if (styleArg && styleArg.variants) {
          styledArgVariants = styleArg.variants;
          delete transformedStyleArg.variants;
          transformedStyleArg = (props) => {
            let result = styleArg;
            const variantStyles = variantsResolver(props, transformVariants(styledArgVariants), styledArgVariants);
            variantStyles.forEach((variantStyle) => {
              result = deepmerge(result, variantStyle);
            });
            return result;
          };
        }
      } else if (typeof styleArg === "function" && // On the server Emotion doesn't use React.forwardRef for creating components, so the created
      // component stays as a function. This condition makes sure that we do not interpolate functions
      // which are basically components used as a selectors.
      styleArg.__emotion_real !== styleArg) {
        transformedStyleArg = (props) => muiStyledFunctionResolver({
          styledArg: styleArg,
          props,
          defaultTheme: defaultTheme2,
          themeId
        });
      }
      if (componentName && overridesResolver2) {
        expressionsWithDefaultTheme.push((props) => {
          const theme2 = resolveTheme(_extends$4({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          const styleOverrides = getStyleOverrides(componentName, theme2);
          if (styleOverrides) {
            const resolvedStyleOverrides = {};
            Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
              resolvedStyleOverrides[slotKey] = typeof slotStyle === "function" ? slotStyle(_extends$4({}, props, {
                theme: theme2
              })) : slotStyle;
            });
            return overridesResolver2(props, resolvedStyleOverrides);
          }
          return null;
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsWithDefaultTheme.push((props) => {
          const theme2 = resolveTheme(_extends$4({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          return themeVariantsResolver(props, getVariantStyles(componentName, theme2), theme2, componentName);
        });
      }
      if (!skipSx) {
        expressionsWithDefaultTheme.push(systemSx);
      }
      const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
      if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
        const placeholders = new Array(numOfCustomFnsApplied).fill("");
        transformedStyleArg = [...styleArg, ...placeholders];
        transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
      }
      const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
      if (tag.muiName) {
        Component.muiName = tag.muiName;
      }
      return Component;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
}
const styled$1 = createStyled();
function getThemeProps(params) {
  const {
    theme: theme2,
    name: name2,
    props
  } = params;
  if (!theme2 || !theme2.components || !theme2.components[name2] || !theme2.components[name2].defaultProps) {
    return props;
  }
  return resolveProps(theme2.components[name2].defaultProps, props);
}
function useThemeProps$1({
  props,
  name: name2,
  defaultTheme: defaultTheme2,
  themeId
}) {
  let theme2 = useTheme$1(defaultTheme2);
  if (themeId) {
    theme2 = theme2[themeId] || theme2;
  }
  const mergedProps = getThemeProps({
    theme: theme2,
    name: name2,
    props
  });
  return mergedProps;
}
function clampWrapper(value, min = 0, max = 1) {
  return clamp(value, min, max);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors2 = color2.match(re2);
  if (colors2 && colors2[0].length === 1) {
    colors2 = colors2.map((n4) => n4 + n4);
  }
  return colors2 ? `rgb${colors2.length === 4 ? "a" : ""}(${colors2.map((n4, index2) => {
    return index2 < 3 ? parseInt(n4, 16) : Math.round(parseInt(n4, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type = color2.substring(0, marker);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
    throw new Error(formatMuiErrorMessage(9, color2));
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
      throw new Error(formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value) => parseFloat(value));
  return {
    type,
    values: values2,
    colorSpace
  };
}
function recomposeColor(color2) {
  const {
    type,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type.indexOf("rgb") !== -1) {
    values2 = values2.map((n4, i3) => i3 < 3 ? parseInt(n4, 10) : n4);
  } else if (type.indexOf("hsl") !== -1) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type.indexOf("color") !== -1) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type}(${values2})`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values2
  } = color2;
  const h4 = values2[0];
  const s4 = values2[1] / 100;
  const l2 = values2[2] / 100;
  const a2 = s4 * Math.min(l2, 1 - l2);
  const f3 = (n4, k4 = (n4 + h4 / 30) % 12) => l2 - a2 * Math.max(Math.min(k4 - 3, 9 - k4, 1), -1);
  let type = "rgb";
  const rgb = [Math.round(f3(0) * 255), Math.round(f3(8) * 255), Math.round(f3(4) * 255)];
  if (color2.type === "hsla") {
    type += "a";
    rgb.push(values2[3]);
  }
  return recomposeColor({
    type,
    values: rgb
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb = rgb.map((val) => {
    if (color2.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value) {
  color2 = decomposeColor(color2);
  value = clampWrapper(value);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value}`;
  } else {
    color2.values[3] = value;
  }
  return recomposeColor(color2);
}
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
    for (let i3 = 0; i3 < 3; i3 += 1) {
      color2.values[i3] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.indexOf("rgb") !== -1) {
    for (let i3 = 0; i3 < 3; i3 += 1) {
      color2.values[i3] += (255 - color2.values[i3]) * coefficient;
    }
  } else if (color2.type.indexOf("color") !== -1) {
    for (let i3 = 0; i3 < 3; i3 += 1) {
      color2.values[i3] += (1 - color2.values[i3]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
const _excluded$C = ["component", "direction", "spacing", "divider", "children", "className", "useFlexGap"];
const defaultTheme$2 = createTheme$1();
const defaultCreateStyledComponent = styled$1("div", {
  name: "MuiStack",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
});
function useThemePropsDefault(props) {
  return useThemeProps$1({
    props,
    name: "MuiStack",
    defaultTheme: defaultTheme$2
  });
}
function joinChildren(children, separator) {
  const childrenArray = reactExports.Children.toArray(children).filter(Boolean);
  return childrenArray.reduce((output2, child, index2) => {
    output2.push(child);
    if (index2 < childrenArray.length - 1) {
      output2.push(/* @__PURE__ */ reactExports.cloneElement(separator, {
        key: `separator-${index2}`
      }));
    }
    return output2;
  }, []);
}
const getSideFromDirection = (direction) => {
  return {
    row: "Left",
    "row-reverse": "Right",
    column: "Top",
    "column-reverse": "Bottom"
  }[direction];
};
const style = ({
  ownerState,
  theme: theme2
}) => {
  let styles2 = _extends$4({
    display: "flex",
    flexDirection: "column"
  }, handleBreakpoints({
    theme: theme2
  }, resolveBreakpointValues({
    values: ownerState.direction,
    breakpoints: theme2.breakpoints.values
  }), (propValue) => ({
    flexDirection: propValue
  })));
  if (ownerState.spacing) {
    const transformer = createUnarySpacing(theme2);
    const base3 = Object.keys(theme2.breakpoints.values).reduce((acc, breakpoint) => {
      if (typeof ownerState.spacing === "object" && ownerState.spacing[breakpoint] != null || typeof ownerState.direction === "object" && ownerState.direction[breakpoint] != null) {
        acc[breakpoint] = true;
      }
      return acc;
    }, {});
    const directionValues = resolveBreakpointValues({
      values: ownerState.direction,
      base: base3
    });
    const spacingValues = resolveBreakpointValues({
      values: ownerState.spacing,
      base: base3
    });
    if (typeof directionValues === "object") {
      Object.keys(directionValues).forEach((breakpoint, index2, breakpoints) => {
        const directionValue = directionValues[breakpoint];
        if (!directionValue) {
          const previousDirectionValue = index2 > 0 ? directionValues[breakpoints[index2 - 1]] : "column";
          directionValues[breakpoint] = previousDirectionValue;
        }
      });
    }
    const styleFromPropValue = (propValue, breakpoint) => {
      if (ownerState.useFlexGap) {
        return {
          gap: getValue(transformer, propValue)
        };
      }
      return {
        // The useFlexGap={false} implement relies on each child to give up control of the margin.
        // We need to reset the margin to avoid double spacing.
        "& > :not(style):not(style)": {
          margin: 0
        },
        "& > :not(style) ~ :not(style)": {
          [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue(transformer, propValue)
        }
      };
    };
    styles2 = deepmerge(styles2, handleBreakpoints({
      theme: theme2
    }, spacingValues, styleFromPropValue));
  }
  styles2 = mergeBreakpointsInOrder(theme2.breakpoints, styles2);
  return styles2;
};
function createStack(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent,
    useThemeProps: useThemeProps2 = useThemePropsDefault,
    componentName = "MuiStack"
  } = options;
  const useUtilityClasses2 = () => {
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
  };
  const StackRoot = createStyledComponent(style);
  const Stack2 = /* @__PURE__ */ reactExports.forwardRef(function Grid3(inProps, ref2) {
    const themeProps = useThemeProps2(inProps);
    const props = extendSxProp(themeProps);
    const {
      component = "div",
      direction = "column",
      spacing = 0,
      divider,
      children,
      className,
      useFlexGap = false
    } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$C);
    const ownerState = {
      direction,
      spacing,
      useFlexGap
    };
    const classes = useUtilityClasses2();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StackRoot, _extends$4({
      as: component,
      ownerState,
      ref: ref2,
      className: clsx(classes.root, className)
    }, other, {
      children: divider ? joinChildren(children, divider) : children
    }));
  });
  return Stack2;
}
function createMixins(breakpoints, mixins) {
  return _extends$4({
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    }
  }, mixins);
}
const _excluded$B = ["mode", "contrastThreshold", "tonalOffset"];
const light = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: "rgba(0, 0, 0, 0.87)",
    // Secondary text.
    secondary: "rgba(0, 0, 0, 0.6)",
    // Disabled text have even lower visual prominence.
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  // The color used to divide different elements.
  divider: "rgba(0, 0, 0, 0.12)",
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: common$7.white,
    default: common$7.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: "rgba(0, 0, 0, 0.54)",
    // The color of an hovered action.
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: "rgba(0, 0, 0, 0.26)",
    // The background color of a disabled action.
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
};
const dark = {
  text: {
    primary: common$7.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: common$7.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: blue$1[200],
      light: blue$1[50],
      dark: blue$1[400]
    };
  }
  return {
    main: blue$1[700],
    light: blue$1[400],
    dark: blue$1[800]
  };
}
function getDefaultSecondary(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: purple$1[200],
      light: purple$1[50],
      dark: purple$1[400]
    };
  }
  return {
    main: purple$1[500],
    light: purple$1[300],
    dark: purple$1[700]
  };
}
function getDefaultError(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: red$1[500],
      light: red$1[300],
      dark: red$1[700]
    };
  }
  return {
    main: red$1[700],
    light: red$1[400],
    dark: red$1[800]
  };
}
function getDefaultInfo(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: lightBlue$1[400],
      light: lightBlue$1[300],
      dark: lightBlue$1[700]
    };
  }
  return {
    main: lightBlue$1[700],
    light: lightBlue$1[500],
    dark: lightBlue$1[900]
  };
}
function getDefaultSuccess(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: green$1[400],
      light: green$1[300],
      dark: green$1[700]
    };
  }
  return {
    main: green$1[800],
    light: green$1[500],
    dark: green$1[900]
  };
}
function getDefaultWarning(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: orange$1[400],
      light: orange$1[300],
      dark: orange$1[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange$1[500],
    dark: orange$1[900]
  };
}
function createPalette(palette) {
  const {
    mode: mode2 = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2
  } = palette, other = _objectWithoutPropertiesLoose$1(palette, _excluded$B);
  const primary = palette.primary || getDefaultPrimary(mode2);
  const secondary = palette.secondary || getDefaultSecondary(mode2);
  const error = palette.error || getDefaultError(mode2);
  const info = palette.info || getDefaultInfo(mode2);
  const success = palette.success || getDefaultSuccess(mode2);
  const warning = palette.warning || getDefaultWarning(mode2);
  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name: name2,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = _extends$4({}, color2);
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(formatMuiErrorMessage(11, name2 ? ` (${name2})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(formatMuiErrorMessage(12, name2 ? ` (${name2})` : "", JSON.stringify(color2.main)));
    }
    addLightOrDark(color2, "light", lightShade, tonalOffset);
    addLightOrDark(color2, "dark", darkShade, tonalOffset);
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  const modes = {
    dark,
    light
  };
  const paletteOutput = deepmerge(_extends$4({
    // A collection of common colors.
    common: _extends$4({}, common$7),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: mode2,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey: grey$1,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset
  }, modes[mode2]), other);
  return paletteOutput;
}
const _excluded$A = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function round$2(value) {
  return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
  const _ref = typeof typography === "function" ? typography(palette) : typography, {
    fontFamily = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2
  } = _ref, other = _objectWithoutPropertiesLoose$1(_ref, _excluded$A);
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || ((size2) => `${size2 / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size2, lineHeight, letterSpacing, casing) => _extends$4({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size2),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight
  }, fontFamily === defaultFontFamily ? {
    letterSpacing: `${round$2(letterSpacing / size2)}em`
  } : {}, casing, allVariants);
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge(_extends$4({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const _excluded$z = ["duration", "easing", "delay"];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant = height2 / 36;
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function createTransitions(inputTransitions) {
  const mergedEasing = _extends$4({}, easing, inputTransitions.easing);
  const mergedDuration = _extends$4({}, duration, inputTransitions.duration);
  const create3 = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay: delay2 = 0
    } = options;
    _objectWithoutPropertiesLoose$1(options, _excluded$z);
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay2 === "string" ? delay2 : formatMs(delay2)}`).join(",");
  };
  return _extends$4({
    getAutoHeightDuration,
    create: create3
  }, inputTransitions, {
    easing: mergedEasing,
    duration: mergedDuration
  });
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
const zIndex$1 = zIndex;
const _excluded$y = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function createTheme(options = {}, ...args) {
  const {
    mixins: mixinsInput = {},
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {}
  } = options, other = _objectWithoutPropertiesLoose$1(options, _excluded$y);
  if (options.vars) {
    throw new Error(formatMuiErrorMessage(18));
  }
  const palette = createPalette(paletteInput);
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: _extends$4({}, zIndex$1),
    applyDarkStyles(css2) {
      if (this.vars) {
        const selector = this.getColorSchemeSelector("dark").replace(/(\[[^\]]+\])/, ":where($1)");
        return {
          [selector]: css2
        };
      }
      if (this.palette.mode === "dark") {
        return css2;
      }
      return {};
    }
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = _extends$4({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
const defaultTheme = createTheme();
const defaultTheme$1 = defaultTheme;
function useTheme() {
  const theme2 = useTheme$1(defaultTheme$1);
  return theme2[THEME_ID] || theme2;
}
function useThemeProps({
  props,
  name: name2
}) {
  return useThemeProps$1({
    props,
    name: name2,
    defaultTheme: defaultTheme$1,
    themeId: THEME_ID
  });
}
const rootShouldForwardProp = (prop) => shouldForwardProp(prop) && prop !== "classes";
const slotShouldForwardProp = shouldForwardProp;
const styled = createStyled({
  themeId: THEME_ID,
  defaultTheme: defaultTheme$1,
  rootShouldForwardProp
});
const getOverlayAlpha = (elevation) => {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return (alphaValue / 100).toFixed(2);
};
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass("MuiSvgIcon", slot);
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const _excluded$x = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
const useUtilityClasses$q = (ownerState) => {
  const {
    color: color2,
    fontSize,
    classes
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize)}`]
  };
  return composeClasses(slots, getSvgIconUtilityClass, classes);
};
const SvgIconRoot = styled("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette2, _palette3;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    // the <svg> will define the property that has `currentColor`
    // e.g. heroicons uses fill="none" and stroke="currentColor"
    fill: ownerState.hasSvgAsChild ? void 0 : "currentColor",
    flexShrink: 0,
    transition: (_theme$transitions = theme2.transitions) == null || (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, "fill", {
      duration: (_theme$transitions2 = theme2.transitions) == null || (_theme$transitions2 = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2.shorter
    }),
    fontSize: {
      inherit: "inherit",
      small: ((_theme$typography = theme2.typography) == null || (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || "1.25rem",
      medium: ((_theme$typography2 = theme2.typography) == null || (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
      large: ((_theme$typography3 = theme2.typography) == null || (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875rem"
    }[ownerState.fontSize],
    // TODO v5 deprecate, v6 remove for sx
    color: (_palette$ownerState$c = (_palette = (theme2.vars || theme2).palette) == null || (_palette = _palette[ownerState.color]) == null ? void 0 : _palette.main) != null ? _palette$ownerState$c : {
      action: (_palette2 = (theme2.vars || theme2).palette) == null || (_palette2 = _palette2.action) == null ? void 0 : _palette2.active,
      disabled: (_palette3 = (theme2.vars || theme2).palette) == null || (_palette3 = _palette3.action) == null ? void 0 : _palette3.disabled,
      inherit: void 0
    }[ownerState.color]
  };
});
const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref2) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const {
    children,
    className,
    color: color2 = "inherit",
    component = "svg",
    fontSize = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$x);
  const hasSvgAsChild = /* @__PURE__ */ reactExports.isValidElement(children) && children.type === "svg";
  const ownerState = _extends$4({}, props, {
    color: color2,
    component,
    fontSize,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox,
    hasSvgAsChild
  });
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes = useUtilityClasses$q(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, _extends$4({
    as: component,
    className: clsx(classes.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref: ref2
  }, more, other, hasSvgAsChild && children.props, {
    ownerState,
    children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
      children: titleAccess
    }) : null]
  }));
});
SvgIcon.muiName = "SvgIcon";
function createSvgIcon(path, displayName) {
  function Component(props, ref2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon, _extends$4({
      "data-testid": `${displayName}Icon`,
      ref: ref2
    }, props, {
      children: path
    }));
  }
  Component.muiName = SvgIcon.muiName;
  return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component));
}
function _setPrototypeOf$2(o2, p2) {
  _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$2(o2, p2);
}
function _inheritsLoose$6(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$2(subClass, superClass);
}
const config$2 = {
  disabled: false
};
const TransitionGroupContext = ReactExports.createContext(null);
var forceReflow = function forceReflow2(node2) {
  return node2.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$6(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node2)
            forceReflow(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config$2.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config$2.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render2() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose$1(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ ReactExports.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : ReactExports.cloneElement(ReactExports.Children.only(children), childProps))
    );
  };
  return Transition2;
}(ReactExports.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
const Transition$1 = Transition;
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children)
    reactExports.Children.map(children, function(c2) {
      return c2;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
  return result;
}
function mergeChildMappings(prev2, next2) {
  prev2 = prev2 || {};
  next2 = next2 || {};
  function getValueForKey(key2) {
    return key2 in next2 ? next2[key2] : prev2[key2];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next2) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i3;
  var childMapping = {};
  for (var nextKey in next2) {
    if (nextKeysPending[nextKey]) {
      for (i3 = 0; i3 < nextKeysPending[nextKey].length; i3++) {
        var pendingNextKey = nextKeysPending[nextKey][i3];
        childMapping[nextKeysPending[nextKey][i3]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i3 = 0; i3 < pendingKeys.length; i3++) {
    childMapping[pendingKeys[i3]] = getValueForKey(pendingKeys[i3]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return reactExports.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key2) {
    var child = children[key2];
    if (!reactExports.isValidElement(child))
      return;
    var hasPrev = key2 in prevChildMapping;
    var hasNext = key2 in nextChildMapping;
    var prevChild = prevChildMapping[key2];
    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key2] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key2] = reactExports.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
      children[key2] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k4) {
    return obj[k4];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$6(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized$2(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping)
      return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state2) {
        var children = _extends$4({}, state2.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render2() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose$1(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return /* @__PURE__ */ ReactExports.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ ReactExports.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ ReactExports.createElement(Component, props, children));
  };
  return TransitionGroup2;
}(ReactExports.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const TransitionGroup$1 = TransitionGroup;
const reflow = (node2) => node2.scrollTop;
function getTransitionProps(props, options) {
  var _style$transitionDura, _style$transitionTimi;
  const {
    timeout,
    easing: easing2,
    style: style2 = {}
  } = props;
  return {
    duration: (_style$transitionDura = style2.transitionDuration) != null ? _style$transitionDura : typeof timeout === "number" ? timeout : timeout[options.mode] || 0,
    easing: (_style$transitionTimi = style2.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing2 === "object" ? easing2[options.mode] : easing2,
    delay: style2.transitionDelay
  };
}
function getPaperUtilityClass(slot) {
  return generateUtilityClass("MuiPaper", slot);
}
generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const _excluded$w = ["className", "component", "elevation", "square", "variant"];
const useUtilityClasses$p = (ownerState) => {
  const {
    square,
    elevation,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
  };
  return composeClasses(slots, getPaperUtilityClass, classes);
};
const PaperRoot = styled("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  var _theme$vars$overlays;
  return _extends$4({
    backgroundColor: (theme2.vars || theme2).palette.background.paper,
    color: (theme2.vars || theme2).palette.text.primary,
    transition: theme2.transitions.create("box-shadow")
  }, !ownerState.square && {
    borderRadius: theme2.shape.borderRadius
  }, ownerState.variant === "outlined" && {
    border: `1px solid ${(theme2.vars || theme2).palette.divider}`
  }, ownerState.variant === "elevation" && _extends$4({
    boxShadow: (theme2.vars || theme2).shadows[ownerState.elevation]
  }, !theme2.vars && theme2.palette.mode === "dark" && {
    backgroundImage: `linear-gradient(${alpha("#fff", getOverlayAlpha(ownerState.elevation))}, ${alpha("#fff", getOverlayAlpha(ownerState.elevation))})`
  }, theme2.vars && {
    backgroundImage: (_theme$vars$overlays = theme2.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
  }));
});
const Paper = /* @__PURE__ */ reactExports.forwardRef(function Paper2(inProps, ref2) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPaper"
  });
  const {
    className,
    component = "div",
    elevation = 1,
    square = false,
    variant = "elevation"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$w);
  const ownerState = _extends$4({}, props, {
    component,
    elevation,
    square,
    variant
  });
  const classes = useUtilityClasses$p(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, _extends$4({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref: ref2
  }, other));
});
const Paper$1 = Paper;
function isHostComponent(element) {
  return typeof element === "string";
}
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent(elementType)) {
    return otherProps;
  }
  return _extends$4({}, otherProps, {
    ownerState: _extends$4({}, otherProps.ownerState, ownerState)
  });
}
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function resolveComponentProps(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
function omitEventHandlers(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle2 = _extends$4({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props2 = _extends$4({}, additionalProps, externalForwardedProps, externalSlotProps);
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers(_extends$4({}, externalForwardedProps, externalSlotProps));
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = _extends$4({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
  const props = _extends$4({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
const _excluded$v = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
function useSlotProps(parameters) {
  var _parameters$additiona;
  const {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false
  } = parameters, rest = _objectWithoutPropertiesLoose$1(parameters, _excluded$v);
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps(_extends$4({}, rest, {
    externalSlotProps: resolvedComponentsProps
  }));
  const ref2 = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
  const props = appendOwnerState(elementType, _extends$4({}, mergedProps, {
    ref: ref2
  }), ownerState);
  return props;
}
function Ripple(props) {
  const {
    className,
    classes,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout
  } = props;
  const [leaving, setLeaving] = reactExports.useState(false);
  const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  reactExports.useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: childClassName
    })
  });
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
const _excluded$u = ["center", "classes", "className"];
let _$4 = (t2) => t2, _t$1, _t2, _t3, _t4;
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes(_t$1 || (_t$1 = _$4`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
const exitKeyframe = keyframes(_t2 || (_t2 = _$4`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
const pulsateKeyframe = keyframes(_t3 || (_t3 = _$4`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
const TouchRippleRoot = styled("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
const TouchRippleRipple = styled(Ripple, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})(_t4 || (_t4 = _$4`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses.rippleVisible, enterKeyframe, DURATION, ({
  theme: theme2
}) => theme2.transitions.easing.easeInOut, touchRippleClasses.ripplePulsate, ({
  theme: theme2
}) => theme2.transitions.duration.shorter, touchRippleClasses.child, touchRippleClasses.childLeaving, exitKeyframe, DURATION, ({
  theme: theme2
}) => theme2.transitions.easing.easeInOut, touchRippleClasses.childPulsate, pulsateKeyframe, ({
  theme: theme2
}) => theme2.transitions.easing.easeInOut);
const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref2) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const {
    center: centerProp = false,
    classes = {},
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$u);
  const [ripples, setRipples] = reactExports.useState([]);
  const nextKey = reactExports.useRef(0);
  const rippleCallback = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = reactExports.useRef(false);
  const startTimer = reactExports.useRef(0);
  const startTimerCommit = reactExports.useRef(null);
  const container = reactExports.useRef(null);
  reactExports.useEffect(() => {
    return () => {
      if (startTimer.current) {
        clearTimeout(startTimer.current);
      }
    };
  }, []);
  const startCommit = reactExports.useCallback((params) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb: cb2
    } = params;
    setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(classes.ripple, touchRippleClasses.ripple),
        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),
        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),
        child: clsx(classes.child, touchRippleClasses.child),
        childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),
        childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb2;
  }, [classes]);
  const start = reactExports.useCallback((event = {}, options = {}, cb2 = () => {
  }) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
      // For test purposes
    } = options;
    if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if ((event == null ? void 0 : event.type) === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }
    if (event != null && event.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb: cb2
          });
        };
        startTimer.current = setTimeout(() => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        }, DELAY_RIPPLE);
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb: cb2
      });
    }
  }, [centerProp, startCommit]);
  const pulsate = reactExports.useCallback(() => {
    start({}, {
      pulsate: true
    });
  }, [start]);
  const stop = reactExports.useCallback((event, cb2) => {
    clearTimeout(startTimer.current);
    if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.current = setTimeout(() => {
        stop(event, cb2);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb2;
  }, []);
  reactExports.useImperativeHandle(ref2, () => ({
    pulsate,
    start,
    stop
  }), [pulsate, start, stop]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, _extends$4({
    className: clsx(touchRippleClasses.root, classes.root, className),
    ref: container
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup$1, {
      component: null,
      exit: true,
      children: ripples
    })
  }));
});
const TouchRipple$1 = TouchRipple;
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass("MuiButtonBase", slot);
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
const _excluded$t = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"];
const useUtilityClasses$o = (ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
};
const ButtonBaseRoot = styled("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${buttonBaseClasses.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref2) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiButtonBase"
  });
  const {
    action,
    centerRipple = false,
    children,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$t);
  const buttonRef = reactExports.useRef(null);
  const rippleRef = reactExports.useRef(null);
  const handleRippleRef = useForkRef(rippleRef, touchRippleRef);
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  reactExports.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const [mountedState, setMountedState] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setMountedState(true);
  }, []);
  const enableTouchRipple = mountedState && !disableRipple && !disabled;
  reactExports.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple && mountedState) {
      rippleRef.current.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, mountedState]);
  function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
    return useEventCallback((event) => {
      if (eventCallback) {
        eventCallback(event);
      }
      const ignore = skipRippleAction;
      if (!ignore && rippleRef.current) {
        rippleRef.current[rippleAction](event);
      }
      return true;
    });
  }
  const handleMouseDown = useRippleHandler("start", onMouseDown);
  const handleContextMenu = useRippleHandler("stop", onContextMenu);
  const handleDragLeave = useRippleHandler("stop", onDragLeave);
  const handleMouseUp = useRippleHandler("stop", onMouseUp);
  const handleMouseLeave = useRippleHandler("stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  });
  const handleTouchStart = useRippleHandler("start", onTouchStart);
  const handleTouchEnd = useRippleHandler("stop", onTouchEnd);
  const handleTouchMove = useRippleHandler("stop", onTouchMove);
  const handleBlur = useRippleHandler("stop", (event) => {
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = () => {
    const button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  };
  const keydownRef = reactExports.useRef(false);
  const handleKeyDown2 = useEventCallback((event) => {
    if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
      keydownRef.current = true;
      rippleRef.current.stop(event, () => {
        rippleRef.current.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback((event) => {
    if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
      keydownRef.current = false;
      rippleRef.current.stop(event, () => {
        rippleRef.current.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type === void 0 ? "button" : type;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleRef = useForkRef(ref2, focusVisibleRef, buttonRef);
  const ownerState = _extends$4({}, props, {
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  });
  const classes = useUtilityClasses$o(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, _extends$4({
    as: ComponentProp,
    className: clsx(classes.root, className),
    ownerState,
    onBlur: handleBlur,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown2,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type
  }, buttonProps, other, {
    children: [children, enableTouchRipple ? (
      /* TouchRipple is only needed client-side, x2 boost on the server. */
      /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple$1, _extends$4({
        ref: handleRippleRef,
        center: centerRipple
      }, TouchRippleProps))
    ) : null]
  }));
});
const ButtonBase$1 = ButtonBase;
function getAlertUtilityClass(slot) {
  return generateUtilityClass("MuiAlert", slot);
}
const alertClasses = generateUtilityClasses("MuiAlert", ["root", "action", "icon", "message", "filled", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"]);
const alertClasses$1 = alertClasses;
function getIconButtonUtilityClass(slot) {
  return generateUtilityClass("MuiIconButton", slot);
}
const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]);
const _excluded$s = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"];
const useUtilityClasses$n = (ownerState) => {
  const {
    classes,
    disabled,
    color: color2,
    edge,
    size: size2
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", color2 !== "default" && `color${capitalize(color2)}`, edge && `edge${capitalize(edge)}`, `size${capitalize(size2)}`]
  };
  return composeClasses(slots, getIconButtonUtilityClass, classes);
};
const IconButtonRoot = styled(ButtonBase$1, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: theme2.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  overflow: "visible",
  // Explicitly set the default value to solve a bug on IE11.
  color: (theme2.vars || theme2).palette.action.active,
  transition: theme2.transitions.create("background-color", {
    duration: theme2.transitions.duration.shortest
  })
}, !ownerState.disableRipple && {
  "&:hover": {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.activeChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette.action.active, theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, ownerState.edge === "start" && {
  marginLeft: ownerState.size === "small" ? -3 : -12
}, ownerState.edge === "end" && {
  marginRight: ownerState.size === "small" ? -3 : -12
}), ({
  theme: theme2,
  ownerState
}) => {
  var _palette;
  const palette = (_palette = (theme2.vars || theme2).palette) == null ? void 0 : _palette[ownerState.color];
  return _extends$4({}, ownerState.color === "inherit" && {
    color: "inherit"
  }, ownerState.color !== "inherit" && ownerState.color !== "default" && _extends$4({
    color: palette == null ? void 0 : palette.main
  }, !ownerState.disableRipple && {
    "&:hover": _extends$4({}, palette && {
      backgroundColor: theme2.vars ? `rgba(${palette.mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(palette.main, theme2.palette.action.hoverOpacity)
    }, {
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    })
  }), ownerState.size === "small" && {
    padding: 5,
    fontSize: theme2.typography.pxToRem(18)
  }, ownerState.size === "large" && {
    padding: 12,
    fontSize: theme2.typography.pxToRem(28)
  }, {
    [`&.${iconButtonClasses.disabled}`]: {
      backgroundColor: "transparent",
      color: (theme2.vars || theme2).palette.action.disabled
    }
  });
});
const IconButton = /* @__PURE__ */ reactExports.forwardRef(function IconButton2(inProps, ref2) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiIconButton"
  });
  const {
    edge = false,
    children,
    className,
    color: color2 = "default",
    disabled = false,
    disableFocusRipple = false,
    size: size2 = "medium"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$s);
  const ownerState = _extends$4({}, props, {
    edge,
    color: color2,
    disabled,
    disableFocusRipple,
    size: size2
  });
  const classes = useUtilityClasses$n(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IconButtonRoot, _extends$4({
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled,
    ref: ref2,
    ownerState
  }, other, {
    children
  }));
});
const IconButton$1 = IconButton;
const SuccessOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
}), "SuccessOutlined");
const ReportProblemOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
}), "ReportProblemOutlined");
const ErrorOutlineIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}), "ErrorOutline");
const InfoOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
}), "InfoOutlined");
const ClearIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
const _excluded$r = ["action", "children", "className", "closeText", "color", "components", "componentsProps", "icon", "iconMapping", "onClose", "role", "severity", "slotProps", "slots", "variant"];
const useUtilityClasses$m = (ownerState) => {
  const {
    variant,
    color: color2,
    severity,
    classes
  } = ownerState;
  const slots = {
    root: ["root", `${variant}${capitalize(color2 || severity)}`, `${variant}`],
    icon: ["icon"],
    message: ["message"],
    action: ["action"]
  };
  return composeClasses(slots, getAlertUtilityClass, classes);
};
const AlertRoot = styled(Paper$1, {
  name: "MuiAlert",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color || ownerState.severity)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  const getColor = theme2.palette.mode === "light" ? darken : lighten;
  const getBackgroundColor = theme2.palette.mode === "light" ? lighten : darken;
  const color2 = ownerState.color || ownerState.severity;
  return _extends$4({}, theme2.typography.body2, {
    backgroundColor: "transparent",
    display: "flex",
    padding: "6px 16px"
  }, color2 && ownerState.variant === "standard" && {
    color: theme2.vars ? theme2.vars.palette.Alert[`${color2}Color`] : getColor(theme2.palette[color2].light, 0.6),
    backgroundColor: theme2.vars ? theme2.vars.palette.Alert[`${color2}StandardBg`] : getBackgroundColor(theme2.palette[color2].light, 0.9),
    [`& .${alertClasses$1.icon}`]: theme2.vars ? {
      color: theme2.vars.palette.Alert[`${color2}IconColor`]
    } : {
      color: theme2.palette[color2].main
    }
  }, color2 && ownerState.variant === "outlined" && {
    color: theme2.vars ? theme2.vars.palette.Alert[`${color2}Color`] : getColor(theme2.palette[color2].light, 0.6),
    border: `1px solid ${(theme2.vars || theme2).palette[color2].light}`,
    [`& .${alertClasses$1.icon}`]: theme2.vars ? {
      color: theme2.vars.palette.Alert[`${color2}IconColor`]
    } : {
      color: theme2.palette[color2].main
    }
  }, color2 && ownerState.variant === "filled" && _extends$4({
    fontWeight: theme2.typography.fontWeightMedium
  }, theme2.vars ? {
    color: theme2.vars.palette.Alert[`${color2}FilledColor`],
    backgroundColor: theme2.vars.palette.Alert[`${color2}FilledBg`]
  } : {
    backgroundColor: theme2.palette.mode === "dark" ? theme2.palette[color2].dark : theme2.palette[color2].main,
    color: theme2.palette.getContrastText(theme2.palette[color2].main)
  }));
});
const AlertIcon = styled("div", {
  name: "MuiAlert",
  slot: "Icon",
  overridesResolver: (props, styles2) => styles2.icon
})({
  marginRight: 12,
  padding: "7px 0",
  display: "flex",
  fontSize: 22,
  opacity: 0.9
});
const AlertMessage = styled("div", {
  name: "MuiAlert",
  slot: "Message",
  overridesResolver: (props, styles2) => styles2.message
})({
  padding: "8px 0",
  minWidth: 0,
  overflow: "auto"
});
const AlertAction = styled("div", {
  name: "MuiAlert",
  slot: "Action",
  overridesResolver: (props, styles2) => styles2.action
})({
  display: "flex",
  alignItems: "flex-start",
  padding: "4px 0 0 16px",
  marginLeft: "auto",
  marginRight: -8
});
const defaultIconMapping = {
  success: /* @__PURE__ */ jsxRuntimeExports.jsx(SuccessOutlinedIcon, {
    fontSize: "inherit"
  }),
  warning: /* @__PURE__ */ jsxRuntimeExports.jsx(ReportProblemOutlinedIcon, {
    fontSize: "inherit"
  }),
  error: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorOutlineIcon, {
    fontSize: "inherit"
  }),
  info: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoOutlinedIcon, {
    fontSize: "inherit"
  })
};
const Alert = /* @__PURE__ */ reactExports.forwardRef(function Alert2(inProps, ref2) {
  var _ref, _slots$closeButton, _ref2, _slots$closeIcon, _slotProps$closeButto, _slotProps$closeIcon;
  const props = useThemeProps({
    props: inProps,
    name: "MuiAlert"
  });
  const {
    action,
    children,
    className,
    closeText = "Close",
    color: color2,
    components = {},
    componentsProps = {},
    icon,
    iconMapping = defaultIconMapping,
    onClose,
    role = "alert",
    severity = "success",
    slotProps = {},
    slots = {},
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$r);
  const ownerState = _extends$4({}, props, {
    color: color2,
    severity,
    variant
  });
  const classes = useUtilityClasses$m(ownerState);
  const AlertCloseButton = (_ref = (_slots$closeButton = slots.closeButton) != null ? _slots$closeButton : components.CloseButton) != null ? _ref : IconButton$1;
  const AlertCloseIcon = (_ref2 = (_slots$closeIcon = slots.closeIcon) != null ? _slots$closeIcon : components.CloseIcon) != null ? _ref2 : ClearIcon;
  const closeButtonProps = (_slotProps$closeButto = slotProps.closeButton) != null ? _slotProps$closeButto : componentsProps.closeButton;
  const closeIconProps = (_slotProps$closeIcon = slotProps.closeIcon) != null ? _slotProps$closeIcon : componentsProps.closeIcon;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(AlertRoot, _extends$4({
    role,
    elevation: 0,
    ownerState,
    className: clsx(classes.root, className),
    ref: ref2
  }, other, {
    children: [icon !== false ? /* @__PURE__ */ jsxRuntimeExports.jsx(AlertIcon, {
      ownerState,
      className: classes.icon,
      children: icon || iconMapping[severity] || defaultIconMapping[severity]
    }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(AlertMessage, {
      ownerState,
      className: classes.message,
      children
    }), action != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(AlertAction, {
      ownerState,
      className: classes.action,
      children: action
    }) : null, action == null && onClose ? /* @__PURE__ */ jsxRuntimeExports.jsx(AlertAction, {
      ownerState,
      className: classes.action,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertCloseButton, _extends$4({
        size: "small",
        "aria-label": closeText,
        title: closeText,
        color: "inherit",
        onClick: onClose
      }, closeButtonProps, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertCloseIcon, _extends$4({
          fontSize: "small"
        }, closeIconProps))
      }))
    }) : null]
  }));
});
const Alert$1 = Alert;
function getTypographyUtilityClass(slot) {
  return generateUtilityClass("MuiTypography", slot);
}
generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const _excluded$q = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"];
const useUtilityClasses$l = (ownerState) => {
  const {
    align,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
  };
  return composeClasses(slots, getTypographyUtilityClass, classes);
};
const TypographyRoot = styled("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  margin: 0
}, ownerState.variant === "inherit" && {
  // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
  font: "inherit"
}, ownerState.variant !== "inherit" && theme2.typography[ownerState.variant], ownerState.align !== "inherit" && {
  textAlign: ownerState.align
}, ownerState.noWrap && {
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
}, ownerState.gutterBottom && {
  marginBottom: "0.35em"
}, ownerState.paragraph && {
  marginBottom: 16
}));
const defaultVariantMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
};
const colorTransformations$1 = {
  primary: "primary.main",
  textPrimary: "text.primary",
  secondary: "secondary.main",
  textSecondary: "text.secondary",
  error: "error.main"
};
const transformDeprecatedColors$1 = (color2) => {
  return colorTransformations$1[color2] || color2;
};
const Typography = /* @__PURE__ */ reactExports.forwardRef(function Typography2(inProps, ref2) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiTypography"
  });
  const color2 = transformDeprecatedColors$1(themeProps.color);
  const props = extendSxProp(_extends$4({}, themeProps, {
    color: color2
  }));
  const {
    align = "inherit",
    className,
    component,
    gutterBottom = false,
    noWrap = false,
    paragraph = false,
    variant = "body1",
    variantMapping = defaultVariantMapping
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$q);
  const ownerState = _extends$4({}, props, {
    align,
    color: color2,
    className,
    component,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    variantMapping
  });
  const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
  const classes = useUtilityClasses$l(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyRoot, _extends$4({
    as: Component,
    ref: ref2,
    ownerState,
    className: clsx(classes.root, className)
  }, other));
});
const Typography$1 = Typography;
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(node2) {
  const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
    return 0;
  }
  return node2.tabIndex;
}
function isNonTabbableRadio(node2) {
  if (node2.tagName !== "INPUT" || node2.type !== "radio") {
    return false;
  }
  if (!node2.name) {
    return false;
  }
  const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
  let roving = getRadio(`[name="${node2.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node2.name}"]`);
  }
  return roving !== node2;
}
function isNodeMatchingSelectorFocusable(node2) {
  if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
    return false;
  }
  return true;
}
function defaultGetTabbable(root) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root.querySelectorAll(candidatesSelector)).forEach((node2, i3) => {
    const nodeTabIndex = getTabIndex(node2);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node2);
    } else {
      orderedTabNodes.push({
        documentOrder: i3,
        tabIndex: nodeTabIndex,
        node: node2
      });
    }
  });
  return orderedTabNodes.sort((a2, b3) => a2.tabIndex === b3.tabIndex ? a2.documentOrder - b3.documentOrder : a2.tabIndex - b3.tabIndex).map((a2) => a2.node).concat(regularTabNodes);
}
function defaultIsEnabled() {
  return true;
}
function FocusTrap(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled = defaultIsEnabled,
    open
  } = props;
  const ignoreNextEnforceFocus = reactExports.useRef(false);
  const sentinelStart = reactExports.useRef(null);
  const sentinelEnd = reactExports.useRef(null);
  const nodeToRestore = reactExports.useRef(null);
  const reactFocusEventTarget = reactExports.useRef(null);
  const activated = reactExports.useRef(false);
  const rootRef = reactExports.useRef(null);
  const handleRef = useForkRef(children.ref, rootRef);
  const lastKeydown = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        rootRef.current.setAttribute("tabIndex", "-1");
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const loopFocus = (nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        if (sentinelEnd.current) {
          sentinelEnd.current.focus();
        }
      }
    };
    const contain = () => {
      const rootElement = rootRef.current;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (rootElement.contains(doc.activeElement)) {
        return;
      }
      if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
        return;
      }
      if (doc.activeElement !== reactFocusEventTarget.current) {
        reactFocusEventTarget.current = null;
      } else if (reactFocusEventTarget.current !== null) {
        return;
      }
      if (!activated.current) {
        return;
      }
      let tabbable = [];
      if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
        tabbable = getTabbable(rootRef.current);
      }
      if (tabbable.length > 0) {
        var _lastKeydown$current, _lastKeydown$current2;
        const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
        const focusNext = tabbable[0];
        const focusPrevious = tabbable[tabbable.length - 1];
        if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        }
      } else {
        rootElement.focus();
      }
    };
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement && doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
  const onFocus = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const handleFocusSentinel = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ reactExports.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
function getContainer$1(container) {
  return typeof container === "function" ? container() : container;
}
const Portal = /* @__PURE__ */ reactExports.forwardRef(function Portal2(props, forwardedRef) {
  const {
    children,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = reactExports.useState(null);
  const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? children.ref : null, forwardedRef);
  useEnhancedEffect(() => {
    if (!disablePortal) {
      setMountNode(getContainer$1(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect(() => {
    if (mountNode && !disablePortal) {
      setRef(forwardedRef, mountNode);
      return () => {
        setRef(forwardedRef, null);
      };
    }
    return void 0;
  }, [forwardedRef, mountNode, disablePortal]);
  if (disablePortal) {
    if (/* @__PURE__ */ reactExports.isValidElement(children)) {
      const newProps = {
        ref: handleRef
      };
      return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode
  });
});
function isOverflowing(container) {
  const doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
function ariaHidden(element, show) {
  if (show) {
    element.setAttribute("aria-hidden", "true");
  } else {
    element.removeAttribute("aria-hidden");
  }
}
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(element) {
  const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
  const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
  const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, (element) => {
    const isNotExcludedElement = blacklist.indexOf(element) === -1;
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden(element, show);
    }
  });
}
function findIndexOf(items, callback) {
  let idx = -1;
  items.some((item, index2) => {
    if (callback(item)) {
      idx = index2;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      const scrollbarSize = getScrollbarSize(ownerDocument(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      });
      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
      const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements2, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment) {
      scrollContainer = ownerDocument(container).body;
    } else {
      const parent2 = container.parentElement;
      const containerWindow = ownerWindow(container);
      scrollContainer = (parent2 == null ? void 0 : parent2.nodeName) === "HTML" && containerWindow.getComputedStyle(parent2).overflowY === "scroll" ? parent2 : container;
    }
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  const restore = () => {
    restoreStyle.forEach(({
      value,
      el: el2,
      property
    }) => {
      if (value) {
        el2.style.setProperty(property, value);
      } else {
        el2.style.removeProperty(property);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, (element) => {
    if (element.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
class ModalManager {
  constructor() {
    this.containers = void 0;
    this.modals = void 0;
    this.modals = [];
    this.containers = [];
  }
  add(modal2, container) {
    let modalIndex = this.modals.indexOf(modal2);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal2);
    if (modal2.modalRef) {
      ariaHidden(modal2.modalRef, false);
    }
    const hiddenSiblings = getHiddenSiblings(container);
    ariaHiddenSiblings(container, modal2.mount, modal2.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal2);
      return modalIndex;
    }
    this.containers.push({
      modals: [modal2],
      container,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }
  mount(modal2, props) {
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal2) !== -1);
    const containerInfo = this.containers[containerIndex];
    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer(containerInfo, props);
    }
  }
  remove(modal2, ariaHiddenState = true) {
    const modalIndex = this.modals.indexOf(modal2);
    if (modalIndex === -1) {
      return modalIndex;
    }
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal2) !== -1);
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal2), 1);
    this.modals.splice(modalIndex, 1);
    if (containerInfo.modals.length === 0) {
      if (containerInfo.restore) {
        containerInfo.restore();
      }
      if (modal2.modalRef) {
        ariaHidden(modal2.modalRef, ariaHiddenState);
      }
      ariaHiddenSiblings(containerInfo.container, modal2.mount, modal2.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
      if (nextTop.modalRef) {
        ariaHidden(nextTop.modalRef, false);
      }
    }
    return modalIndex;
  }
  isTopModal(modal2) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal2;
  }
}
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
function getHasTransition(children) {
  return children ? children.props.hasOwnProperty("in") : false;
}
const defaultManager = new ModalManager();
function useModal(parameters) {
  const {
    container,
    disableEscapeKeyDown = false,
    disableScrollLock = false,
    // @ts-ignore internal logic - Base UI supports the manager as a prop too
    manager = defaultManager,
    closeAfterTransition = false,
    onTransitionEnter,
    onTransitionExited,
    children,
    onClose,
    open,
    rootRef
  } = parameters;
  const modal2 = reactExports.useRef({});
  const mountNodeRef = reactExports.useRef(null);
  const modalRef = reactExports.useRef(null);
  const handleRef = useForkRef(modalRef, rootRef);
  const [exited, setExited] = reactExports.useState(!open);
  const hasTransition = getHasTransition(children);
  let ariaHiddenProp = true;
  if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
    ariaHiddenProp = false;
  }
  const getDoc = () => ownerDocument(mountNodeRef.current);
  const getModal = () => {
    modal2.current.modalRef = modalRef.current;
    modal2.current.mount = mountNodeRef.current;
    return modal2.current;
  };
  const handleMounted = () => {
    manager.mount(getModal(), {
      disableScrollLock
    });
    if (modalRef.current) {
      modalRef.current.scrollTop = 0;
    }
  };
  const handleOpen = useEventCallback(() => {
    const resolvedContainer = getContainer(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = reactExports.useCallback(() => manager.isTopModal(getModal()), [manager]);
  const handlePortalRef = useEventCallback((node2) => {
    mountNodeRef.current = node2;
    if (!node2) {
      return;
    }
    if (open && isTopModal()) {
      handleMounted();
    } else if (modalRef.current) {
      ariaHidden(modalRef.current, ariaHiddenProp);
    }
  });
  const handleClose = reactExports.useCallback(() => {
    manager.remove(getModal(), ariaHiddenProp);
  }, [ariaHiddenProp, manager]);
  reactExports.useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  reactExports.useEffect(() => {
    if (open) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  const createHandleKeyDown = (otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
    if (event.key !== "Escape" || event.which === 229 || // Wait until IME is settled.
    !isTopModal()) {
      return;
    }
    if (!disableEscapeKeyDown) {
      event.stopPropagation();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
    }
  };
  const createHandleBackdropClick = (otherHandlers) => (event) => {
    var _otherHandlers$onClic;
    (_otherHandlers$onClic = otherHandlers.onClick) == null || _otherHandlers$onClic.call(otherHandlers, event);
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const getRootProps = (otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters);
    delete propsEventHandlers.onTransitionEnter;
    delete propsEventHandlers.onTransitionExited;
    const externalEventHandlers = _extends$4({}, propsEventHandlers, otherHandlers);
    return _extends$4({
      role: "presentation"
    }, externalEventHandlers, {
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      ref: handleRef
    });
  };
  const getBackdropProps = (otherHandlers = {}) => {
    const externalEventHandlers = otherHandlers;
    return _extends$4({
      "aria-hidden": true
    }, externalEventHandlers, {
      onClick: createHandleBackdropClick(externalEventHandlers),
      open
    });
  };
  const getTransitionProps2 = () => {
    const handleEnter = () => {
      setExited(false);
      if (onTransitionEnter) {
        onTransitionEnter();
      }
    };
    const handleExited = () => {
      setExited(true);
      if (onTransitionExited) {
        onTransitionExited();
      }
      if (closeAfterTransition) {
        handleClose();
      }
    };
    return {
      onEnter: createChainedFunction(handleEnter, children == null ? void 0 : children.props.onEnter),
      onExited: createChainedFunction(handleExited, children == null ? void 0 : children.props.onExited)
    };
  };
  return {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    rootRef: handleRef,
    portalRef: handlePortalRef,
    isTopModal,
    exited,
    hasTransition
  };
}
const _excluded$p = ["onChange", "maxRows", "minRows", "style", "value"];
function getStyleValue(value) {
  return parseInt(value, 10) || 0;
}
const styles$1d = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function isEmpty$1(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0 || obj.outerHeightStyle === 0 && !obj.overflow;
}
const TextareaAutosize = /* @__PURE__ */ reactExports.forwardRef(function TextareaAutosize2(props, forwardedRef) {
  const {
    onChange,
    maxRows,
    minRows = 1,
    style: style2,
    value
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$p);
  const {
    current: isControlled
  } = reactExports.useRef(value != null);
  const inputRef = reactExports.useRef(null);
  const handleRef = useForkRef(forwardedRef, inputRef);
  const shadowRef = reactExports.useRef(null);
  const renders = reactExports.useRef(0);
  const [state2, setState] = reactExports.useState({
    outerHeightStyle: 0
  });
  const getUpdatedState = reactExports.useCallback(() => {
    const input = inputRef.current;
    const containerWindow = ownerWindow(input);
    const computedStyle = containerWindow.getComputedStyle(input);
    if (computedStyle.width === "0px") {
      return {
        outerHeightStyle: 0
      };
    }
    const inputShallow = shadowRef.current;
    inputShallow.style.width = computedStyle.width;
    inputShallow.value = input.value || props.placeholder || "x";
    if (inputShallow.value.slice(-1) === "\n") {
      inputShallow.value += " ";
    }
    const boxSizing2 = computedStyle.boxSizing;
    const padding2 = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
    const border2 = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);
    const innerHeight = inputShallow.scrollHeight;
    inputShallow.value = "x";
    const singleRowHeight = inputShallow.scrollHeight;
    let outerHeight = innerHeight;
    if (minRows) {
      outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
    }
    if (maxRows) {
      outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
    }
    outerHeight = Math.max(outerHeight, singleRowHeight);
    const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding2 + border2 : 0);
    const overflow = Math.abs(outerHeight - innerHeight) <= 1;
    return {
      outerHeightStyle,
      overflow
    };
  }, [maxRows, minRows, props.placeholder]);
  const updateState = (prevState, newState) => {
    const {
      outerHeightStyle,
      overflow
    } = newState;
    if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow)) {
      renders.current += 1;
      return {
        overflow,
        outerHeightStyle
      };
    }
    return prevState;
  };
  const syncHeight = reactExports.useCallback(() => {
    const newState = getUpdatedState();
    if (isEmpty$1(newState)) {
      return;
    }
    setState((prevState) => updateState(prevState, newState));
  }, [getUpdatedState]);
  useEnhancedEffect(() => {
    const syncHeightWithFlushSync = () => {
      const newState = getUpdatedState();
      if (isEmpty$1(newState)) {
        return;
      }
      reactDomExports.flushSync(() => {
        setState((prevState) => updateState(prevState, newState));
      });
    };
    const handleResize = () => {
      renders.current = 0;
      syncHeightWithFlushSync();
    };
    let rAF;
    const debounceHandleResize = debounce(handleResize);
    const input = inputRef.current;
    const containerWindow = ownerWindow(input);
    containerWindow.addEventListener("resize", debounceHandleResize);
    let resizeObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(input);
    }
    return () => {
      debounceHandleResize.clear();
      cancelAnimationFrame(rAF);
      containerWindow.removeEventListener("resize", debounceHandleResize);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, [getUpdatedState]);
  useEnhancedEffect(() => {
    syncHeight();
  });
  reactExports.useEffect(() => {
    renders.current = 0;
  }, [value]);
  const handleChange = (event) => {
    renders.current = 0;
    if (!isControlled) {
      syncHeight();
    }
    if (onChange) {
      onChange(event);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("textarea", _extends$4({
      value,
      onChange: handleChange,
      ref: handleRef,
      rows: minRows,
      style: _extends$4({
        height: state2.outerHeightStyle,
        // Need a large enough difference to allow scrolling.
        // This prevents infinite rendering loop.
        overflow: state2.overflow ? "hidden" : void 0
      }, style2)
    }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", {
      "aria-hidden": true,
      className: props.className,
      readOnly: true,
      ref: shadowRef,
      tabIndex: -1,
      style: _extends$4({}, styles$1d.shadow, style2, {
        paddingTop: 0,
        paddingBottom: 0
      })
    })]
  });
});
function formControlState({
  props,
  states,
  muiFormControl
}) {
  return states.reduce((acc, state2) => {
    acc[state2] = props[state2];
    if (muiFormControl) {
      if (typeof props[state2] === "undefined") {
        acc[state2] = muiFormControl[state2];
      }
    }
    return acc;
  }, {});
}
const FormControlContext = /* @__PURE__ */ reactExports.createContext(void 0);
const FormControlContext$1 = FormControlContext;
function useFormControl() {
  return reactExports.useContext(FormControlContext$1);
}
function GlobalStyles(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, _extends$4({}, props, {
    defaultTheme: defaultTheme$1,
    themeId: THEME_ID
  }));
}
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0);
}
function isFilled(obj, SSR = false) {
  return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
}
function isAdornedStart(obj) {
  return obj.startAdornment;
}
function getInputBaseUtilityClass(slot) {
  return generateUtilityClass("MuiInputBase", slot);
}
const inputBaseClasses = generateUtilityClasses("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
const inputBaseClasses$1 = inputBaseClasses;
const _excluded$o = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"];
const rootOverridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.formControl && styles2.formControl, ownerState.startAdornment && styles2.adornedStart, ownerState.endAdornment && styles2.adornedEnd, ownerState.error && styles2.error, ownerState.size === "small" && styles2.sizeSmall, ownerState.multiline && styles2.multiline, ownerState.color && styles2[`color${capitalize(ownerState.color)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.hiddenLabel && styles2.hiddenLabel];
};
const inputOverridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.input, ownerState.size === "small" && styles2.inputSizeSmall, ownerState.multiline && styles2.inputMultiline, ownerState.type === "search" && styles2.inputTypeSearch, ownerState.startAdornment && styles2.inputAdornedStart, ownerState.endAdornment && styles2.inputAdornedEnd, ownerState.hiddenLabel && styles2.inputHiddenLabel];
};
const useUtilityClasses$k = (ownerState) => {
  const {
    classes,
    color: color2,
    disabled,
    error,
    endAdornment,
    focused,
    formControl,
    fullWidth,
    hiddenLabel,
    multiline,
    readOnly,
    size: size2,
    startAdornment,
    type
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", fullWidth && "fullWidth", focused && "focused", formControl && "formControl", size2 && size2 !== "medium" && `size${capitalize(size2)}`, multiline && "multiline", startAdornment && "adornedStart", endAdornment && "adornedEnd", hiddenLabel && "hiddenLabel", readOnly && "readOnly"],
    input: ["input", disabled && "disabled", type === "search" && "inputTypeSearch", multiline && "inputMultiline", size2 === "small" && "inputSizeSmall", hiddenLabel && "inputHiddenLabel", startAdornment && "inputAdornedStart", endAdornment && "inputAdornedEnd", readOnly && "readOnly"]
  };
  return composeClasses(slots, getInputBaseUtilityClass, classes);
};
const InputBaseRoot = styled("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => _extends$4({}, theme2.typography.body1, {
  color: (theme2.vars || theme2).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${inputBaseClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled,
    cursor: "default"
  }
}, ownerState.multiline && _extends$4({
  padding: "4px 0 5px"
}, ownerState.size === "small" && {
  paddingTop: 1
}), ownerState.fullWidth && {
  width: "100%"
}));
const InputBaseComponent = styled("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => {
  const light2 = theme2.palette.mode === "light";
  const placeholder = _extends$4({
    color: "currentColor"
  }, theme2.vars ? {
    opacity: theme2.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  }, {
    transition: theme2.transitions.create("opacity", {
      duration: theme2.transitions.duration.shorter
    })
  });
  const placeholderHidden = {
    opacity: "0 !important"
  };
  const placeholderVisible = theme2.vars ? {
    opacity: theme2.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  };
  return _extends$4({
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    // Fix IE11 width issue
    animationName: "mui-auto-fill-cancel",
    animationDuration: "10ms",
    "&::-webkit-input-placeholder": placeholder,
    "&::-moz-placeholder": placeholder,
    // Firefox 19+
    "&:-ms-input-placeholder": placeholder,
    // IE11
    "&::-ms-input-placeholder": placeholder,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${inputBaseClasses$1.formControl} &`]: {
      "&::-webkit-input-placeholder": placeholderHidden,
      "&::-moz-placeholder": placeholderHidden,
      // Firefox 19+
      "&:-ms-input-placeholder": placeholderHidden,
      // IE11
      "&::-ms-input-placeholder": placeholderHidden,
      // Edge
      "&:focus::-webkit-input-placeholder": placeholderVisible,
      "&:focus::-moz-placeholder": placeholderVisible,
      // Firefox 19+
      "&:focus:-ms-input-placeholder": placeholderVisible,
      // IE11
      "&:focus::-ms-input-placeholder": placeholderVisible
      // Edge
    },
    [`&.${inputBaseClasses$1.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (theme2.vars || theme2).palette.text.disabled
      // Fix opacity Safari bug
    },
    "&:-webkit-autofill": {
      animationDuration: "5000s",
      animationName: "mui-auto-fill"
    }
  }, ownerState.size === "small" && {
    paddingTop: 1
  }, ownerState.multiline && {
    height: "auto",
    resize: "none",
    padding: 0,
    paddingTop: 0
  }, ownerState.type === "search" && {
    // Improve type search style.
    MozAppearance: "textfield"
  });
});
const inputGlobalStyles = /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
  styles: {
    "@keyframes mui-auto-fill": {
      from: {
        display: "block"
      }
    },
    "@keyframes mui-auto-fill-cancel": {
      from: {
        display: "block"
      }
    }
  }
});
const InputBase = /* @__PURE__ */ reactExports.forwardRef(function InputBase2(inProps, ref2) {
  var _slotProps$input;
  const props = useThemeProps({
    props: inProps,
    name: "MuiInputBase"
  });
  const {
    "aria-describedby": ariaDescribedby,
    autoComplete,
    autoFocus,
    className,
    components = {},
    componentsProps = {},
    defaultValue,
    disabled,
    disableInjectingGlobalStyles,
    endAdornment,
    fullWidth = false,
    id: id2,
    inputComponent = "input",
    inputProps: inputPropsProp = {},
    inputRef: inputRefProp,
    maxRows,
    minRows,
    multiline = false,
    name: name2,
    onBlur,
    onChange,
    onClick,
    onFocus,
    onKeyDown,
    onKeyUp,
    placeholder,
    readOnly,
    renderSuffix,
    rows,
    slotProps = {},
    slots = {},
    startAdornment,
    type = "text",
    value: valueProp
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$o);
  const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
  const {
    current: isControlled
  } = reactExports.useRef(value != null);
  const inputRef = reactExports.useRef();
  const handleInputRefWarning = reactExports.useCallback((instance) => {
  }, []);
  const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
  const [focused, setFocused] = reactExports.useState(false);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  fcs.focused = muiFormControl ? muiFormControl.focused : focused;
  reactExports.useEffect(() => {
    if (!muiFormControl && disabled && focused) {
      setFocused(false);
      if (onBlur) {
        onBlur();
      }
    }
  }, [muiFormControl, disabled, focused, onBlur]);
  const onFilled = muiFormControl && muiFormControl.onFilled;
  const onEmpty = muiFormControl && muiFormControl.onEmpty;
  const checkDirty = reactExports.useCallback((obj) => {
    if (isFilled(obj)) {
      if (onFilled) {
        onFilled();
      }
    } else if (onEmpty) {
      onEmpty();
    }
  }, [onFilled, onEmpty]);
  useEnhancedEffect(() => {
    if (isControlled) {
      checkDirty({
        value
      });
    }
  }, [value, checkDirty, isControlled]);
  const handleFocus = (event) => {
    if (fcs.disabled) {
      event.stopPropagation();
      return;
    }
    if (onFocus) {
      onFocus(event);
    }
    if (inputPropsProp.onFocus) {
      inputPropsProp.onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    } else {
      setFocused(true);
    }
  };
  const handleBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (inputPropsProp.onBlur) {
      inputPropsProp.onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    } else {
      setFocused(false);
    }
  };
  const handleChange = (event, ...args) => {
    if (!isControlled) {
      const element = event.target || inputRef.current;
      if (element == null) {
        throw new Error(formatMuiErrorMessage(1));
      }
      checkDirty({
        value: element.value
      });
    }
    if (inputPropsProp.onChange) {
      inputPropsProp.onChange(event, ...args);
    }
    if (onChange) {
      onChange(event, ...args);
    }
  };
  reactExports.useEffect(() => {
    checkDirty(inputRef.current);
  }, []);
  const handleClick = (event) => {
    if (inputRef.current && event.currentTarget === event.target) {
      inputRef.current.focus();
    }
    if (onClick) {
      onClick(event);
    }
  };
  let InputComponent = inputComponent;
  let inputProps = inputPropsProp;
  if (multiline && InputComponent === "input") {
    if (rows) {
      inputProps = _extends$4({
        type: void 0,
        minRows: rows,
        maxRows: rows
      }, inputProps);
    } else {
      inputProps = _extends$4({
        type: void 0,
        maxRows,
        minRows
      }, inputProps);
    }
    InputComponent = TextareaAutosize;
  }
  const handleAutoFill = (event) => {
    checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
      value: "x"
    });
  };
  reactExports.useEffect(() => {
    if (muiFormControl) {
      muiFormControl.setAdornedStart(Boolean(startAdornment));
    }
  }, [muiFormControl, startAdornment]);
  const ownerState = _extends$4({}, props, {
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    endAdornment,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    startAdornment,
    type
  });
  const classes = useUtilityClasses$k(ownerState);
  const Root = slots.root || components.Root || InputBaseRoot;
  const rootProps = slotProps.root || componentsProps.root || {};
  const Input3 = slots.input || components.Input || InputBaseComponent;
  inputProps = _extends$4({}, inputProps, (_slotProps$input = slotProps.input) != null ? _slotProps$input : componentsProps.input);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [!disableInjectingGlobalStyles && inputGlobalStyles, /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, _extends$4({}, rootProps, !isHostComponent(Root) && {
      ownerState: _extends$4({}, ownerState, rootProps.ownerState)
    }, {
      ref: ref2,
      onClick: handleClick
    }, other, {
      className: clsx(classes.root, rootProps.className, className, readOnly && "MuiInputBase-readOnly"),
      children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
        value: null,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input3, _extends$4({
          ownerState,
          "aria-invalid": fcs.error,
          "aria-describedby": ariaDescribedby,
          autoComplete,
          autoFocus,
          defaultValue,
          disabled: fcs.disabled,
          id: id2,
          onAnimationStart: handleAutoFill,
          name: name2,
          placeholder,
          readOnly,
          required: fcs.required,
          rows,
          value,
          onKeyDown,
          onKeyUp,
          type
        }, inputProps, !isHostComponent(Input3) && {
          as: InputComponent,
          ownerState: _extends$4({}, ownerState, inputProps.ownerState)
        }, {
          ref: handleInputRef,
          className: clsx(classes.input, inputProps.className, readOnly && "MuiInputBase-readOnly"),
          onBlur: handleBlur,
          onChange: handleChange,
          onFocus: handleFocus
        }))
      }), endAdornment, renderSuffix ? renderSuffix(_extends$4({}, fcs, {
        startAdornment
      })) : null]
    }))]
  });
});
const InputBase$1 = InputBase;
function getInputUtilityClass(slot) {
  return generateUtilityClass("MuiInput", slot);
}
const inputClasses = _extends$4({}, inputBaseClasses$1, generateUtilityClasses("MuiInput", ["root", "underline", "input"]));
const inputClasses$1 = inputClasses;
function getOutlinedInputUtilityClass(slot) {
  return generateUtilityClass("MuiOutlinedInput", slot);
}
const outlinedInputClasses = _extends$4({}, inputBaseClasses$1, generateUtilityClasses("MuiOutlinedInput", ["root", "notchedOutline", "input"]));
const outlinedInputClasses$1 = outlinedInputClasses;
function getFilledInputUtilityClass(slot) {
  return generateUtilityClass("MuiFilledInput", slot);
}
const filledInputClasses = _extends$4({}, inputBaseClasses$1, generateUtilityClasses("MuiFilledInput", ["root", "underline", "input"]));
const filledInputClasses$1 = filledInputClasses;
const ArrowDropDownIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown");
const _excluded$n = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
const styles$1c = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
};
const Fade = /* @__PURE__ */ reactExports.forwardRef(function Fade2(props, ref2) {
  const theme2 = useTheme();
  const defaultTimeout = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = defaultTimeout,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition$1
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$n);
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, children.ref, ref2);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme2.transitions.create("opacity", transitionProps);
    node2.style.transition = theme2.transitions.create("opacity", transitionProps);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme2.transitions.create("opacity", transitionProps);
    node2.style.transition = theme2.transitions.create("opacity", transitionProps);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$4({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout
  }, other, {
    children: (state2, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends$4({
        style: _extends$4({
          opacity: 0,
          visibility: state2 === "exited" && !inProp ? "hidden" : void 0
        }, styles$1c[state2], style2, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
});
const Fade$1 = Fade;
function getBackdropUtilityClass(slot) {
  return generateUtilityClass("MuiBackdrop", slot);
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const _excluded$m = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"];
const useUtilityClasses$j = (ownerState) => {
  const {
    classes,
    invisible
  } = ownerState;
  const slots = {
    root: ["root", invisible && "invisible"]
  };
  return composeClasses(slots, getBackdropUtilityClass, classes);
};
const BackdropRoot = styled("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.invisible && styles2.invisible];
  }
})(({
  ownerState
}) => _extends$4({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent"
}, ownerState.invisible && {
  backgroundColor: "transparent"
}));
const Backdrop = /* @__PURE__ */ reactExports.forwardRef(function Backdrop2(inProps, ref2) {
  var _slotProps$root, _ref, _slots$root;
  const props = useThemeProps({
    props: inProps,
    name: "MuiBackdrop"
  });
  const {
    children,
    className,
    component = "div",
    components = {},
    componentsProps = {},
    invisible = false,
    open,
    slotProps = {},
    slots = {},
    TransitionComponent = Fade$1,
    transitionDuration
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$m);
  const ownerState = _extends$4({}, props, {
    component,
    invisible
  });
  const classes = useUtilityClasses$j(ownerState);
  const rootSlotProps = (_slotProps$root = slotProps.root) != null ? _slotProps$root : componentsProps.root;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$4({
    in: open,
    timeout: transitionDuration
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropRoot, _extends$4({
      "aria-hidden": true
    }, rootSlotProps, {
      as: (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : component,
      className: clsx(classes.root, className, rootSlotProps == null ? void 0 : rootSlotProps.className),
      ownerState: _extends$4({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
      classes,
      ref: ref2,
      children
    }))
  }));
});
const Backdrop$1 = Backdrop;
function getButtonUtilityClass(slot) {
  return generateUtilityClass("MuiButton", slot);
}
const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]);
const buttonClasses$1 = buttonClasses;
const ButtonGroupContext = /* @__PURE__ */ reactExports.createContext({});
const ButtonGroupContext$1 = ButtonGroupContext;
const ButtonGroupButtonContext = /* @__PURE__ */ reactExports.createContext(void 0);
const ButtonGroupButtonContext$1 = ButtonGroupButtonContext;
const _excluded$l = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"];
const useUtilityClasses$i = (ownerState) => {
  const {
    color: color2,
    disableElevation,
    fullWidth,
    size: size2,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, `${variant}${capitalize(color2)}`, `size${capitalize(size2)}`, `${variant}Size${capitalize(size2)}`, color2 === "inherit" && "colorInherit", disableElevation && "disableElevation", fullWidth && "fullWidth"],
    label: ["label"],
    startIcon: ["startIcon", `iconSize${capitalize(size2)}`],
    endIcon: ["endIcon", `iconSize${capitalize(size2)}`]
  };
  const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
  return _extends$4({}, classes, composedClasses);
};
const commonIconStyles = (ownerState) => _extends$4({}, ownerState.size === "small" && {
  "& > *:nth-of-type(1)": {
    fontSize: 18
  }
}, ownerState.size === "medium" && {
  "& > *:nth-of-type(1)": {
    fontSize: 20
  }
}, ownerState.size === "large" && {
  "& > *:nth-of-type(1)": {
    fontSize: 22
  }
});
const ButtonRoot = styled(ButtonBase$1, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color)}`], styles2[`size${capitalize(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  var _theme$palette$getCon, _theme$palette;
  const inheritContainedBackgroundColor = theme2.palette.mode === "light" ? theme2.palette.grey[300] : theme2.palette.grey[800];
  const inheritContainedHoverBackgroundColor = theme2.palette.mode === "light" ? theme2.palette.grey.A100 : theme2.palette.grey[700];
  return _extends$4({}, theme2.typography.button, {
    minWidth: 64,
    padding: "6px 16px",
    borderRadius: (theme2.vars || theme2).shape.borderRadius,
    transition: theme2.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: theme2.transitions.duration.short
    }),
    "&:hover": _extends$4({
      textDecoration: "none",
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.text.primaryChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette.text.primary, theme2.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
      border: `1px solid ${(theme2.vars || theme2).palette[ownerState.color].main}`,
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "contained" && {
      backgroundColor: theme2.vars ? theme2.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
      boxShadow: (theme2.vars || theme2).shadows[4],
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        boxShadow: (theme2.vars || theme2).shadows[2],
        backgroundColor: (theme2.vars || theme2).palette.grey[300]
      }
    }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
      backgroundColor: (theme2.vars || theme2).palette[ownerState.color].dark,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: (theme2.vars || theme2).palette[ownerState.color].main
      }
    }),
    "&:active": _extends$4({}, ownerState.variant === "contained" && {
      boxShadow: (theme2.vars || theme2).shadows[8]
    }),
    [`&.${buttonClasses$1.focusVisible}`]: _extends$4({}, ownerState.variant === "contained" && {
      boxShadow: (theme2.vars || theme2).shadows[6]
    }),
    [`&.${buttonClasses$1.disabled}`]: _extends$4({
      color: (theme2.vars || theme2).palette.action.disabled
    }, ownerState.variant === "outlined" && {
      border: `1px solid ${(theme2.vars || theme2).palette.action.disabledBackground}`
    }, ownerState.variant === "contained" && {
      color: (theme2.vars || theme2).palette.action.disabled,
      boxShadow: (theme2.vars || theme2).shadows[0],
      backgroundColor: (theme2.vars || theme2).palette.action.disabledBackground
    })
  }, ownerState.variant === "text" && {
    padding: "6px 8px"
  }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
    color: (theme2.vars || theme2).palette[ownerState.color].main
  }, ownerState.variant === "outlined" && {
    padding: "5px 15px",
    border: "1px solid currentColor"
  }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
    color: (theme2.vars || theme2).palette[ownerState.color].main,
    border: theme2.vars ? `1px solid rgba(${theme2.vars.palette[ownerState.color].mainChannel} / 0.5)` : `1px solid ${alpha(theme2.palette[ownerState.color].main, 0.5)}`
  }, ownerState.variant === "contained" && {
    color: theme2.vars ? (
      // this is safe because grey does not change between default light/dark mode
      theme2.vars.palette.text.primary
    ) : (_theme$palette$getCon = (_theme$palette = theme2.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme2.palette.grey[300]),
    backgroundColor: theme2.vars ? theme2.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
    boxShadow: (theme2.vars || theme2).shadows[2]
  }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
    color: (theme2.vars || theme2).palette[ownerState.color].contrastText,
    backgroundColor: (theme2.vars || theme2).palette[ownerState.color].main
  }, ownerState.color === "inherit" && {
    color: "inherit",
    borderColor: "currentColor"
  }, ownerState.size === "small" && ownerState.variant === "text" && {
    padding: "4px 5px",
    fontSize: theme2.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "text" && {
    padding: "8px 11px",
    fontSize: theme2.typography.pxToRem(15)
  }, ownerState.size === "small" && ownerState.variant === "outlined" && {
    padding: "3px 9px",
    fontSize: theme2.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "outlined" && {
    padding: "7px 21px",
    fontSize: theme2.typography.pxToRem(15)
  }, ownerState.size === "small" && ownerState.variant === "contained" && {
    padding: "4px 10px",
    fontSize: theme2.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "contained" && {
    padding: "8px 22px",
    fontSize: theme2.typography.pxToRem(15)
  }, ownerState.fullWidth && {
    width: "100%"
  });
}, ({
  ownerState
}) => ownerState.disableElevation && {
  boxShadow: "none",
  "&:hover": {
    boxShadow: "none"
  },
  [`&.${buttonClasses$1.focusVisible}`]: {
    boxShadow: "none"
  },
  "&:active": {
    boxShadow: "none"
  },
  [`&.${buttonClasses$1.disabled}`]: {
    boxShadow: "none"
  }
});
const ButtonStartIcon = styled("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.startIcon, styles2[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends$4({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4
}, ownerState.size === "small" && {
  marginLeft: -2
}, commonIconStyles(ownerState)));
const ButtonEndIcon = styled("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.endIcon, styles2[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends$4({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8
}, ownerState.size === "small" && {
  marginRight: -2
}, commonIconStyles(ownerState)));
const Button = /* @__PURE__ */ reactExports.forwardRef(function Button2(inProps, ref2) {
  const contextProps = reactExports.useContext(ButtonGroupContext$1);
  const buttonGroupButtonContextPositionClassName = reactExports.useContext(ButtonGroupButtonContext$1);
  const resolvedProps = resolveProps(contextProps, inProps);
  const props = useThemeProps({
    props: resolvedProps,
    name: "MuiButton"
  });
  const {
    children,
    color: color2 = "primary",
    component = "button",
    className,
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    endIcon: endIconProp,
    focusVisibleClassName,
    fullWidth = false,
    size: size2 = "medium",
    startIcon: startIconProp,
    type,
    variant = "text"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$l);
  const ownerState = _extends$4({}, props, {
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    fullWidth,
    size: size2,
    type,
    variant
  });
  const classes = useUtilityClasses$i(ownerState);
  const startIcon = startIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonStartIcon, {
    className: classes.startIcon,
    ownerState,
    children: startIconProp
  });
  const endIcon = endIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonEndIcon, {
    className: classes.endIcon,
    ownerState,
    children: endIconProp
  });
  const positionClassName = buttonGroupButtonContextPositionClassName || "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonRoot, _extends$4({
    ownerState,
    className: clsx(contextProps.className, classes.root, className, positionClassName),
    component,
    disabled,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ref: ref2,
    type
  }, other, {
    classes,
    children: [startIcon, children, endIcon]
  }));
});
const Button$1 = Button;
const html = (theme2, enableColorScheme) => _extends$4({
  WebkitFontSmoothing: "antialiased",
  // Antialiasing.
  MozOsxFontSmoothing: "grayscale",
  // Antialiasing.
  // Change from `box-sizing: content-box` so that `width`
  // is not affected by `padding` or `border`.
  boxSizing: "border-box",
  // Fix font resize problem in iOS
  WebkitTextSizeAdjust: "100%"
}, enableColorScheme && !theme2.vars && {
  colorScheme: theme2.palette.mode
});
const body = (theme2) => _extends$4({
  color: (theme2.vars || theme2).palette.text.primary
}, theme2.typography.body1, {
  backgroundColor: (theme2.vars || theme2).palette.background.default,
  "@media print": {
    // Save printer ink.
    backgroundColor: (theme2.vars || theme2).palette.common.white
  }
});
const styles$1b = (theme2, enableColorScheme = false) => {
  var _theme$components;
  const colorSchemeStyles = {};
  if (enableColorScheme && theme2.colorSchemes) {
    Object.entries(theme2.colorSchemes).forEach(([key2, scheme]) => {
      var _scheme$palette;
      colorSchemeStyles[theme2.getColorSchemeSelector(key2).replace(/\s*&/, "")] = {
        colorScheme: (_scheme$palette = scheme.palette) == null ? void 0 : _scheme$palette.mode
      };
    });
  }
  let defaultStyles = _extends$4({
    html: html(theme2, enableColorScheme),
    "*, *::before, *::after": {
      boxSizing: "inherit"
    },
    "strong, b": {
      fontWeight: theme2.typography.fontWeightBold
    },
    body: _extends$4({
      margin: 0
    }, body(theme2), {
      // Add support for document.body.requestFullScreen().
      // Other elements, if background transparent, are not supported.
      "&::backdrop": {
        backgroundColor: (theme2.vars || theme2).palette.background.default
      }
    })
  }, colorSchemeStyles);
  const themeOverrides = (_theme$components = theme2.components) == null || (_theme$components = _theme$components.MuiCssBaseline) == null ? void 0 : _theme$components.styleOverrides;
  if (themeOverrides) {
    defaultStyles = [defaultStyles, themeOverrides];
  }
  return defaultStyles;
};
function CssBaseline(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiCssBaseline"
  });
  const {
    children,
    enableColorScheme = false
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
      styles: (theme2) => styles$1b(theme2, enableColorScheme)
    }), children]
  });
}
function getModalUtilityClass(slot) {
  return generateUtilityClass("MuiModal", slot);
}
generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
const _excluded$k = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onTransitionEnter", "onTransitionExited", "open", "slotProps", "slots", "theme"];
const useUtilityClasses$h = (ownerState) => {
  const {
    open,
    exited,
    classes
  } = ownerState;
  const slots = {
    root: ["root", !open && exited && "hidden"],
    backdrop: ["backdrop"]
  };
  return composeClasses(slots, getModalUtilityClass, classes);
};
const ModalRoot = styled("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  position: "fixed",
  zIndex: (theme2.vars || theme2).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0
}, !ownerState.open && ownerState.exited && {
  visibility: "hidden"
}));
const ModalBackdrop = styled(Backdrop$1, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (props, styles2) => {
    return styles2.backdrop;
  }
})({
  zIndex: -1
});
const Modal = /* @__PURE__ */ reactExports.forwardRef(function Modal2(inProps, ref2) {
  var _ref, _slots$root, _ref2, _slots$backdrop, _slotProps$root, _slotProps$backdrop;
  const props = useThemeProps({
    name: "MuiModal",
    props: inProps
  });
  const {
    BackdropComponent = ModalBackdrop,
    BackdropProps,
    className,
    closeAfterTransition = false,
    children,
    container,
    component,
    components = {},
    componentsProps = {},
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    onBackdropClick,
    open,
    slotProps,
    slots
    // eslint-disable-next-line react/prop-types
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$k);
  const propsWithDefaults = _extends$4({}, props, {
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    hideBackdrop,
    keepMounted
  });
  const {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    portalRef,
    isTopModal,
    exited,
    hasTransition
  } = useModal(_extends$4({}, propsWithDefaults, {
    rootRef: ref2
  }));
  const ownerState = _extends$4({}, propsWithDefaults, {
    exited
  });
  const classes = useUtilityClasses$h(ownerState);
  const childProps = {};
  if (children.props.tabIndex === void 0) {
    childProps.tabIndex = "-1";
  }
  if (hasTransition) {
    const {
      onEnter,
      onExited
    } = getTransitionProps2();
    childProps.onEnter = onEnter;
    childProps.onExited = onExited;
  }
  const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : ModalRoot;
  const BackdropSlot = (_ref2 = (_slots$backdrop = slots == null ? void 0 : slots.backdrop) != null ? _slots$backdrop : components.Backdrop) != null ? _ref2 : BackdropComponent;
  const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
  const backdropSlotProps = (_slotProps$backdrop = slotProps == null ? void 0 : slotProps.backdrop) != null ? _slotProps$backdrop : componentsProps.backdrop;
  const rootProps = useSlotProps({
    elementType: RootSlot,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    getSlotProps: getRootProps,
    additionalProps: {
      ref: ref2,
      as: component
    },
    ownerState,
    className: clsx(className, rootSlotProps == null ? void 0 : rootSlotProps.className, classes == null ? void 0 : classes.root, !ownerState.open && ownerState.exited && (classes == null ? void 0 : classes.hidden))
  });
  const backdropProps = useSlotProps({
    elementType: BackdropSlot,
    externalSlotProps: backdropSlotProps,
    additionalProps: BackdropProps,
    getSlotProps: (otherHandlers) => {
      return getBackdropProps(_extends$4({}, otherHandlers, {
        onClick: (e2) => {
          if (onBackdropClick) {
            onBackdropClick(e2);
          }
          if (otherHandlers != null && otherHandlers.onClick) {
            otherHandlers.onClick(e2);
          }
        }
      }));
    },
    className: clsx(backdropSlotProps == null ? void 0 : backdropSlotProps.className, BackdropProps == null ? void 0 : BackdropProps.className, classes == null ? void 0 : classes.backdrop),
    ownerState
  });
  if (!keepMounted && !open && (!hasTransition || exited)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    ref: portalRef,
    container,
    disablePortal,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends$4({}, rootProps, {
      children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropSlot, _extends$4({}, backdropProps)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
        disableEnforceFocus,
        disableAutoFocus,
        disableRestoreFocus,
        isEnabled: isTopModal,
        open,
        children: /* @__PURE__ */ reactExports.cloneElement(children, childProps)
      })]
    }))
  });
});
const Modal$1 = Modal;
const dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
const dividerClasses$1 = dividerClasses;
const _excluded$j = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"];
const useUtilityClasses$g = (ownerState) => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes);
  return _extends$4({}, classes, composedClasses);
};
const FilledInputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  var _palette;
  const light2 = theme2.palette.mode === "light";
  const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
  const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
  const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return _extends$4({
    position: "relative",
    backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2,
    borderTopLeftRadius: (theme2.vars || theme2).shape.borderRadius,
    borderTopRightRadius: (theme2.vars || theme2).shape.borderRadius,
    transition: theme2.transitions.create("background-color", {
      duration: theme2.transitions.duration.shorter,
      easing: theme2.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.hoverBg : hoverBackground,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2
      }
    },
    [`&.${filledInputClasses$1.focused}`]: {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2
    },
    [`&.${filledInputClasses$1.disabled}`]: {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.disabledBg : disabledBackground
    }
  }, !ownerState.disableUnderline && {
    "&::after": {
      borderBottom: `2px solid ${(_palette = (theme2.vars || theme2).palette[ownerState.color || "primary"]) == null ? void 0 : _palette.main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: theme2.transitions.create("transform", {
        duration: theme2.transitions.duration.shorter,
        easing: theme2.transitions.easing.easeOut
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&.${filledInputClasses$1.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${filledInputClasses$1.error}`]: {
      "&::before, &::after": {
        borderBottomColor: (theme2.vars || theme2).palette.error.main
      }
    },
    "&::before": {
      borderBottom: `1px solid ${theme2.vars ? `rgba(${theme2.vars.palette.common.onBackgroundChannel} / ${theme2.vars.opacity.inputUnderline})` : bottomLineColor}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: theme2.transitions.create("border-bottom-color", {
        duration: theme2.transitions.duration.shorter
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&:hover:not(.${filledInputClasses$1.disabled}, .${filledInputClasses$1.error}):before`]: {
      borderBottom: `1px solid ${(theme2.vars || theme2).palette.text.primary}`
    },
    [`&.${filledInputClasses$1.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  }, ownerState.startAdornment && {
    paddingLeft: 12
  }, ownerState.endAdornment && {
    paddingRight: 12
  }, ownerState.multiline && _extends$4({
    padding: "25px 12px 8px"
  }, ownerState.size === "small" && {
    paddingTop: 21,
    paddingBottom: 4
  }, ownerState.hiddenLabel && {
    paddingTop: 16,
    paddingBottom: 17
  }, ownerState.hiddenLabel && ownerState.size === "small" && {
    paddingTop: 8,
    paddingBottom: 9
  }));
});
const FilledInputInput = styled(InputBaseComponent, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12
}, !theme2.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: theme2.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: theme2.palette.mode === "light" ? null : "#fff",
    caretColor: theme2.palette.mode === "light" ? null : "#fff",
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  }
}, theme2.vars && {
  "&:-webkit-autofill": {
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  },
  [theme2.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, ownerState.size === "small" && {
  paddingTop: 21,
  paddingBottom: 4
}, ownerState.hiddenLabel && {
  paddingTop: 16,
  paddingBottom: 17
}, ownerState.startAdornment && {
  paddingLeft: 0
}, ownerState.endAdornment && {
  paddingRight: 0
}, ownerState.hiddenLabel && ownerState.size === "small" && {
  paddingTop: 8,
  paddingBottom: 9
}, ownerState.multiline && {
  paddingTop: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  paddingRight: 0
}));
const FilledInput = /* @__PURE__ */ reactExports.forwardRef(function FilledInput2(inProps, ref2) {
  var _ref, _slots$root, _ref2, _slots$input;
  const props = useThemeProps({
    props: inProps,
    name: "MuiFilledInput"
  });
  const {
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    // declare here to prevent spreading to DOM
    inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type = "text"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$j);
  const ownerState = _extends$4({}, props, {
    fullWidth,
    inputComponent,
    multiline,
    type
  });
  const classes = useUtilityClasses$g(props);
  const filledInputComponentsProps = {
    root: {
      ownerState
    },
    input: {
      ownerState
    }
  };
  const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(filledInputComponentsProps, slotProps != null ? slotProps : componentsPropsProp) : filledInputComponentsProps;
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : FilledInputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : FilledInputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$4({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref: ref2,
    type
  }, other, {
    classes
  }));
});
FilledInput.muiName = "Input";
const FilledInput$1 = FilledInput;
function getFormControlUtilityClasses(slot) {
  return generateUtilityClass("MuiFormControl", slot);
}
generateUtilityClasses("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const _excluded$i = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"];
const useUtilityClasses$f = (ownerState) => {
  const {
    classes,
    margin: margin2,
    fullWidth
  } = ownerState;
  const slots = {
    root: ["root", margin2 !== "none" && `margin${capitalize(margin2)}`, fullWidth && "fullWidth"]
  };
  return composeClasses(slots, getFormControlUtilityClasses, classes);
};
const FormControlRoot = styled("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: ({
    ownerState
  }, styles2) => {
    return _extends$4({}, styles2.root, styles2[`margin${capitalize(ownerState.margin)}`], ownerState.fullWidth && styles2.fullWidth);
  }
})(({
  ownerState
}) => _extends$4({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top"
}, ownerState.margin === "normal" && {
  marginTop: 16,
  marginBottom: 8
}, ownerState.margin === "dense" && {
  marginTop: 8,
  marginBottom: 4
}, ownerState.fullWidth && {
  width: "100%"
}));
const FormControl = /* @__PURE__ */ reactExports.forwardRef(function FormControl2(inProps, ref2) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiFormControl"
  });
  const {
    children,
    className,
    color: color2 = "primary",
    component = "div",
    disabled = false,
    error = false,
    focused: visuallyFocused,
    fullWidth = false,
    hiddenLabel = false,
    margin: margin2 = "none",
    required = false,
    size: size2 = "medium",
    variant = "outlined"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$i);
  const ownerState = _extends$4({}, props, {
    color: color2,
    component,
    disabled,
    error,
    fullWidth,
    hiddenLabel,
    margin: margin2,
    required,
    size: size2,
    variant
  });
  const classes = useUtilityClasses$f(ownerState);
  const [adornedStart, setAdornedStart] = reactExports.useState(() => {
    let initialAdornedStart = false;
    if (children) {
      reactExports.Children.forEach(children, (child) => {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        const input = isMuiElement(child, ["Select"]) ? child.props.input : child;
        if (input && isAdornedStart(input.props)) {
          initialAdornedStart = true;
        }
      });
    }
    return initialAdornedStart;
  });
  const [filled, setFilled] = reactExports.useState(() => {
    let initialFilled = false;
    if (children) {
      reactExports.Children.forEach(children, (child) => {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        if (isFilled(child.props, true) || isFilled(child.props.inputProps, true)) {
          initialFilled = true;
        }
      });
    }
    return initialFilled;
  });
  const [focusedState, setFocused] = reactExports.useState(false);
  if (disabled && focusedState) {
    setFocused(false);
  }
  const focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState;
  let registerEffect;
  const childContext = reactExports.useMemo(() => {
    return {
      adornedStart,
      setAdornedStart,
      color: color2,
      disabled,
      error,
      filled,
      focused,
      fullWidth,
      hiddenLabel,
      size: size2,
      onBlur: () => {
        setFocused(false);
      },
      onEmpty: () => {
        setFilled(false);
      },
      onFilled: () => {
        setFilled(true);
      },
      onFocus: () => {
        setFocused(true);
      },
      registerEffect,
      required,
      variant
    };
  }, [adornedStart, color2, disabled, error, filled, focused, fullWidth, hiddenLabel, registerEffect, required, size2, variant]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlRoot, _extends$4({
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref: ref2
    }, other, {
      children
    }))
  });
});
const FormControl$1 = FormControl;
const Stack = createStack({
  createStyledComponent: styled("div", {
    name: "MuiStack",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  }),
  useThemeProps: (inProps) => useThemeProps({
    props: inProps,
    name: "MuiStack"
  })
});
const Stack$1 = Stack;
function getFormHelperTextUtilityClasses(slot) {
  return generateUtilityClass("MuiFormHelperText", slot);
}
const formHelperTextClasses = generateUtilityClasses("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
const formHelperTextClasses$1 = formHelperTextClasses;
var _span$2;
const _excluded$h = ["children", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"];
const useUtilityClasses$e = (ownerState) => {
  const {
    classes,
    contained,
    size: size2,
    disabled,
    error,
    filled,
    focused,
    required
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", error && "error", size2 && `size${capitalize(size2)}`, contained && "contained", focused && "focused", filled && "filled", required && "required"]
  };
  return composeClasses(slots, getFormHelperTextUtilityClasses, classes);
};
const FormHelperTextRoot = styled("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.size && styles2[`size${capitalize(ownerState.size)}`], ownerState.contained && styles2.contained, ownerState.filled && styles2.filled];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  color: (theme2.vars || theme2).palette.text.secondary
}, theme2.typography.caption, {
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${formHelperTextClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled
  },
  [`&.${formHelperTextClasses$1.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
}, ownerState.size === "small" && {
  marginTop: 4
}, ownerState.contained && {
  marginLeft: 14,
  marginRight: 14
}));
const FormHelperText = /* @__PURE__ */ reactExports.forwardRef(function FormHelperText2(inProps, ref2) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiFormHelperText"
  });
  const {
    children,
    className,
    component = "p"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$h);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  });
  const ownerState = _extends$4({}, props, {
    component,
    contained: fcs.variant === "filled" || fcs.variant === "outlined",
    variant: fcs.variant,
    size: fcs.size,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  });
  const classes = useUtilityClasses$e(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperTextRoot, _extends$4({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref: ref2
  }, other, {
    children: children === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      _span$2 || (_span$2 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: "notranslate",
        children: ""
      }))
    ) : children
  }));
});
const FormHelperText$1 = FormHelperText;
function getFormLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiFormLabel", slot);
}
const formLabelClasses = generateUtilityClasses("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]);
const formLabelClasses$1 = formLabelClasses;
const _excluded$g = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"];
const useUtilityClasses$d = (ownerState) => {
  const {
    classes,
    color: color2,
    focused,
    disabled,
    error,
    filled,
    required
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", filled && "filled", focused && "focused", required && "required"],
    asterisk: ["asterisk", error && "error"]
  };
  return composeClasses(slots, getFormLabelUtilityClasses, classes);
};
const FormLabelRoot = styled("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: ({
    ownerState
  }, styles2) => {
    return _extends$4({}, styles2.root, ownerState.color === "secondary" && styles2.colorSecondary, ownerState.filled && styles2.filled);
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  color: (theme2.vars || theme2).palette.text.secondary
}, theme2.typography.body1, {
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  [`&.${formLabelClasses$1.focused}`]: {
    color: (theme2.vars || theme2).palette[ownerState.color].main
  },
  [`&.${formLabelClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled
  },
  [`&.${formLabelClasses$1.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
}));
const AsteriskComponent = styled("span", {
  name: "MuiFormLabel",
  slot: "Asterisk",
  overridesResolver: (props, styles2) => styles2.asterisk
})(({
  theme: theme2
}) => ({
  [`&.${formLabelClasses$1.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
}));
const FormLabel = /* @__PURE__ */ reactExports.forwardRef(function FormLabel2(inProps, ref2) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiFormLabel"
  });
  const {
    children,
    className,
    component = "label"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$g);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  });
  const ownerState = _extends$4({}, props, {
    color: fcs.color || "primary",
    component,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  });
  const classes = useUtilityClasses$d(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormLabelRoot, _extends$4({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref: ref2
  }, other, {
    children: [children, fcs.required && /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent, {
      ownerState,
      "aria-hidden": true,
      className: classes.asterisk,
      children: ["", "*"]
    })]
  }));
});
const FormLabel$1 = FormLabel;
const GridContext = /* @__PURE__ */ reactExports.createContext();
const GridContext$1 = GridContext;
function getGridUtilityClass(slot) {
  return generateUtilityClass("MuiGrid", slot);
}
const SPACINGS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const DIRECTIONS = ["column-reverse", "column", "row-reverse", "row"];
const WRAPS = ["nowrap", "wrap-reverse", "wrap"];
const GRID_SIZES = ["auto", true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
const gridClasses = generateUtilityClasses("MuiGrid", [
  "root",
  "container",
  "item",
  "zeroMinWidth",
  // spacings
  ...SPACINGS.map((spacing) => `spacing-xs-${spacing}`),
  // direction values
  ...DIRECTIONS.map((direction) => `direction-xs-${direction}`),
  // wrap values
  ...WRAPS.map((wrap2) => `wrap-xs-${wrap2}`),
  // grid sizes for all breakpoints
  ...GRID_SIZES.map((size2) => `grid-xs-${size2}`),
  ...GRID_SIZES.map((size2) => `grid-sm-${size2}`),
  ...GRID_SIZES.map((size2) => `grid-md-${size2}`),
  ...GRID_SIZES.map((size2) => `grid-lg-${size2}`),
  ...GRID_SIZES.map((size2) => `grid-xl-${size2}`)
]);
const _excluded$f = ["className", "columns", "columnSpacing", "component", "container", "direction", "item", "rowSpacing", "spacing", "wrap", "zeroMinWidth"];
function getOffset(val) {
  const parse2 = parseFloat(val);
  return `${parse2}${String(val).replace(String(parse2), "") || "px"}`;
}
function generateGrid({
  theme: theme2,
  ownerState
}) {
  let size2;
  return theme2.breakpoints.keys.reduce((globalStyles, breakpoint) => {
    let styles2 = {};
    if (ownerState[breakpoint]) {
      size2 = ownerState[breakpoint];
    }
    if (!size2) {
      return globalStyles;
    }
    if (size2 === true) {
      styles2 = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: "100%"
      };
    } else if (size2 === "auto") {
      styles2 = {
        flexBasis: "auto",
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: "none",
        width: "auto"
      };
    } else {
      const columnsBreakpointValues = resolveBreakpointValues({
        values: ownerState.columns,
        breakpoints: theme2.breakpoints.values
      });
      const columnValue = typeof columnsBreakpointValues === "object" ? columnsBreakpointValues[breakpoint] : columnsBreakpointValues;
      if (columnValue === void 0 || columnValue === null) {
        return globalStyles;
      }
      const width2 = `${Math.round(size2 / columnValue * 1e8) / 1e6}%`;
      let more = {};
      if (ownerState.container && ownerState.item && ownerState.columnSpacing !== 0) {
        const themeSpacing = theme2.spacing(ownerState.columnSpacing);
        if (themeSpacing !== "0px") {
          const fullWidth = `calc(${width2} + ${getOffset(themeSpacing)})`;
          more = {
            flexBasis: fullWidth,
            maxWidth: fullWidth
          };
        }
      }
      styles2 = _extends$4({
        flexBasis: width2,
        flexGrow: 0,
        maxWidth: width2
      }, more);
    }
    if (theme2.breakpoints.values[breakpoint] === 0) {
      Object.assign(globalStyles, styles2);
    } else {
      globalStyles[theme2.breakpoints.up(breakpoint)] = styles2;
    }
    return globalStyles;
  }, {});
}
function generateDirection({
  theme: theme2,
  ownerState
}) {
  const directionValues = resolveBreakpointValues({
    values: ownerState.direction,
    breakpoints: theme2.breakpoints.values
  });
  return handleBreakpoints({
    theme: theme2
  }, directionValues, (propValue) => {
    const output2 = {
      flexDirection: propValue
    };
    if (propValue.indexOf("column") === 0) {
      output2[`& > .${gridClasses.item}`] = {
        maxWidth: "none"
      };
    }
    return output2;
  });
}
function extractZeroValueBreakpointKeys({
  breakpoints,
  values: values2
}) {
  let nonZeroKey = "";
  Object.keys(values2).forEach((key2) => {
    if (nonZeroKey !== "") {
      return;
    }
    if (values2[key2] !== 0) {
      nonZeroKey = key2;
    }
  });
  const sortedBreakpointKeysByValue = Object.keys(breakpoints).sort((a2, b3) => {
    return breakpoints[a2] - breakpoints[b3];
  });
  return sortedBreakpointKeysByValue.slice(0, sortedBreakpointKeysByValue.indexOf(nonZeroKey));
}
function generateRowGap({
  theme: theme2,
  ownerState
}) {
  const {
    container,
    rowSpacing
  } = ownerState;
  let styles2 = {};
  if (container && rowSpacing !== 0) {
    const rowSpacingValues = resolveBreakpointValues({
      values: rowSpacing,
      breakpoints: theme2.breakpoints.values
    });
    let zeroValueBreakpointKeys;
    if (typeof rowSpacingValues === "object") {
      zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
        breakpoints: theme2.breakpoints.values,
        values: rowSpacingValues
      });
    }
    styles2 = handleBreakpoints({
      theme: theme2
    }, rowSpacingValues, (propValue, breakpoint) => {
      var _zeroValueBreakpointK;
      const themeSpacing = theme2.spacing(propValue);
      if (themeSpacing !== "0px") {
        return {
          marginTop: `-${getOffset(themeSpacing)}`,
          [`& > .${gridClasses.item}`]: {
            paddingTop: getOffset(themeSpacing)
          }
        };
      }
      if ((_zeroValueBreakpointK = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK.includes(breakpoint)) {
        return {};
      }
      return {
        marginTop: 0,
        [`& > .${gridClasses.item}`]: {
          paddingTop: 0
        }
      };
    });
  }
  return styles2;
}
function generateColumnGap({
  theme: theme2,
  ownerState
}) {
  const {
    container,
    columnSpacing
  } = ownerState;
  let styles2 = {};
  if (container && columnSpacing !== 0) {
    const columnSpacingValues = resolveBreakpointValues({
      values: columnSpacing,
      breakpoints: theme2.breakpoints.values
    });
    let zeroValueBreakpointKeys;
    if (typeof columnSpacingValues === "object") {
      zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
        breakpoints: theme2.breakpoints.values,
        values: columnSpacingValues
      });
    }
    styles2 = handleBreakpoints({
      theme: theme2
    }, columnSpacingValues, (propValue, breakpoint) => {
      var _zeroValueBreakpointK2;
      const themeSpacing = theme2.spacing(propValue);
      if (themeSpacing !== "0px") {
        return {
          width: `calc(100% + ${getOffset(themeSpacing)})`,
          marginLeft: `-${getOffset(themeSpacing)}`,
          [`& > .${gridClasses.item}`]: {
            paddingLeft: getOffset(themeSpacing)
          }
        };
      }
      if ((_zeroValueBreakpointK2 = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK2.includes(breakpoint)) {
        return {};
      }
      return {
        width: "100%",
        marginLeft: 0,
        [`& > .${gridClasses.item}`]: {
          paddingLeft: 0
        }
      };
    });
  }
  return styles2;
}
function resolveSpacingStyles(spacing, breakpoints, styles2 = {}) {
  if (!spacing || spacing <= 0) {
    return [];
  }
  if (typeof spacing === "string" && !Number.isNaN(Number(spacing)) || typeof spacing === "number") {
    return [styles2[`spacing-xs-${String(spacing)}`]];
  }
  const spacingStyles = [];
  breakpoints.forEach((breakpoint) => {
    const value = spacing[breakpoint];
    if (Number(value) > 0) {
      spacingStyles.push(styles2[`spacing-${breakpoint}-${String(value)}`]);
    }
  });
  return spacingStyles;
}
const GridRoot = styled("div", {
  name: "MuiGrid",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      container,
      direction,
      item,
      spacing,
      wrap: wrap2,
      zeroMinWidth,
      breakpoints
    } = ownerState;
    let spacingStyles = [];
    if (container) {
      spacingStyles = resolveSpacingStyles(spacing, breakpoints, styles2);
    }
    const breakpointsStyles = [];
    breakpoints.forEach((breakpoint) => {
      const value = ownerState[breakpoint];
      if (value) {
        breakpointsStyles.push(styles2[`grid-${breakpoint}-${String(value)}`]);
      }
    });
    return [styles2.root, container && styles2.container, item && styles2.item, zeroMinWidth && styles2.zeroMinWidth, ...spacingStyles, direction !== "row" && styles2[`direction-xs-${String(direction)}`], wrap2 !== "wrap" && styles2[`wrap-xs-${String(wrap2)}`], ...breakpointsStyles];
  }
})(({
  ownerState
}) => _extends$4({
  boxSizing: "border-box"
}, ownerState.container && {
  display: "flex",
  flexWrap: "wrap",
  width: "100%"
}, ownerState.item && {
  margin: 0
  // For instance, it's useful when used with a `figure` element.
}, ownerState.zeroMinWidth && {
  minWidth: 0
}, ownerState.wrap !== "wrap" && {
  flexWrap: ownerState.wrap
}), generateDirection, generateRowGap, generateColumnGap, generateGrid);
function resolveSpacingClasses(spacing, breakpoints) {
  if (!spacing || spacing <= 0) {
    return [];
  }
  if (typeof spacing === "string" && !Number.isNaN(Number(spacing)) || typeof spacing === "number") {
    return [`spacing-xs-${String(spacing)}`];
  }
  const classes = [];
  breakpoints.forEach((breakpoint) => {
    const value = spacing[breakpoint];
    if (Number(value) > 0) {
      const className = `spacing-${breakpoint}-${String(value)}`;
      classes.push(className);
    }
  });
  return classes;
}
const useUtilityClasses$c = (ownerState) => {
  const {
    classes,
    container,
    direction,
    item,
    spacing,
    wrap: wrap2,
    zeroMinWidth,
    breakpoints
  } = ownerState;
  let spacingClasses = [];
  if (container) {
    spacingClasses = resolveSpacingClasses(spacing, breakpoints);
  }
  const breakpointsClasses = [];
  breakpoints.forEach((breakpoint) => {
    const value = ownerState[breakpoint];
    if (value) {
      breakpointsClasses.push(`grid-${breakpoint}-${String(value)}`);
    }
  });
  const slots = {
    root: ["root", container && "container", item && "item", zeroMinWidth && "zeroMinWidth", ...spacingClasses, direction !== "row" && `direction-xs-${String(direction)}`, wrap2 !== "wrap" && `wrap-xs-${String(wrap2)}`, ...breakpointsClasses]
  };
  return composeClasses(slots, getGridUtilityClass, classes);
};
const Grid = /* @__PURE__ */ reactExports.forwardRef(function Grid2(inProps, ref2) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiGrid"
  });
  const {
    breakpoints
  } = useTheme();
  const props = extendSxProp(themeProps);
  const {
    className,
    columns: columnsProp,
    columnSpacing: columnSpacingProp,
    component = "div",
    container = false,
    direction = "row",
    item = false,
    rowSpacing: rowSpacingProp,
    spacing = 0,
    wrap: wrap2 = "wrap",
    zeroMinWidth = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$f);
  const rowSpacing = rowSpacingProp || spacing;
  const columnSpacing = columnSpacingProp || spacing;
  const columnsContext = reactExports.useContext(GridContext$1);
  const columns = container ? columnsProp || 12 : columnsContext;
  const breakpointsValues = {};
  const otherFiltered = _extends$4({}, other);
  breakpoints.keys.forEach((breakpoint) => {
    if (other[breakpoint] != null) {
      breakpointsValues[breakpoint] = other[breakpoint];
      delete otherFiltered[breakpoint];
    }
  });
  const ownerState = _extends$4({}, props, {
    columns,
    container,
    direction,
    item,
    rowSpacing,
    columnSpacing,
    wrap: wrap2,
    zeroMinWidth,
    spacing
  }, breakpointsValues, {
    breakpoints: breakpoints.keys
  });
  const classes = useUtilityClasses$c(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridContext$1.Provider, {
    value: columns,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridRoot, _extends$4({
      ownerState,
      className: clsx(classes.root, className),
      as: component,
      ref: ref2
    }, otherFiltered))
  });
});
const Grid$1 = Grid;
const _excluded$e = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function getScale(value) {
  return `scale(${value}, ${value ** 2})`;
}
const styles$1a = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
};
const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
const Grow = /* @__PURE__ */ reactExports.forwardRef(function Grow2(props, ref2) {
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition$1
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$e);
  const timer2 = reactExports.useRef();
  const autoTimeout = reactExports.useRef();
  const theme2 = useTheme();
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, children.ref, ref2);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const {
      duration: transitionDuration,
      delay: delay2,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme2.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme2.transitions.create("opacity", {
      duration: duration2,
      delay: delay2
    }), theme2.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: delay2,
      easing: transitionTimingFunction
    })].join(",");
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const {
      duration: transitionDuration,
      delay: delay2,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme2.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme2.transitions.create("opacity", {
      duration: duration2,
      delay: delay2
    }), theme2.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: isWebKit154 ? delay2 : delay2 || duration2 * 0.333,
      easing: transitionTimingFunction
    })].join(",");
    node2.style.opacity = 0;
    node2.style.transform = getScale(0.75);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (timeout === "auto") {
      timer2.current = setTimeout(next2, autoTimeout.current || 0);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  reactExports.useEffect(() => {
    return () => {
      clearTimeout(timer2.current);
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$4({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout === "auto" ? null : timeout
  }, other, {
    children: (state2, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends$4({
        style: _extends$4({
          opacity: 0,
          transform: getScale(0.75),
          visibility: state2 === "exited" && !inProp ? "hidden" : void 0
        }, styles$1a[state2], style2, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
});
Grow.muiSupportAuto = true;
const Grow$1 = Grow;
const _excluded$d = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"];
const useUtilityClasses$b = (ownerState) => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getInputUtilityClass, classes);
  return _extends$4({}, classes, composedClasses);
};
const InputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  const light2 = theme2.palette.mode === "light";
  let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  if (theme2.vars) {
    bottomLineColor = `rgba(${theme2.vars.palette.common.onBackgroundChannel} / ${theme2.vars.opacity.inputUnderline})`;
  }
  return _extends$4({
    position: "relative"
  }, ownerState.formControl && {
    "label + &": {
      marginTop: 16
    }
  }, !ownerState.disableUnderline && {
    "&::after": {
      borderBottom: `2px solid ${(theme2.vars || theme2).palette[ownerState.color].main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: theme2.transitions.create("transform", {
        duration: theme2.transitions.duration.shorter,
        easing: theme2.transitions.easing.easeOut
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&.${inputClasses$1.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${inputClasses$1.error}`]: {
      "&::before, &::after": {
        borderBottomColor: (theme2.vars || theme2).palette.error.main
      }
    },
    "&::before": {
      borderBottom: `1px solid ${bottomLineColor}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: theme2.transitions.create("border-bottom-color", {
        duration: theme2.transitions.duration.shorter
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&:hover:not(.${inputClasses$1.disabled}, .${inputClasses$1.error}):before`]: {
      borderBottom: `2px solid ${(theme2.vars || theme2).palette.text.primary}`,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        borderBottom: `1px solid ${bottomLineColor}`
      }
    },
    [`&.${inputClasses$1.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  });
});
const InputInput = styled(InputBaseComponent, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})({});
const Input = /* @__PURE__ */ reactExports.forwardRef(function Input2(inProps, ref2) {
  var _ref, _slots$root, _ref2, _slots$input;
  const props = useThemeProps({
    props: inProps,
    name: "MuiInput"
  });
  const {
    disableUnderline,
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type = "text"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$d);
  const classes = useUtilityClasses$b(props);
  const ownerState = {
    disableUnderline
  };
  const inputComponentsProps = {
    root: {
      ownerState
    }
  };
  const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, inputComponentsProps) : inputComponentsProps;
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : InputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : InputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$4({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    slotProps: componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref: ref2,
    type
  }, other, {
    classes
  }));
});
Input.muiName = "Input";
const Input$1 = Input;
function getInputLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiInputLabel", slot);
}
generateUtilityClasses("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const _excluded$c = ["disableAnimation", "margin", "shrink", "variant", "className"];
const useUtilityClasses$a = (ownerState) => {
  const {
    classes,
    formControl,
    size: size2,
    shrink,
    disableAnimation,
    variant,
    required
  } = ownerState;
  const slots = {
    root: ["root", formControl && "formControl", !disableAnimation && "animated", shrink && "shrink", size2 && size2 !== "normal" && `size${capitalize(size2)}`, variant],
    asterisk: [required && "asterisk"]
  };
  const composedClasses = composeClasses(slots, getInputLabelUtilityClasses, classes);
  return _extends$4({}, classes, composedClasses);
};
const InputLabelRoot = styled(FormLabel$1, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${formLabelClasses$1.asterisk}`]: styles2.asterisk
    }, styles2.root, ownerState.formControl && styles2.formControl, ownerState.size === "small" && styles2.sizeSmall, ownerState.shrink && styles2.shrink, !ownerState.disableAnimation && styles2.animated, ownerState.focused && styles2.focused, styles2[ownerState.variant]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%"
}, ownerState.formControl && {
  position: "absolute",
  left: 0,
  top: 0,
  // slight alteration to spec spacing to match visual spec result
  transform: "translate(0, 20px) scale(1)"
}, ownerState.size === "small" && {
  // Compensation for the `Input.inputSizeSmall` style.
  transform: "translate(0, 17px) scale(1)"
}, ownerState.shrink && {
  transform: "translate(0, -1.5px) scale(0.75)",
  transformOrigin: "top left",
  maxWidth: "133%"
}, !ownerState.disableAnimation && {
  transition: theme2.transitions.create(["color", "transform", "max-width"], {
    duration: theme2.transitions.duration.shorter,
    easing: theme2.transitions.easing.easeOut
  })
}, ownerState.variant === "filled" && _extends$4({
  // Chrome's autofill feature gives the input field a yellow background.
  // Since the input field is behind the label in the HTML tree,
  // the input field is drawn last and hides the label with an opaque background color.
  // zIndex: 1 will raise the label above opaque background-colors of input.
  zIndex: 1,
  pointerEvents: "none",
  transform: "translate(12px, 16px) scale(1)",
  maxWidth: "calc(100% - 24px)"
}, ownerState.size === "small" && {
  transform: "translate(12px, 13px) scale(1)"
}, ownerState.shrink && _extends$4({
  userSelect: "none",
  pointerEvents: "auto",
  transform: "translate(12px, 7px) scale(0.75)",
  maxWidth: "calc(133% - 24px)"
}, ownerState.size === "small" && {
  transform: "translate(12px, 4px) scale(0.75)"
})), ownerState.variant === "outlined" && _extends$4({
  // see comment above on filled.zIndex
  zIndex: 1,
  pointerEvents: "none",
  transform: "translate(14px, 16px) scale(1)",
  maxWidth: "calc(100% - 24px)"
}, ownerState.size === "small" && {
  transform: "translate(14px, 9px) scale(1)"
}, ownerState.shrink && {
  userSelect: "none",
  pointerEvents: "auto",
  // Theoretically, we should have (8+5)*2/0.75 = 34px
  // but it feels a better when it bleeds a bit on the left, so 32px.
  maxWidth: "calc(133% - 32px)",
  transform: "translate(14px, -9px) scale(0.75)"
})));
const InputLabel = /* @__PURE__ */ reactExports.forwardRef(function InputLabel2(inProps, ref2) {
  const props = useThemeProps({
    name: "MuiInputLabel",
    props: inProps
  });
  const {
    disableAnimation = false,
    shrink: shrinkProp,
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$c);
  const muiFormControl = useFormControl();
  let shrink = shrinkProp;
  if (typeof shrink === "undefined" && muiFormControl) {
    shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
  }
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["size", "variant", "required", "focused"]
  });
  const ownerState = _extends$4({}, props, {
    disableAnimation,
    formControl: muiFormControl,
    shrink,
    size: fcs.size,
    variant: fcs.variant,
    required: fcs.required,
    focused: fcs.focused
  });
  const classes = useUtilityClasses$a(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabelRoot, _extends$4({
    "data-shrink": shrink,
    ownerState,
    ref: ref2,
    className: clsx(classes.root, className)
  }, other, {
    classes
  }));
});
const InputLabel$1 = InputLabel;
function getLinkUtilityClass(slot) {
  return generateUtilityClass("MuiLink", slot);
}
const linkClasses = generateUtilityClasses("MuiLink", ["root", "underlineNone", "underlineHover", "underlineAlways", "button", "focusVisible"]);
const linkClasses$1 = linkClasses;
const colorTransformations = {
  primary: "primary.main",
  textPrimary: "text.primary",
  secondary: "secondary.main",
  textSecondary: "text.secondary",
  error: "error.main"
};
const transformDeprecatedColors = (color2) => {
  return colorTransformations[color2] || color2;
};
const getTextDecoration = ({
  theme: theme2,
  ownerState
}) => {
  const transformedColor = transformDeprecatedColors(ownerState.color);
  const color2 = getPath(theme2, `palette.${transformedColor}`, false) || ownerState.color;
  const channelColor = getPath(theme2, `palette.${transformedColor}Channel`);
  if ("vars" in theme2 && channelColor) {
    return `rgba(${channelColor} / 0.4)`;
  }
  return alpha(color2, 0.4);
};
const _excluded$b = ["className", "color", "component", "onBlur", "onFocus", "TypographyClasses", "underline", "variant", "sx"];
const useUtilityClasses$9 = (ownerState) => {
  const {
    classes,
    component,
    focusVisible,
    underline
  } = ownerState;
  const slots = {
    root: ["root", `underline${capitalize(underline)}`, component === "button" && "button", focusVisible && "focusVisible"]
  };
  return composeClasses(slots, getLinkUtilityClass, classes);
};
const LinkRoot = styled(Typography$1, {
  name: "MuiLink",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`underline${capitalize(ownerState.underline)}`], ownerState.component === "button" && styles2.button];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  return _extends$4({}, ownerState.underline === "none" && {
    textDecoration: "none"
  }, ownerState.underline === "hover" && {
    textDecoration: "none",
    "&:hover": {
      textDecoration: "underline"
    }
  }, ownerState.underline === "always" && _extends$4({
    textDecoration: "underline"
  }, ownerState.color !== "inherit" && {
    textDecorationColor: getTextDecoration({
      theme: theme2,
      ownerState
    })
  }, {
    "&:hover": {
      textDecorationColor: "inherit"
    }
  }), ownerState.component === "button" && {
    position: "relative",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    // Reset default value
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    border: 0,
    margin: 0,
    // Remove the margin in Safari
    borderRadius: 0,
    padding: 0,
    // Remove the padding in Firefox
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    // Reset
    WebkitAppearance: "none",
    // Reset
    "&::-moz-focus-inner": {
      borderStyle: "none"
      // Remove Firefox dotted outline.
    },
    [`&.${linkClasses$1.focusVisible}`]: {
      outline: "auto"
    }
  });
});
const Link = /* @__PURE__ */ reactExports.forwardRef(function Link2(inProps, ref2) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiLink"
  });
  const {
    className,
    color: color2 = "primary",
    component = "a",
    onBlur,
    onFocus,
    TypographyClasses,
    underline = "always",
    variant = "inherit",
    sx
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$b);
  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  const handlerRef = useForkRef(ref2, focusVisibleRef);
  const handleBlur = (event) => {
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  };
  const handleFocus = (event) => {
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusVisible(true);
    }
    if (onFocus) {
      onFocus(event);
    }
  };
  const ownerState = _extends$4({}, props, {
    color: color2,
    component,
    focusVisible,
    underline,
    variant
  });
  const classes = useUtilityClasses$9(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LinkRoot, _extends$4({
    color: color2,
    className: clsx(classes.root, className),
    classes: TypographyClasses,
    component,
    onBlur: handleBlur,
    onFocus: handleFocus,
    ref: handlerRef,
    ownerState,
    variant,
    sx: [...!Object.keys(colorTransformations).includes(color2) ? [{
      color: color2
    }] : [], ...Array.isArray(sx) ? sx : [sx]]
  }, other));
});
const Link$1 = Link;
const ListContext = /* @__PURE__ */ reactExports.createContext({});
const ListContext$1 = ListContext;
function getListUtilityClass(slot) {
  return generateUtilityClass("MuiList", slot);
}
generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
const _excluded$a = ["children", "className", "component", "dense", "disablePadding", "subheader"];
const useUtilityClasses$8 = (ownerState) => {
  const {
    classes,
    disablePadding,
    dense,
    subheader
  } = ownerState;
  const slots = {
    root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
  };
  return composeClasses(slots, getListUtilityClass, classes);
};
const ListRoot = styled("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
  }
})(({
  ownerState
}) => _extends$4({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative"
}, !ownerState.disablePadding && {
  paddingTop: 8,
  paddingBottom: 8
}, ownerState.subheader && {
  paddingTop: 0
}));
const List = /* @__PURE__ */ reactExports.forwardRef(function List2(inProps, ref2) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiList"
  });
  const {
    children,
    className,
    component = "ul",
    dense = false,
    disablePadding = false,
    subheader
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$a);
  const context = reactExports.useMemo(() => ({
    dense
  }), [dense]);
  const ownerState = _extends$4({}, props, {
    component,
    dense,
    disablePadding
  });
  const classes = useUtilityClasses$8(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
    value: context,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, _extends$4({
      as: component,
      className: clsx(classes.root, className),
      ref: ref2,
      ownerState
    }, other, {
      children: [subheader, children]
    }))
  });
});
const List$1 = List;
const listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
const listItemIconClasses$1 = listItemIconClasses;
const listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
const listItemTextClasses$1 = listItemTextClasses;
const _excluded$9 = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
function nextItem(list, item, disableListWrap) {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return disableListWrap ? null : list.firstChild;
}
function previousItem(list, item, disableListWrap) {
  if (list === item) {
    return disableListWrap ? list.firstChild : list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return disableListWrap ? null : list.lastChild;
}
function textCriteriaMatches(nextFocus, textCriteria) {
  if (textCriteria === void 0) {
    return true;
  }
  let text = nextFocus.innerText;
  if (text === void 0) {
    text = nextFocus.textContent;
  }
  text = text.trim().toLowerCase();
  if (text.length === 0) {
    return false;
  }
  if (textCriteria.repeating) {
    return text[0] === textCriteria.keys[0];
  }
  return text.indexOf(textCriteria.keys.join("")) === 0;
}
function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return false;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus, disableListWrap);
    } else {
      nextFocus.focus();
      return true;
    }
  }
  return false;
}
const MenuList = /* @__PURE__ */ reactExports.forwardRef(function MenuList2(props, ref2) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions,
    autoFocus = false,
    autoFocusItem = false,
    children,
    className,
    disabledItemsFocusable = false,
    disableListWrap = false,
    onKeyDown,
    variant = "selectedMenu"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$9);
  const listRef = reactExports.useRef(null);
  const textCriteriaRef = reactExports.useRef({
    keys: [],
    repeating: true,
    previousKeyMatched: true,
    lastTime: null
  });
  useEnhancedEffect(() => {
    if (autoFocus) {
      listRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useImperativeHandle(actions, () => ({
    adjustStyleForScrollbar: (containerElement, theme2) => {
      const noExplicitWidth = !listRef.current.style.width;
      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
        const scrollbarSize = `${getScrollbarSize(ownerDocument(containerElement))}px`;
        listRef.current.style[theme2.direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
      }
      return listRef.current;
    }
  }), []);
  const handleKeyDown2 = (event) => {
    const list = listRef.current;
    const key2 = event.key;
    const currentFocus = ownerDocument(list).activeElement;
    if (key2 === "ArrowDown") {
      event.preventDefault();
      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
    } else if (key2 === "ArrowUp") {
      event.preventDefault();
      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
    } else if (key2 === "Home") {
      event.preventDefault();
      moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
    } else if (key2 === "End") {
      event.preventDefault();
      moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
    } else if (key2.length === 1) {
      const criteria = textCriteriaRef.current;
      const lowerKey = key2.toLowerCase();
      const currTime = performance.now();
      if (criteria.keys.length > 0) {
        if (currTime - criteria.lastTime > 500) {
          criteria.keys = [];
          criteria.repeating = true;
          criteria.previousKeyMatched = true;
        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
          criteria.repeating = false;
        }
      }
      criteria.lastTime = currTime;
      criteria.keys.push(lowerKey);
      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {
        event.preventDefault();
      } else {
        criteria.previousKeyMatched = false;
      }
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleRef = useForkRef(listRef, ref2);
  let activeItemIndex = -1;
  reactExports.Children.forEach(children, (child, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      if (activeItemIndex === index2) {
        activeItemIndex += 1;
        if (activeItemIndex >= children.length) {
          activeItemIndex = -1;
        }
      }
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index2;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index2;
      }
    }
    if (activeItemIndex === index2 && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
      activeItemIndex += 1;
      if (activeItemIndex >= children.length) {
        activeItemIndex = -1;
      }
    }
  });
  const items = reactExports.Children.map(children, (child, index2) => {
    if (index2 === activeItemIndex) {
      const newChildProps = {};
      if (autoFocusItem) {
        newChildProps.autoFocus = true;
      }
      if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
        newChildProps.tabIndex = 0;
      }
      return /* @__PURE__ */ reactExports.cloneElement(child, newChildProps);
    }
    return child;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, _extends$4({
    role: "menu",
    ref: handleRef,
    className,
    onKeyDown: handleKeyDown2,
    tabIndex: autoFocus ? 0 : -1
  }, other, {
    children: items
  }));
});
const MenuList$1 = MenuList;
function getPopoverUtilityClass(slot) {
  return generateUtilityClass("MuiPopover", slot);
}
generateUtilityClasses("MuiPopover", ["root", "paper"]);
const _excluded$8 = ["onEntering"], _excluded2$2 = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "slots", "slotProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps", "disableScrollLock"], _excluded3 = ["slotProps"];
function getOffsetTop(rect, vertical) {
  let offset = 0;
  if (typeof vertical === "number") {
    offset = vertical;
  } else if (vertical === "center") {
    offset = rect.height / 2;
  } else if (vertical === "bottom") {
    offset = rect.height;
  }
  return offset;
}
function getOffsetLeft(rect, horizontal) {
  let offset = 0;
  if (typeof horizontal === "number") {
    offset = horizontal;
  } else if (horizontal === "center") {
    offset = rect.width / 2;
  } else if (horizontal === "right") {
    offset = rect.width;
  }
  return offset;
}
function getTransformOriginValue(transformOrigin) {
  return [transformOrigin.horizontal, transformOrigin.vertical].map((n4) => typeof n4 === "number" ? `${n4}px` : n4).join(" ");
}
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
const useUtilityClasses$7 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"]
  };
  return composeClasses(slots, getPopoverUtilityClass, classes);
};
const PopoverRoot = styled(Modal$1, {
  name: "MuiPopover",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const PopoverPaper = styled(Paper$1, {
  name: "MuiPopover",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Popover = /* @__PURE__ */ reactExports.forwardRef(function Popover2(inProps, ref2) {
  var _slotProps$paper, _slots$root, _slots$paper;
  const props = useThemeProps({
    props: inProps,
    name: "MuiPopover"
  });
  const {
    action,
    anchorEl,
    anchorOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition,
    anchorReference = "anchorEl",
    children,
    className,
    container: containerProp,
    elevation = 8,
    marginThreshold = 16,
    open,
    PaperProps: PaperPropsProp = {},
    slots,
    slotProps,
    transformOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent = Grow$1,
    transitionDuration: transitionDurationProp = "auto",
    TransitionProps: {
      onEntering
    } = {},
    disableScrollLock = false
  } = props, TransitionProps = _objectWithoutPropertiesLoose$1(props.TransitionProps, _excluded$8), other = _objectWithoutPropertiesLoose$1(props, _excluded2$2);
  const externalPaperSlotProps = (_slotProps$paper = slotProps == null ? void 0 : slotProps.paper) != null ? _slotProps$paper : PaperPropsProp;
  const paperRef = reactExports.useRef();
  const handlePaperRef = useForkRef(paperRef, externalPaperSlotProps.ref);
  const ownerState = _extends$4({}, props, {
    anchorOrigin,
    anchorReference,
    elevation,
    marginThreshold,
    externalPaperSlotProps,
    transformOrigin,
    TransitionComponent,
    transitionDuration: transitionDurationProp,
    TransitionProps
  });
  const classes = useUtilityClasses$7(ownerState);
  const getAnchorOffset = reactExports.useCallback(() => {
    if (anchorReference === "anchorPosition") {
      return anchorPosition;
    }
    const resolvedAnchorEl = resolveAnchorEl(anchorEl);
    const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
    const anchorRect = anchorElement.getBoundingClientRect();
    return {
      top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
      left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
    };
  }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
  const getTransformOrigin = reactExports.useCallback((elemRect) => {
    return {
      vertical: getOffsetTop(elemRect, transformOrigin.vertical),
      horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
    };
  }, [transformOrigin.horizontal, transformOrigin.vertical]);
  const getPositioningStyle = reactExports.useCallback((element) => {
    const elemRect = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
    const elemTransformOrigin = getTransformOrigin(elemRect);
    if (anchorReference === "none") {
      return {
        top: null,
        left: null,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }
    const anchorOffset = getAnchorOffset();
    let top = anchorOffset.top - elemTransformOrigin.vertical;
    let left = anchorOffset.left - elemTransformOrigin.horizontal;
    const bottom = top + elemRect.height;
    const right = left + elemRect.width;
    const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
    const heightThreshold = containerWindow.innerHeight - marginThreshold;
    const widthThreshold = containerWindow.innerWidth - marginThreshold;
    if (marginThreshold !== null && top < marginThreshold) {
      const diff = top - marginThreshold;
      top -= diff;
      elemTransformOrigin.vertical += diff;
    } else if (marginThreshold !== null && bottom > heightThreshold) {
      const diff = bottom - heightThreshold;
      top -= diff;
      elemTransformOrigin.vertical += diff;
    }
    if (marginThreshold !== null && left < marginThreshold) {
      const diff = left - marginThreshold;
      left -= diff;
      elemTransformOrigin.horizontal += diff;
    } else if (right > widthThreshold) {
      const diff = right - widthThreshold;
      left -= diff;
      elemTransformOrigin.horizontal += diff;
    }
    return {
      top: `${Math.round(top)}px`,
      left: `${Math.round(left)}px`,
      transformOrigin: getTransformOriginValue(elemTransformOrigin)
    };
  }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
  const [isPositioned, setIsPositioned] = reactExports.useState(open);
  const setPositioningStyles = reactExports.useCallback(() => {
    const element = paperRef.current;
    if (!element) {
      return;
    }
    const positioning = getPositioningStyle(element);
    if (positioning.top !== null) {
      element.style.top = positioning.top;
    }
    if (positioning.left !== null) {
      element.style.left = positioning.left;
    }
    element.style.transformOrigin = positioning.transformOrigin;
    setIsPositioned(true);
  }, [getPositioningStyle]);
  reactExports.useEffect(() => {
    if (disableScrollLock) {
      window.addEventListener("scroll", setPositioningStyles);
    }
    return () => window.removeEventListener("scroll", setPositioningStyles);
  }, [anchorEl, disableScrollLock, setPositioningStyles]);
  const handleEntering = (element, isAppearing) => {
    if (onEntering) {
      onEntering(element, isAppearing);
    }
    setPositioningStyles();
  };
  const handleExited = () => {
    setIsPositioned(false);
  };
  reactExports.useEffect(() => {
    if (open) {
      setPositioningStyles();
    }
  });
  reactExports.useImperativeHandle(action, () => open ? {
    updatePosition: () => {
      setPositioningStyles();
    }
  } : null, [open, setPositioningStyles]);
  reactExports.useEffect(() => {
    if (!open) {
      return void 0;
    }
    const handleResize = debounce(() => {
      setPositioningStyles();
    });
    const containerWindow = ownerWindow(anchorEl);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [anchorEl, open, setPositioningStyles]);
  let transitionDuration = transitionDurationProp;
  if (transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto) {
    transitionDuration = void 0;
  }
  const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
  const RootSlot = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : PopoverRoot;
  const PaperSlot = (_slots$paper = slots == null ? void 0 : slots.paper) != null ? _slots$paper : PopoverPaper;
  const paperProps = useSlotProps({
    elementType: PaperSlot,
    externalSlotProps: _extends$4({}, externalPaperSlotProps, {
      style: isPositioned ? externalPaperSlotProps.style : _extends$4({}, externalPaperSlotProps.style, {
        opacity: 0
      })
    }),
    additionalProps: {
      elevation,
      ref: handlePaperRef
    },
    ownerState,
    className: clsx(classes.paper, externalPaperSlotProps == null ? void 0 : externalPaperSlotProps.className)
  });
  const _useSlotProps = useSlotProps({
    elementType: RootSlot,
    externalSlotProps: (slotProps == null ? void 0 : slotProps.root) || {},
    externalForwardedProps: other,
    additionalProps: {
      ref: ref2,
      slotProps: {
        backdrop: {
          invisible: true
        }
      },
      container,
      open
    },
    ownerState,
    className: clsx(classes.root, className)
  }), {
    slotProps: rootSlotPropsProp
  } = _useSlotProps, rootProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded3);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, _extends$4({}, rootProps, !isHostComponent(RootSlot) && {
    slotProps: rootSlotPropsProp,
    disableScrollLock
  }, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$4({
      appear: true,
      in: open,
      onEntering: handleEntering,
      onExited: handleExited,
      timeout: transitionDuration
    }, TransitionProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, _extends$4({}, paperProps, {
        children
      }))
    }))
  }));
});
const Popover$1 = Popover;
function getMenuUtilityClass(slot) {
  return generateUtilityClass("MuiMenu", slot);
}
generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
const _excluded$7 = ["onEntering"], _excluded2$1 = ["autoFocus", "children", "className", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant", "slots", "slotProps"];
const RTL_ORIGIN = {
  vertical: "top",
  horizontal: "right"
};
const LTR_ORIGIN = {
  vertical: "top",
  horizontal: "left"
};
const useUtilityClasses$6 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  };
  return composeClasses(slots, getMenuUtilityClass, classes);
};
const MenuRoot = styled(Popover$1, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenu",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const MenuPaper = styled(PopoverPaper, {
  name: "MuiMenu",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
});
const MenuMenuList = styled(MenuList$1, {
  name: "MuiMenu",
  slot: "List",
  overridesResolver: (props, styles2) => styles2.list
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Menu = /* @__PURE__ */ reactExports.forwardRef(function Menu2(inProps, ref2) {
  var _slots$paper, _slotProps$paper;
  const props = useThemeProps({
    props: inProps,
    name: "MuiMenu"
  });
  const {
    autoFocus = true,
    children,
    className,
    disableAutoFocusItem = false,
    MenuListProps = {},
    onClose,
    open,
    PaperProps = {},
    PopoverClasses,
    transitionDuration = "auto",
    TransitionProps: {
      onEntering
    } = {},
    variant = "selectedMenu",
    slots = {},
    slotProps = {}
  } = props, TransitionProps = _objectWithoutPropertiesLoose$1(props.TransitionProps, _excluded$7), other = _objectWithoutPropertiesLoose$1(props, _excluded2$1);
  const theme2 = useTheme();
  const isRtl = theme2.direction === "rtl";
  const ownerState = _extends$4({}, props, {
    autoFocus,
    disableAutoFocusItem,
    MenuListProps,
    onEntering,
    PaperProps,
    transitionDuration,
    TransitionProps,
    variant
  });
  const classes = useUtilityClasses$6(ownerState);
  const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
  const menuListActionsRef = reactExports.useRef(null);
  const handleEntering = (element, isAppearing) => {
    if (menuListActionsRef.current) {
      menuListActionsRef.current.adjustStyleForScrollbar(element, theme2);
    }
    if (onEntering) {
      onEntering(element, isAppearing);
    }
  };
  const handleListKeyDown = (event) => {
    if (event.key === "Tab") {
      event.preventDefault();
      if (onClose) {
        onClose(event, "tabKeyDown");
      }
    }
  };
  let activeItemIndex = -1;
  reactExports.Children.map(children, (child, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index2;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index2;
      }
    }
  });
  const PaperSlot = (_slots$paper = slots.paper) != null ? _slots$paper : MenuPaper;
  const paperExternalSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : PaperProps;
  const rootSlotProps = useSlotProps({
    elementType: slots.root,
    externalSlotProps: slotProps.root,
    ownerState,
    className: [classes.root, className]
  });
  const paperSlotProps = useSlotProps({
    elementType: PaperSlot,
    externalSlotProps: paperExternalSlotProps,
    ownerState,
    className: classes.paper
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, _extends$4({
    onClose,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: isRtl ? "right" : "left"
    },
    transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
    slots: {
      paper: PaperSlot,
      root: slots.root
    },
    slotProps: {
      root: rootSlotProps,
      paper: paperSlotProps
    },
    open,
    ref: ref2,
    transitionDuration,
    TransitionProps: _extends$4({
      onEntering: handleEntering
    }, TransitionProps),
    ownerState
  }, other, {
    classes: PopoverClasses,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuMenuList, _extends$4({
      onKeyDown: handleListKeyDown,
      actions: menuListActionsRef,
      autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
      autoFocusItem,
      variant
    }, MenuListProps, {
      className: clsx(classes.list, MenuListProps.className),
      children
    }))
  }));
});
const Menu$1 = Menu;
function getMenuItemUtilityClass(slot) {
  return generateUtilityClass("MuiMenuItem", slot);
}
const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
const menuItemClasses$1 = menuItemClasses;
const _excluded$6 = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"];
const overridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
};
const useUtilityClasses$5 = (ownerState) => {
  const {
    disabled,
    dense,
    divider,
    disableGutters,
    selected,
    classes
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
  };
  const composedClasses = composeClasses(slots, getMenuItemUtilityClass, classes);
  return _extends$4({}, classes, composedClasses);
};
const MenuItemRoot = styled(ButtonBase$1, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver
})(({
  theme: theme2,
  ownerState
}) => _extends$4({}, theme2.typography.body1, {
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap"
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ownerState.divider && {
  borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`,
  backgroundClip: "padding-box"
}, {
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme2.vars || theme2).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${menuItemClasses$1.selected}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
    [`&.${menuItemClasses$1.focusVisible}`]: {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
    }
  },
  [`&.${menuItemClasses$1.selected}:hover`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity)
    }
  },
  [`&.${menuItemClasses$1.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.focus
  },
  [`&.${menuItemClasses$1.disabled}`]: {
    opacity: (theme2.vars || theme2).palette.action.disabledOpacity
  },
  [`& + .${dividerClasses$1.root}`]: {
    marginTop: theme2.spacing(1),
    marginBottom: theme2.spacing(1)
  },
  [`& + .${dividerClasses$1.inset}`]: {
    marginLeft: 52
  },
  [`& .${listItemTextClasses$1.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${listItemTextClasses$1.inset}`]: {
    paddingLeft: 36
  },
  [`& .${listItemIconClasses$1.root}`]: {
    minWidth: 36
  }
}, !ownerState.dense && {
  [theme2.breakpoints.up("sm")]: {
    minHeight: "auto"
  }
}, ownerState.dense && _extends$4({
  minHeight: 32,
  // https://m2.material.io/components/menus#specs > Dense
  paddingTop: 4,
  paddingBottom: 4
}, theme2.typography.body2, {
  [`& .${listItemIconClasses$1.root} svg`]: {
    fontSize: "1.25rem"
  }
})));
const MenuItem = /* @__PURE__ */ reactExports.forwardRef(function MenuItem2(inProps, ref2) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiMenuItem"
  });
  const {
    autoFocus = false,
    component = "li",
    dense = false,
    divider = false,
    disableGutters = false,
    focusVisibleClassName,
    role = "menuitem",
    tabIndex: tabIndexProp,
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$6);
  const context = reactExports.useContext(ListContext$1);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    disableGutters
  }), [context.dense, dense, disableGutters]);
  const menuItemRef = reactExports.useRef(null);
  useEnhancedEffect(() => {
    if (autoFocus) {
      if (menuItemRef.current) {
        menuItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const ownerState = _extends$4({}, props, {
    dense: childContext.dense,
    divider,
    disableGutters
  });
  const classes = useUtilityClasses$5(props);
  const handleRef = useForkRef(menuItemRef, ref2);
  let tabIndex;
  if (!props.disabled) {
    tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemRoot, _extends$4({
      ref: handleRef,
      role,
      tabIndex,
      component,
      focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
      className: clsx(classes.root, className)
    }, other, {
      ownerState,
      classes
    }))
  });
});
const MenuItem$1 = MenuItem;
function getNativeSelectUtilityClasses(slot) {
  return generateUtilityClass("MuiNativeSelect", slot);
}
const nativeSelectClasses = generateUtilityClasses("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
const nativeSelectClasses$1 = nativeSelectClasses;
const _excluded$5 = ["className", "disabled", "error", "IconComponent", "inputRef", "variant"];
const useUtilityClasses$4 = (ownerState) => {
  const {
    classes,
    variant,
    disabled,
    multiple,
    open,
    error
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
    icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"]
  };
  return composeClasses(slots, getNativeSelectUtilityClasses, classes);
};
const nativeSelectSelectStyles = ({
  ownerState,
  theme: theme2
}) => _extends$4({
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  borderRadius: 0,
  // Reset
  cursor: "pointer",
  "&:focus": _extends$4({}, theme2.vars ? {
    backgroundColor: `rgba(${theme2.vars.palette.common.onBackgroundChannel} / 0.05)`
  } : {
    backgroundColor: theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
  }, {
    borderRadius: 0
    // Reset Chrome style
  }),
  // Remove IE11 arrow
  "&::-ms-expand": {
    display: "none"
  },
  [`&.${nativeSelectClasses$1.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (theme2.vars || theme2).palette.background.paper
  },
  // Bump specificity to allow extending custom inputs
  "&&&": {
    paddingRight: 24,
    minWidth: 16
    // So it doesn't collapse.
  }
}, ownerState.variant === "filled" && {
  "&&&": {
    paddingRight: 32
  }
}, ownerState.variant === "outlined" && {
  borderRadius: (theme2.vars || theme2).shape.borderRadius,
  "&:focus": {
    borderRadius: (theme2.vars || theme2).shape.borderRadius
    // Reset the reset for Chrome style
  },
  "&&&": {
    paddingRight: 32
  }
});
const NativeSelectSelect = styled("select", {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: rootShouldForwardProp,
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.select, styles2[ownerState.variant], ownerState.error && styles2.error, {
      [`&.${nativeSelectClasses$1.multiple}`]: styles2.multiple
    }];
  }
})(nativeSelectSelectStyles);
const nativeSelectIconStyles = ({
  ownerState,
  theme: theme2
}) => _extends$4({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  top: "calc(50% - .5em)",
  // Center vertically, height is 1em
  pointerEvents: "none",
  // Don't block pointer events on the select under the icon.
  color: (theme2.vars || theme2).palette.action.active,
  [`&.${nativeSelectClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.action.disabled
  }
}, ownerState.open && {
  transform: "rotate(180deg)"
}, ownerState.variant === "filled" && {
  right: 7
}, ownerState.variant === "outlined" && {
  right: 7
});
const NativeSelectIcon = styled("svg", {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})(nativeSelectIconStyles);
const NativeSelectInput = /* @__PURE__ */ reactExports.forwardRef(function NativeSelectInput2(props, ref2) {
  const {
    className,
    disabled,
    error,
    IconComponent,
    inputRef,
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$5);
  const ownerState = _extends$4({}, props, {
    disabled,
    variant,
    error
  });
  const classes = useUtilityClasses$4(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectSelect, _extends$4({
      ownerState,
      className: clsx(classes.select, className),
      disabled,
      ref: inputRef || ref2
    }, other)), props.multiple ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectIcon, {
      as: IconComponent,
      ownerState,
      className: classes.icon
    })]
  });
});
const NativeSelectInput$1 = NativeSelectInput;
var _span$1;
const _excluded$4 = ["children", "classes", "className", "label", "notched"];
const NotchedOutlineRoot$1 = styled("fieldset", {
  shouldForwardProp: rootShouldForwardProp
})({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
});
const NotchedOutlineLegend = styled("legend", {
  shouldForwardProp: rootShouldForwardProp
})(({
  ownerState,
  theme: theme2
}) => _extends$4({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden"
}, !ownerState.withLabel && {
  padding: 0,
  lineHeight: "11px",
  // sync with `height` in `legend` styles
  transition: theme2.transitions.create("width", {
    duration: 150,
    easing: theme2.transitions.easing.easeOut
  })
}, ownerState.withLabel && _extends$4({
  display: "block",
  // Fix conflict with normalize.css and sanitize.css
  padding: 0,
  height: 11,
  // sync with `lineHeight` in `legend` styles
  fontSize: "0.75em",
  visibility: "hidden",
  maxWidth: 0.01,
  transition: theme2.transitions.create("max-width", {
    duration: 50,
    easing: theme2.transitions.easing.easeOut
  }),
  whiteSpace: "nowrap",
  "& > span": {
    paddingLeft: 5,
    paddingRight: 5,
    display: "inline-block",
    opacity: 0,
    visibility: "visible"
  }
}, ownerState.notched && {
  maxWidth: "100%",
  transition: theme2.transitions.create("max-width", {
    duration: 100,
    easing: theme2.transitions.easing.easeOut,
    delay: 50
  })
})));
function NotchedOutline(props) {
  const {
    className,
    label,
    notched
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$4);
  const withLabel = label != null && label !== "";
  const ownerState = _extends$4({}, props, {
    notched,
    withLabel
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot$1, _extends$4({
    "aria-hidden": true,
    className,
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineLegend, {
      ownerState,
      children: withLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        children: label
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span$1 || (_span$1 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          children: ""
        }))
      )
    })
  }));
}
const _excluded$3 = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"];
const useUtilityClasses$3 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes);
  return _extends$4({}, classes, composedClasses);
};
const OutlinedInputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return _extends$4({
    position: "relative",
    borderRadius: (theme2.vars || theme2).shape.borderRadius,
    [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
        borderColor: theme2.vars ? `rgba(${theme2.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
      }
    },
    [`&.${outlinedInputClasses$1.focused} .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette[ownerState.color].main,
      borderWidth: 2
    },
    [`&.${outlinedInputClasses$1.error} .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.error.main
    },
    [`&.${outlinedInputClasses$1.disabled} .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.action.disabled
    }
  }, ownerState.startAdornment && {
    paddingLeft: 14
  }, ownerState.endAdornment && {
    paddingRight: 14
  }, ownerState.multiline && _extends$4({
    padding: "16.5px 14px"
  }, ownerState.size === "small" && {
    padding: "8.5px 14px"
  }));
});
const NotchedOutlineRoot = styled(NotchedOutline, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline",
  overridesResolver: (props, styles2) => styles2.notchedOutline
})(({
  theme: theme2
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: theme2.vars ? `rgba(${theme2.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
  };
});
const OutlinedInputInput = styled(InputBaseComponent, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => _extends$4({
  padding: "16.5px 14px"
}, !theme2.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: theme2.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: theme2.palette.mode === "light" ? null : "#fff",
    caretColor: theme2.palette.mode === "light" ? null : "#fff",
    borderRadius: "inherit"
  }
}, theme2.vars && {
  "&:-webkit-autofill": {
    borderRadius: "inherit"
  },
  [theme2.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, ownerState.size === "small" && {
  padding: "8.5px 14px"
}, ownerState.multiline && {
  padding: 0
}, ownerState.startAdornment && {
  paddingLeft: 0
}, ownerState.endAdornment && {
  paddingRight: 0
}));
const OutlinedInput = /* @__PURE__ */ reactExports.forwardRef(function OutlinedInput2(inProps, ref2) {
  var _ref, _slots$root, _ref2, _slots$input, _React$Fragment;
  const props = useThemeProps({
    props: inProps,
    name: "MuiOutlinedInput"
  });
  const {
    components = {},
    fullWidth = false,
    inputComponent = "input",
    label,
    multiline = false,
    notched,
    slots = {},
    type = "text"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$3);
  const classes = useUtilityClasses$3(props);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  });
  const ownerState = _extends$4({}, props, {
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    type
  });
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : OutlinedInputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : OutlinedInputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$4({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    renderSuffix: (state2) => /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot, {
      ownerState,
      className: classes.notchedOutline,
      label: label != null && label !== "" && fcs.required ? _React$Fragment || (_React$Fragment = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [label, "", "*"]
      })) : label,
      notched: typeof notched !== "undefined" ? notched : Boolean(state2.startAdornment || state2.filled || state2.focused)
    }),
    fullWidth,
    inputComponent,
    multiline,
    ref: ref2,
    type
  }, other, {
    classes: _extends$4({}, classes, {
      notchedOutline: null
    })
  }));
});
OutlinedInput.muiName = "Input";
const OutlinedInput$1 = OutlinedInput;
function getSelectUtilityClasses(slot) {
  return generateUtilityClass("MuiSelect", slot);
}
const selectClasses = generateUtilityClasses("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var _span;
const _excluded$2 = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "error", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"];
const SelectSelect = styled("div", {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [
      // Win specificity over the input base
      {
        [`&.${selectClasses.select}`]: styles2.select
      },
      {
        [`&.${selectClasses.select}`]: styles2[ownerState.variant]
      },
      {
        [`&.${selectClasses.error}`]: styles2.error
      },
      {
        [`&.${selectClasses.multiple}`]: styles2.multiple
      }
    ];
  }
})(nativeSelectSelectStyles, {
  // Win specificity over the input base
  [`&.${selectClasses.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
});
const SelectIcon = styled("svg", {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})(nativeSelectIconStyles);
const SelectNativeInput = styled("input", {
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "classes",
  name: "MuiSelect",
  slot: "NativeInput",
  overridesResolver: (props, styles2) => styles2.nativeInput
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function areEqualValues(a2, b3) {
  if (typeof b3 === "object" && b3 !== null) {
    return a2 === b3;
  }
  return String(a2) === String(b3);
}
function isEmpty(display) {
  return display == null || typeof display === "string" && !display.trim();
}
const useUtilityClasses$2 = (ownerState) => {
  const {
    classes,
    variant,
    disabled,
    multiple,
    open,
    error
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
    icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return composeClasses(slots, getSelectUtilityClasses, classes);
};
const SelectInput = /* @__PURE__ */ reactExports.forwardRef(function SelectInput2(props, ref2) {
  var _MenuProps$slotProps;
  const {
    "aria-describedby": ariaDescribedby,
    "aria-label": ariaLabel,
    autoFocus,
    autoWidth,
    children,
    className,
    defaultOpen,
    defaultValue,
    disabled,
    displayEmpty,
    error = false,
    IconComponent,
    inputRef: inputRefProp,
    labelId,
    MenuProps = {},
    multiple,
    name: name2,
    onBlur,
    onChange,
    onClose,
    onFocus,
    onOpen,
    open: openProp,
    readOnly,
    renderValue,
    SelectDisplayProps = {},
    tabIndex: tabIndexProp,
    value: valueProp,
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2);
  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "Select"
  });
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: defaultOpen,
    name: "Select"
  });
  const inputRef = reactExports.useRef(null);
  const displayRef = reactExports.useRef(null);
  const [displayNode, setDisplayNode] = reactExports.useState(null);
  const {
    current: isOpenControlled
  } = reactExports.useRef(openProp != null);
  const [menuMinWidthState, setMenuMinWidthState] = reactExports.useState();
  const handleRef = useForkRef(ref2, inputRefProp);
  const handleDisplayRef = reactExports.useCallback((node2) => {
    displayRef.current = node2;
    if (node2) {
      setDisplayNode(node2);
    }
  }, []);
  const anchorElement = displayNode == null ? void 0 : displayNode.parentNode;
  reactExports.useImperativeHandle(handleRef, () => ({
    focus: () => {
      displayRef.current.focus();
    },
    node: inputRef.current,
    value
  }), [value]);
  reactExports.useEffect(() => {
    if (defaultOpen && openState && displayNode && !isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      displayRef.current.focus();
    }
  }, [displayNode, autoWidth]);
  reactExports.useEffect(() => {
    if (autoFocus) {
      displayRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useEffect(() => {
    if (!labelId) {
      return void 0;
    }
    const label = ownerDocument(displayRef.current).getElementById(labelId);
    if (label) {
      const handler = () => {
        if (getSelection().isCollapsed) {
          displayRef.current.focus();
        }
      };
      label.addEventListener("click", handler);
      return () => {
        label.removeEventListener("click", handler);
      };
    }
    return void 0;
  }, [labelId]);
  const update5 = (open2, event) => {
    if (open2) {
      if (onOpen) {
        onOpen(event);
      }
    } else if (onClose) {
      onClose(event);
    }
    if (!isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      setOpenState(open2);
    }
  };
  const handleMouseDown = (event) => {
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    displayRef.current.focus();
    update5(true, event);
  };
  const handleClose = (event) => {
    update5(false, event);
  };
  const childrenArray = reactExports.Children.toArray(children);
  const handleChange = (event) => {
    const child = childrenArray.find((childItem) => childItem.props.value === event.target.value);
    if (child === void 0) {
      return;
    }
    setValueState(child.props.value);
    if (onChange) {
      onChange(event, child);
    }
  };
  const handleItemClick = (child) => (event) => {
    let newValue;
    if (!event.currentTarget.hasAttribute("tabindex")) {
      return;
    }
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = value.indexOf(child.props.value);
      if (itemIndex === -1) {
        newValue.push(child.props.value);
      } else {
        newValue.splice(itemIndex, 1);
      }
    } else {
      newValue = child.props.value;
    }
    if (child.props.onClick) {
      child.props.onClick(event);
    }
    if (value !== newValue) {
      setValueState(newValue);
      if (onChange) {
        const nativeEvent = event.nativeEvent || event;
        const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
        Object.defineProperty(clonedEvent, "target", {
          writable: true,
          value: {
            value: newValue,
            name: name2
          }
        });
        onChange(clonedEvent, child);
      }
    }
    if (!multiple) {
      update5(false, event);
    }
  };
  const handleKeyDown2 = (event) => {
    if (!readOnly) {
      const validKeys = [
        " ",
        "ArrowUp",
        "ArrowDown",
        // The native select doesn't respond to enter on macOS, but it's recommended by
        // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
        "Enter"
      ];
      if (validKeys.indexOf(event.key) !== -1) {
        event.preventDefault();
        update5(true, event);
      }
    }
  };
  const open = displayNode !== null && openState;
  const handleBlur = (event) => {
    if (!open && onBlur) {
      Object.defineProperty(event, "target", {
        writable: true,
        value: {
          value,
          name: name2
        }
      });
      onBlur(event);
    }
  };
  delete other["aria-invalid"];
  let display;
  let displaySingle;
  const displayMultiple = [];
  let computeDisplay = false;
  if (isFilled({
    value
  }) || displayEmpty) {
    if (renderValue) {
      display = renderValue(value);
    } else {
      computeDisplay = true;
    }
  }
  const items = childrenArray.map((child) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return null;
    }
    let selected;
    if (multiple) {
      if (!Array.isArray(value)) {
        throw new Error(formatMuiErrorMessage(2));
      }
      selected = value.some((v2) => areEqualValues(v2, child.props.value));
      if (selected && computeDisplay) {
        displayMultiple.push(child.props.children);
      }
    } else {
      selected = areEqualValues(value, child.props.value);
      if (selected && computeDisplay) {
        displaySingle = child.props.children;
      }
    }
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      "aria-selected": selected ? "true" : "false",
      onClick: handleItemClick(child),
      onKeyUp: (event) => {
        if (event.key === " ") {
          event.preventDefault();
        }
        if (child.props.onKeyUp) {
          child.props.onKeyUp(event);
        }
      },
      role: "option",
      selected,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": child.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  if (computeDisplay) {
    if (multiple) {
      if (displayMultiple.length === 0) {
        display = null;
      } else {
        display = displayMultiple.reduce((output2, child, index2) => {
          output2.push(child);
          if (index2 < displayMultiple.length - 1) {
            output2.push(", ");
          }
          return output2;
        }, []);
      }
    } else {
      display = displaySingle;
    }
  }
  let menuMinWidth = menuMinWidthState;
  if (!autoWidth && isOpenControlled && displayNode) {
    menuMinWidth = anchorElement.clientWidth;
  }
  let tabIndex;
  if (typeof tabIndexProp !== "undefined") {
    tabIndex = tabIndexProp;
  } else {
    tabIndex = disabled ? null : 0;
  }
  const buttonId = SelectDisplayProps.id || (name2 ? `mui-component-select-${name2}` : void 0);
  const ownerState = _extends$4({}, props, {
    variant,
    value,
    open,
    error
  });
  const classes = useUtilityClasses$2(ownerState);
  const paperProps = _extends$4({}, MenuProps.PaperProps, (_MenuProps$slotProps = MenuProps.slotProps) == null ? void 0 : _MenuProps$slotProps.paper);
  const listboxId = useId();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SelectSelect, _extends$4({
      ref: handleDisplayRef,
      tabIndex,
      role: "combobox",
      "aria-controls": listboxId,
      "aria-disabled": disabled ? "true" : void 0,
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": ariaLabel,
      "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
      "aria-describedby": ariaDescribedby,
      onKeyDown: handleKeyDown2,
      onMouseDown: disabled || readOnly ? null : handleMouseDown,
      onBlur: handleBlur,
      onFocus
    }, SelectDisplayProps, {
      ownerState,
      className: clsx(SelectDisplayProps.className, classes.select, className),
      id: buttonId,
      children: isEmpty(display) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span || (_span = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          children: ""
        }))
      ) : display
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectNativeInput, _extends$4({
      "aria-invalid": error,
      value: Array.isArray(value) ? value.join(",") : value,
      name: name2,
      ref: inputRef,
      "aria-hidden": true,
      onChange: handleChange,
      tabIndex: -1,
      disabled,
      className: classes.nativeInput,
      autoFocus,
      ownerState
    }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIcon, {
      as: IconComponent,
      className: classes.icon,
      ownerState
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Menu$1, _extends$4({
      id: `menu-${name2 || ""}`,
      anchorEl: anchorElement,
      open,
      onClose: handleClose,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      }
    }, MenuProps, {
      MenuListProps: _extends$4({
        "aria-labelledby": labelId,
        role: "listbox",
        "aria-multiselectable": multiple ? "true" : void 0,
        disableListWrap: true,
        id: listboxId
      }, MenuProps.MenuListProps),
      slotProps: _extends$4({}, MenuProps.slotProps, {
        paper: _extends$4({}, paperProps, {
          style: _extends$4({
            minWidth: menuMinWidth
          }, paperProps != null ? paperProps.style : null)
        })
      }),
      children: items
    }))]
  });
});
const SelectInput$1 = SelectInput;
const _excluded$1 = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"], _excluded2 = ["root"];
const useUtilityClasses$1 = (ownerState) => {
  const {
    classes
  } = ownerState;
  return classes;
};
const styledRootConfig = {
  name: "MuiSelect",
  overridesResolver: (props, styles2) => styles2.root,
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) && prop !== "variant",
  slot: "Root"
};
const StyledInput = styled(Input$1, styledRootConfig)("");
const StyledOutlinedInput = styled(OutlinedInput$1, styledRootConfig)("");
const StyledFilledInput = styled(FilledInput$1, styledRootConfig)("");
const Select = /* @__PURE__ */ reactExports.forwardRef(function Select2(inProps, ref2) {
  const props = useThemeProps({
    name: "MuiSelect",
    props: inProps
  });
  const {
    autoWidth = false,
    children,
    classes: classesProp = {},
    className,
    defaultOpen = false,
    displayEmpty = false,
    IconComponent = ArrowDropDownIcon,
    id: id2,
    input,
    inputProps,
    label,
    labelId,
    MenuProps,
    multiple = false,
    native = false,
    onClose,
    onOpen,
    open,
    renderValue,
    SelectDisplayProps,
    variant: variantProp = "outlined"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1);
  const inputComponent = native ? NativeSelectInput$1 : SelectInput$1;
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "error"]
  });
  const variant = fcs.variant || variantProp;
  const ownerState = _extends$4({}, props, {
    variant,
    classes: classesProp
  });
  const classes = useUtilityClasses$1(ownerState);
  const restOfClasses = _objectWithoutPropertiesLoose$1(classes, _excluded2);
  const InputComponent = input || {
    standard: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInput, {
      ownerState
    }),
    outlined: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledOutlinedInput, {
      label,
      ownerState
    }),
    filled: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledFilledInput, {
      ownerState
    })
  }[variant];
  const inputComponentRef = useForkRef(ref2, InputComponent.ref);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: /* @__PURE__ */ reactExports.cloneElement(InputComponent, _extends$4({
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent,
      inputProps: _extends$4({
        children,
        error: fcs.error,
        IconComponent,
        variant,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple
      }, native ? {
        id: id2
      } : {
        autoWidth,
        defaultOpen,
        displayEmpty,
        labelId,
        MenuProps,
        onClose,
        onOpen,
        open,
        renderValue,
        SelectDisplayProps: _extends$4({
          id: id2
        }, SelectDisplayProps)
      }, inputProps, {
        classes: inputProps ? deepmerge(restOfClasses, inputProps.classes) : restOfClasses
      }, input ? input.props.inputProps : {})
    }, multiple && native && variant === "outlined" ? {
      notched: true
    } : {}, {
      ref: inputComponentRef,
      className: clsx(InputComponent.props.className, className, classes.root)
    }, !input && {
      variant
    }, other))
  });
});
Select.muiName = "Select";
const Select$1 = Select;
function getTextFieldUtilityClass(slot) {
  return generateUtilityClass("MuiTextField", slot);
}
generateUtilityClasses("MuiTextField", ["root"]);
const _excluded = ["autoComplete", "autoFocus", "children", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "select", "SelectProps", "type", "value", "variant"];
const variantComponent = {
  standard: Input$1,
  filled: FilledInput$1,
  outlined: OutlinedInput$1
};
const useUtilityClasses = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTextFieldUtilityClass, classes);
};
const TextFieldRoot = styled(FormControl$1, {
  name: "MuiTextField",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const TextField = /* @__PURE__ */ reactExports.forwardRef(function TextField2(inProps, ref2) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTextField"
  });
  const {
    autoComplete,
    autoFocus = false,
    children,
    className,
    color: color2 = "primary",
    defaultValue,
    disabled = false,
    error = false,
    FormHelperTextProps,
    fullWidth = false,
    helperText,
    id: idOverride,
    InputLabelProps,
    inputProps,
    InputProps,
    inputRef,
    label,
    maxRows,
    minRows,
    multiline = false,
    name: name2,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    required = false,
    rows,
    select: select2 = false,
    SelectProps,
    type,
    value,
    variant = "outlined"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded);
  const ownerState = _extends$4({}, props, {
    autoFocus,
    color: color2,
    disabled,
    error,
    fullWidth,
    multiline,
    required,
    select: select2,
    variant
  });
  const classes = useUtilityClasses(ownerState);
  const InputMore = {};
  if (variant === "outlined") {
    if (InputLabelProps && typeof InputLabelProps.shrink !== "undefined") {
      InputMore.notched = InputLabelProps.shrink;
    }
    InputMore.label = label;
  }
  if (select2) {
    if (!SelectProps || !SelectProps.native) {
      InputMore.id = void 0;
    }
    InputMore["aria-describedby"] = void 0;
  }
  const id2 = useId(idOverride);
  const helperTextId = helperText && id2 ? `${id2}-helper-text` : void 0;
  const inputLabelId = label && id2 ? `${id2}-label` : void 0;
  const InputComponent = variantComponent[variant];
  const InputElement = /* @__PURE__ */ jsxRuntimeExports.jsx(InputComponent, _extends$4({
    "aria-describedby": helperTextId,
    autoComplete,
    autoFocus,
    defaultValue,
    fullWidth,
    multiline,
    name: name2,
    rows,
    maxRows,
    minRows,
    type,
    value,
    id: id2,
    inputRef,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    inputProps
  }, InputMore, InputProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TextFieldRoot, _extends$4({
    className: clsx(classes.root, className),
    disabled,
    error,
    fullWidth,
    ref: ref2,
    required,
    color: color2,
    variant,
    ownerState
  }, other, {
    children: [label != null && label !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$1, _extends$4({
      htmlFor: id2,
      id: inputLabelId
    }, InputLabelProps, {
      children: label
    })), select2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1, _extends$4({
      "aria-describedby": helperTextId,
      id: id2,
      labelId: inputLabelId,
      value,
      input: InputElement
    }, SelectProps, {
      children
    })) : InputElement, helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperText$1, _extends$4({
      id: helperTextId
    }, FormHelperTextProps, {
      children: helperText
    }))]
  }));
});
const TextField$1 = TextField;
const colorTokens = () => ({
  orange: {
    100: "#fde4cd",
    200: "#fbc99b",
    300: "#f9af69",
    400: "#f79437",
    500: "#f57905",
    600: "#c46104",
    700: "#934903",
    800: "#623002",
    900: "#311801"
  },
  black: {
    100: "#cccccc",
    200: "#999999",
    300: "#666666",
    400: "#333333",
    500: "#000000",
    600: "#000000",
    700: "#000000",
    800: "#000000",
    900: "#000000"
  },
  yellow: {
    100: "#ffe8cc",
    200: "#ffd199",
    300: "#ffba66",
    400: "#ffa333",
    500: "#ff8c00",
    600: "#cc7000",
    700: "#995400",
    800: "#663800",
    900: "#331c00"
  },
  white: {
    100: "#ffffff",
    200: "#ffffff",
    300: "#ffffff",
    400: "#ffffff",
    500: "#ffffff",
    600: "#cccccc",
    700: "#999999",
    800: "#666666",
    900: "#333333"
  }
});
const themeSetting = () => {
  const colors2 = colorTokens();
  return {
    palette: {
      primary: {
        main: colors2.orange[500]
      },
      secondary: {
        main: colors2.yellow[500]
      },
      info: {
        main: colors2.white[500]
      },
      background: {
        default: colors2.black[500]
      }
    },
    typography: {
      fontFamily: ["Roboto", "sans-serif", "Oswald"].join(","),
      fontSize: 12,
      h1: {
        fontFamily: ["Roboto", "sans-serif", "Oswald"].join(","),
        fontSize: 40
      },
      h2: {
        fontFamily: ["Roboto", "sans-serif", "Oswald"].join(","),
        fontSize: 32
      },
      h3: {
        fontFamily: ["Roboto", "sans-serif", "Oswald"].join(","),
        fontSize: 24
      },
      h4: {
        fontFamily: ["Roboto", "sans-serif", "Oswald"].join(","),
        fontSize: 20
      },
      h5: {
        fontFamily: ["Roboto", "sans-serif", "Oswald"].join(","),
        fontSize: 16
      },
      h6: {
        fontFamily: ["Roboto", "sans-serif", "Oswald"].join(","),
        fontSize: 14
      }
    },
    components: {
      MuiIconButton: {
        defaultProps: {
          size: "small"
        }
      },
      MuiButton: {
        styleOverrides: {
          root: {
            textTransform: "none"
            // Set textTransform to "none"
          }
        }
      }
    }
  };
};
const theme = createTheme(themeSetting());
const SelectItem = ({ value, handleChange, label, menus }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl$1, { fullWidth: true, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel$1, { id: `${label}-label`, children: label }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Select$1,
      {
        labelId: `${label}-label`,
        id: label,
        value,
        label,
        onChange: handleChange,
        children: menus.map((e2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { value: e2[0], children: e2[1] }, index2))
      }
    )
  ] });
};
class NodeJSCache {
  constructor(nodeCache2) {
    this.nodeCache = nodeCache2;
  }
  async get(key2) {
    return this.nodeCache.get(key2);
  }
  async set(key2, value) {
    return this.nodeCache.set(key2, value);
  }
  async has(key2) {
    return this.nodeCache.has(key2);
  }
}
class NullLogger {
  constructor() {
    this.ERROR_MESSAGE = 'NullLogger does not support. Instantiate a valid logger using "setGlobalLogger"';
    this.src = true;
  }
  addStream(_stream) {
    throw new Error(this.ERROR_MESSAGE);
  }
  addSerializers(_serializers) {
    throw new Error(this.ERROR_MESSAGE);
  }
  child(_options, _simple) {
    return this;
  }
  reopenFileStreams() {
    throw new Error(this.ERROR_MESSAGE);
  }
  level(_value) {
    return;
  }
  levels(_name, _value) {
    return;
  }
  trace(..._rest) {
    return true;
  }
  debug(..._rest) {
    return true;
  }
  info(..._rest) {
    return true;
  }
  warn(..._rest) {
    return true;
  }
  error(..._rest) {
    return true;
  }
  fatal(..._rest) {
    return true;
  }
  addListener(_event, _listener) {
    throw new Error(this.ERROR_MESSAGE);
  }
  on(_event, _listener) {
    throw new Error(this.ERROR_MESSAGE);
  }
  once(_event, _listener) {
    throw new Error(this.ERROR_MESSAGE);
  }
  removeListener(_event, _listener) {
    throw new Error(this.ERROR_MESSAGE);
  }
  off(_event, _listener) {
    throw new Error(this.ERROR_MESSAGE);
  }
  removeAllListeners(_event) {
    throw new Error(this.ERROR_MESSAGE);
  }
  setMaxListeners(_n) {
    throw new Error(this.ERROR_MESSAGE);
  }
  getMaxListeners() {
    throw new Error(this.ERROR_MESSAGE);
  }
  listeners(_event) {
    throw new Error(this.ERROR_MESSAGE);
  }
  rawListeners(_event) {
    throw new Error(this.ERROR_MESSAGE);
  }
  emit(_event, ..._args) {
    throw new Error(this.ERROR_MESSAGE);
  }
  listenerCount(_event) {
    throw new Error(this.ERROR_MESSAGE);
  }
  prependListener(_event, _listener) {
    throw new Error(this.ERROR_MESSAGE);
  }
  prependOnceListener(_event, _listener) {
    throw new Error(this.ERROR_MESSAGE);
  }
  eventNames() {
    throw new Error(this.ERROR_MESSAGE);
  }
}
let log = new NullLogger();
class CachingGasStationProvider {
  /**
   * Creates an instance of CachingGasStationProvider.
   * @param chainId The chain id to use.
   * @param gasPriceProvider The provider to use to get the gas price when not in the cache.
   * @param cache Cache instance to hold cached pools.
   */
  constructor(chainId2, gasPriceProvider, cache) {
    this.chainId = chainId2;
    this.gasPriceProvider = gasPriceProvider;
    this.cache = cache;
    this.GAS_KEY = (chainId3) => `gasPrice-${chainId3}`;
  }
  async getGasPrice() {
    const cachedGasPrice = await this.cache.get(this.GAS_KEY(this.chainId));
    if (cachedGasPrice) {
      log.info({ cachedGasPrice }, `Got gas station price from local cache: ${cachedGasPrice.gasPriceWei}.`);
      return cachedGasPrice;
    }
    log.info("Gas station price local cache miss.");
    const gasPrice = await this.gasPriceProvider.getGasPrice();
    await this.cache.set(this.GAS_KEY(this.chainId), gasPrice);
    return gasPrice;
  }
}
class JSBI extends Array {
  constructor(i3, _2) {
    if (super(i3), this.sign = _2, i3 > JSBI.__kMaxLength)
      throw new RangeError("Maximum BigInt size exceeded");
  }
  static BigInt(i3) {
    var _2 = Math.floor, t2 = Number.isFinite;
    if ("number" == typeof i3) {
      if (0 === i3)
        return JSBI.__zero();
      if (JSBI.__isOneDigitInt(i3))
        return 0 > i3 ? JSBI.__oneDigit(-i3, true) : JSBI.__oneDigit(i3, false);
      if (!t2(i3) || _2(i3) !== i3)
        throw new RangeError("The number " + i3 + " cannot be converted to BigInt because it is not an integer");
      return JSBI.__fromDouble(i3);
    }
    if ("string" == typeof i3) {
      const _3 = JSBI.__fromString(i3);
      if (null === _3)
        throw new SyntaxError("Cannot convert " + i3 + " to a BigInt");
      return _3;
    }
    if ("boolean" == typeof i3)
      return true === i3 ? JSBI.__oneDigit(1, false) : JSBI.__zero();
    if ("object" == typeof i3) {
      if (i3.constructor === JSBI)
        return i3;
      const _3 = JSBI.__toPrimitive(i3);
      return JSBI.BigInt(_3);
    }
    throw new TypeError("Cannot convert " + i3 + " to a BigInt");
  }
  toDebugString() {
    const i3 = ["BigInt["];
    for (const _2 of this)
      i3.push((_2 ? (_2 >>> 0).toString(16) : _2) + ", ");
    return i3.push("]"), i3.join("");
  }
  toString(i3 = 10) {
    if (2 > i3 || 36 < i3)
      throw new RangeError("toString() radix argument must be between 2 and 36");
    return 0 === this.length ? "0" : 0 == (i3 & i3 - 1) ? JSBI.__toStringBasePowerOfTwo(this, i3) : JSBI.__toStringGeneric(this, i3, false);
  }
  static toNumber(i3) {
    const _2 = i3.length;
    if (0 === _2)
      return 0;
    if (1 === _2) {
      const _3 = i3.__unsignedDigit(0);
      return i3.sign ? -_3 : _3;
    }
    const t2 = i3.__digit(_2 - 1), e2 = JSBI.__clz30(t2), n4 = 30 * _2 - e2;
    if (1024 < n4)
      return i3.sign ? -Infinity : 1 / 0;
    let g2 = n4 - 1, o2 = t2, s4 = _2 - 1;
    const l2 = e2 + 3;
    let r2 = 32 === l2 ? 0 : o2 << l2;
    r2 >>>= 12;
    const a2 = l2 - 12;
    let u2 = 12 <= l2 ? 0 : o2 << 20 + l2, d2 = 20 + l2;
    for (0 < a2 && 0 < s4 && (s4--, o2 = i3.__digit(s4), r2 |= o2 >>> 30 - a2, u2 = o2 << a2 + 2, d2 = a2 + 2); 0 < d2 && 0 < s4; )
      s4--, o2 = i3.__digit(s4), u2 |= 30 <= d2 ? o2 << d2 - 30 : o2 >>> 30 - d2, d2 -= 30;
    const h4 = JSBI.__decideRounding(i3, d2, s4, o2);
    if ((1 === h4 || 0 === h4 && 1 == (1 & u2)) && (u2 = u2 + 1 >>> 0, 0 === u2 && (r2++, 0 != r2 >>> 20 && (r2 = 0, g2++, 1023 < g2))))
      return i3.sign ? -Infinity : 1 / 0;
    const m2 = i3.sign ? -2147483648 : 0;
    return g2 = g2 + 1023 << 20, JSBI.__kBitConversionInts[1] = m2 | g2 | r2, JSBI.__kBitConversionInts[0] = u2, JSBI.__kBitConversionDouble[0];
  }
  static unaryMinus(i3) {
    if (0 === i3.length)
      return i3;
    const _2 = i3.__copy();
    return _2.sign = !i3.sign, _2;
  }
  static bitwiseNot(i3) {
    return i3.sign ? JSBI.__absoluteSubOne(i3).__trim() : JSBI.__absoluteAddOne(i3, true);
  }
  static exponentiate(i3, _2) {
    if (_2.sign)
      throw new RangeError("Exponent must be positive");
    if (0 === _2.length)
      return JSBI.__oneDigit(1, false);
    if (0 === i3.length)
      return i3;
    if (1 === i3.length && 1 === i3.__digit(0))
      return i3.sign && 0 == (1 & _2.__digit(0)) ? JSBI.unaryMinus(i3) : i3;
    if (1 < _2.length)
      throw new RangeError("BigInt too big");
    let t2 = _2.__unsignedDigit(0);
    if (1 === t2)
      return i3;
    if (t2 >= JSBI.__kMaxLengthBits)
      throw new RangeError("BigInt too big");
    if (1 === i3.length && 2 === i3.__digit(0)) {
      const _3 = 1 + (0 | t2 / 30), e3 = i3.sign && 0 != (1 & t2), n5 = new JSBI(_3, e3);
      n5.__initializeDigits();
      const g2 = 1 << t2 % 30;
      return n5.__setDigit(_3 - 1, g2), n5;
    }
    let e2 = null, n4 = i3;
    for (0 != (1 & t2) && (e2 = i3), t2 >>= 1; 0 !== t2; t2 >>= 1)
      n4 = JSBI.multiply(n4, n4), 0 != (1 & t2) && (null === e2 ? e2 = n4 : e2 = JSBI.multiply(e2, n4));
    return e2;
  }
  static multiply(_2, t2) {
    if (0 === _2.length)
      return _2;
    if (0 === t2.length)
      return t2;
    let i3 = _2.length + t2.length;
    30 <= _2.__clzmsd() + t2.__clzmsd() && i3--;
    const e2 = new JSBI(i3, _2.sign !== t2.sign);
    e2.__initializeDigits();
    for (let n4 = 0; n4 < _2.length; n4++)
      JSBI.__multiplyAccumulate(t2, _2.__digit(n4), e2, n4);
    return e2.__trim();
  }
  static divide(i3, _2) {
    if (0 === _2.length)
      throw new RangeError("Division by zero");
    if (0 > JSBI.__absoluteCompare(i3, _2))
      return JSBI.__zero();
    const t2 = i3.sign !== _2.sign, e2 = _2.__unsignedDigit(0);
    let n4;
    if (1 === _2.length && 32767 >= e2) {
      if (1 === e2)
        return t2 === i3.sign ? i3 : JSBI.unaryMinus(i3);
      n4 = JSBI.__absoluteDivSmall(i3, e2, null);
    } else
      n4 = JSBI.__absoluteDivLarge(i3, _2, true, false);
    return n4.sign = t2, n4.__trim();
  }
  static remainder(i3, _2) {
    if (0 === _2.length)
      throw new RangeError("Division by zero");
    if (0 > JSBI.__absoluteCompare(i3, _2))
      return i3;
    const t2 = _2.__unsignedDigit(0);
    if (1 === _2.length && 32767 >= t2) {
      if (1 === t2)
        return JSBI.__zero();
      const _3 = JSBI.__absoluteModSmall(i3, t2);
      return 0 === _3 ? JSBI.__zero() : JSBI.__oneDigit(_3, i3.sign);
    }
    const e2 = JSBI.__absoluteDivLarge(i3, _2, false, true);
    return e2.sign = i3.sign, e2.__trim();
  }
  static add(i3, _2) {
    const t2 = i3.sign;
    return t2 === _2.sign ? JSBI.__absoluteAdd(i3, _2, t2) : 0 <= JSBI.__absoluteCompare(i3, _2) ? JSBI.__absoluteSub(i3, _2, t2) : JSBI.__absoluteSub(_2, i3, !t2);
  }
  static subtract(i3, _2) {
    const t2 = i3.sign;
    return t2 === _2.sign ? 0 <= JSBI.__absoluteCompare(i3, _2) ? JSBI.__absoluteSub(i3, _2, t2) : JSBI.__absoluteSub(_2, i3, !t2) : JSBI.__absoluteAdd(i3, _2, t2);
  }
  static leftShift(i3, _2) {
    return 0 === _2.length || 0 === i3.length ? i3 : _2.sign ? JSBI.__rightShiftByAbsolute(i3, _2) : JSBI.__leftShiftByAbsolute(i3, _2);
  }
  static signedRightShift(i3, _2) {
    return 0 === _2.length || 0 === i3.length ? i3 : _2.sign ? JSBI.__leftShiftByAbsolute(i3, _2) : JSBI.__rightShiftByAbsolute(i3, _2);
  }
  static unsignedRightShift() {
    throw new TypeError("BigInts have no unsigned right shift; use >> instead");
  }
  static lessThan(i3, _2) {
    return 0 > JSBI.__compareToBigInt(i3, _2);
  }
  static lessThanOrEqual(i3, _2) {
    return 0 >= JSBI.__compareToBigInt(i3, _2);
  }
  static greaterThan(i3, _2) {
    return 0 < JSBI.__compareToBigInt(i3, _2);
  }
  static greaterThanOrEqual(i3, _2) {
    return 0 <= JSBI.__compareToBigInt(i3, _2);
  }
  static equal(_2, t2) {
    if (_2.sign !== t2.sign)
      return false;
    if (_2.length !== t2.length)
      return false;
    for (let e2 = 0; e2 < _2.length; e2++)
      if (_2.__digit(e2) !== t2.__digit(e2))
        return false;
    return true;
  }
  static notEqual(i3, _2) {
    return !JSBI.equal(i3, _2);
  }
  static bitwiseAnd(i3, _2) {
    var t2 = Math.max;
    if (!i3.sign && !_2.sign)
      return JSBI.__absoluteAnd(i3, _2).__trim();
    if (i3.sign && _2.sign) {
      const e2 = t2(i3.length, _2.length) + 1;
      let n4 = JSBI.__absoluteSubOne(i3, e2);
      const g2 = JSBI.__absoluteSubOne(_2);
      return n4 = JSBI.__absoluteOr(n4, g2, n4), JSBI.__absoluteAddOne(n4, true, n4).__trim();
    }
    return i3.sign && ([i3, _2] = [_2, i3]), JSBI.__absoluteAndNot(i3, JSBI.__absoluteSubOne(_2)).__trim();
  }
  static bitwiseXor(i3, _2) {
    var t2 = Math.max;
    if (!i3.sign && !_2.sign)
      return JSBI.__absoluteXor(i3, _2).__trim();
    if (i3.sign && _2.sign) {
      const e3 = t2(i3.length, _2.length), n5 = JSBI.__absoluteSubOne(i3, e3), g2 = JSBI.__absoluteSubOne(_2);
      return JSBI.__absoluteXor(n5, g2, n5).__trim();
    }
    const e2 = t2(i3.length, _2.length) + 1;
    i3.sign && ([i3, _2] = [_2, i3]);
    let n4 = JSBI.__absoluteSubOne(_2, e2);
    return n4 = JSBI.__absoluteXor(n4, i3, n4), JSBI.__absoluteAddOne(n4, true, n4).__trim();
  }
  static bitwiseOr(i3, _2) {
    var t2 = Math.max;
    const e2 = t2(i3.length, _2.length);
    if (!i3.sign && !_2.sign)
      return JSBI.__absoluteOr(i3, _2).__trim();
    if (i3.sign && _2.sign) {
      let t3 = JSBI.__absoluteSubOne(i3, e2);
      const n5 = JSBI.__absoluteSubOne(_2);
      return t3 = JSBI.__absoluteAnd(t3, n5, t3), JSBI.__absoluteAddOne(t3, true, t3).__trim();
    }
    i3.sign && ([i3, _2] = [_2, i3]);
    let n4 = JSBI.__absoluteSubOne(_2, e2);
    return n4 = JSBI.__absoluteAndNot(n4, i3, n4), JSBI.__absoluteAddOne(n4, true, n4).__trim();
  }
  static asIntN(_2, t2) {
    var i3 = Math.floor;
    if (0 === t2.length)
      return t2;
    if (_2 = i3(_2), 0 > _2)
      throw new RangeError("Invalid value: not (convertible to) a safe integer");
    if (0 === _2)
      return JSBI.__zero();
    if (_2 >= JSBI.__kMaxLengthBits)
      return t2;
    const e2 = 0 | (_2 + 29) / 30;
    if (t2.length < e2)
      return t2;
    const g2 = t2.__unsignedDigit(e2 - 1), o2 = 1 << (_2 - 1) % 30;
    if (t2.length === e2 && g2 < o2)
      return t2;
    if (!((g2 & o2) === o2))
      return JSBI.__truncateToNBits(_2, t2);
    if (!t2.sign)
      return JSBI.__truncateAndSubFromPowerOfTwo(_2, t2, true);
    if (0 == (g2 & o2 - 1)) {
      for (let n4 = e2 - 2; 0 <= n4; n4--)
        if (0 !== t2.__digit(n4))
          return JSBI.__truncateAndSubFromPowerOfTwo(_2, t2, false);
      return t2.length === e2 && g2 === o2 ? t2 : JSBI.__truncateToNBits(_2, t2);
    }
    return JSBI.__truncateAndSubFromPowerOfTwo(_2, t2, false);
  }
  static asUintN(i3, _2) {
    var t2 = Math.floor;
    if (0 === _2.length)
      return _2;
    if (i3 = t2(i3), 0 > i3)
      throw new RangeError("Invalid value: not (convertible to) a safe integer");
    if (0 === i3)
      return JSBI.__zero();
    if (_2.sign) {
      if (i3 > JSBI.__kMaxLengthBits)
        throw new RangeError("BigInt too big");
      return JSBI.__truncateAndSubFromPowerOfTwo(i3, _2, false);
    }
    if (i3 >= JSBI.__kMaxLengthBits)
      return _2;
    const e2 = 0 | (i3 + 29) / 30;
    if (_2.length < e2)
      return _2;
    const g2 = i3 % 30;
    if (_2.length == e2) {
      if (0 === g2)
        return _2;
      const i4 = _2.__digit(e2 - 1);
      if (0 == i4 >>> g2)
        return _2;
    }
    return JSBI.__truncateToNBits(i3, _2);
  }
  static ADD(i3, _2) {
    if (i3 = JSBI.__toPrimitive(i3), _2 = JSBI.__toPrimitive(_2), "string" == typeof i3)
      return "string" != typeof _2 && (_2 = _2.toString()), i3 + _2;
    if ("string" == typeof _2)
      return i3.toString() + _2;
    if (i3 = JSBI.__toNumeric(i3), _2 = JSBI.__toNumeric(_2), JSBI.__isBigInt(i3) && JSBI.__isBigInt(_2))
      return JSBI.add(i3, _2);
    if ("number" == typeof i3 && "number" == typeof _2)
      return i3 + _2;
    throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
  }
  static LT(i3, _2) {
    return JSBI.__compare(i3, _2, 0);
  }
  static LE(i3, _2) {
    return JSBI.__compare(i3, _2, 1);
  }
  static GT(i3, _2) {
    return JSBI.__compare(i3, _2, 2);
  }
  static GE(i3, _2) {
    return JSBI.__compare(i3, _2, 3);
  }
  static EQ(i3, _2) {
    for (; ; ) {
      if (JSBI.__isBigInt(i3))
        return JSBI.__isBigInt(_2) ? JSBI.equal(i3, _2) : JSBI.EQ(_2, i3);
      if ("number" == typeof i3) {
        if (JSBI.__isBigInt(_2))
          return JSBI.__equalToNumber(_2, i3);
        if ("object" != typeof _2)
          return i3 == _2;
        _2 = JSBI.__toPrimitive(_2);
      } else if ("string" == typeof i3) {
        if (JSBI.__isBigInt(_2))
          return i3 = JSBI.__fromString(i3), null !== i3 && JSBI.equal(i3, _2);
        if ("object" != typeof _2)
          return i3 == _2;
        _2 = JSBI.__toPrimitive(_2);
      } else if ("boolean" == typeof i3) {
        if (JSBI.__isBigInt(_2))
          return JSBI.__equalToNumber(_2, +i3);
        if ("object" != typeof _2)
          return i3 == _2;
        _2 = JSBI.__toPrimitive(_2);
      } else if ("symbol" == typeof i3) {
        if (JSBI.__isBigInt(_2))
          return false;
        if ("object" != typeof _2)
          return i3 == _2;
        _2 = JSBI.__toPrimitive(_2);
      } else if ("object" == typeof i3) {
        if ("object" == typeof _2 && _2.constructor !== JSBI)
          return i3 == _2;
        i3 = JSBI.__toPrimitive(i3);
      } else
        return i3 == _2;
    }
  }
  static NE(i3, _2) {
    return !JSBI.EQ(i3, _2);
  }
  static __zero() {
    return new JSBI(0, false);
  }
  static __oneDigit(i3, _2) {
    const t2 = new JSBI(1, _2);
    return t2.__setDigit(0, i3), t2;
  }
  __copy() {
    const _2 = new JSBI(this.length, this.sign);
    for (let t2 = 0; t2 < this.length; t2++)
      _2[t2] = this[t2];
    return _2;
  }
  __trim() {
    let i3 = this.length, _2 = this[i3 - 1];
    for (; 0 === _2; )
      i3--, _2 = this[i3 - 1], this.pop();
    return 0 === i3 && (this.sign = false), this;
  }
  __initializeDigits() {
    for (let _2 = 0; _2 < this.length; _2++)
      this[_2] = 0;
  }
  static __decideRounding(i3, _2, t2, e2) {
    if (0 < _2)
      return -1;
    let n4;
    if (0 > _2)
      n4 = -_2 - 1;
    else {
      if (0 === t2)
        return -1;
      t2--, e2 = i3.__digit(t2), n4 = 29;
    }
    let g2 = 1 << n4;
    if (0 == (e2 & g2))
      return -1;
    if (g2 -= 1, 0 != (e2 & g2))
      return 1;
    for (; 0 < t2; )
      if (t2--, 0 !== i3.__digit(t2))
        return 1;
    return 0;
  }
  static __fromDouble(i3) {
    JSBI.__kBitConversionDouble[0] = i3;
    const _2 = 2047 & JSBI.__kBitConversionInts[1] >>> 20, t2 = _2 - 1023, e2 = (0 | t2 / 30) + 1, n4 = new JSBI(e2, 0 > i3);
    let g2 = 1048575 & JSBI.__kBitConversionInts[1] | 1048576, o2 = JSBI.__kBitConversionInts[0];
    const s4 = 20, l2 = t2 % 30;
    let r2, a2 = 0;
    if (l2 < 20) {
      const i4 = s4 - l2;
      a2 = i4 + 32, r2 = g2 >>> i4, g2 = g2 << 32 - i4 | o2 >>> i4, o2 <<= 32 - i4;
    } else if (l2 === 20)
      a2 = 32, r2 = g2, g2 = o2, o2 = 0;
    else {
      const i4 = l2 - s4;
      a2 = 32 - i4, r2 = g2 << i4 | o2 >>> 32 - i4, g2 = o2 << i4, o2 = 0;
    }
    n4.__setDigit(e2 - 1, r2);
    for (let _3 = e2 - 2; 0 <= _3; _3--)
      0 < a2 ? (a2 -= 30, r2 = g2 >>> 2, g2 = g2 << 30 | o2 >>> 2, o2 <<= 30) : r2 = 0, n4.__setDigit(_3, r2);
    return n4.__trim();
  }
  static __isWhitespace(i3) {
    return !!(13 >= i3 && 9 <= i3) || (159 >= i3 ? 32 == i3 : 131071 >= i3 ? 160 == i3 || 5760 == i3 : 196607 >= i3 ? (i3 &= 131071, 10 >= i3 || 40 == i3 || 41 == i3 || 47 == i3 || 95 == i3 || 4096 == i3) : 65279 == i3);
  }
  static __fromString(i3, _2 = 0) {
    let t2 = 0;
    const e2 = i3.length;
    let n4 = 0;
    if (n4 === e2)
      return JSBI.__zero();
    let g2 = i3.charCodeAt(n4);
    for (; JSBI.__isWhitespace(g2); ) {
      if (++n4 === e2)
        return JSBI.__zero();
      g2 = i3.charCodeAt(n4);
    }
    if (43 === g2) {
      if (++n4 === e2)
        return null;
      g2 = i3.charCodeAt(n4), t2 = 1;
    } else if (45 === g2) {
      if (++n4 === e2)
        return null;
      g2 = i3.charCodeAt(n4), t2 = -1;
    }
    if (0 === _2) {
      if (_2 = 10, 48 === g2) {
        if (++n4 === e2)
          return JSBI.__zero();
        if (g2 = i3.charCodeAt(n4), 88 === g2 || 120 === g2) {
          if (_2 = 16, ++n4 === e2)
            return null;
          g2 = i3.charCodeAt(n4);
        } else if (79 === g2 || 111 === g2) {
          if (_2 = 8, ++n4 === e2)
            return null;
          g2 = i3.charCodeAt(n4);
        } else if (66 === g2 || 98 === g2) {
          if (_2 = 2, ++n4 === e2)
            return null;
          g2 = i3.charCodeAt(n4);
        }
      }
    } else if (16 === _2 && 48 === g2) {
      if (++n4 === e2)
        return JSBI.__zero();
      if (g2 = i3.charCodeAt(n4), 88 === g2 || 120 === g2) {
        if (++n4 === e2)
          return null;
        g2 = i3.charCodeAt(n4);
      }
    }
    if (0 != t2 && 10 !== _2)
      return null;
    for (; 48 === g2; ) {
      if (++n4 === e2)
        return JSBI.__zero();
      g2 = i3.charCodeAt(n4);
    }
    const o2 = e2 - n4;
    let s4 = JSBI.__kMaxBitsPerChar[_2], l2 = JSBI.__kBitsPerCharTableMultiplier - 1;
    if (o2 > 1073741824 / s4)
      return null;
    const r2 = s4 * o2 + l2 >>> JSBI.__kBitsPerCharTableShift, a2 = new JSBI(0 | (r2 + 29) / 30, false), u2 = 10 > _2 ? _2 : 10, h4 = 10 < _2 ? _2 - 10 : 0;
    if (0 == (_2 & _2 - 1)) {
      s4 >>= JSBI.__kBitsPerCharTableShift;
      const _3 = [], t3 = [];
      let o3 = false;
      do {
        let l3 = 0, r3 = 0;
        for (; ; ) {
          let _4;
          if (g2 - 48 >>> 0 < u2)
            _4 = g2 - 48;
          else if ((32 | g2) - 97 >>> 0 < h4)
            _4 = (32 | g2) - 87;
          else {
            o3 = true;
            break;
          }
          if (r3 += s4, l3 = l3 << s4 | _4, ++n4 === e2) {
            o3 = true;
            break;
          }
          if (g2 = i3.charCodeAt(n4), 30 < r3 + s4)
            break;
        }
        _3.push(l3), t3.push(r3);
      } while (!o3);
      JSBI.__fillFromParts(a2, _3, t3);
    } else {
      a2.__initializeDigits();
      let t3 = false, o3 = 0;
      do {
        let r3 = 0, b3 = 1;
        for (; ; ) {
          let s5;
          if (g2 - 48 >>> 0 < u2)
            s5 = g2 - 48;
          else if ((32 | g2) - 97 >>> 0 < h4)
            s5 = (32 | g2) - 87;
          else {
            t3 = true;
            break;
          }
          const l3 = b3 * _2;
          if (1073741823 < l3)
            break;
          if (b3 = l3, r3 = r3 * _2 + s5, o3++, ++n4 === e2) {
            t3 = true;
            break;
          }
          g2 = i3.charCodeAt(n4);
        }
        l2 = 30 * JSBI.__kBitsPerCharTableMultiplier - 1;
        const D2 = 0 | (s4 * o3 + l2 >>> JSBI.__kBitsPerCharTableShift) / 30;
        a2.__inplaceMultiplyAdd(b3, r3, D2);
      } while (!t3);
    }
    if (n4 !== e2) {
      if (!JSBI.__isWhitespace(g2))
        return null;
      for (n4++; n4 < e2; n4++)
        if (g2 = i3.charCodeAt(n4), !JSBI.__isWhitespace(g2))
          return null;
    }
    return a2.sign = -1 == t2, a2.__trim();
  }
  static __fillFromParts(_2, t2, e2) {
    let n4 = 0, g2 = 0, o2 = 0;
    for (let s4 = t2.length - 1; 0 <= s4; s4--) {
      const i3 = t2[s4], l2 = e2[s4];
      g2 |= i3 << o2, o2 += l2, 30 === o2 ? (_2.__setDigit(n4++, g2), o2 = 0, g2 = 0) : 30 < o2 && (_2.__setDigit(n4++, 1073741823 & g2), o2 -= 30, g2 = i3 >>> l2 - o2);
    }
    if (0 !== g2) {
      if (n4 >= _2.length)
        throw new Error("implementation bug");
      _2.__setDigit(n4++, g2);
    }
    for (; n4 < _2.length; n4++)
      _2.__setDigit(n4, 0);
  }
  static __toStringBasePowerOfTwo(_2, i3) {
    const t2 = _2.length;
    let e2 = i3 - 1;
    e2 = (85 & e2 >>> 1) + (85 & e2), e2 = (51 & e2 >>> 2) + (51 & e2), e2 = (15 & e2 >>> 4) + (15 & e2);
    const n4 = e2, g2 = i3 - 1, o2 = _2.__digit(t2 - 1), s4 = JSBI.__clz30(o2);
    let l2 = 0 | (30 * t2 - s4 + n4 - 1) / n4;
    if (_2.sign && l2++, 268435456 < l2)
      throw new Error("string too long");
    const r2 = Array(l2);
    let a2 = l2 - 1, u2 = 0, d2 = 0;
    for (let e3 = 0; e3 < t2 - 1; e3++) {
      const i4 = _2.__digit(e3), t3 = (u2 | i4 << d2) & g2;
      r2[a2--] = JSBI.__kConversionChars[t3];
      const o3 = n4 - d2;
      for (u2 = i4 >>> o3, d2 = 30 - o3; d2 >= n4; )
        r2[a2--] = JSBI.__kConversionChars[u2 & g2], u2 >>>= n4, d2 -= n4;
    }
    const h4 = (u2 | o2 << d2) & g2;
    for (r2[a2--] = JSBI.__kConversionChars[h4], u2 = o2 >>> n4 - d2; 0 !== u2; )
      r2[a2--] = JSBI.__kConversionChars[u2 & g2], u2 >>>= n4;
    if (_2.sign && (r2[a2--] = "-"), -1 != a2)
      throw new Error("implementation bug");
    return r2.join("");
  }
  static __toStringGeneric(_2, i3, t2) {
    const e2 = _2.length;
    if (0 === e2)
      return "";
    if (1 === e2) {
      let e3 = _2.__unsignedDigit(0).toString(i3);
      return false === t2 && _2.sign && (e3 = "-" + e3), e3;
    }
    const n4 = 30 * e2 - JSBI.__clz30(_2.__digit(e2 - 1)), g2 = JSBI.__kMaxBitsPerChar[i3], o2 = g2 - 1;
    let s4 = n4 * JSBI.__kBitsPerCharTableMultiplier;
    s4 += o2 - 1, s4 = 0 | s4 / o2;
    const l2 = s4 + 1 >> 1, r2 = JSBI.exponentiate(JSBI.__oneDigit(i3, false), JSBI.__oneDigit(l2, false));
    let a2, u2;
    const d2 = r2.__unsignedDigit(0);
    if (1 === r2.length && 32767 >= d2) {
      a2 = new JSBI(_2.length, false), a2.__initializeDigits();
      let t3 = 0;
      for (let e3 = 2 * _2.length - 1; 0 <= e3; e3--) {
        const i4 = t3 << 15 | _2.__halfDigit(e3);
        a2.__setHalfDigit(e3, 0 | i4 / d2), t3 = 0 | i4 % d2;
      }
      u2 = t3.toString(i3);
    } else {
      const t3 = JSBI.__absoluteDivLarge(_2, r2, true, true);
      a2 = t3.quotient;
      const e3 = t3.remainder.__trim();
      u2 = JSBI.__toStringGeneric(e3, i3, true);
    }
    a2.__trim();
    let h4 = JSBI.__toStringGeneric(a2, i3, true);
    for (; u2.length < l2; )
      u2 = "0" + u2;
    return false === t2 && _2.sign && (h4 = "-" + h4), h4 + u2;
  }
  static __unequalSign(i3) {
    return i3 ? -1 : 1;
  }
  static __absoluteGreater(i3) {
    return i3 ? -1 : 1;
  }
  static __absoluteLess(i3) {
    return i3 ? 1 : -1;
  }
  static __compareToBigInt(i3, _2) {
    const t2 = i3.sign;
    if (t2 !== _2.sign)
      return JSBI.__unequalSign(t2);
    const e2 = JSBI.__absoluteCompare(i3, _2);
    return 0 < e2 ? JSBI.__absoluteGreater(t2) : 0 > e2 ? JSBI.__absoluteLess(t2) : 0;
  }
  static __compareToNumber(i3, _2) {
    if (JSBI.__isOneDigitInt(_2)) {
      const t2 = i3.sign, e2 = 0 > _2;
      if (t2 !== e2)
        return JSBI.__unequalSign(t2);
      if (0 === i3.length) {
        if (e2)
          throw new Error("implementation bug");
        return 0 === _2 ? 0 : -1;
      }
      if (1 < i3.length)
        return JSBI.__absoluteGreater(t2);
      const n4 = Math.abs(_2), g2 = i3.__unsignedDigit(0);
      return g2 > n4 ? JSBI.__absoluteGreater(t2) : g2 < n4 ? JSBI.__absoluteLess(t2) : 0;
    }
    return JSBI.__compareToDouble(i3, _2);
  }
  static __compareToDouble(i3, _2) {
    if (_2 !== _2)
      return _2;
    if (_2 === 1 / 0)
      return -1;
    if (_2 === -Infinity)
      return 1;
    const t2 = i3.sign;
    if (t2 !== 0 > _2)
      return JSBI.__unequalSign(t2);
    if (0 === _2)
      throw new Error("implementation bug: should be handled elsewhere");
    if (0 === i3.length)
      return -1;
    JSBI.__kBitConversionDouble[0] = _2;
    const e2 = 2047 & JSBI.__kBitConversionInts[1] >>> 20;
    if (2047 == e2)
      throw new Error("implementation bug: handled elsewhere");
    const n4 = e2 - 1023;
    if (0 > n4)
      return JSBI.__absoluteGreater(t2);
    const g2 = i3.length;
    let o2 = i3.__digit(g2 - 1);
    const s4 = JSBI.__clz30(o2), l2 = 30 * g2 - s4, r2 = n4 + 1;
    if (l2 < r2)
      return JSBI.__absoluteLess(t2);
    if (l2 > r2)
      return JSBI.__absoluteGreater(t2);
    let a2 = 1048576 | 1048575 & JSBI.__kBitConversionInts[1], u2 = JSBI.__kBitConversionInts[0];
    const d2 = 20, h4 = 29 - s4;
    if (h4 !== (0 | (l2 - 1) % 30))
      throw new Error("implementation bug");
    let m2, b3 = 0;
    if (20 > h4) {
      const i4 = d2 - h4;
      b3 = i4 + 32, m2 = a2 >>> i4, a2 = a2 << 32 - i4 | u2 >>> i4, u2 <<= 32 - i4;
    } else if (20 === h4)
      b3 = 32, m2 = a2, a2 = u2;
    else {
      const i4 = h4 - d2;
      b3 = 32 - i4, m2 = a2 << i4 | u2 >>> 32 - i4, a2 = u2 << i4;
    }
    if (o2 >>>= 0, m2 >>>= 0, o2 > m2)
      return JSBI.__absoluteGreater(t2);
    if (o2 < m2)
      return JSBI.__absoluteLess(t2);
    for (let e3 = g2 - 2; 0 <= e3; e3--) {
      0 < b3 ? (b3 -= 30, m2 = a2 >>> 2, a2 = a2 << 30 | u2 >>> 2, u2 <<= 30) : m2 = 0;
      const _3 = i3.__unsignedDigit(e3);
      if (_3 > m2)
        return JSBI.__absoluteGreater(t2);
      if (_3 < m2)
        return JSBI.__absoluteLess(t2);
    }
    if (0 !== a2 || 0 !== u2) {
      if (0 === b3)
        throw new Error("implementation bug");
      return JSBI.__absoluteLess(t2);
    }
    return 0;
  }
  static __equalToNumber(i3, _2) {
    var t2 = Math.abs;
    return JSBI.__isOneDigitInt(_2) ? 0 === _2 ? 0 === i3.length : 1 === i3.length && i3.sign === 0 > _2 && i3.__unsignedDigit(0) === t2(_2) : 0 === JSBI.__compareToDouble(i3, _2);
  }
  static __comparisonResultToBool(i3, _2) {
    return 0 === _2 ? 0 > i3 : 1 === _2 ? 0 >= i3 : 2 === _2 ? 0 < i3 : 3 === _2 ? 0 <= i3 : void 0;
  }
  static __compare(i3, _2, t2) {
    if (i3 = JSBI.__toPrimitive(i3), _2 = JSBI.__toPrimitive(_2), "string" == typeof i3 && "string" == typeof _2)
      switch (t2) {
        case 0:
          return i3 < _2;
        case 1:
          return i3 <= _2;
        case 2:
          return i3 > _2;
        case 3:
          return i3 >= _2;
      }
    if (JSBI.__isBigInt(i3) && "string" == typeof _2)
      return _2 = JSBI.__fromString(_2), null !== _2 && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i3, _2), t2);
    if ("string" == typeof i3 && JSBI.__isBigInt(_2))
      return i3 = JSBI.__fromString(i3), null !== i3 && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i3, _2), t2);
    if (i3 = JSBI.__toNumeric(i3), _2 = JSBI.__toNumeric(_2), JSBI.__isBigInt(i3)) {
      if (JSBI.__isBigInt(_2))
        return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i3, _2), t2);
      if ("number" != typeof _2)
        throw new Error("implementation bug");
      return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(i3, _2), t2);
    }
    if ("number" != typeof i3)
      throw new Error("implementation bug");
    if (JSBI.__isBigInt(_2))
      return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(_2, i3), 2 ^ t2);
    if ("number" != typeof _2)
      throw new Error("implementation bug");
    return 0 === t2 ? i3 < _2 : 1 === t2 ? i3 <= _2 : 2 === t2 ? i3 > _2 : 3 === t2 ? i3 >= _2 : void 0;
  }
  __clzmsd() {
    return JSBI.__clz30(this.__digit(this.length - 1));
  }
  static __absoluteAdd(_2, t2, e2) {
    if (_2.length < t2.length)
      return JSBI.__absoluteAdd(t2, _2, e2);
    if (0 === _2.length)
      return _2;
    if (0 === t2.length)
      return _2.sign === e2 ? _2 : JSBI.unaryMinus(_2);
    let n4 = _2.length;
    (0 === _2.__clzmsd() || t2.length === _2.length && 0 === t2.__clzmsd()) && n4++;
    const g2 = new JSBI(n4, e2);
    let o2 = 0, s4 = 0;
    for (; s4 < t2.length; s4++) {
      const i3 = _2.__digit(s4) + t2.__digit(s4) + o2;
      o2 = i3 >>> 30, g2.__setDigit(s4, 1073741823 & i3);
    }
    for (; s4 < _2.length; s4++) {
      const i3 = _2.__digit(s4) + o2;
      o2 = i3 >>> 30, g2.__setDigit(s4, 1073741823 & i3);
    }
    return s4 < g2.length && g2.__setDigit(s4, o2), g2.__trim();
  }
  static __absoluteSub(_2, t2, e2) {
    if (0 === _2.length)
      return _2;
    if (0 === t2.length)
      return _2.sign === e2 ? _2 : JSBI.unaryMinus(_2);
    const n4 = new JSBI(_2.length, e2);
    let g2 = 0, o2 = 0;
    for (; o2 < t2.length; o2++) {
      const i3 = _2.__digit(o2) - t2.__digit(o2) - g2;
      g2 = 1 & i3 >>> 30, n4.__setDigit(o2, 1073741823 & i3);
    }
    for (; o2 < _2.length; o2++) {
      const i3 = _2.__digit(o2) - g2;
      g2 = 1 & i3 >>> 30, n4.__setDigit(o2, 1073741823 & i3);
    }
    return n4.__trim();
  }
  static __absoluteAddOne(_2, i3, t2 = null) {
    const e2 = _2.length;
    null === t2 ? t2 = new JSBI(e2, i3) : t2.sign = i3;
    let n4 = 1;
    for (let g2 = 0; g2 < e2; g2++) {
      const i4 = _2.__digit(g2) + n4;
      n4 = i4 >>> 30, t2.__setDigit(g2, 1073741823 & i4);
    }
    return 0 != n4 && t2.__setDigitGrow(e2, 1), t2;
  }
  static __absoluteSubOne(_2, t2) {
    const e2 = _2.length;
    t2 = t2 || e2;
    const n4 = new JSBI(t2, false);
    let g2 = 1;
    for (let o2 = 0; o2 < e2; o2++) {
      const i3 = _2.__digit(o2) - g2;
      g2 = 1 & i3 >>> 30, n4.__setDigit(o2, 1073741823 & i3);
    }
    if (0 != g2)
      throw new Error("implementation bug");
    for (let g3 = e2; g3 < t2; g3++)
      n4.__setDigit(g3, 0);
    return n4;
  }
  static __absoluteAnd(_2, t2, e2 = null) {
    let n4 = _2.length, g2 = t2.length, o2 = g2;
    if (n4 < g2) {
      o2 = n4;
      const i3 = _2, e3 = n4;
      _2 = t2, n4 = g2, t2 = i3, g2 = e3;
    }
    let s4 = o2;
    null === e2 ? e2 = new JSBI(s4, false) : s4 = e2.length;
    let l2 = 0;
    for (; l2 < o2; l2++)
      e2.__setDigit(l2, _2.__digit(l2) & t2.__digit(l2));
    for (; l2 < s4; l2++)
      e2.__setDigit(l2, 0);
    return e2;
  }
  static __absoluteAndNot(_2, t2, e2 = null) {
    const n4 = _2.length, g2 = t2.length;
    let o2 = g2;
    n4 < g2 && (o2 = n4);
    let s4 = n4;
    null === e2 ? e2 = new JSBI(s4, false) : s4 = e2.length;
    let l2 = 0;
    for (; l2 < o2; l2++)
      e2.__setDigit(l2, _2.__digit(l2) & ~t2.__digit(l2));
    for (; l2 < n4; l2++)
      e2.__setDigit(l2, _2.__digit(l2));
    for (; l2 < s4; l2++)
      e2.__setDigit(l2, 0);
    return e2;
  }
  static __absoluteOr(_2, t2, e2 = null) {
    let n4 = _2.length, g2 = t2.length, o2 = g2;
    if (n4 < g2) {
      o2 = n4;
      const i3 = _2, e3 = n4;
      _2 = t2, n4 = g2, t2 = i3, g2 = e3;
    }
    let s4 = n4;
    null === e2 ? e2 = new JSBI(s4, false) : s4 = e2.length;
    let l2 = 0;
    for (; l2 < o2; l2++)
      e2.__setDigit(l2, _2.__digit(l2) | t2.__digit(l2));
    for (; l2 < n4; l2++)
      e2.__setDigit(l2, _2.__digit(l2));
    for (; l2 < s4; l2++)
      e2.__setDigit(l2, 0);
    return e2;
  }
  static __absoluteXor(_2, t2, e2 = null) {
    let n4 = _2.length, g2 = t2.length, o2 = g2;
    if (n4 < g2) {
      o2 = n4;
      const i3 = _2, e3 = n4;
      _2 = t2, n4 = g2, t2 = i3, g2 = e3;
    }
    let s4 = n4;
    null === e2 ? e2 = new JSBI(s4, false) : s4 = e2.length;
    let l2 = 0;
    for (; l2 < o2; l2++)
      e2.__setDigit(l2, _2.__digit(l2) ^ t2.__digit(l2));
    for (; l2 < n4; l2++)
      e2.__setDigit(l2, _2.__digit(l2));
    for (; l2 < s4; l2++)
      e2.__setDigit(l2, 0);
    return e2;
  }
  static __absoluteCompare(_2, t2) {
    const e2 = _2.length - t2.length;
    if (0 != e2)
      return e2;
    let n4 = _2.length - 1;
    for (; 0 <= n4 && _2.__digit(n4) === t2.__digit(n4); )
      n4--;
    return 0 > n4 ? 0 : _2.__unsignedDigit(n4) > t2.__unsignedDigit(n4) ? 1 : -1;
  }
  static __multiplyAccumulate(_2, t2, e2, n4) {
    if (0 === t2)
      return;
    const g2 = 32767 & t2, o2 = t2 >>> 15;
    let s4 = 0, l2 = 0;
    for (let r2, a2 = 0; a2 < _2.length; a2++, n4++) {
      r2 = e2.__digit(n4);
      const i3 = _2.__digit(a2), t3 = 32767 & i3, u2 = i3 >>> 15, d2 = JSBI.__imul(t3, g2), h4 = JSBI.__imul(t3, o2), m2 = JSBI.__imul(u2, g2), b3 = JSBI.__imul(u2, o2);
      r2 += l2 + d2 + s4, s4 = r2 >>> 30, r2 &= 1073741823, r2 += ((32767 & h4) << 15) + ((32767 & m2) << 15), s4 += r2 >>> 30, l2 = b3 + (h4 >>> 15) + (m2 >>> 15), e2.__setDigit(n4, 1073741823 & r2);
    }
    for (; 0 != s4 || 0 !== l2; n4++) {
      let i3 = e2.__digit(n4);
      i3 += s4 + l2, l2 = 0, s4 = i3 >>> 30, e2.__setDigit(n4, 1073741823 & i3);
    }
  }
  static __internalMultiplyAdd(_2, t2, e2, g2, o2) {
    let s4 = e2, l2 = 0;
    for (let n4 = 0; n4 < g2; n4++) {
      const i3 = _2.__digit(n4), e3 = JSBI.__imul(32767 & i3, t2), g3 = JSBI.__imul(i3 >>> 15, t2), a2 = e3 + ((32767 & g3) << 15) + l2 + s4;
      s4 = a2 >>> 30, l2 = g3 >>> 15, o2.__setDigit(n4, 1073741823 & a2);
    }
    if (o2.length > g2)
      for (o2.__setDigit(g2++, s4 + l2); g2 < o2.length; )
        o2.__setDigit(g2++, 0);
    else if (0 !== s4 + l2)
      throw new Error("implementation bug");
  }
  __inplaceMultiplyAdd(i3, _2, t2) {
    t2 > this.length && (t2 = this.length);
    const e2 = 32767 & i3, n4 = i3 >>> 15;
    let g2 = 0, o2 = _2;
    for (let s4 = 0; s4 < t2; s4++) {
      const i4 = this.__digit(s4), _3 = 32767 & i4, t3 = i4 >>> 15, l2 = JSBI.__imul(_3, e2), r2 = JSBI.__imul(_3, n4), a2 = JSBI.__imul(t3, e2), u2 = JSBI.__imul(t3, n4);
      let d2 = o2 + l2 + g2;
      g2 = d2 >>> 30, d2 &= 1073741823, d2 += ((32767 & r2) << 15) + ((32767 & a2) << 15), g2 += d2 >>> 30, o2 = u2 + (r2 >>> 15) + (a2 >>> 15), this.__setDigit(s4, 1073741823 & d2);
    }
    if (0 != g2 || 0 !== o2)
      throw new Error("implementation bug");
  }
  static __absoluteDivSmall(_2, t2, e2 = null) {
    null === e2 && (e2 = new JSBI(_2.length, false));
    let n4 = 0;
    for (let g2, o2 = 2 * _2.length - 1; 0 <= o2; o2 -= 2) {
      g2 = (n4 << 15 | _2.__halfDigit(o2)) >>> 0;
      const i3 = 0 | g2 / t2;
      n4 = 0 | g2 % t2, g2 = (n4 << 15 | _2.__halfDigit(o2 - 1)) >>> 0;
      const s4 = 0 | g2 / t2;
      n4 = 0 | g2 % t2, e2.__setDigit(o2 >>> 1, i3 << 15 | s4);
    }
    return e2;
  }
  static __absoluteModSmall(_2, t2) {
    let e2 = 0;
    for (let n4 = 2 * _2.length - 1; 0 <= n4; n4--) {
      const i3 = (e2 << 15 | _2.__halfDigit(n4)) >>> 0;
      e2 = 0 | i3 % t2;
    }
    return e2;
  }
  static __absoluteDivLarge(i3, _2, t2, e2) {
    const g2 = _2.__halfDigitLength(), n4 = _2.length, o2 = i3.__halfDigitLength() - g2;
    let s4 = null;
    t2 && (s4 = new JSBI(o2 + 2 >>> 1, false), s4.__initializeDigits());
    const l2 = new JSBI(g2 + 2 >>> 1, false);
    l2.__initializeDigits();
    const r2 = JSBI.__clz15(_2.__halfDigit(g2 - 1));
    0 < r2 && (_2 = JSBI.__specialLeftShift(_2, r2, 0));
    const a2 = JSBI.__specialLeftShift(i3, r2, 1), u2 = _2.__halfDigit(g2 - 1);
    let d2 = 0;
    for (let r3, h4 = o2; 0 <= h4; h4--) {
      r3 = 32767;
      const i4 = a2.__halfDigit(h4 + g2);
      if (i4 !== u2) {
        const t3 = (i4 << 15 | a2.__halfDigit(h4 + g2 - 1)) >>> 0;
        r3 = 0 | t3 / u2;
        let e4 = 0 | t3 % u2;
        const n5 = _2.__halfDigit(g2 - 2), o3 = a2.__halfDigit(h4 + g2 - 2);
        for (; JSBI.__imul(r3, n5) >>> 0 > (e4 << 16 | o3) >>> 0 && (r3--, e4 += u2, !(32767 < e4)); )
          ;
      }
      JSBI.__internalMultiplyAdd(_2, r3, 0, n4, l2);
      let e3 = a2.__inplaceSub(l2, h4, g2 + 1);
      0 !== e3 && (e3 = a2.__inplaceAdd(_2, h4, g2), a2.__setHalfDigit(h4 + g2, 32767 & a2.__halfDigit(h4 + g2) + e3), r3--), t2 && (1 & h4 ? d2 = r3 << 15 : s4.__setDigit(h4 >>> 1, d2 | r3));
    }
    if (e2)
      return a2.__inplaceRightShift(r2), t2 ? { quotient: s4, remainder: a2 } : a2;
    if (t2)
      return s4;
    throw new Error("unreachable");
  }
  static __clz15(i3) {
    return JSBI.__clz30(i3) - 15;
  }
  __inplaceAdd(_2, t2, e2) {
    let n4 = 0;
    for (let g2 = 0; g2 < e2; g2++) {
      const i3 = this.__halfDigit(t2 + g2) + _2.__halfDigit(g2) + n4;
      n4 = i3 >>> 15, this.__setHalfDigit(t2 + g2, 32767 & i3);
    }
    return n4;
  }
  __inplaceSub(_2, t2, e2) {
    let n4 = 0;
    if (1 & t2) {
      t2 >>= 1;
      let g2 = this.__digit(t2), o2 = 32767 & g2, s4 = 0;
      for (; s4 < e2 - 1 >>> 1; s4++) {
        const i4 = _2.__digit(s4), e3 = (g2 >>> 15) - (32767 & i4) - n4;
        n4 = 1 & e3 >>> 15, this.__setDigit(t2 + s4, (32767 & e3) << 15 | 32767 & o2), g2 = this.__digit(t2 + s4 + 1), o2 = (32767 & g2) - (i4 >>> 15) - n4, n4 = 1 & o2 >>> 15;
      }
      const i3 = _2.__digit(s4), l2 = (g2 >>> 15) - (32767 & i3) - n4;
      n4 = 1 & l2 >>> 15, this.__setDigit(t2 + s4, (32767 & l2) << 15 | 32767 & o2);
      if (t2 + s4 + 1 >= this.length)
        throw new RangeError("out of bounds");
      0 == (1 & e2) && (g2 = this.__digit(t2 + s4 + 1), o2 = (32767 & g2) - (i3 >>> 15) - n4, n4 = 1 & o2 >>> 15, this.__setDigit(t2 + _2.length, 1073709056 & g2 | 32767 & o2));
    } else {
      t2 >>= 1;
      let g2 = 0;
      for (; g2 < _2.length - 1; g2++) {
        const i4 = this.__digit(t2 + g2), e3 = _2.__digit(g2), o3 = (32767 & i4) - (32767 & e3) - n4;
        n4 = 1 & o3 >>> 15;
        const s5 = (i4 >>> 15) - (e3 >>> 15) - n4;
        n4 = 1 & s5 >>> 15, this.__setDigit(t2 + g2, (32767 & s5) << 15 | 32767 & o3);
      }
      const i3 = this.__digit(t2 + g2), o2 = _2.__digit(g2), s4 = (32767 & i3) - (32767 & o2) - n4;
      n4 = 1 & s4 >>> 15;
      let l2 = 0;
      0 == (1 & e2) && (l2 = (i3 >>> 15) - (o2 >>> 15) - n4, n4 = 1 & l2 >>> 15), this.__setDigit(t2 + g2, (32767 & l2) << 15 | 32767 & s4);
    }
    return n4;
  }
  __inplaceRightShift(_2) {
    if (0 === _2)
      return;
    let t2 = this.__digit(0) >>> _2;
    const e2 = this.length - 1;
    for (let n4 = 0; n4 < e2; n4++) {
      const i3 = this.__digit(n4 + 1);
      this.__setDigit(n4, 1073741823 & i3 << 30 - _2 | t2), t2 = i3 >>> _2;
    }
    this.__setDigit(e2, t2);
  }
  static __specialLeftShift(_2, t2, e2) {
    const g2 = _2.length, n4 = new JSBI(g2 + e2, false);
    if (0 === t2) {
      for (let t3 = 0; t3 < g2; t3++)
        n4.__setDigit(t3, _2.__digit(t3));
      return 0 < e2 && n4.__setDigit(g2, 0), n4;
    }
    let o2 = 0;
    for (let s4 = 0; s4 < g2; s4++) {
      const i3 = _2.__digit(s4);
      n4.__setDigit(s4, 1073741823 & i3 << t2 | o2), o2 = i3 >>> 30 - t2;
    }
    return 0 < e2 && n4.__setDigit(g2, o2), n4;
  }
  static __leftShiftByAbsolute(_2, i3) {
    const t2 = JSBI.__toShiftAmount(i3);
    if (0 > t2)
      throw new RangeError("BigInt too big");
    const e2 = 0 | t2 / 30, n4 = t2 % 30, g2 = _2.length, o2 = 0 !== n4 && 0 != _2.__digit(g2 - 1) >>> 30 - n4, s4 = g2 + e2 + (o2 ? 1 : 0), l2 = new JSBI(s4, _2.sign);
    if (0 === n4) {
      let t3 = 0;
      for (; t3 < e2; t3++)
        l2.__setDigit(t3, 0);
      for (; t3 < s4; t3++)
        l2.__setDigit(t3, _2.__digit(t3 - e2));
    } else {
      let t3 = 0;
      for (let _3 = 0; _3 < e2; _3++)
        l2.__setDigit(_3, 0);
      for (let o3 = 0; o3 < g2; o3++) {
        const i4 = _2.__digit(o3);
        l2.__setDigit(o3 + e2, 1073741823 & i4 << n4 | t3), t3 = i4 >>> 30 - n4;
      }
      if (o2)
        l2.__setDigit(g2 + e2, t3);
      else if (0 !== t3)
        throw new Error("implementation bug");
    }
    return l2.__trim();
  }
  static __rightShiftByAbsolute(_2, i3) {
    const t2 = _2.length, e2 = _2.sign, n4 = JSBI.__toShiftAmount(i3);
    if (0 > n4)
      return JSBI.__rightShiftByMaximum(e2);
    const g2 = 0 | n4 / 30, o2 = n4 % 30;
    let s4 = t2 - g2;
    if (0 >= s4)
      return JSBI.__rightShiftByMaximum(e2);
    let l2 = false;
    if (e2) {
      if (0 != (_2.__digit(g2) & (1 << o2) - 1))
        l2 = true;
      else
        for (let t3 = 0; t3 < g2; t3++)
          if (0 !== _2.__digit(t3)) {
            l2 = true;
            break;
          }
    }
    if (l2 && 0 === o2) {
      const i4 = _2.__digit(t2 - 1);
      0 == ~i4 && s4++;
    }
    let r2 = new JSBI(s4, e2);
    if (0 === o2) {
      r2.__setDigit(s4 - 1, 0);
      for (let e3 = g2; e3 < t2; e3++)
        r2.__setDigit(e3 - g2, _2.__digit(e3));
    } else {
      let e3 = _2.__digit(g2) >>> o2;
      const n5 = t2 - g2 - 1;
      for (let t3 = 0; t3 < n5; t3++) {
        const i4 = _2.__digit(t3 + g2 + 1);
        r2.__setDigit(t3, 1073741823 & i4 << 30 - o2 | e3), e3 = i4 >>> o2;
      }
      r2.__setDigit(n5, e3);
    }
    return l2 && (r2 = JSBI.__absoluteAddOne(r2, true, r2)), r2.__trim();
  }
  static __rightShiftByMaximum(i3) {
    return i3 ? JSBI.__oneDigit(1, true) : JSBI.__zero();
  }
  static __toShiftAmount(i3) {
    if (1 < i3.length)
      return -1;
    const _2 = i3.__unsignedDigit(0);
    return _2 > JSBI.__kMaxLengthBits ? -1 : _2;
  }
  static __toPrimitive(i3, _2 = "default") {
    if ("object" != typeof i3)
      return i3;
    if (i3.constructor === JSBI)
      return i3;
    const t2 = i3[Symbol.toPrimitive];
    if (t2) {
      const i4 = t2(_2);
      if ("object" != typeof i4)
        return i4;
      throw new TypeError("Cannot convert object to primitive value");
    }
    const e2 = i3.valueOf;
    if (e2) {
      const _3 = e2.call(i3);
      if ("object" != typeof _3)
        return _3;
    }
    const n4 = i3.toString;
    if (n4) {
      const _3 = n4.call(i3);
      if ("object" != typeof _3)
        return _3;
    }
    throw new TypeError("Cannot convert object to primitive value");
  }
  static __toNumeric(i3) {
    return JSBI.__isBigInt(i3) ? i3 : +i3;
  }
  static __isBigInt(i3) {
    return "object" == typeof i3 && null !== i3 && i3.constructor === JSBI;
  }
  static __truncateToNBits(i3, _2) {
    const t2 = 0 | (i3 + 29) / 30, e2 = new JSBI(t2, _2.sign), n4 = t2 - 1;
    for (let t3 = 0; t3 < n4; t3++)
      e2.__setDigit(t3, _2.__digit(t3));
    let g2 = _2.__digit(n4);
    if (0 != i3 % 30) {
      const _3 = 32 - i3 % 30;
      g2 = g2 << _3 >>> _3;
    }
    return e2.__setDigit(n4, g2), e2.__trim();
  }
  static __truncateAndSubFromPowerOfTwo(_2, t2, e2) {
    var n4 = Math.min;
    const g2 = 0 | (_2 + 29) / 30, o2 = new JSBI(g2, e2);
    let s4 = 0;
    const l2 = g2 - 1;
    let a2 = 0;
    for (const i3 = n4(l2, t2.length); s4 < i3; s4++) {
      const i4 = 0 - t2.__digit(s4) - a2;
      a2 = 1 & i4 >>> 30, o2.__setDigit(s4, 1073741823 & i4);
    }
    for (; s4 < l2; s4++)
      o2.__setDigit(s4, 0 | 1073741823 & -a2);
    let u2 = l2 < t2.length ? t2.__digit(l2) : 0;
    const d2 = _2 % 30;
    let h4;
    if (0 == d2)
      h4 = 0 - u2 - a2, h4 &= 1073741823;
    else {
      const i3 = 32 - d2;
      u2 = u2 << i3 >>> i3;
      const _3 = 1 << 32 - i3;
      h4 = _3 - u2 - a2, h4 &= _3 - 1;
    }
    return o2.__setDigit(l2, h4), o2.__trim();
  }
  __digit(_2) {
    return this[_2];
  }
  __unsignedDigit(_2) {
    return this[_2] >>> 0;
  }
  __setDigit(_2, i3) {
    this[_2] = 0 | i3;
  }
  __setDigitGrow(_2, i3) {
    this[_2] = 0 | i3;
  }
  __halfDigitLength() {
    const i3 = this.length;
    return 32767 >= this.__unsignedDigit(i3 - 1) ? 2 * i3 - 1 : 2 * i3;
  }
  __halfDigit(_2) {
    return 32767 & this[_2 >>> 1] >>> 15 * (1 & _2);
  }
  __setHalfDigit(_2, i3) {
    const t2 = _2 >>> 1, e2 = this.__digit(t2), n4 = 1 & _2 ? 32767 & e2 | i3 << 15 : 1073709056 & e2 | 32767 & i3;
    this.__setDigit(t2, n4);
  }
  static __digitPow(i3, _2) {
    let t2 = 1;
    for (; 0 < _2; )
      1 & _2 && (t2 *= i3), _2 >>>= 1, i3 *= i3;
    return t2;
  }
  static __isOneDigitInt(i3) {
    return (1073741823 & i3) === i3;
  }
}
JSBI.__kMaxLength = 33554432, JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5, JSBI.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], JSBI.__kBitsPerCharTableShift = 5, JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift, JSBI.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], JSBI.__kBitConversionBuffer = new ArrayBuffer(8), JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer), JSBI.__clz30 = Math.clz32 ? function(i3) {
  return Math.clz32(i3) - 2;
} : function(i3) {
  return 0 === i3 ? 30 : 0 | 29 - (0 | Math.log(i3 >>> 0) / Math.LN2);
}, JSBI.__imul = Math.imul || function(i3, _2) {
  return 0 | i3 * _2;
};
var prefix = "Invariant failed";
function invariant$1(condition, message) {
  if (condition) {
    return;
  }
  {
    throw new Error(prefix);
  }
}
const tinyInvariant = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: invariant$1
}, Symbol.toStringTag, { value: "Module" }));
var MAX_DIGITS = 1e9, defaults$4 = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed during run-time using `Decimal.config`.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
  // `toFixed`, `toPrecision` and `toSignificantDigits`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -MAX_E
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to MAX_E
  // The natural logarithm of 10.
  // 115 digits
  LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
}, Decimal$4, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", exponentOutOfRange = decimalError + "Exponent out of range: ", mathfloor = Math.floor, mathpow = Math.pow, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ONE$7, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER$4 = 9007199254740991, MAX_E = mathfloor(MAX_SAFE_INTEGER$4 / LOG_BASE), P$3 = {};
P$3.absoluteValue = P$3.abs = function() {
  var x2 = new this.constructor(this);
  if (x2.s)
    x2.s = 1;
  return x2;
};
P$3.comparedTo = P$3.cmp = function(y2) {
  var i3, j2, xdL, ydL, x2 = this;
  y2 = new x2.constructor(y2);
  if (x2.s !== y2.s)
    return x2.s || -y2.s;
  if (x2.e !== y2.e)
    return x2.e > y2.e ^ x2.s < 0 ? 1 : -1;
  xdL = x2.d.length;
  ydL = y2.d.length;
  for (i3 = 0, j2 = xdL < ydL ? xdL : ydL; i3 < j2; ++i3) {
    if (x2.d[i3] !== y2.d[i3])
      return x2.d[i3] > y2.d[i3] ^ x2.s < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ x2.s < 0 ? 1 : -1;
};
P$3.decimalPlaces = P$3.dp = function() {
  var x2 = this, w2 = x2.d.length - 1, dp = (w2 - x2.e) * LOG_BASE;
  w2 = x2.d[w2];
  if (w2)
    for (; w2 % 10 == 0; w2 /= 10)
      dp--;
  return dp < 0 ? 0 : dp;
};
P$3.dividedBy = P$3.div = function(y2) {
  return divide(this, new this.constructor(y2));
};
P$3.dividedToIntegerBy = P$3.idiv = function(y2) {
  var x2 = this, Ctor = x2.constructor;
  return round$1(divide(x2, new Ctor(y2), 0, 1), Ctor.precision);
};
P$3.equals = P$3.eq = function(y2) {
  return !this.cmp(y2);
};
P$3.exponent = function() {
  return getBase10Exponent(this);
};
P$3.greaterThan = P$3.gt = function(y2) {
  return this.cmp(y2) > 0;
};
P$3.greaterThanOrEqualTo = P$3.gte = function(y2) {
  return this.cmp(y2) >= 0;
};
P$3.isInteger = P$3.isint = function() {
  return this.e > this.d.length - 2;
};
P$3.isNegative = P$3.isneg = function() {
  return this.s < 0;
};
P$3.isPositive = P$3.ispos = function() {
  return this.s > 0;
};
P$3.isZero = function() {
  return this.s === 0;
};
P$3.lessThan = P$3.lt = function(y2) {
  return this.cmp(y2) < 0;
};
P$3.lessThanOrEqualTo = P$3.lte = function(y2) {
  return this.cmp(y2) < 1;
};
P$3.logarithm = P$3.log = function(base3) {
  var r2, x2 = this, Ctor = x2.constructor, pr = Ctor.precision, wpr = pr + 5;
  if (base3 === void 0) {
    base3 = new Ctor(10);
  } else {
    base3 = new Ctor(base3);
    if (base3.s < 1 || base3.eq(ONE$7))
      throw Error(decimalError + "NaN");
  }
  if (x2.s < 1)
    throw Error(decimalError + (x2.s ? "NaN" : "-Infinity"));
  if (x2.eq(ONE$7))
    return new Ctor(0);
  external = false;
  r2 = divide(ln$1(x2, wpr), ln$1(base3, wpr), wpr);
  external = true;
  return round$1(r2, pr);
};
P$3.minus = P$3.sub = function(y2) {
  var x2 = this;
  y2 = new x2.constructor(y2);
  return x2.s == y2.s ? subtract(x2, y2) : add$1(x2, (y2.s = -y2.s, y2));
};
P$3.modulo = P$3.mod = function(y2) {
  var q2, x2 = this, Ctor = x2.constructor, pr = Ctor.precision;
  y2 = new Ctor(y2);
  if (!y2.s)
    throw Error(decimalError + "NaN");
  if (!x2.s)
    return round$1(new Ctor(x2), pr);
  external = false;
  q2 = divide(x2, y2, 0, 1).times(y2);
  external = true;
  return x2.minus(q2);
};
P$3.naturalExponential = P$3.exp = function() {
  return exp(this);
};
P$3.naturalLogarithm = P$3.ln = function() {
  return ln$1(this);
};
P$3.negated = P$3.neg = function() {
  var x2 = new this.constructor(this);
  x2.s = -x2.s || 0;
  return x2;
};
P$3.plus = P$3.add = function(y2) {
  var x2 = this;
  y2 = new x2.constructor(y2);
  return x2.s == y2.s ? add$1(x2, y2) : subtract(x2, (y2.s = -y2.s, y2));
};
P$3.precision = P$3.sd = function(z2) {
  var e2, sd2, w2, x2 = this;
  if (z2 !== void 0 && z2 !== !!z2 && z2 !== 1 && z2 !== 0)
    throw Error(invalidArgument + z2);
  e2 = getBase10Exponent(x2) + 1;
  w2 = x2.d.length - 1;
  sd2 = w2 * LOG_BASE + 1;
  w2 = x2.d[w2];
  if (w2) {
    for (; w2 % 10 == 0; w2 /= 10)
      sd2--;
    for (w2 = x2.d[0]; w2 >= 10; w2 /= 10)
      sd2++;
  }
  return z2 && e2 > sd2 ? e2 : sd2;
};
P$3.squareRoot = P$3.sqrt = function() {
  var e2, n4, pr, r2, s4, t2, wpr, x2 = this, Ctor = x2.constructor;
  if (x2.s < 1) {
    if (!x2.s)
      return new Ctor(0);
    throw Error(decimalError + "NaN");
  }
  e2 = getBase10Exponent(x2);
  external = false;
  s4 = Math.sqrt(+x2);
  if (s4 == 0 || s4 == 1 / 0) {
    n4 = digitsToString(x2.d);
    if ((n4.length + e2) % 2 == 0)
      n4 += "0";
    s4 = Math.sqrt(n4);
    e2 = mathfloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
    if (s4 == 1 / 0) {
      n4 = "5e" + e2;
    } else {
      n4 = s4.toExponential();
      n4 = n4.slice(0, n4.indexOf("e") + 1) + e2;
    }
    r2 = new Ctor(n4);
  } else {
    r2 = new Ctor(s4.toString());
  }
  pr = Ctor.precision;
  s4 = wpr = pr + 3;
  for (; ; ) {
    t2 = r2;
    r2 = t2.plus(divide(x2, t2, wpr + 2)).times(0.5);
    if (digitsToString(t2.d).slice(0, wpr) === (n4 = digitsToString(r2.d)).slice(0, wpr)) {
      n4 = n4.slice(wpr - 3, wpr + 1);
      if (s4 == wpr && n4 == "4999") {
        round$1(t2, pr + 1, 0);
        if (t2.times(t2).eq(x2)) {
          r2 = t2;
          break;
        }
      } else if (n4 != "9999") {
        break;
      }
      wpr += 4;
    }
  }
  external = true;
  return round$1(r2, pr);
};
P$3.times = P$3.mul = function(y2) {
  var carry, e2, i3, k4, r2, rL, t2, xdL, ydL, x2 = this, Ctor = x2.constructor, xd2 = x2.d, yd2 = (y2 = new Ctor(y2)).d;
  if (!x2.s || !y2.s)
    return new Ctor(0);
  y2.s *= x2.s;
  e2 = x2.e + y2.e;
  xdL = xd2.length;
  ydL = yd2.length;
  if (xdL < ydL) {
    r2 = xd2;
    xd2 = yd2;
    yd2 = r2;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r2 = [];
  rL = xdL + ydL;
  for (i3 = rL; i3--; )
    r2.push(0);
  for (i3 = ydL; --i3 >= 0; ) {
    carry = 0;
    for (k4 = xdL + i3; k4 > i3; ) {
      t2 = r2[k4] + yd2[i3] * xd2[k4 - i3 - 1] + carry;
      r2[k4--] = t2 % BASE | 0;
      carry = t2 / BASE | 0;
    }
    r2[k4] = (r2[k4] + carry) % BASE | 0;
  }
  for (; !r2[--rL]; )
    r2.pop();
  if (carry)
    ++e2;
  else
    r2.shift();
  y2.d = r2;
  y2.e = e2;
  return external ? round$1(y2, Ctor.precision) : y2;
};
P$3.toDecimalPlaces = P$3.todp = function(dp, rm) {
  var x2 = this, Ctor = x2.constructor;
  x2 = new Ctor(x2);
  if (dp === void 0)
    return x2;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return round$1(x2, dp + getBase10Exponent(x2) + 1, rm);
};
P$3.toExponential = function(dp, rm) {
  var str, x2 = this, Ctor = x2.constructor;
  if (dp === void 0) {
    str = toString$3(x2, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x2 = round$1(new Ctor(x2), dp + 1, rm);
    str = toString$3(x2, true, dp + 1);
  }
  return str;
};
P$3.toFixed = function(dp, rm) {
  var str, y2, x2 = this, Ctor = x2.constructor;
  if (dp === void 0)
    return toString$3(x2);
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  y2 = round$1(new Ctor(x2), dp + getBase10Exponent(x2) + 1, rm);
  str = toString$3(y2.abs(), false, dp + getBase10Exponent(y2) + 1);
  return x2.isneg() && !x2.isZero() ? "-" + str : str;
};
P$3.toInteger = P$3.toint = function() {
  var x2 = this, Ctor = x2.constructor;
  return round$1(new Ctor(x2), getBase10Exponent(x2) + 1, Ctor.rounding);
};
P$3.toNumber = function() {
  return +this;
};
P$3.toPower = P$3.pow = function(y2) {
  var e2, k4, pr, r2, sign3, yIsInt, x2 = this, Ctor = x2.constructor, guard = 12, yn2 = +(y2 = new Ctor(y2));
  if (!y2.s)
    return new Ctor(ONE$7);
  x2 = new Ctor(x2);
  if (!x2.s) {
    if (y2.s < 1)
      throw Error(decimalError + "Infinity");
    return x2;
  }
  if (x2.eq(ONE$7))
    return x2;
  pr = Ctor.precision;
  if (y2.eq(ONE$7))
    return round$1(x2, pr);
  e2 = y2.e;
  k4 = y2.d.length - 1;
  yIsInt = e2 >= k4;
  sign3 = x2.s;
  if (!yIsInt) {
    if (sign3 < 0)
      throw Error(decimalError + "NaN");
  } else if ((k4 = yn2 < 0 ? -yn2 : yn2) <= MAX_SAFE_INTEGER$4) {
    r2 = new Ctor(ONE$7);
    e2 = Math.ceil(pr / LOG_BASE + 4);
    external = false;
    for (; ; ) {
      if (k4 % 2) {
        r2 = r2.times(x2);
        truncate(r2.d, e2);
      }
      k4 = mathfloor(k4 / 2);
      if (k4 === 0)
        break;
      x2 = x2.times(x2);
      truncate(x2.d, e2);
    }
    external = true;
    return y2.s < 0 ? new Ctor(ONE$7).div(r2) : round$1(r2, pr);
  }
  sign3 = sign3 < 0 && y2.d[Math.max(e2, k4)] & 1 ? -1 : 1;
  x2.s = 1;
  external = false;
  r2 = y2.times(ln$1(x2, pr + guard));
  external = true;
  r2 = exp(r2);
  r2.s = sign3;
  return r2;
};
P$3.toPrecision = function(sd2, rm) {
  var e2, str, x2 = this, Ctor = x2.constructor;
  if (sd2 === void 0) {
    e2 = getBase10Exponent(x2);
    str = toString$3(x2, e2 <= Ctor.toExpNeg || e2 >= Ctor.toExpPos);
  } else {
    checkInt32(sd2, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x2 = round$1(new Ctor(x2), sd2, rm);
    e2 = getBase10Exponent(x2);
    str = toString$3(x2, sd2 <= e2 || e2 <= Ctor.toExpNeg, sd2);
  }
  return str;
};
P$3.toSignificantDigits = P$3.tosd = function(sd2, rm) {
  var x2 = this, Ctor = x2.constructor;
  if (sd2 === void 0) {
    sd2 = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd2, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return round$1(new Ctor(x2), sd2, rm);
};
P$3.toString = P$3.valueOf = P$3.val = P$3.toJSON = P$3[Symbol.for("nodejs.util.inspect.custom")] = function() {
  var x2 = this, e2 = getBase10Exponent(x2), Ctor = x2.constructor;
  return toString$3(x2, e2 <= Ctor.toExpNeg || e2 >= Ctor.toExpPos);
};
function add$1(x2, y2) {
  var carry, d2, e2, i3, k4, len, xd2, yd2, Ctor = x2.constructor, pr = Ctor.precision;
  if (!x2.s || !y2.s) {
    if (!y2.s)
      y2 = new Ctor(x2);
    return external ? round$1(y2, pr) : y2;
  }
  xd2 = x2.d;
  yd2 = y2.d;
  k4 = x2.e;
  e2 = y2.e;
  xd2 = xd2.slice();
  i3 = k4 - e2;
  if (i3) {
    if (i3 < 0) {
      d2 = xd2;
      i3 = -i3;
      len = yd2.length;
    } else {
      d2 = yd2;
      e2 = k4;
      len = xd2.length;
    }
    k4 = Math.ceil(pr / LOG_BASE);
    len = k4 > len ? k4 + 1 : len + 1;
    if (i3 > len) {
      i3 = len;
      d2.length = 1;
    }
    d2.reverse();
    for (; i3--; )
      d2.push(0);
    d2.reverse();
  }
  len = xd2.length;
  i3 = yd2.length;
  if (len - i3 < 0) {
    i3 = len;
    d2 = yd2;
    yd2 = xd2;
    xd2 = d2;
  }
  for (carry = 0; i3; ) {
    carry = (xd2[--i3] = xd2[i3] + yd2[i3] + carry) / BASE | 0;
    xd2[i3] %= BASE;
  }
  if (carry) {
    xd2.unshift(carry);
    ++e2;
  }
  for (len = xd2.length; xd2[--len] == 0; )
    xd2.pop();
  y2.d = xd2;
  y2.e = e2;
  return external ? round$1(y2, pr) : y2;
}
function checkInt32(i3, min, max) {
  if (i3 !== ~~i3 || i3 < min || i3 > max) {
    throw Error(invalidArgument + i3);
  }
}
function digitsToString(d2) {
  var i3, k4, ws, indexOfLastWord = d2.length - 1, str = "", w2 = d2[0];
  if (indexOfLastWord > 0) {
    str += w2;
    for (i3 = 1; i3 < indexOfLastWord; i3++) {
      ws = d2[i3] + "";
      k4 = LOG_BASE - ws.length;
      if (k4)
        str += getZeroString(k4);
      str += ws;
    }
    w2 = d2[i3];
    ws = w2 + "";
    k4 = LOG_BASE - ws.length;
    if (k4)
      str += getZeroString(k4);
  } else if (w2 === 0) {
    return "0";
  }
  for (; w2 % 10 === 0; )
    w2 /= 10;
  return str + w2;
}
var divide = /* @__PURE__ */ function() {
  function multiplyInteger(x2, k4) {
    var temp, carry = 0, i3 = x2.length;
    for (x2 = x2.slice(); i3--; ) {
      temp = x2[i3] * k4 + carry;
      x2[i3] = temp % BASE | 0;
      carry = temp / BASE | 0;
    }
    if (carry)
      x2.unshift(carry);
    return x2;
  }
  function compare2(a2, b3, aL, bL) {
    var i3, r2;
    if (aL != bL) {
      r2 = aL > bL ? 1 : -1;
    } else {
      for (i3 = r2 = 0; i3 < aL; i3++) {
        if (a2[i3] != b3[i3]) {
          r2 = a2[i3] > b3[i3] ? 1 : -1;
          break;
        }
      }
    }
    return r2;
  }
  function subtract2(a2, b3, aL) {
    var i3 = 0;
    for (; aL--; ) {
      a2[aL] -= i3;
      i3 = a2[aL] < b3[aL] ? 1 : 0;
      a2[aL] = i3 * BASE + a2[aL] - b3[aL];
    }
    for (; !a2[0] && a2.length > 1; )
      a2.shift();
  }
  return function(x2, y2, pr, dp) {
    var cmp, e2, i3, k4, prod, prodL, q2, qd2, rem, remL, rem0, sd2, t2, xi2, xL, yd0, yL, yz, Ctor = x2.constructor, sign3 = x2.s == y2.s ? 1 : -1, xd2 = x2.d, yd2 = y2.d;
    if (!x2.s)
      return new Ctor(x2);
    if (!y2.s)
      throw Error(decimalError + "Division by zero");
    e2 = x2.e - y2.e;
    yL = yd2.length;
    xL = xd2.length;
    q2 = new Ctor(sign3);
    qd2 = q2.d = [];
    for (i3 = 0; yd2[i3] == (xd2[i3] || 0); )
      ++i3;
    if (yd2[i3] > (xd2[i3] || 0))
      --e2;
    if (pr == null) {
      sd2 = pr = Ctor.precision;
    } else if (dp) {
      sd2 = pr + (getBase10Exponent(x2) - getBase10Exponent(y2)) + 1;
    } else {
      sd2 = pr;
    }
    if (sd2 < 0)
      return new Ctor(0);
    sd2 = sd2 / LOG_BASE + 2 | 0;
    i3 = 0;
    if (yL == 1) {
      k4 = 0;
      yd2 = yd2[0];
      sd2++;
      for (; (i3 < xL || k4) && sd2--; i3++) {
        t2 = k4 * BASE + (xd2[i3] || 0);
        qd2[i3] = t2 / yd2 | 0;
        k4 = t2 % yd2 | 0;
      }
    } else {
      k4 = BASE / (yd2[0] + 1) | 0;
      if (k4 > 1) {
        yd2 = multiplyInteger(yd2, k4);
        xd2 = multiplyInteger(xd2, k4);
        yL = yd2.length;
        xL = xd2.length;
      }
      xi2 = yL;
      rem = xd2.slice(0, yL);
      remL = rem.length;
      for (; remL < yL; )
        rem[remL++] = 0;
      yz = yd2.slice();
      yz.unshift(0);
      yd0 = yd2[0];
      if (yd2[1] >= BASE / 2)
        ++yd0;
      do {
        k4 = 0;
        cmp = compare2(yd2, rem, yL, remL);
        if (cmp < 0) {
          rem0 = rem[0];
          if (yL != remL)
            rem0 = rem0 * BASE + (rem[1] || 0);
          k4 = rem0 / yd0 | 0;
          if (k4 > 1) {
            if (k4 >= BASE)
              k4 = BASE - 1;
            prod = multiplyInteger(yd2, k4);
            prodL = prod.length;
            remL = rem.length;
            cmp = compare2(prod, rem, prodL, remL);
            if (cmp == 1) {
              k4--;
              subtract2(prod, yL < prodL ? yz : yd2, prodL);
            }
          } else {
            if (k4 == 0)
              cmp = k4 = 1;
            prod = yd2.slice();
          }
          prodL = prod.length;
          if (prodL < remL)
            prod.unshift(0);
          subtract2(rem, prod, remL);
          if (cmp == -1) {
            remL = rem.length;
            cmp = compare2(yd2, rem, yL, remL);
            if (cmp < 1) {
              k4++;
              subtract2(rem, yL < remL ? yz : yd2, remL);
            }
          }
          remL = rem.length;
        } else if (cmp === 0) {
          k4++;
          rem = [0];
        }
        qd2[i3++] = k4;
        if (cmp && rem[0]) {
          rem[remL++] = xd2[xi2] || 0;
        } else {
          rem = [xd2[xi2]];
          remL = 1;
        }
      } while ((xi2++ < xL || rem[0] !== void 0) && sd2--);
    }
    if (!qd2[0])
      qd2.shift();
    q2.e = e2;
    return round$1(q2, dp ? pr + getBase10Exponent(q2) + 1 : pr);
  };
}();
function exp(x2, sd2) {
  var denominator, guard, pow, sum2, t2, wpr, i3 = 0, k4 = 0, Ctor = x2.constructor, pr = Ctor.precision;
  if (getBase10Exponent(x2) > 16)
    throw Error(exponentOutOfRange + getBase10Exponent(x2));
  if (!x2.s)
    return new Ctor(ONE$7);
  if (sd2 == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd2;
  }
  t2 = new Ctor(0.03125);
  while (x2.abs().gte(0.1)) {
    x2 = x2.times(t2);
    k4 += 5;
  }
  guard = Math.log(mathpow(2, k4)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow = sum2 = new Ctor(ONE$7);
  Ctor.precision = wpr;
  for (; ; ) {
    pow = round$1(pow.times(x2), wpr);
    denominator = denominator.times(++i3);
    t2 = sum2.plus(divide(pow, denominator, wpr));
    if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      while (k4--)
        sum2 = round$1(sum2.times(sum2), wpr);
      Ctor.precision = pr;
      return sd2 == null ? (external = true, round$1(sum2, pr)) : sum2;
    }
    sum2 = t2;
  }
}
function getBase10Exponent(x2) {
  var e2 = x2.e * LOG_BASE, w2 = x2.d[0];
  for (; w2 >= 10; w2 /= 10)
    e2++;
  return e2;
}
function getLn10(Ctor, sd2, pr) {
  if (sd2 > Ctor.LN10.sd()) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(decimalError + "LN10 precision limit exceeded");
  }
  return round$1(new Ctor(Ctor.LN10), sd2);
}
function getZeroString(k4) {
  var zs = "";
  for (; k4--; )
    zs += "0";
  return zs;
}
function ln$1(y2, sd2) {
  var c2, c0, denominator, e2, numerator, sum2, t2, wpr, x2, n4 = 1, guard = 10, x3 = y2, xd2 = x3.d, Ctor = x3.constructor, pr = Ctor.precision;
  if (x3.s < 1)
    throw Error(decimalError + (x3.s ? "NaN" : "-Infinity"));
  if (x3.eq(ONE$7))
    return new Ctor(0);
  if (sd2 == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd2;
  }
  if (x3.eq(10)) {
    if (sd2 == null)
      external = true;
    return getLn10(Ctor, wpr);
  }
  wpr += guard;
  Ctor.precision = wpr;
  c2 = digitsToString(xd2);
  c0 = c2.charAt(0);
  e2 = getBase10Exponent(x3);
  if (Math.abs(e2) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c2.charAt(1) > 3) {
      x3 = x3.times(y2);
      c2 = digitsToString(x3.d);
      c0 = c2.charAt(0);
      n4++;
    }
    e2 = getBase10Exponent(x3);
    if (c0 > 1) {
      x3 = new Ctor("0." + c2);
      e2++;
    } else {
      x3 = new Ctor(c0 + "." + c2.slice(1));
    }
  } else {
    t2 = getLn10(Ctor, wpr + 2, pr).times(e2 + "");
    x3 = ln$1(new Ctor(c0 + "." + c2.slice(1)), wpr - guard).plus(t2);
    Ctor.precision = pr;
    return sd2 == null ? (external = true, round$1(x3, pr)) : x3;
  }
  sum2 = numerator = x3 = divide(x3.minus(ONE$7), x3.plus(ONE$7), wpr);
  x2 = round$1(x3.times(x3), wpr);
  denominator = 3;
  for (; ; ) {
    numerator = round$1(numerator.times(x2), wpr);
    t2 = sum2.plus(divide(numerator, new Ctor(denominator), wpr));
    if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2);
      if (e2 !== 0)
        sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e2 + ""));
      sum2 = divide(sum2, new Ctor(n4), wpr);
      Ctor.precision = pr;
      return sd2 == null ? (external = true, round$1(sum2, pr)) : sum2;
    }
    sum2 = t2;
    denominator += 2;
  }
}
function parseDecimal(x2, str) {
  var e2, i3, len;
  if ((e2 = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i3 = str.search(/e/i)) > 0) {
    if (e2 < 0)
      e2 = i3;
    e2 += +str.slice(i3 + 1);
    str = str.substring(0, i3);
  } else if (e2 < 0) {
    e2 = str.length;
  }
  for (i3 = 0; str.charCodeAt(i3) === 48; )
    ++i3;
  for (len = str.length; str.charCodeAt(len - 1) === 48; )
    --len;
  str = str.slice(i3, len);
  if (str) {
    len -= i3;
    e2 = e2 - i3 - 1;
    x2.e = mathfloor(e2 / LOG_BASE);
    x2.d = [];
    i3 = (e2 + 1) % LOG_BASE;
    if (e2 < 0)
      i3 += LOG_BASE;
    if (i3 < len) {
      if (i3)
        x2.d.push(+str.slice(0, i3));
      for (len -= LOG_BASE; i3 < len; )
        x2.d.push(+str.slice(i3, i3 += LOG_BASE));
      str = str.slice(i3);
      i3 = LOG_BASE - str.length;
    } else {
      i3 -= len;
    }
    for (; i3--; )
      str += "0";
    x2.d.push(+str);
    if (external && (x2.e > MAX_E || x2.e < -MAX_E))
      throw Error(exponentOutOfRange + e2);
  } else {
    x2.s = 0;
    x2.e = 0;
    x2.d = [0];
  }
  return x2;
}
function round$1(x2, sd2, rm) {
  var i3, j2, k4, n4, rd2, doRound, w2, xdi, xd2 = x2.d;
  for (n4 = 1, k4 = xd2[0]; k4 >= 10; k4 /= 10)
    n4++;
  i3 = sd2 - n4;
  if (i3 < 0) {
    i3 += LOG_BASE;
    j2 = sd2;
    w2 = xd2[xdi = 0];
  } else {
    xdi = Math.ceil((i3 + 1) / LOG_BASE);
    k4 = xd2.length;
    if (xdi >= k4)
      return x2;
    w2 = k4 = xd2[xdi];
    for (n4 = 1; k4 >= 10; k4 /= 10)
      n4++;
    i3 %= LOG_BASE;
    j2 = i3 - LOG_BASE + n4;
  }
  if (rm !== void 0) {
    k4 = mathpow(10, n4 - j2 - 1);
    rd2 = w2 / k4 % 10 | 0;
    doRound = sd2 < 0 || xd2[xdi + 1] !== void 0 || w2 % k4;
    doRound = rm < 4 ? (rd2 || doRound) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd2 > 5 || rd2 == 5 && (rm == 4 || doRound || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (i3 > 0 ? j2 > 0 ? w2 / mathpow(10, n4 - j2) : 0 : xd2[xdi - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
  }
  if (sd2 < 1 || !xd2[0]) {
    if (doRound) {
      k4 = getBase10Exponent(x2);
      xd2.length = 1;
      sd2 = sd2 - k4 - 1;
      xd2[0] = mathpow(10, (LOG_BASE - sd2 % LOG_BASE) % LOG_BASE);
      x2.e = mathfloor(-sd2 / LOG_BASE) || 0;
    } else {
      xd2.length = 1;
      xd2[0] = x2.e = x2.s = 0;
    }
    return x2;
  }
  if (i3 == 0) {
    xd2.length = xdi;
    k4 = 1;
    xdi--;
  } else {
    xd2.length = xdi + 1;
    k4 = mathpow(10, LOG_BASE - i3);
    xd2[xdi] = j2 > 0 ? (w2 / mathpow(10, n4 - j2) % mathpow(10, j2) | 0) * k4 : 0;
  }
  if (doRound) {
    for (; ; ) {
      if (xdi == 0) {
        if ((xd2[0] += k4) == BASE) {
          xd2[0] = 1;
          ++x2.e;
        }
        break;
      } else {
        xd2[xdi] += k4;
        if (xd2[xdi] != BASE)
          break;
        xd2[xdi--] = 0;
        k4 = 1;
      }
    }
  }
  for (i3 = xd2.length; xd2[--i3] === 0; )
    xd2.pop();
  if (external && (x2.e > MAX_E || x2.e < -MAX_E)) {
    throw Error(exponentOutOfRange + getBase10Exponent(x2));
  }
  return x2;
}
function subtract(x2, y2) {
  var d2, e2, i3, j2, k4, len, xd2, xe, xLTy, yd2, Ctor = x2.constructor, pr = Ctor.precision;
  if (!x2.s || !y2.s) {
    if (y2.s)
      y2.s = -y2.s;
    else
      y2 = new Ctor(x2);
    return external ? round$1(y2, pr) : y2;
  }
  xd2 = x2.d;
  yd2 = y2.d;
  e2 = y2.e;
  xe = x2.e;
  xd2 = xd2.slice();
  k4 = xe - e2;
  if (k4) {
    xLTy = k4 < 0;
    if (xLTy) {
      d2 = xd2;
      k4 = -k4;
      len = yd2.length;
    } else {
      d2 = yd2;
      e2 = xe;
      len = xd2.length;
    }
    i3 = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k4 > i3) {
      k4 = i3;
      d2.length = 1;
    }
    d2.reverse();
    for (i3 = k4; i3--; )
      d2.push(0);
    d2.reverse();
  } else {
    i3 = xd2.length;
    len = yd2.length;
    xLTy = i3 < len;
    if (xLTy)
      len = i3;
    for (i3 = 0; i3 < len; i3++) {
      if (xd2[i3] != yd2[i3]) {
        xLTy = xd2[i3] < yd2[i3];
        break;
      }
    }
    k4 = 0;
  }
  if (xLTy) {
    d2 = xd2;
    xd2 = yd2;
    yd2 = d2;
    y2.s = -y2.s;
  }
  len = xd2.length;
  for (i3 = yd2.length - len; i3 > 0; --i3)
    xd2[len++] = 0;
  for (i3 = yd2.length; i3 > k4; ) {
    if (xd2[--i3] < yd2[i3]) {
      for (j2 = i3; j2 && xd2[--j2] === 0; )
        xd2[j2] = BASE - 1;
      --xd2[j2];
      xd2[i3] += BASE;
    }
    xd2[i3] -= yd2[i3];
  }
  for (; xd2[--len] === 0; )
    xd2.pop();
  for (; xd2[0] === 0; xd2.shift())
    --e2;
  if (!xd2[0])
    return new Ctor(0);
  y2.d = xd2;
  y2.e = e2;
  return external ? round$1(y2, pr) : y2;
}
function toString$3(x2, isExp, sd2) {
  var k4, e2 = getBase10Exponent(x2), str = digitsToString(x2.d), len = str.length;
  if (isExp) {
    if (sd2 && (k4 = sd2 - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k4);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (e2 < 0 ? "e" : "e+") + e2;
  } else if (e2 < 0) {
    str = "0." + getZeroString(-e2 - 1) + str;
    if (sd2 && (k4 = sd2 - len) > 0)
      str += getZeroString(k4);
  } else if (e2 >= len) {
    str += getZeroString(e2 + 1 - len);
    if (sd2 && (k4 = sd2 - e2 - 1) > 0)
      str = str + "." + getZeroString(k4);
  } else {
    if ((k4 = e2 + 1) < len)
      str = str.slice(0, k4) + "." + str.slice(k4);
    if (sd2 && (k4 = sd2 - len) > 0) {
      if (e2 + 1 === len)
        str += ".";
      str += getZeroString(k4);
    }
  }
  return x2.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function clone$1(obj) {
  var i3, p2, ps;
  function Decimal2(value) {
    var x2 = this;
    if (!(x2 instanceof Decimal2))
      return new Decimal2(value);
    x2.constructor = Decimal2;
    if (value instanceof Decimal2) {
      x2.s = value.s;
      x2.e = value.e;
      x2.d = (value = value.d) ? value.slice() : value;
      return;
    }
    if (typeof value === "number") {
      if (value * 0 !== 0) {
        throw Error(invalidArgument + value);
      }
      if (value > 0) {
        x2.s = 1;
      } else if (value < 0) {
        value = -value;
        x2.s = -1;
      } else {
        x2.s = 0;
        x2.e = 0;
        x2.d = [0];
        return;
      }
      if (value === ~~value && value < 1e7) {
        x2.e = 0;
        x2.d = [value];
        return;
      }
      return parseDecimal(x2, value.toString());
    } else if (typeof value !== "string") {
      throw Error(invalidArgument + value);
    }
    if (value.charCodeAt(0) === 45) {
      value = value.slice(1);
      x2.s = -1;
    } else {
      x2.s = 1;
    }
    if (isDecimal.test(value))
      parseDecimal(x2, value);
    else
      throw Error(invalidArgument + value);
  }
  Decimal2.prototype = P$3;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.clone = clone$1;
  Decimal2.config = Decimal2.set = config$1;
  if (obj === void 0)
    obj = {};
  if (obj) {
    ps = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
    for (i3 = 0; i3 < ps.length; )
      if (!obj.hasOwnProperty(p2 = ps[i3++]))
        obj[p2] = this[p2];
  }
  Decimal2.config(obj);
  return Decimal2;
}
function config$1(obj) {
  if (!obj || typeof obj !== "object") {
    throw Error(decimalError + "Object expected");
  }
  var i3, p2, v2, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -1 / 0,
    0,
    "toExpPos",
    0,
    1 / 0
  ];
  for (i3 = 0; i3 < ps.length; i3 += 3) {
    if ((v2 = obj[p2 = ps[i3]]) !== void 0) {
      if (mathfloor(v2) === v2 && v2 >= ps[i3 + 1] && v2 <= ps[i3 + 2])
        this[p2] = v2;
      else
        throw Error(invalidArgument + p2 + ": " + v2);
    }
  }
  if ((v2 = obj[p2 = "LN10"]) !== void 0) {
    if (v2 == Math.LN10)
      this[p2] = new this(v2);
    else
      throw Error(invalidArgument + p2 + ": " + v2);
  }
  return this;
}
var Decimal$4 = clone$1(defaults$4);
ONE$7 = new Decimal$4(1);
const _Decimal = Decimal$4;
var DP = 20, RM = 1, MAX_DP = 1e6, MAX_POWER = 1e6, NE = -7, PE = 21, NAME = "[big.js] ", INVALID$1 = NAME + "Invalid ", INVALID_DP = INVALID$1 + "decimal places", INVALID_RM = INVALID$1 + "rounding mode", DIV_BY_ZERO = NAME + "Division by zero", P$2 = {}, UNDEFINED = void 0, NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
function _Big_() {
  function Big2(n4) {
    var x2 = this;
    if (!(x2 instanceof Big2))
      return n4 === UNDEFINED ? _Big_() : new Big2(n4);
    if (n4 instanceof Big2) {
      x2.s = n4.s;
      x2.e = n4.e;
      x2.c = n4.c.slice();
    } else {
      parse$1(x2, n4);
    }
    x2.constructor = Big2;
  }
  Big2.prototype = P$2;
  Big2.DP = DP;
  Big2.RM = RM;
  Big2.NE = NE;
  Big2.PE = PE;
  Big2.version = "5.2.2";
  return Big2;
}
function parse$1(x2, n4) {
  var e2, i3, nl2;
  if (n4 === 0 && 1 / n4 < 0)
    n4 = "-0";
  else if (!NUMERIC.test(n4 += ""))
    throw Error(INVALID$1 + "number");
  x2.s = n4.charAt(0) == "-" ? (n4 = n4.slice(1), -1) : 1;
  if ((e2 = n4.indexOf(".")) > -1)
    n4 = n4.replace(".", "");
  if ((i3 = n4.search(/e/i)) > 0) {
    if (e2 < 0)
      e2 = i3;
    e2 += +n4.slice(i3 + 1);
    n4 = n4.substring(0, i3);
  } else if (e2 < 0) {
    e2 = n4.length;
  }
  nl2 = n4.length;
  for (i3 = 0; i3 < nl2 && n4.charAt(i3) == "0"; )
    ++i3;
  if (i3 == nl2) {
    x2.c = [x2.e = 0];
  } else {
    for (; nl2 > 0 && n4.charAt(--nl2) == "0"; )
      ;
    x2.e = e2 - i3 - 1;
    x2.c = [];
    for (e2 = 0; i3 <= nl2; )
      x2.c[e2++] = +n4.charAt(i3++);
  }
  return x2;
}
function round(x2, dp, rm, more) {
  var xc2 = x2.c, i3 = x2.e + dp + 1;
  if (i3 < xc2.length) {
    if (rm === 1) {
      more = xc2[i3] >= 5;
    } else if (rm === 2) {
      more = xc2[i3] > 5 || xc2[i3] == 5 && (more || i3 < 0 || xc2[i3 + 1] !== UNDEFINED || xc2[i3 - 1] & 1);
    } else if (rm === 3) {
      more = more || !!xc2[0];
    } else {
      more = false;
      if (rm !== 0)
        throw Error(INVALID_RM);
    }
    if (i3 < 1) {
      xc2.length = 1;
      if (more) {
        x2.e = -dp;
        xc2[0] = 1;
      } else {
        xc2[0] = x2.e = 0;
      }
    } else {
      xc2.length = i3--;
      if (more) {
        for (; ++xc2[i3] > 9; ) {
          xc2[i3] = 0;
          if (!i3--) {
            ++x2.e;
            xc2.unshift(1);
          }
        }
      }
      for (i3 = xc2.length; !xc2[--i3]; )
        xc2.pop();
    }
  } else if (rm < 0 || rm > 3 || rm !== ~~rm) {
    throw Error(INVALID_RM);
  }
  return x2;
}
function stringify$1(x2, id2, n4, k4) {
  var e2, s4, Big2 = x2.constructor, z2 = !x2.c[0];
  if (n4 !== UNDEFINED) {
    if (n4 !== ~~n4 || n4 < (id2 == 3) || n4 > MAX_DP) {
      throw Error(id2 == 3 ? INVALID$1 + "precision" : INVALID_DP);
    }
    x2 = new Big2(x2);
    n4 = k4 - x2.e;
    if (x2.c.length > ++k4)
      round(x2, n4, Big2.RM);
    if (id2 == 2)
      k4 = x2.e + n4 + 1;
    for (; x2.c.length < k4; )
      x2.c.push(0);
  }
  e2 = x2.e;
  s4 = x2.c.join("");
  n4 = s4.length;
  if (id2 != 2 && (id2 == 1 || id2 == 3 && k4 <= e2 || e2 <= Big2.NE || e2 >= Big2.PE)) {
    s4 = s4.charAt(0) + (n4 > 1 ? "." + s4.slice(1) : "") + (e2 < 0 ? "e" : "e+") + e2;
  } else if (e2 < 0) {
    for (; ++e2; )
      s4 = "0" + s4;
    s4 = "0." + s4;
  } else if (e2 > 0) {
    if (++e2 > n4)
      for (e2 -= n4; e2--; )
        s4 += "0";
    else if (e2 < n4)
      s4 = s4.slice(0, e2) + "." + s4.slice(e2);
  } else if (n4 > 1) {
    s4 = s4.charAt(0) + "." + s4.slice(1);
  }
  return x2.s < 0 && (!z2 || id2 == 4) ? "-" + s4 : s4;
}
P$2.abs = function() {
  var x2 = new this.constructor(this);
  x2.s = 1;
  return x2;
};
P$2.cmp = function(y2) {
  var isneg, x2 = this, xc2 = x2.c, yc2 = (y2 = new x2.constructor(y2)).c, i3 = x2.s, j2 = y2.s, k4 = x2.e, l2 = y2.e;
  if (!xc2[0] || !yc2[0])
    return !xc2[0] ? !yc2[0] ? 0 : -j2 : i3;
  if (i3 != j2)
    return i3;
  isneg = i3 < 0;
  if (k4 != l2)
    return k4 > l2 ^ isneg ? 1 : -1;
  j2 = (k4 = xc2.length) < (l2 = yc2.length) ? k4 : l2;
  for (i3 = -1; ++i3 < j2; ) {
    if (xc2[i3] != yc2[i3])
      return xc2[i3] > yc2[i3] ^ isneg ? 1 : -1;
  }
  return k4 == l2 ? 0 : k4 > l2 ^ isneg ? 1 : -1;
};
P$2.div = function(y2) {
  var x2 = this, Big2 = x2.constructor, a2 = x2.c, b3 = (y2 = new Big2(y2)).c, k4 = x2.s == y2.s ? 1 : -1, dp = Big2.DP;
  if (dp !== ~~dp || dp < 0 || dp > MAX_DP)
    throw Error(INVALID_DP);
  if (!b3[0])
    throw Error(DIV_BY_ZERO);
  if (!a2[0])
    return new Big2(k4 * 0);
  var bl2, bt2, n4, cmp, ri2, bz = b3.slice(), ai2 = bl2 = b3.length, al2 = a2.length, r2 = a2.slice(0, bl2), rl2 = r2.length, q2 = y2, qc2 = q2.c = [], qi2 = 0, d2 = dp + (q2.e = x2.e - y2.e) + 1;
  q2.s = k4;
  k4 = d2 < 0 ? 0 : d2;
  bz.unshift(0);
  for (; rl2++ < bl2; )
    r2.push(0);
  do {
    for (n4 = 0; n4 < 10; n4++) {
      if (bl2 != (rl2 = r2.length)) {
        cmp = bl2 > rl2 ? 1 : -1;
      } else {
        for (ri2 = -1, cmp = 0; ++ri2 < bl2; ) {
          if (b3[ri2] != r2[ri2]) {
            cmp = b3[ri2] > r2[ri2] ? 1 : -1;
            break;
          }
        }
      }
      if (cmp < 0) {
        for (bt2 = rl2 == bl2 ? b3 : bz; rl2; ) {
          if (r2[--rl2] < bt2[rl2]) {
            ri2 = rl2;
            for (; ri2 && !r2[--ri2]; )
              r2[ri2] = 9;
            --r2[ri2];
            r2[rl2] += 10;
          }
          r2[rl2] -= bt2[rl2];
        }
        for (; !r2[0]; )
          r2.shift();
      } else {
        break;
      }
    }
    qc2[qi2++] = cmp ? n4 : ++n4;
    if (r2[0] && cmp)
      r2[rl2] = a2[ai2] || 0;
    else
      r2 = [a2[ai2]];
  } while ((ai2++ < al2 || r2[0] !== UNDEFINED) && k4--);
  if (!qc2[0] && qi2 != 1) {
    qc2.shift();
    q2.e--;
  }
  if (qi2 > d2)
    round(q2, dp, Big2.RM, r2[0] !== UNDEFINED);
  return q2;
};
P$2.eq = function(y2) {
  return !this.cmp(y2);
};
P$2.gt = function(y2) {
  return this.cmp(y2) > 0;
};
P$2.gte = function(y2) {
  return this.cmp(y2) > -1;
};
P$2.lt = function(y2) {
  return this.cmp(y2) < 0;
};
P$2.lte = function(y2) {
  return this.cmp(y2) < 1;
};
P$2.minus = P$2.sub = function(y2) {
  var i3, j2, t2, xlty, x2 = this, Big2 = x2.constructor, a2 = x2.s, b3 = (y2 = new Big2(y2)).s;
  if (a2 != b3) {
    y2.s = -b3;
    return x2.plus(y2);
  }
  var xc2 = x2.c.slice(), xe = x2.e, yc2 = y2.c, ye = y2.e;
  if (!xc2[0] || !yc2[0]) {
    return yc2[0] ? (y2.s = -b3, y2) : new Big2(xc2[0] ? x2 : 0);
  }
  if (a2 = xe - ye) {
    if (xlty = a2 < 0) {
      a2 = -a2;
      t2 = xc2;
    } else {
      ye = xe;
      t2 = yc2;
    }
    t2.reverse();
    for (b3 = a2; b3--; )
      t2.push(0);
    t2.reverse();
  } else {
    j2 = ((xlty = xc2.length < yc2.length) ? xc2 : yc2).length;
    for (a2 = b3 = 0; b3 < j2; b3++) {
      if (xc2[b3] != yc2[b3]) {
        xlty = xc2[b3] < yc2[b3];
        break;
      }
    }
  }
  if (xlty) {
    t2 = xc2;
    xc2 = yc2;
    yc2 = t2;
    y2.s = -y2.s;
  }
  if ((b3 = (j2 = yc2.length) - (i3 = xc2.length)) > 0)
    for (; b3--; )
      xc2[i3++] = 0;
  for (b3 = i3; j2 > a2; ) {
    if (xc2[--j2] < yc2[j2]) {
      for (i3 = j2; i3 && !xc2[--i3]; )
        xc2[i3] = 9;
      --xc2[i3];
      xc2[j2] += 10;
    }
    xc2[j2] -= yc2[j2];
  }
  for (; xc2[--b3] === 0; )
    xc2.pop();
  for (; xc2[0] === 0; ) {
    xc2.shift();
    --ye;
  }
  if (!xc2[0]) {
    y2.s = 1;
    xc2 = [ye = 0];
  }
  y2.c = xc2;
  y2.e = ye;
  return y2;
};
P$2.mod = function(y2) {
  var ygtx, x2 = this, Big2 = x2.constructor, a2 = x2.s, b3 = (y2 = new Big2(y2)).s;
  if (!y2.c[0])
    throw Error(DIV_BY_ZERO);
  x2.s = y2.s = 1;
  ygtx = y2.cmp(x2) == 1;
  x2.s = a2;
  y2.s = b3;
  if (ygtx)
    return new Big2(x2);
  a2 = Big2.DP;
  b3 = Big2.RM;
  Big2.DP = Big2.RM = 0;
  x2 = x2.div(y2);
  Big2.DP = a2;
  Big2.RM = b3;
  return this.minus(x2.times(y2));
};
P$2.plus = P$2.add = function(y2) {
  var t2, x2 = this, Big2 = x2.constructor, a2 = x2.s, b3 = (y2 = new Big2(y2)).s;
  if (a2 != b3) {
    y2.s = -b3;
    return x2.minus(y2);
  }
  var xe = x2.e, xc2 = x2.c, ye = y2.e, yc2 = y2.c;
  if (!xc2[0] || !yc2[0])
    return yc2[0] ? y2 : new Big2(xc2[0] ? x2 : a2 * 0);
  xc2 = xc2.slice();
  if (a2 = xe - ye) {
    if (a2 > 0) {
      ye = xe;
      t2 = yc2;
    } else {
      a2 = -a2;
      t2 = xc2;
    }
    t2.reverse();
    for (; a2--; )
      t2.push(0);
    t2.reverse();
  }
  if (xc2.length - yc2.length < 0) {
    t2 = yc2;
    yc2 = xc2;
    xc2 = t2;
  }
  a2 = yc2.length;
  for (b3 = 0; a2; xc2[a2] %= 10)
    b3 = (xc2[--a2] = xc2[a2] + yc2[a2] + b3) / 10 | 0;
  if (b3) {
    xc2.unshift(b3);
    ++ye;
  }
  for (a2 = xc2.length; xc2[--a2] === 0; )
    xc2.pop();
  y2.c = xc2;
  y2.e = ye;
  return y2;
};
P$2.pow = function(n4) {
  var x2 = this, one = new x2.constructor(1), y2 = one, isneg = n4 < 0;
  if (n4 !== ~~n4 || n4 < -MAX_POWER || n4 > MAX_POWER)
    throw Error(INVALID$1 + "exponent");
  if (isneg)
    n4 = -n4;
  for (; ; ) {
    if (n4 & 1)
      y2 = y2.times(x2);
    n4 >>= 1;
    if (!n4)
      break;
    x2 = x2.times(x2);
  }
  return isneg ? one.div(y2) : y2;
};
P$2.round = function(dp, rm) {
  var Big2 = this.constructor;
  if (dp === UNDEFINED)
    dp = 0;
  else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP)
    throw Error(INVALID_DP);
  return round(new Big2(this), dp, rm === UNDEFINED ? Big2.RM : rm);
};
P$2.sqrt = function() {
  var r2, c2, t2, x2 = this, Big2 = x2.constructor, s4 = x2.s, e2 = x2.e, half = new Big2(0.5);
  if (!x2.c[0])
    return new Big2(x2);
  if (s4 < 0)
    throw Error(NAME + "No square root");
  s4 = Math.sqrt(x2 + "");
  if (s4 === 0 || s4 === 1 / 0) {
    c2 = x2.c.join("");
    if (!(c2.length + e2 & 1))
      c2 += "0";
    s4 = Math.sqrt(c2);
    e2 = ((e2 + 1) / 2 | 0) - (e2 < 0 || e2 & 1);
    r2 = new Big2((s4 == 1 / 0 ? "1e" : (s4 = s4.toExponential()).slice(0, s4.indexOf("e") + 1)) + e2);
  } else {
    r2 = new Big2(s4);
  }
  e2 = r2.e + (Big2.DP += 4);
  do {
    t2 = r2;
    r2 = half.times(t2.plus(x2.div(t2)));
  } while (t2.c.slice(0, e2).join("") !== r2.c.slice(0, e2).join(""));
  return round(r2, Big2.DP -= 4, Big2.RM);
};
P$2.times = P$2.mul = function(y2) {
  var c2, x2 = this, Big2 = x2.constructor, xc2 = x2.c, yc2 = (y2 = new Big2(y2)).c, a2 = xc2.length, b3 = yc2.length, i3 = x2.e, j2 = y2.e;
  y2.s = x2.s == y2.s ? 1 : -1;
  if (!xc2[0] || !yc2[0])
    return new Big2(y2.s * 0);
  y2.e = i3 + j2;
  if (a2 < b3) {
    c2 = xc2;
    xc2 = yc2;
    yc2 = c2;
    j2 = a2;
    a2 = b3;
    b3 = j2;
  }
  for (c2 = new Array(j2 = a2 + b3); j2--; )
    c2[j2] = 0;
  for (i3 = b3; i3--; ) {
    b3 = 0;
    for (j2 = a2 + i3; j2 > i3; ) {
      b3 = c2[j2] + yc2[i3] * xc2[j2 - i3 - 1] + b3;
      c2[j2--] = b3 % 10;
      b3 = b3 / 10 | 0;
    }
    c2[j2] = (c2[j2] + b3) % 10;
  }
  if (b3)
    ++y2.e;
  else
    c2.shift();
  for (i3 = c2.length; !c2[--i3]; )
    c2.pop();
  y2.c = c2;
  return y2;
};
P$2.toExponential = function(dp) {
  return stringify$1(this, 1, dp, dp);
};
P$2.toFixed = function(dp) {
  return stringify$1(this, 2, dp, this.e + dp);
};
P$2.toPrecision = function(sd2) {
  return stringify$1(this, 3, sd2, sd2 - 1);
};
P$2.toString = function() {
  return stringify$1(this);
};
P$2.valueOf = P$2.toJSON = function() {
  return stringify$1(this, 4);
};
var Big$5 = _Big_();
var toFormat$1 = { exports: {} };
(function(module) {
  function toFormat2(Ctor) {
    Ctor.prototype.toFormat = function toFormat3(dp, rm, fmt) {
      if (!this.e && this.e !== 0)
        return this.toString();
      var arr, g1, g2, i3, u2, nd2, intd, intp, fracp, dsep, gsep, gsize, sgsize, fgsep, fgsize, tfmt = this.format || {}, cfmt = this.constructor.format || {};
      if (dp != u2) {
        if (typeof dp == "object") {
          fmt = dp;
          dp = u2;
        } else if (rm != u2) {
          if (typeof rm == "object") {
            fmt = rm;
            rm = u2;
          } else if (typeof fmt != "object") {
            fmt = {};
          }
        } else {
          fmt = {};
        }
      } else {
        fmt = {};
      }
      arr = this.toFixed(dp, rm).split(".");
      intp = arr[0];
      fracp = arr[1];
      intd = this.s < 0 ? intp.slice(1) : intp;
      nd2 = intd.length;
      dsep = fmt.decimalSeparator;
      if (dsep == u2) {
        dsep = tfmt.decimalSeparator;
        if (dsep == u2) {
          dsep = cfmt.decimalSeparator;
          if (dsep == u2)
            dsep = ".";
        }
      }
      gsep = fmt.groupSeparator;
      if (gsep == u2) {
        gsep = tfmt.groupSeparator;
        if (gsep == u2)
          gsep = cfmt.groupSeparator;
      }
      if (gsep) {
        gsize = fmt.groupSize;
        if (gsize == u2) {
          gsize = tfmt.groupSize;
          if (gsize == u2) {
            gsize = cfmt.groupSize;
            if (gsize == u2)
              gsize = 0;
          }
        }
        sgsize = fmt.secondaryGroupSize;
        if (sgsize == u2) {
          sgsize = tfmt.secondaryGroupSize;
          if (sgsize == u2) {
            sgsize = cfmt.secondaryGroupSize;
            if (sgsize == u2)
              sgsize = 0;
          }
        }
        if (sgsize) {
          g1 = +sgsize;
          g2 = +gsize;
          nd2 -= g2;
        } else {
          g1 = +gsize;
          g2 = +sgsize;
        }
        if (g1 > 0 && nd2 > 0) {
          i3 = nd2 % g1 || g1;
          intp = intd.substr(0, i3);
          for (; i3 < nd2; i3 += g1)
            intp += gsep + intd.substr(i3, g1);
          if (g2 > 0)
            intp += gsep + intd.slice(i3);
          if (this.s < 0)
            intp = "-" + intp;
        }
      }
      if (fracp) {
        fgsep = fmt.fractionGroupSeparator;
        if (fgsep == u2) {
          fgsep = tfmt.fractionGroupSeparator;
          if (fgsep == u2)
            fgsep = cfmt.fractionGroupSeparator;
        }
        if (fgsep) {
          fgsize = fmt.fractionGroupSize;
          if (fgsize == u2) {
            fgsize = tfmt.fractionGroupSize;
            if (fgsize == u2) {
              fgsize = cfmt.fractionGroupSize;
              if (fgsize == u2)
                fgsize = 0;
            }
          }
          fgsize = +fgsize;
          if (fgsize) {
            fracp = fracp.replace(new RegExp("\\d{" + fgsize + "}\\B", "g"), "$&" + fgsep);
          }
        }
        return intp + dsep + fracp;
      } else {
        return intp;
      }
    };
    Ctor.format = {
      decimalSeparator: ".",
      groupSeparator: ",",
      groupSize: 3,
      secondaryGroupSize: 0,
      fractionGroupSeparator: "",
      fractionGroupSize: 0
    };
    return Ctor;
  }
  if (module.exports)
    module.exports = toFormat2;
})(toFormat$1);
var toFormatExports = toFormat$1.exports;
const toFormat = /* @__PURE__ */ getDefaultExportFromCjs(toFormatExports);
const version$m = "logger/5.7.0";
let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(version2) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version2,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code2, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code2, {});
    }
    if (!code2) {
      code2 = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key2) => {
      const value = params[key2];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i3 = 0; i3 < value.length; i3++) {
            hex += HEX[value[i3] >> 4];
            hex += HEX[value[i3] & 15];
          }
          messageDetails.push(key2 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key2 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
      }
    });
    messageDetails.push(`code=${code2}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code2) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code2;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code2;
    Object.keys(params).forEach(function(key2) {
      error[key2] = params[key2];
    });
    return error;
  }
  throwError(message, code2, params) {
    throw this.makeError(message, code2, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code2, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code2, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version$m);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version2) {
    return new Logger(version2);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
const version$l = "bytes/5.7.0";
const logger$q = new Logger(version$l);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i3 = 0; i3 < value.length; i3++) {
    const v2 = value[i3];
    if (!isInteger(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$q.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger$q.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i3 = 0; i3 < hex.length; i3 += 2) {
      result.push(parseInt(hex.substring(i3, i3 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger$q.throwArgumentError("invalid arrayify value", "value", value);
}
function concat$2(items) {
  const objects = items.map((item) => arrayify(item));
  const length2 = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length2);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value, length2) {
  value = arrayify(value);
  if (value.length > length2) {
    logger$q.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length2);
  result.set(value, length2 - value.length);
  return addSlice(result);
}
function isHexString(value, length2) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length2 && value.length !== 2 + 2 * length2) {
    return false;
  }
  return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$q.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger$q.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i3 = 0; i3 < value.length; i3++) {
      let v2 = value[i3];
      result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
    }
    return result;
  }
  return logger$q.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data2) {
  if (typeof data2 !== "string") {
    data2 = hexlify(data2);
  } else if (!isHexString(data2) || data2.length % 2) {
    return null;
  }
  return (data2.length - 2) / 2;
}
function hexDataSlice(data2, offset, endOffset) {
  if (typeof data2 !== "string") {
    data2 = hexlify(data2);
  } else if (!isHexString(data2) || data2.length % 2) {
    logger$q.throwArgumentError("invalid hexData", "value", data2);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data2.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data2.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString(value)) {
    logger$q.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad(value, length2) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger$q.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length2 + 2) {
    logger$q.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length2 + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature2)) {
    let bytes2 = arrayify(signature2);
    if (bytes2.length === 64) {
      result.v = 27 + (bytes2[32] >> 7);
      bytes2[32] &= 127;
      result.r = hexlify(bytes2.slice(0, 32));
      result.s = hexlify(bytes2.slice(32, 64));
    } else if (bytes2.length === 65) {
      result.r = hexlify(bytes2.slice(0, 32));
      result.s = hexlify(bytes2.slice(32, 64));
      result.v = bytes2[64];
    } else {
      logger$q.throwArgumentError("invalid signature string", "signature", signature2);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger$q.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes2[32] |= 128;
    }
    result._vs = hexlify(bytes2.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger$q.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs2[0] &= 127;
      const s4 = hexlify(vs2);
      if (result.s == null) {
        result.s = s4;
      } else if (result.s !== s4) {
        logger$q.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger$q.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger$q.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger$q.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger$q.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger$q.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger$q.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger$q.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
var bn = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$3$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
bn.exports;
(function(module) {
  (function(module2, exports) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number2, base3, endian) {
      if (BN2.isBN(number2)) {
        return number2;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number2 !== null) {
        if (base3 === "le" || base3 === "be") {
          endian = base3;
          base3 = 10;
        }
        this._init(number2 || 0, base3 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$3$1.Buffer;
      }
    } catch (e2) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init3(number2, base3, endian) {
      if (typeof number2 === "number") {
        return this._initNumber(number2, base3, endian);
      }
      if (typeof number2 === "object") {
        return this._initArray(number2, base3, endian);
      }
      if (base3 === "hex") {
        base3 = 16;
      }
      assert2(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
      number2 = number2.toString().replace(/\s+/g, "");
      var start = 0;
      if (number2[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number2.length) {
        if (base3 === 16) {
          this._parseHex(number2, start, endian);
        } else {
          this._parseBase(number2, base3, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base3, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number2, base3, endian) {
      if (number2 < 0) {
        this.negative = 1;
        number2 = -number2;
      }
      if (number2 < 67108864) {
        this.words = [number2 & 67108863];
        this.length = 1;
      } else if (number2 < 4503599627370496) {
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number2 < 9007199254740992);
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base3, endian);
    };
    BN2.prototype._initArray = function _initArray(number2, base3, endian) {
      assert2(typeof number2.length === "number");
      if (number2.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number2.length / 3);
      this.words = new Array(this.length);
      for (var i3 = 0; i3 < this.length; i3++) {
        this.words[i3] = 0;
      }
      var j2, w2;
      var off = 0;
      if (endian === "be") {
        for (i3 = number2.length - 1, j2 = 0; i3 >= 0; i3 -= 3) {
          w2 = number2[i3] | number2[i3 - 1] << 8 | number2[i3 - 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      } else if (endian === "le") {
        for (i3 = 0, j2 = 0; i3 < number2.length; i3 += 3) {
          w2 = number2[i3] | number2[i3 + 1] << 8 | number2[i3 + 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string2, index2) {
      var c2 = string2.charCodeAt(index2);
      if (c2 >= 48 && c2 <= 57) {
        return c2 - 48;
      } else if (c2 >= 65 && c2 <= 70) {
        return c2 - 55;
      } else if (c2 >= 97 && c2 <= 102) {
        return c2 - 87;
      } else {
        assert2(false, "Invalid character in " + string2);
      }
    }
    function parseHexByte(string2, lowerBound, index2) {
      var r2 = parseHex4Bits(string2, index2);
      if (index2 - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string2, index2 - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
      this.length = Math.ceil((number2.length - start) / 6);
      this.words = new Array(this.length);
      for (var i3 = 0; i3 < this.length; i3++) {
        this.words[i3] = 0;
      }
      var off = 0;
      var j2 = 0;
      var w2;
      if (endian === "be") {
        for (i3 = number2.length - 1; i3 >= start; i3 -= 2) {
          w2 = parseHexByte(number2, start, i3) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number2.length - start;
        for (i3 = parseLength % 2 === 0 ? start + 1 : start; i3 < number2.length; i3 += 2) {
          w2 = parseHexByte(number2, start, i3) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul4) {
      var r2 = 0;
      var b3 = 0;
      var len = Math.min(str.length, end);
      for (var i3 = start; i3 < len; i3++) {
        var c2 = str.charCodeAt(i3) - 48;
        r2 *= mul4;
        if (c2 >= 49) {
          b3 = c2 - 49 + 10;
        } else if (c2 >= 17) {
          b3 = c2 - 17 + 10;
        } else {
          b3 = c2;
        }
        assert2(c2 >= 0 && b3 < mul4, "Invalid character");
        r2 += b3;
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number2, base3, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base3 | 0;
      var total = number2.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i3 = start; i3 < end; i3 += limbLen) {
        word = parseBase(number2, i3, i3 + limbLen, base3);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number2, i3, number2.length, base3);
        for (i3 = 0; i3 < mod; i3++) {
          pow *= base3;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN2.prototype.copy = function copy2(dest) {
      dest.words = new Array(this.length);
      for (var i3 = 0; i3 < this.length; i3++) {
        dest.words[i3] = this.words[i3];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src2) {
      dest.words = src2.words;
      dest.length = src2.length;
      dest.negative = src2.negative;
      dest.red = src2.red;
    }
    BN2.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN2.prototype.clone = function clone2() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size2) {
      while (this.length < size2) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect5;
      } catch (e2) {
        BN2.prototype.inspect = inspect5;
      }
    } else {
      BN2.prototype.inspect = inspect5;
    }
    function inspect5() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString2(base3, padding2) {
      base3 = base3 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base3 === 16 || base3 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var w2 = this.words[i3];
          var word = ((w2 << off | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i3--;
          }
          if (carry !== 0 || i3 !== this.length - 1) {
            out = zeros2[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
        var groupSize = groupSizes[base3];
        var groupBase = groupBases[base3];
        out = "";
        var c2 = this.clone();
        c2.negative = 0;
        while (!c2.isZero()) {
          var r2 = c2.modrn(groupBase).toString(base3);
          c2 = c2.idivn(groupBase);
          if (!c2.isZero()) {
            out = zeros2[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON2() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN2.prototype.toBuffer = function toBuffer(endian, length2) {
        return this.toArrayLike(Buffer2, endian, length2);
      };
    }
    BN2.prototype.toArray = function toArray2(endian, length2) {
      return this.toArrayLike(Array, endian, length2);
    };
    var allocate = function allocate2(ArrayType, size2) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size2);
      }
      return new ArrayType(size2);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
      this._strip();
      var byteLength2 = this.byteLength();
      var reqLength = length2 || Math.max(1, byteLength2);
      assert2(byteLength2 <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength2);
      return res;
    };
    BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
      var position2 = 0;
      var carry = 0;
      for (var i3 = 0, shift = 0; i3 < this.length; i3++) {
        var word = this.words[i3] << shift | carry;
        res[position2++] = word & 255;
        if (position2 < res.length) {
          res[position2++] = word >> 8 & 255;
        }
        if (position2 < res.length) {
          res[position2++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position2 < res.length) {
            res[position2++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position2 < res.length) {
        res[position2++] = carry;
        while (position2 < res.length) {
          res[position2++] = 0;
        }
      }
    };
    BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
      var position2 = res.length - 1;
      var carry = 0;
      for (var i3 = 0, shift = 0; i3 < this.length; i3++) {
        var word = this.words[i3] << shift | carry;
        res[position2--] = word & 255;
        if (position2 >= 0) {
          res[position2--] = word >> 8 & 255;
        }
        if (position2 >= 0) {
          res[position2--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position2 >= 0) {
            res[position2--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position2 >= 0) {
        res[position2--] = carry;
        while (position2 >= 0) {
          res[position2--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t2 = w2;
        var r2 = 0;
        if (t2 >= 4096) {
          r2 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r2 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r2 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r2 += 2;
          t2 >>>= 2;
        }
        return r2 + t2;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0)
        return 26;
      var t2 = w2;
      var r2 = 0;
      if ((t2 & 8191) === 0) {
        r2 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r2 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r2 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r2 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi2 = this._countBits(w2);
      return (this.length - 1) * 26 + hi2;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = num.words[off] >>> wbit & 1;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i3 = 0; i3 < this.length; i3++) {
        var b3 = this._zeroBits(this.words[i3]);
        r2 += b3;
        if (b3 !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width2) {
      if (this.negative !== 0) {
        return this.abs().inotn(width2).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width2) {
      if (this.testn(width2 - 1)) {
        return this.notn(width2).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg3() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i3 = 0; i3 < num.length; i3++) {
        this.words[i3] = this.words[i3] | num.words[i3];
      }
      return this._strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or2(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b3;
      if (this.length > num.length) {
        b3 = num;
      } else {
        b3 = this;
      }
      for (var i3 = 0; i3 < b3.length; i3++) {
        this.words[i3] = this.words[i3] & num.words[i3];
      }
      this.length = b3.length;
      return this._strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a2;
      var b3;
      if (this.length > num.length) {
        a2 = this;
        b3 = num;
      } else {
        a2 = num;
        b3 = this;
      }
      for (var i3 = 0; i3 < b3.length; i3++) {
        this.words[i3] = a2.words[i3] ^ b3.words[i3];
      }
      if (this !== a2) {
        for (; i3 < a2.length; i3++) {
          this.words[i3] = a2.words[i3];
        }
      }
      this.length = a2.length;
      return this._strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width2) {
      assert2(typeof width2 === "number" && width2 >= 0);
      var bytesNeeded = Math.ceil(width2 / 26) | 0;
      var bitsLeft = width2 % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i3 = 0; i3 < bytesNeeded; i3++) {
        this.words[i3] = ~this.words[i3] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN2.prototype.notn = function notn(width2) {
      return this.clone().inotn(width2);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a2, b3;
      if (this.length > num.length) {
        a2 = this;
        b3 = num;
      } else {
        a2 = num;
        b3 = this;
      }
      var carry = 0;
      for (var i3 = 0; i3 < b3.length; i3++) {
        r2 = (a2.words[i3] | 0) + (b3.words[i3] | 0) + carry;
        this.words[i3] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i3 < a2.length; i3++) {
        r2 = (a2.words[i3] | 0) + carry;
        this.words[i3] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a2.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a2 !== this) {
        for (; i3 < a2.length; i3++) {
          this.words[i3] = a2.words[i3];
        }
      }
      return this;
    };
    BN2.prototype.add = function add4(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a2, b3;
      if (cmp > 0) {
        a2 = this;
        b3 = num;
      } else {
        a2 = num;
        b3 = this;
      }
      var carry = 0;
      for (var i3 = 0; i3 < b3.length; i3++) {
        r2 = (a2.words[i3] | 0) - (b3.words[i3] | 0) + carry;
        carry = r2 >> 26;
        this.words[i3] = r2 & 67108863;
      }
      for (; carry !== 0 && i3 < a2.length; i3++) {
        r2 = (a2.words[i3] | 0) + carry;
        carry = r2 >> 26;
        this.words[i3] = r2 & 67108863;
      }
      if (carry === 0 && i3 < a2.length && a2 !== this) {
        for (; i3 < a2.length; i3++) {
          this.words[i3] = a2.words[i3];
        }
      }
      this.length = Math.max(this.length, i3);
      if (a2 !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a2 = self2.words[0] | 0;
      var b3 = num.words[0] | 0;
      var r2 = a2 * b3;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k4 = 1; k4 < len; k4++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k4, num.length - 1);
        for (var j2 = Math.max(0, k4 - self2.length + 1); j2 <= maxJ; j2++) {
          var i3 = k4 - j2 | 0;
          a2 = self2.words[i3] | 0;
          b3 = num.words[j2] | 0;
          r2 = a2 * b3 + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k4] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k4] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a2 = self2.words;
      var b3 = num.words;
      var o2 = out.words;
      var c2 = 0;
      var lo;
      var mid;
      var hi2;
      var a0 = a2[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a2[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a22 = a2[2] | 0;
      var al2 = a22 & 8191;
      var ah2 = a22 >>> 13;
      var a3 = a2[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a2[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a2[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a2[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a2[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a2[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a2[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b3[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b3[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b3[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b32 = b3[3] | 0;
      var bl3 = b32 & 8191;
      var bh3 = b32 >>> 13;
      var b4 = b3[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b3[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b3[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b3[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b3[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b3[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi2 = Math.imul(ah0, bh0);
      var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi2 = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi2 = hi2 + Math.imul(ah0, bh1) | 0;
      var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi2 = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi2 = hi2 + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi2 = hi2 + Math.imul(ah0, bh2) | 0;
      var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi2 = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi2 = hi2 + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi2 = hi2 + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi2 = hi2 + Math.imul(ah0, bh3) | 0;
      var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi2 = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi2 = hi2 + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi2 = hi2 + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi2 = hi2 + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi2 = hi2 + Math.imul(ah0, bh4) | 0;
      var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi2 = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi2 = hi2 + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi2 = hi2 + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi2 = hi2 + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi2 = hi2 + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi2 = hi2 + Math.imul(ah0, bh5) | 0;
      var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi2 = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi2 = hi2 + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi2 = hi2 + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi2 = hi2 + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi2 = hi2 + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi2 = hi2 + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi2 = hi2 + Math.imul(ah0, bh6) | 0;
      var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi2 = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi2 = hi2 + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi2 = hi2 + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi2 = hi2 + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi2 = hi2 + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi2 = hi2 + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi2 = hi2 + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi2 = hi2 + Math.imul(ah0, bh7) | 0;
      var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi2 = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi2 = hi2 + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi2 = hi2 + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi2 = hi2 + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi2 = hi2 + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi2 = hi2 + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi2 = hi2 + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi2 = hi2 + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi2 = hi2 + Math.imul(ah0, bh8) | 0;
      var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi2 = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi2 = hi2 + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi2 = hi2 + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi2 = hi2 + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi2 = hi2 + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi2 = hi2 + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi2 = hi2 + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi2 = hi2 + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi2 = hi2 + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi2 = hi2 + Math.imul(ah0, bh9) | 0;
      var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi2 = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi2 = hi2 + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi2 = hi2 + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi2 = hi2 + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi2 = hi2 + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi2 = hi2 + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi2 = hi2 + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi2 = hi2 + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi2 = hi2 + Math.imul(ah1, bh9) | 0;
      var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi2 = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi2 = hi2 + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi2 = hi2 + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi2 = hi2 + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi2 = hi2 + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi2 = hi2 + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi2 = hi2 + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi2 = hi2 + Math.imul(ah2, bh9) | 0;
      var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi2 = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi2 = hi2 + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi2 = hi2 + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi2 = hi2 + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi2 = hi2 + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi2 = hi2 + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi2 = hi2 + Math.imul(ah3, bh9) | 0;
      var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi2 = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi2 = hi2 + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi2 = hi2 + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi2 = hi2 + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi2 = hi2 + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi2 = hi2 + Math.imul(ah4, bh9) | 0;
      var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi2 = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi2 = hi2 + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi2 = hi2 + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi2 = hi2 + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi2 = hi2 + Math.imul(ah5, bh9) | 0;
      var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi2 = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi2 = hi2 + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi2 = hi2 + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi2 = hi2 + Math.imul(ah6, bh9) | 0;
      var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi2 = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi2 = hi2 + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi2 = hi2 + Math.imul(ah7, bh9) | 0;
      var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi2 = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi2 = hi2 + Math.imul(ah8, bh9) | 0;
      var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi2 = Math.imul(ah9, bh9);
      var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o2[0] = w0;
      o2[1] = w1;
      o2[2] = w2;
      o2[3] = w3;
      o2[4] = w4;
      o2[5] = w5;
      o2[6] = w6;
      o2[7] = w7;
      o2[8] = w8;
      o2[9] = w9;
      o2[10] = w10;
      o2[11] = w11;
      o2[12] = w12;
      o2[13] = w13;
      o2[14] = w14;
      o2[15] = w15;
      o2[16] = w16;
      o2[17] = w17;
      o2[18] = w18;
      if (c2 !== 0) {
        o2[19] = c2;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k4 = 0; k4 < out.length - 1; k4++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k4, num.length - 1);
        for (var j2 = Math.max(0, k4 - self2.length + 1); j2 <= maxJ; j2++) {
          var i3 = k4 - j2;
          var a2 = self2.words[i3] | 0;
          var b3 = num.words[j2] | 0;
          var r2 = a2 * b3;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k4] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k4] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    BN2.prototype.mul = function mul4(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i3 = 0; i3 < this.length; i3++) {
        var w2 = (this.words[i3] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i3] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i3] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0)
        return new BN2(1);
      var res = this;
      for (var i3 = 0; i3 < w2.length; i3++, res = res.sqr()) {
        if (w2[i3] !== 0)
          break;
      }
      if (++i3 < w2.length) {
        for (var q2 = res.sqr(); i3 < w2.length; i3++, q2 = q2.sqr()) {
          if (w2[i3] === 0)
            continue;
          res = res.mul(q2);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s4 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i3;
      if (r2 !== 0) {
        var carry = 0;
        for (i3 = 0; i3 < this.length; i3++) {
          var newCarry = this.words[i3] & carryMask;
          var c2 = (this.words[i3] | 0) - newCarry << r2;
          this.words[i3] = c2 | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i3] = carry;
          this.length++;
        }
      }
      if (s4 !== 0) {
        for (i3 = this.length - 1; i3 >= 0; i3--) {
          this.words[i3 + s4] = this.words[i3];
        }
        for (i3 = 0; i3 < s4; i3++) {
          this.words[i3] = 0;
        }
        this.length += s4;
      }
      return this._strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h4;
      if (hint) {
        h4 = (hint - hint % 26) / 26;
      } else {
        h4 = 0;
      }
      var r2 = bits % 26;
      var s4 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h4 -= s4;
      h4 = Math.max(0, h4);
      if (maskedWords) {
        for (var i3 = 0; i3 < s4; i3++) {
          maskedWords.words[i3] = this.words[i3];
        }
        maskedWords.length = s4;
      }
      if (s4 === 0)
        ;
      else if (this.length > s4) {
        this.length -= s4;
        for (i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = this.words[i3 + s4];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h4); i3--) {
        var word = this.words[i3] | 0;
        this.words[i3] = carry << 26 - r2 | word >>> r2;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s4 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s4)
        return false;
      var w2 = this.words[s4];
      return !!(w2 & q2);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s4 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s4) {
        return this;
      }
      if (r2 !== 0) {
        s4++;
      }
      this.length = Math.min(s4, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this._strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
        this.words[i3] -= 67108864;
        if (i3 === this.length - 1) {
          this.words[i3 + 1] = 1;
        } else {
          this.words[i3 + 1]++;
        }
      }
      this.length = Math.max(this.length, i3 + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
          this.words[i3] += 67108864;
          this.words[i3 + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs2() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul4, shift) {
      var len = num.length + shift;
      var i3;
      this._expand(len);
      var w2;
      var carry = 0;
      for (i3 = 0; i3 < num.length; i3++) {
        w2 = (this.words[i3 + shift] | 0) + carry;
        var right = (num.words[i3] | 0) * mul4;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i3 + shift] = w2 & 67108863;
      }
      for (; i3 < this.length - shift; i3++) {
        w2 = (this.words[i3 + shift] | 0) + carry;
        carry = w2 >> 26;
        this.words[i3 + shift] = w2 & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i3 = 0; i3 < this.length; i3++) {
        w2 = -(this.words[i3] | 0) + carry;
        carry = w2 >> 26;
        this.words[i3] = w2 & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode2) {
      var shift = this.length - num.length;
      var a2 = this.clone();
      var b3 = num;
      var bhi = b3.words[b3.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b3 = b3.ushln(shift);
        a2.iushln(shift);
        bhi = b3.words[b3.length - 1] | 0;
      }
      var m2 = a2.length - b3.length;
      var q2;
      if (mode2 !== "mod") {
        q2 = new BN2(null);
        q2.length = m2 + 1;
        q2.words = new Array(q2.length);
        for (var i3 = 0; i3 < q2.length; i3++) {
          q2.words[i3] = 0;
        }
      }
      var diff = a2.clone()._ishlnsubmul(b3, 1, m2);
      if (diff.negative === 0) {
        a2 = diff;
        if (q2) {
          q2.words[m2] = 1;
        }
      }
      for (var j2 = m2 - 1; j2 >= 0; j2--) {
        var qj2 = (a2.words[b3.length + j2] | 0) * 67108864 + (a2.words[b3.length + j2 - 1] | 0);
        qj2 = Math.min(qj2 / bhi | 0, 67108863);
        a2._ishlnsubmul(b3, qj2, j2);
        while (a2.negative !== 0) {
          qj2--;
          a2.negative = 0;
          a2._ishlnsubmul(b3, 1, j2);
          if (!a2.isZero()) {
            a2.negative ^= 1;
          }
        }
        if (q2) {
          q2.words[j2] = qj2;
        }
      }
      if (q2) {
        q2._strip();
      }
      a2._strip();
      if (mode2 !== "div" && shift !== 0) {
        a2.iushrn(shift);
      }
      return {
        div: q2 || null,
        mod: a2
      };
    };
    BN2.prototype.divmod = function divmod(num, mode2, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        if (mode2 !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode2);
        if (mode2 !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode2 === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode2 === "mod") {
          return {
            div: null,
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode2);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i3 = this.length - 1; i3 >= 0; i3--) {
        acc = (p2 * acc + (this.words[i3] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN2.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN2.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i3 = this.length - 1; i3 >= 0; i3--) {
        var w2 = (this.words[i3] | 0) + carry * 67108864;
        this.words[i3] = w2 / num | 0;
        carry = w2 % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x2 = this;
      var y2 = p2.clone();
      if (x2.negative !== 0) {
        x2 = x2.umod(p2);
      } else {
        x2 = x2.clone();
      }
      var A2 = new BN2(1);
      var B2 = new BN2(0);
      var C2 = new BN2(0);
      var D2 = new BN2(1);
      var g2 = 0;
      while (x2.isEven() && y2.isEven()) {
        x2.iushrn(1);
        y2.iushrn(1);
        ++g2;
      }
      var yp = y2.clone();
      var xp = x2.clone();
      while (!x2.isZero()) {
        for (var i3 = 0, im = 1; (x2.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
          ;
        if (i3 > 0) {
          x2.iushrn(i3);
          while (i3-- > 0) {
            if (A2.isOdd() || B2.isOdd()) {
              A2.iadd(yp);
              B2.isub(xp);
            }
            A2.iushrn(1);
            B2.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          y2.iushrn(j2);
          while (j2-- > 0) {
            if (C2.isOdd() || D2.isOdd()) {
              C2.iadd(yp);
              D2.isub(xp);
            }
            C2.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x2.cmp(y2) >= 0) {
          x2.isub(y2);
          A2.isub(C2);
          B2.isub(D2);
        } else {
          y2.isub(x2);
          C2.isub(A2);
          D2.isub(B2);
        }
      }
      return {
        a: C2,
        b: D2,
        gcd: y2.iushln(g2)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a2 = this;
      var b3 = p2.clone();
      if (a2.negative !== 0) {
        a2 = a2.umod(p2);
      } else {
        a2 = a2.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b3.clone();
      while (a2.cmpn(1) > 0 && b3.cmpn(1) > 0) {
        for (var i3 = 0, im = 1; (a2.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
          ;
        if (i3 > 0) {
          a2.iushrn(i3);
          while (i3-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (b3.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          b3.iushrn(j2);
          while (j2-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a2.cmp(b3) >= 0) {
          a2.isub(b3);
          x1.isub(x2);
        } else {
          b3.isub(a2);
          x2.isub(x1);
        }
      }
      var res;
      if (a2.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a2 = this.clone();
      var b3 = num.clone();
      a2.negative = 0;
      b3.negative = 0;
      for (var shift = 0; a2.isEven() && b3.isEven(); shift++) {
        a2.iushrn(1);
        b3.iushrn(1);
      }
      do {
        while (a2.isEven()) {
          a2.iushrn(1);
        }
        while (b3.isEven()) {
          b3.iushrn(1);
        }
        var r2 = a2.cmp(b3);
        if (r2 < 0) {
          var t2 = a2;
          a2 = b3;
          b3 = t2;
        } else if (r2 === 0 || b3.cmpn(1) === 0) {
          break;
        }
        a2.isub(b3);
      } while (true);
      return b3.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s4 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s4) {
        this._expand(s4 + 1);
        this.words[s4] |= q2;
        return this;
      }
      var carry = q2;
      for (var i3 = s4; carry !== 0 && i3 < this.length; i3++) {
        var w2 = this.words[i3] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i3] = w2;
      }
      if (carry !== 0) {
        this.words[i3] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i3 = this.length - 1; i3 >= 0; i3--) {
        var a2 = this.words[i3] | 0;
        var b3 = num.words[i3] | 0;
        if (a2 === b3)
          continue;
        if (a2 < b3) {
          res = -1;
        } else if (a2 > b3) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt2(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt2(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq4(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red2(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p2) {
      this.name = name2;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split2(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split2(input, output2) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i3 = 0; i3 < outLen; i3++) {
        output2.words[i3] = input.words[i3];
      }
      output2.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev2 = input.words[9];
      output2.words[output2.length++] = prev2 & mask;
      for (i3 = 10; i3 < input.length; i3++) {
        var next2 = input.words[i3] | 0;
        input.words[i3 - 10] = (next2 & mask) << 4 | prev2 >>> 22;
        prev2 = next2;
      }
      prev2 >>>= 22;
      input.words[i3 - 10] = prev2;
      if (prev2 === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i3 = 0; i3 < num.length; i3++) {
        var w2 = num.words[i3] | 0;
        lo += w2 * 977;
        num.words[i3] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i3 = 0; i3 < num.length; i3++) {
        var hi2 = (num.words[i3] | 0) * 19 + carry;
        var lo = hi2 & 67108863;
        hi2 >>>= 26;
        num.words[i3] = lo;
        carry = hi2;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2])
        return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a2) {
      assert2(a2.negative === 0, "red works only with positives");
      assert2(a2.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a2, b3) {
      assert2((a2.negative | b3.negative) === 0, "red works only with positives");
      assert2(
        a2.red && a2.red === b3.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a2) {
      if (this.prime)
        return this.prime.ireduce(a2)._forceRed(this);
      move(a2, a2.umod(this.m)._forceRed(this));
      return a2;
    };
    Red.prototype.neg = function neg3(a2) {
      if (a2.isZero()) {
        return a2.clone();
      }
      return this.m.sub(a2)._forceRed(this);
    };
    Red.prototype.add = function add4(a2, b3) {
      this._verify2(a2, b3);
      var res = a2.add(b3);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a2, b3) {
      this._verify2(a2, b3);
      var res = a2.iadd(b3);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a2, b3) {
      this._verify2(a2, b3);
      var res = a2.sub(b3);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a2, b3) {
      this._verify2(a2, b3);
      var res = a2.isub(b3);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a2, num) {
      this._verify1(a2);
      return this.imod(a2.ushln(num));
    };
    Red.prototype.imul = function imul(a2, b3) {
      this._verify2(a2, b3);
      return this.imod(a2.imul(b3));
    };
    Red.prototype.mul = function mul4(a2, b3) {
      this._verify2(a2, b3);
      return this.imod(a2.mul(b3));
    };
    Red.prototype.isqr = function isqr(a2) {
      return this.imul(a2, a2.clone());
    };
    Red.prototype.sqr = function sqr(a2) {
      return this.mul(a2, a2);
    };
    Red.prototype.sqrt = function sqrt2(a2) {
      if (a2.isZero())
        return a2.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a2, pow);
      }
      var q2 = this.m.subn(1);
      var s4 = 0;
      while (!q2.isZero() && q2.andln(1) === 0) {
        s4++;
        q2.iushrn(1);
      }
      assert2(!q2.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN2(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c2 = this.pow(z2, q2);
      var r2 = this.pow(a2, q2.addn(1).iushrn(1));
      var t2 = this.pow(a2, q2);
      var m2 = s4;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i3 = 0; tmp.cmp(one) !== 0; i3++) {
          tmp = tmp.redSqr();
        }
        assert2(i3 < m2);
        var b3 = this.pow(c2, new BN2(1).iushln(m2 - i3 - 1));
        r2 = r2.redMul(b3);
        c2 = b3.redSqr();
        t2 = t2.redMul(c2);
        m2 = i3;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a2) {
      var inv = a2._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a2, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a2.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a2;
      for (var i3 = 2; i3 < wnd.length; i3++) {
        wnd[i3] = this.mul(wnd[i3 - 1], a2);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i3 = num.length - 1; i3 >= 0; i3--) {
        var word = num.words[i3];
        for (var j2 = start - 1; j2 >= 0; j2--) {
          var bit = word >> j2 & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i3 !== 0 || j2 !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a2, b3) {
      if (a2.isZero() || b3.isZero()) {
        a2.words[0] = 0;
        a2.length = 1;
        return a2;
      }
      var t2 = a2.imul(b3);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul4(a2, b3) {
      if (a2.isZero() || b3.isZero())
        return new BN2(0)._forceRed(this);
      var t2 = a2.mul(b3);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a2) {
      var res = this.imod(a2._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn);
var bnExports = bn.exports;
const BN$1 = /* @__PURE__ */ getDefaultExportFromCjs(bnExports);
const version$k = "bignumber/5.7.0";
var BN = BN$1.BN;
const logger$p = new Logger(version$k);
const _constructorGuard$3 = {};
const MAX_SAFE = 9007199254740991;
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
}
let _warnedToStringRadix = false;
class BigNumber {
  constructor(constructorGuard, hex) {
    if (constructorGuard !== _constructorGuard$3) {
      logger$p.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o2 = BigNumber.from(other);
    if (o2.isZero()) {
      throwFault$1("division-by-zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault$1("division-by-zero", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault$1("negative-power", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault$1("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e2) {
    }
    return logger$p.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger$p.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger$p.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger$p.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key2) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard$3, toHex$4(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard$3, toHex$4(new BN(value)));
      }
      return logger$p.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault$1("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault$1("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
            return BigNumber.from(hex);
          }
        }
      }
    }
    return logger$p.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
}
function toHex$4(value) {
  if (typeof value !== "string") {
    return toHex$4(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger$p.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex$4(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex$4(value));
}
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
}
function throwFault$1(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger$p.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN(value, 36).toString(16);
}
const logger$o = new Logger(version$k);
const _constructorGuard$2 = {};
const Zero$2 = BigNumber.from(0);
const NegativeOne$2 = BigNumber.from(-1);
function throwFault(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger$o.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
let zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e2) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger$o.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero$2);
  if (negative) {
    value = value.mul(NegativeOne$2);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger$o.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger$o.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger$o.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne$2);
  }
  return wei;
}
class FixedFormat {
  constructor(constructorGuard, signed2, width2, decimals) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$o.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed2;
    this.width = width2;
    this.decimals = decimals;
    this.name = (signed2 ? "" : "u") + "fixed" + String(width2) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed2 = true;
    let width2 = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed")
        ;
      else if (value === "ufixed") {
        signed2 = false;
      } else {
        const match2 = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match2) {
          logger$o.throwArgumentError("invalid fixed format", "format", value);
        }
        signed2 = match2[1] !== "u";
        width2 = parseInt(match2[2]);
        decimals = parseInt(match2[3]);
      }
    } else if (value) {
      const check = (key2, type, defaultValue) => {
        if (value[key2] == null) {
          return defaultValue;
        }
        if (typeof value[key2] !== type) {
          logger$o.throwArgumentError("invalid fixed format (" + key2 + " not " + type + ")", "format." + key2, value[key2]);
        }
        return value[key2];
      };
      signed2 = check("signed", "boolean", signed2);
      width2 = check("width", "number", width2);
      decimals = check("decimals", "number", decimals);
    }
    if (width2 % 8) {
      logger$o.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width2);
    }
    if (decimals > 80) {
      logger$o.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard$2, signed2, width2, decimals);
  }
}
class FixedNumber {
  constructor(constructorGuard, hex, value, format) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$o.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger$o.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b3 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.add(b3), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b3 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.sub(b3), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b3 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.mul(b3).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b3 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.mul(this.format._multiplier).div(b3), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE$6.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE$6.toFormat(result.format));
    }
    return result;
  }
  // @TODO: Support other rounding algorithms
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger$o.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width2) {
    if (width2 == null) {
      return this._hex;
    }
    if (width2 % 8) {
      logger$o.throwArgumentError("invalid byte width", "width", width2);
    }
    const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width2).toHexString();
    return hexZeroPad(hex, width2 / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    const numeric2 = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric2.lt(Zero$2)) {
      throwFault("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric2.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric2.toHexString();
      hex = hexZeroPad(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric2, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$2, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    if (arrayify(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric2 = BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric2 = numeric2.fromTwos(fixedFormat.width);
    }
    const hex = numeric2.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric2, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$2, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format);
    }
    if (isBytes(value)) {
      return FixedNumber.fromBytes(value, format);
    }
    try {
      return FixedNumber.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger$o.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
}
const ONE$6 = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");
var sha3$1 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(module) {
  (function() {
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && true && module.exports;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING = [6, 1536, 393216, 100663296];
    var SHIFT = [0, 8, 16, 24];
    var RC = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
    var CSHAKE_BYTEPAD = {
      "128": 168,
      "256": 136
    };
    if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(bits2, padding2, outputType) {
      return function(message) {
        return new Keccak2(bits2, padding2, bits2).update(message)[outputType]();
      };
    };
    var createShakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits) {
        return new Keccak2(bits2, padding2, outputBits).update(message)[outputType]();
      };
    };
    var createCshakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits, n4, s4) {
        return methods["cshake" + bits2].update(message, outputBits, n4, s4)[outputType]();
      };
    };
    var createKmacOutputMethod = function(bits2, padding2, outputType) {
      return function(key2, message, outputBits, s4) {
        return methods["kmac" + bits2].update(key2, message, outputBits, s4)[outputType]();
      };
    };
    var createOutputMethods = function(method, createMethod2, bits2, padding2) {
      for (var i4 = 0; i4 < OUTPUT_TYPES.length; ++i4) {
        var type = OUTPUT_TYPES[i4];
        method[type] = createMethod2(bits2, padding2, type);
      }
      return method;
    };
    var createMethod = function(bits2, padding2) {
      var method = createOutputMethod(bits2, padding2, "hex");
      method.create = function() {
        return new Keccak2(bits2, padding2, bits2);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      return createOutputMethods(method, createOutputMethod, bits2, padding2);
    };
    var createShakeMethod = function(bits2, padding2) {
      var method = createShakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits) {
        return new Keccak2(bits2, padding2, outputBits);
      };
      method.update = function(message, outputBits) {
        return method.create(outputBits).update(message);
      };
      return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
    };
    var createCshakeMethod = function(bits2, padding2) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method = createCshakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits, n4, s4) {
        if (!n4 && !s4) {
          return methods["shake" + bits2].create(outputBits);
        } else {
          return new Keccak2(bits2, padding2, outputBits).bytepad([n4, s4], w2);
        }
      };
      method.update = function(message, outputBits, n4, s4) {
        return method.create(outputBits, n4, s4).update(message);
      };
      return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
    };
    var createKmacMethod = function(bits2, padding2) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method = createKmacOutputMethod(bits2, padding2, "hex");
      method.create = function(key2, outputBits, s4) {
        return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s4], w2).bytepad([key2], w2);
      };
      method.update = function(key2, message, outputBits, s4) {
        return method.create(key2, outputBits, s4).update(message);
      };
      return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
    };
    var algorithms = [
      { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
      { name: "sha3", padding: PADDING, bits: BITS, createMethod },
      { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
      { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
      { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
    ];
    var methods = {}, methodNames = [];
    for (var i3 = 0; i3 < algorithms.length; ++i3) {
      var algorithm = algorithms[i3];
      var bits = algorithm.bits;
      for (var j2 = 0; j2 < bits.length; ++j2) {
        var methodName = algorithm.name + "_" + bits[j2];
        methodNames.push(methodName);
        methods[methodName] = algorithm.createMethod(bits[j2], algorithm.padding);
        if (algorithm.name !== "sha3") {
          var newMethodName = algorithm.name + bits[j2];
          methodNames.push(newMethodName);
          methods[newMethodName] = methods[methodName];
        }
      }
    }
    function Keccak2(bits2, padding2, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding2;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = 1600 - (bits2 << 1) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;
      for (var i4 = 0; i4 < 50; ++i4) {
        this.s[i4] = 0;
      }
    }
    Keccak2.prototype.update = function(message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var blocks = this.blocks, byteCount = this.byteCount, length2 = message.length, blockCount = this.blockCount, index2 = 0, s4 = this.s, i4, code2;
      while (index2 < length2) {
        if (this.reset) {
          this.reset = false;
          blocks[0] = this.block;
          for (i4 = 1; i4 < blockCount + 1; ++i4) {
            blocks[i4] = 0;
          }
        }
        if (notString) {
          for (i4 = this.start; index2 < length2 && i4 < byteCount; ++index2) {
            blocks[i4 >> 2] |= message[index2] << SHIFT[i4++ & 3];
          }
        } else {
          for (i4 = this.start; index2 < length2 && i4 < byteCount; ++index2) {
            code2 = message.charCodeAt(index2);
            if (code2 < 128) {
              blocks[i4 >> 2] |= code2 << SHIFT[i4++ & 3];
            } else if (code2 < 2048) {
              blocks[i4 >> 2] |= (192 | code2 >> 6) << SHIFT[i4++ & 3];
              blocks[i4 >> 2] |= (128 | code2 & 63) << SHIFT[i4++ & 3];
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks[i4 >> 2] |= (224 | code2 >> 12) << SHIFT[i4++ & 3];
              blocks[i4 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i4++ & 3];
              blocks[i4 >> 2] |= (128 | code2 & 63) << SHIFT[i4++ & 3];
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
              blocks[i4 >> 2] |= (240 | code2 >> 18) << SHIFT[i4++ & 3];
              blocks[i4 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i4++ & 3];
              blocks[i4 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i4++ & 3];
              blocks[i4 >> 2] |= (128 | code2 & 63) << SHIFT[i4++ & 3];
            }
          }
        }
        this.lastByteIndex = i4;
        if (i4 >= byteCount) {
          this.start = i4 - byteCount;
          this.block = blocks[blockCount];
          for (i4 = 0; i4 < blockCount; ++i4) {
            s4[i4] ^= blocks[i4];
          }
          f3(s4);
          this.reset = true;
        } else {
          this.start = i4;
        }
      }
      return this;
    };
    Keccak2.prototype.encode = function(x2, right) {
      var o2 = x2 & 255, n4 = 1;
      var bytes2 = [o2];
      x2 = x2 >> 8;
      o2 = x2 & 255;
      while (o2 > 0) {
        bytes2.unshift(o2);
        x2 = x2 >> 8;
        o2 = x2 & 255;
        ++n4;
      }
      if (right) {
        bytes2.push(n4);
      } else {
        bytes2.unshift(n4);
      }
      this.update(bytes2);
      return bytes2.length;
    };
    Keccak2.prototype.encodeString = function(str) {
      var notString, type = typeof str;
      if (type !== "string") {
        if (type === "object") {
          if (str === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
            str = new Uint8Array(str);
          } else if (!Array.isArray(str)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var bytes2 = 0, length2 = str.length;
      if (notString) {
        bytes2 = length2;
      } else {
        for (var i4 = 0; i4 < str.length; ++i4) {
          var code2 = str.charCodeAt(i4);
          if (code2 < 128) {
            bytes2 += 1;
          } else if (code2 < 2048) {
            bytes2 += 2;
          } else if (code2 < 55296 || code2 >= 57344) {
            bytes2 += 3;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i4) & 1023);
            bytes2 += 4;
          }
        }
      }
      bytes2 += this.encode(bytes2 * 8);
      this.update(str);
      return bytes2;
    };
    Keccak2.prototype.bytepad = function(strs, w2) {
      var bytes2 = this.encode(w2);
      for (var i4 = 0; i4 < strs.length; ++i4) {
        bytes2 += this.encodeString(strs[i4]);
      }
      var paddingBytes = w2 - bytes2 % w2;
      var zeros2 = [];
      zeros2.length = paddingBytes;
      this.update(zeros2);
      return this;
    };
    Keccak2.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks = this.blocks, i4 = this.lastByteIndex, blockCount = this.blockCount, s4 = this.s;
      blocks[i4 >> 2] |= this.padding[i4 & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks[0] = blocks[blockCount];
        for (i4 = 1; i4 < blockCount + 1; ++i4) {
          blocks[i4] = 0;
        }
      }
      blocks[blockCount - 1] |= 2147483648;
      for (i4 = 0; i4 < blockCount; ++i4) {
        s4[i4] ^= blocks[i4];
      }
      f3(s4);
    };
    Keccak2.prototype.toString = Keccak2.prototype.hex = function() {
      this.finalize();
      var blockCount = this.blockCount, s4 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j3 = 0;
      var hex = "", block2;
      while (j3 < outputBlocks) {
        for (i4 = 0; i4 < blockCount && j3 < outputBlocks; ++i4, ++j3) {
          block2 = s4[i4];
          hex += HEX_CHARS[block2 >> 4 & 15] + HEX_CHARS[block2 & 15] + HEX_CHARS[block2 >> 12 & 15] + HEX_CHARS[block2 >> 8 & 15] + HEX_CHARS[block2 >> 20 & 15] + HEX_CHARS[block2 >> 16 & 15] + HEX_CHARS[block2 >> 28 & 15] + HEX_CHARS[block2 >> 24 & 15];
        }
        if (j3 % blockCount === 0) {
          f3(s4);
          i4 = 0;
        }
      }
      if (extraBytes) {
        block2 = s4[i4];
        hex += HEX_CHARS[block2 >> 4 & 15] + HEX_CHARS[block2 & 15];
        if (extraBytes > 1) {
          hex += HEX_CHARS[block2 >> 12 & 15] + HEX_CHARS[block2 >> 8 & 15];
        }
        if (extraBytes > 2) {
          hex += HEX_CHARS[block2 >> 20 & 15] + HEX_CHARS[block2 >> 16 & 15];
        }
      }
      return hex;
    };
    Keccak2.prototype.arrayBuffer = function() {
      this.finalize();
      var blockCount = this.blockCount, s4 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j3 = 0;
      var bytes2 = this.outputBits >> 3;
      var buffer2;
      if (extraBytes) {
        buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
      } else {
        buffer2 = new ArrayBuffer(bytes2);
      }
      var array = new Uint32Array(buffer2);
      while (j3 < outputBlocks) {
        for (i4 = 0; i4 < blockCount && j3 < outputBlocks; ++i4, ++j3) {
          array[j3] = s4[i4];
        }
        if (j3 % blockCount === 0) {
          f3(s4);
        }
      }
      if (extraBytes) {
        array[i4] = s4[i4];
        buffer2 = buffer2.slice(0, bytes2);
      }
      return buffer2;
    };
    Keccak2.prototype.buffer = Keccak2.prototype.arrayBuffer;
    Keccak2.prototype.digest = Keccak2.prototype.array = function() {
      this.finalize();
      var blockCount = this.blockCount, s4 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j3 = 0;
      var array = [], offset, block2;
      while (j3 < outputBlocks) {
        for (i4 = 0; i4 < blockCount && j3 < outputBlocks; ++i4, ++j3) {
          offset = j3 << 2;
          block2 = s4[i4];
          array[offset] = block2 & 255;
          array[offset + 1] = block2 >> 8 & 255;
          array[offset + 2] = block2 >> 16 & 255;
          array[offset + 3] = block2 >> 24 & 255;
        }
        if (j3 % blockCount === 0) {
          f3(s4);
        }
      }
      if (extraBytes) {
        offset = j3 << 2;
        block2 = s4[i4];
        array[offset] = block2 & 255;
        if (extraBytes > 1) {
          array[offset + 1] = block2 >> 8 & 255;
        }
        if (extraBytes > 2) {
          array[offset + 2] = block2 >> 16 & 255;
        }
      }
      return array;
    };
    function Kmac(bits2, padding2, outputBits) {
      Keccak2.call(this, bits2, padding2, outputBits);
    }
    Kmac.prototype = new Keccak2();
    Kmac.prototype.finalize = function() {
      this.encode(this.outputBits, true);
      return Keccak2.prototype.finalize.call(this);
    };
    var f3 = function(s4) {
      var h4, l2, n4, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b22, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n4 = 0; n4 < 48; n4 += 2) {
        c0 = s4[0] ^ s4[10] ^ s4[20] ^ s4[30] ^ s4[40];
        c1 = s4[1] ^ s4[11] ^ s4[21] ^ s4[31] ^ s4[41];
        c2 = s4[2] ^ s4[12] ^ s4[22] ^ s4[32] ^ s4[42];
        c3 = s4[3] ^ s4[13] ^ s4[23] ^ s4[33] ^ s4[43];
        c4 = s4[4] ^ s4[14] ^ s4[24] ^ s4[34] ^ s4[44];
        c5 = s4[5] ^ s4[15] ^ s4[25] ^ s4[35] ^ s4[45];
        c6 = s4[6] ^ s4[16] ^ s4[26] ^ s4[36] ^ s4[46];
        c7 = s4[7] ^ s4[17] ^ s4[27] ^ s4[37] ^ s4[47];
        c8 = s4[8] ^ s4[18] ^ s4[28] ^ s4[38] ^ s4[48];
        c9 = s4[9] ^ s4[19] ^ s4[29] ^ s4[39] ^ s4[49];
        h4 = c8 ^ (c2 << 1 | c3 >>> 31);
        l2 = c9 ^ (c3 << 1 | c2 >>> 31);
        s4[0] ^= h4;
        s4[1] ^= l2;
        s4[10] ^= h4;
        s4[11] ^= l2;
        s4[20] ^= h4;
        s4[21] ^= l2;
        s4[30] ^= h4;
        s4[31] ^= l2;
        s4[40] ^= h4;
        s4[41] ^= l2;
        h4 = c0 ^ (c4 << 1 | c5 >>> 31);
        l2 = c1 ^ (c5 << 1 | c4 >>> 31);
        s4[2] ^= h4;
        s4[3] ^= l2;
        s4[12] ^= h4;
        s4[13] ^= l2;
        s4[22] ^= h4;
        s4[23] ^= l2;
        s4[32] ^= h4;
        s4[33] ^= l2;
        s4[42] ^= h4;
        s4[43] ^= l2;
        h4 = c2 ^ (c6 << 1 | c7 >>> 31);
        l2 = c3 ^ (c7 << 1 | c6 >>> 31);
        s4[4] ^= h4;
        s4[5] ^= l2;
        s4[14] ^= h4;
        s4[15] ^= l2;
        s4[24] ^= h4;
        s4[25] ^= l2;
        s4[34] ^= h4;
        s4[35] ^= l2;
        s4[44] ^= h4;
        s4[45] ^= l2;
        h4 = c4 ^ (c8 << 1 | c9 >>> 31);
        l2 = c5 ^ (c9 << 1 | c8 >>> 31);
        s4[6] ^= h4;
        s4[7] ^= l2;
        s4[16] ^= h4;
        s4[17] ^= l2;
        s4[26] ^= h4;
        s4[27] ^= l2;
        s4[36] ^= h4;
        s4[37] ^= l2;
        s4[46] ^= h4;
        s4[47] ^= l2;
        h4 = c6 ^ (c0 << 1 | c1 >>> 31);
        l2 = c7 ^ (c1 << 1 | c0 >>> 31);
        s4[8] ^= h4;
        s4[9] ^= l2;
        s4[18] ^= h4;
        s4[19] ^= l2;
        s4[28] ^= h4;
        s4[29] ^= l2;
        s4[38] ^= h4;
        s4[39] ^= l2;
        s4[48] ^= h4;
        s4[49] ^= l2;
        b0 = s4[0];
        b1 = s4[1];
        b32 = s4[11] << 4 | s4[10] >>> 28;
        b33 = s4[10] << 4 | s4[11] >>> 28;
        b14 = s4[20] << 3 | s4[21] >>> 29;
        b15 = s4[21] << 3 | s4[20] >>> 29;
        b46 = s4[31] << 9 | s4[30] >>> 23;
        b47 = s4[30] << 9 | s4[31] >>> 23;
        b28 = s4[40] << 18 | s4[41] >>> 14;
        b29 = s4[41] << 18 | s4[40] >>> 14;
        b20 = s4[2] << 1 | s4[3] >>> 31;
        b21 = s4[3] << 1 | s4[2] >>> 31;
        b22 = s4[13] << 12 | s4[12] >>> 20;
        b3 = s4[12] << 12 | s4[13] >>> 20;
        b34 = s4[22] << 10 | s4[23] >>> 22;
        b35 = s4[23] << 10 | s4[22] >>> 22;
        b16 = s4[33] << 13 | s4[32] >>> 19;
        b17 = s4[32] << 13 | s4[33] >>> 19;
        b48 = s4[42] << 2 | s4[43] >>> 30;
        b49 = s4[43] << 2 | s4[42] >>> 30;
        b40 = s4[5] << 30 | s4[4] >>> 2;
        b41 = s4[4] << 30 | s4[5] >>> 2;
        b222 = s4[14] << 6 | s4[15] >>> 26;
        b23 = s4[15] << 6 | s4[14] >>> 26;
        b4 = s4[25] << 11 | s4[24] >>> 21;
        b5 = s4[24] << 11 | s4[25] >>> 21;
        b36 = s4[34] << 15 | s4[35] >>> 17;
        b37 = s4[35] << 15 | s4[34] >>> 17;
        b18 = s4[45] << 29 | s4[44] >>> 3;
        b19 = s4[44] << 29 | s4[45] >>> 3;
        b10 = s4[6] << 28 | s4[7] >>> 4;
        b11 = s4[7] << 28 | s4[6] >>> 4;
        b42 = s4[17] << 23 | s4[16] >>> 9;
        b43 = s4[16] << 23 | s4[17] >>> 9;
        b24 = s4[26] << 25 | s4[27] >>> 7;
        b25 = s4[27] << 25 | s4[26] >>> 7;
        b6 = s4[36] << 21 | s4[37] >>> 11;
        b7 = s4[37] << 21 | s4[36] >>> 11;
        b38 = s4[47] << 24 | s4[46] >>> 8;
        b39 = s4[46] << 24 | s4[47] >>> 8;
        b30 = s4[8] << 27 | s4[9] >>> 5;
        b31 = s4[9] << 27 | s4[8] >>> 5;
        b12 = s4[18] << 20 | s4[19] >>> 12;
        b13 = s4[19] << 20 | s4[18] >>> 12;
        b44 = s4[29] << 7 | s4[28] >>> 25;
        b45 = s4[28] << 7 | s4[29] >>> 25;
        b26 = s4[38] << 8 | s4[39] >>> 24;
        b27 = s4[39] << 8 | s4[38] >>> 24;
        b8 = s4[48] << 14 | s4[49] >>> 18;
        b9 = s4[49] << 14 | s4[48] >>> 18;
        s4[0] = b0 ^ ~b22 & b4;
        s4[1] = b1 ^ ~b3 & b5;
        s4[10] = b10 ^ ~b12 & b14;
        s4[11] = b11 ^ ~b13 & b15;
        s4[20] = b20 ^ ~b222 & b24;
        s4[21] = b21 ^ ~b23 & b25;
        s4[30] = b30 ^ ~b32 & b34;
        s4[31] = b31 ^ ~b33 & b35;
        s4[40] = b40 ^ ~b42 & b44;
        s4[41] = b41 ^ ~b43 & b45;
        s4[2] = b22 ^ ~b4 & b6;
        s4[3] = b3 ^ ~b5 & b7;
        s4[12] = b12 ^ ~b14 & b16;
        s4[13] = b13 ^ ~b15 & b17;
        s4[22] = b222 ^ ~b24 & b26;
        s4[23] = b23 ^ ~b25 & b27;
        s4[32] = b32 ^ ~b34 & b36;
        s4[33] = b33 ^ ~b35 & b37;
        s4[42] = b42 ^ ~b44 & b46;
        s4[43] = b43 ^ ~b45 & b47;
        s4[4] = b4 ^ ~b6 & b8;
        s4[5] = b5 ^ ~b7 & b9;
        s4[14] = b14 ^ ~b16 & b18;
        s4[15] = b15 ^ ~b17 & b19;
        s4[24] = b24 ^ ~b26 & b28;
        s4[25] = b25 ^ ~b27 & b29;
        s4[34] = b34 ^ ~b36 & b38;
        s4[35] = b35 ^ ~b37 & b39;
        s4[44] = b44 ^ ~b46 & b48;
        s4[45] = b45 ^ ~b47 & b49;
        s4[6] = b6 ^ ~b8 & b0;
        s4[7] = b7 ^ ~b9 & b1;
        s4[16] = b16 ^ ~b18 & b10;
        s4[17] = b17 ^ ~b19 & b11;
        s4[26] = b26 ^ ~b28 & b20;
        s4[27] = b27 ^ ~b29 & b21;
        s4[36] = b36 ^ ~b38 & b30;
        s4[37] = b37 ^ ~b39 & b31;
        s4[46] = b46 ^ ~b48 & b40;
        s4[47] = b47 ^ ~b49 & b41;
        s4[8] = b8 ^ ~b0 & b22;
        s4[9] = b9 ^ ~b1 & b3;
        s4[18] = b18 ^ ~b10 & b12;
        s4[19] = b19 ^ ~b11 & b13;
        s4[28] = b28 ^ ~b20 & b222;
        s4[29] = b29 ^ ~b21 & b23;
        s4[38] = b38 ^ ~b30 & b32;
        s4[39] = b39 ^ ~b31 & b33;
        s4[48] = b48 ^ ~b40 & b42;
        s4[49] = b49 ^ ~b41 & b43;
        s4[0] ^= RC[n4];
        s4[1] ^= RC[n4 + 1];
      }
    };
    if (COMMON_JS) {
      module.exports = methods;
    } else {
      for (i3 = 0; i3 < methodNames.length; ++i3) {
        root[methodNames[i3]] = methods[methodNames[i3]];
      }
    }
  })();
})(sha3$1);
var sha3Exports = sha3$1.exports;
const sha3 = /* @__PURE__ */ getDefaultExportFromCjs(sha3Exports);
function keccak256$2(data2) {
  return "0x" + sha3.keccak_256(arrayify(data2));
}
const version$j = "rlp/5.7.0";
const logger$n = new Logger(version$j);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data2, offset, length2) {
  let result = 0;
  for (let i3 = 0; i3 < length2; i3++) {
    result = result * 256 + data2[offset + i3];
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length3 = arrayifyInteger(payload.length);
    length3.unshift(247 + length3.length);
    return length3.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger$n.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data2 = Array.prototype.slice.call(arrayify(object));
  if (data2.length === 1 && data2[0] <= 127) {
    return data2;
  } else if (data2.length <= 55) {
    data2.unshift(128 + data2.length);
    return data2;
  }
  const length2 = arrayifyInteger(data2.length);
  length2.unshift(183 + length2.length);
  return length2.concat(data2);
}
function encode$5(object) {
  return hexlify(_encode(object));
}
function _decodeChildren(data2, offset, childOffset, length2) {
  const result = [];
  while (childOffset < offset + 1 + length2) {
    const decoded = _decode(data2, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length2) {
      logger$n.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length2, result };
}
function _decode(data2, offset) {
  if (data2.length === 0) {
    logger$n.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  if (data2[offset] >= 248) {
    const lengthLength = data2[offset] - 247;
    if (offset + 1 + lengthLength > data2.length) {
      logger$n.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length2 = unarrayifyInteger(data2, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length2 > data2.length) {
      logger$n.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data2, offset, offset + 1 + lengthLength, lengthLength + length2);
  } else if (data2[offset] >= 192) {
    const length2 = data2[offset] - 192;
    if (offset + 1 + length2 > data2.length) {
      logger$n.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data2, offset, offset + 1, length2);
  } else if (data2[offset] >= 184) {
    const lengthLength = data2[offset] - 183;
    if (offset + 1 + lengthLength > data2.length) {
      logger$n.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length2 = unarrayifyInteger(data2, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length2 > data2.length) {
      logger$n.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data2.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length2));
    return { consumed: 1 + lengthLength + length2, result };
  } else if (data2[offset] >= 128) {
    const length2 = data2[offset] - 128;
    if (offset + 1 + length2 > data2.length) {
      logger$n.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data2.slice(offset + 1, offset + 1 + length2));
    return { consumed: 1 + length2, result };
  }
  return { consumed: 1, result: hexlify(data2[offset]) };
}
function decode$5(data2) {
  const bytes2 = arrayify(data2);
  const decoded = _decode(bytes2, 0);
  if (decoded.consumed !== bytes2.length) {
    logger$n.throwArgumentError("invalid rlp data", "data", data2);
  }
  return decoded.result;
}
const version$i = "address/5.7.0";
const logger$m = new Logger(version$i);
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger$m.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i3 = 0; i3 < 40; i3++) {
    expanded[i3] = chars[i3].charCodeAt(0);
  }
  const hashed = arrayify(keccak256$2(expanded));
  for (let i3 = 0; i3 < 40; i3 += 2) {
    if (hashed[i3 >> 1] >> 4 >= 8) {
      chars[i3] = chars[i3].toUpperCase();
    }
    if ((hashed[i3 >> 1] & 15) >= 8) {
      chars[i3 + 1] = chars[i3 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const MAX_SAFE_INTEGER$3 = 9007199254740991;
function log10(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
const ibanLookup = {};
for (let i3 = 0; i3 < 10; i3++) {
  ibanLookup[String(i3)] = String(i3);
}
for (let i3 = 0; i3 < 26; i3++) {
  ibanLookup[String.fromCharCode(65 + i3)] = String(10 + i3);
}
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER$3));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block2 = expanded.substring(0, safeDigits);
    expanded = parseInt(block2, 10) % 97 + expanded.substring(block2.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress$1(address) {
  let result = null;
  if (typeof address !== "string") {
    logger$m.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger$m.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger$m.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger$m.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function getContractAddress$1(transaction) {
  let from2 = null;
  try {
    from2 = getAddress$1(transaction.from);
  } catch (error) {
    logger$m.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
  return getAddress$1(hexDataSlice(keccak256$2(encode$5([from2, nonce])), 12));
}
function getCreate2Address(from2, salt, initCodeHash) {
  if (hexDataLength(salt) !== 32) {
    logger$m.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength(initCodeHash) !== 32) {
    logger$m.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress$1(hexDataSlice(keccak256$2(concat$2(["0xff", getAddress$1(from2), salt, initCodeHash])), 12));
}
var SupportedChainId;
(function(SupportedChainId2) {
  SupportedChainId2[SupportedChainId2["MAINNET"] = 1] = "MAINNET";
  SupportedChainId2[SupportedChainId2["GOERLI"] = 5] = "GOERLI";
  SupportedChainId2[SupportedChainId2["SEPOLIA"] = 11155111] = "SEPOLIA";
  SupportedChainId2[SupportedChainId2["ARBITRUM_ONE"] = 42161] = "ARBITRUM_ONE";
  SupportedChainId2[SupportedChainId2["ARBITRUM_GOERLI"] = 421613] = "ARBITRUM_GOERLI";
  SupportedChainId2[SupportedChainId2["OPTIMISM"] = 10] = "OPTIMISM";
  SupportedChainId2[SupportedChainId2["OPTIMISM_GOERLI"] = 420] = "OPTIMISM_GOERLI";
  SupportedChainId2[SupportedChainId2["POLYGON"] = 137] = "POLYGON";
  SupportedChainId2[SupportedChainId2["POLYGON_MUMBAI"] = 80001] = "POLYGON_MUMBAI";
  SupportedChainId2[SupportedChainId2["CELO"] = 42220] = "CELO";
  SupportedChainId2[SupportedChainId2["CELO_ALFAJORES"] = 44787] = "CELO_ALFAJORES";
  SupportedChainId2[SupportedChainId2["BNB"] = 56] = "BNB";
})(SupportedChainId || (SupportedChainId = {}));
var TradeType$3;
(function(TradeType2) {
  TradeType2[TradeType2["EXACT_INPUT"] = 0] = "EXACT_INPUT";
  TradeType2[TradeType2["EXACT_OUTPUT"] = 1] = "EXACT_OUTPUT";
})(TradeType$3 || (TradeType$3 = {}));
var Rounding$3;
(function(Rounding2) {
  Rounding2[Rounding2["ROUND_DOWN"] = 0] = "ROUND_DOWN";
  Rounding2[Rounding2["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
  Rounding2[Rounding2["ROUND_UP"] = 2] = "ROUND_UP";
})(Rounding$3 || (Rounding$3 = {}));
var MaxUint256$5 = /* @__PURE__ */ JSBI.BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function _defineProperties$6(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$6(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$6(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$6(Constructor, staticProps);
  return Constructor;
}
function _inheritsLoose$5(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var _toSignificantRoundin$3, _toFixedRounding$3;
var Decimal$3 = /* @__PURE__ */ toFormat(_Decimal);
var Big$4 = /* @__PURE__ */ toFormat(Big$5);
var toSignificantRounding$3 = (_toSignificantRoundin$3 = {}, _toSignificantRoundin$3[Rounding$3.ROUND_DOWN] = Decimal$3.ROUND_DOWN, _toSignificantRoundin$3[Rounding$3.ROUND_HALF_UP] = Decimal$3.ROUND_HALF_UP, _toSignificantRoundin$3[Rounding$3.ROUND_UP] = Decimal$3.ROUND_UP, _toSignificantRoundin$3);
var toFixedRounding$3 = (_toFixedRounding$3 = {}, _toFixedRounding$3[Rounding$3.ROUND_DOWN] = 0, _toFixedRounding$3[Rounding$3.ROUND_HALF_UP] = 1, _toFixedRounding$3[Rounding$3.ROUND_UP] = 3, _toFixedRounding$3);
var Fraction$3 = /* @__PURE__ */ function() {
  function Fraction2(numerator, denominator) {
    if (denominator === void 0) {
      denominator = JSBI.BigInt(1);
    }
    this.numerator = JSBI.BigInt(numerator);
    this.denominator = JSBI.BigInt(denominator);
  }
  Fraction2.tryParseFraction = function tryParseFraction(fractionish) {
    if (fractionish instanceof JSBI || typeof fractionish === "number" || typeof fractionish === "string")
      return new Fraction2(fractionish);
    if ("numerator" in fractionish && "denominator" in fractionish)
      return fractionish;
    throw new Error("Could not parse fraction");
  };
  var _proto = Fraction2.prototype;
  _proto.invert = function invert() {
    return new Fraction2(this.denominator, this.numerator);
  };
  _proto.add = function add4(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    if (JSBI.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction2(JSBI.add(this.numerator, otherParsed.numerator), this.denominator);
    }
    return new Fraction2(JSBI.add(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.subtract = function subtract2(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    if (JSBI.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction2(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator);
    }
    return new Fraction2(JSBI.subtract(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.lessThan = function lessThan(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return JSBI.lessThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.equalTo = function equalTo(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return JSBI.equal(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.greaterThan = function greaterThan(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return JSBI.greaterThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.multiply = function multiply(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return new Fraction2(JSBI.multiply(this.numerator, otherParsed.numerator), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.divide = function divide2(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return new Fraction2(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(this.denominator, otherParsed.numerator));
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    if (rounding === void 0) {
      rounding = Rounding$3.ROUND_HALF_UP;
    }
    !Number.isInteger(significantDigits) ? invariant$1(false) : void 0;
    !(significantDigits > 0) ? invariant$1(false) : void 0;
    Decimal$3.set({
      precision: significantDigits + 1,
      rounding: toSignificantRounding$3[rounding]
    });
    var quotient = new Decimal$3(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
    return quotient.toFormat(quotient.decimalPlaces(), format);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    if (rounding === void 0) {
      rounding = Rounding$3.ROUND_HALF_UP;
    }
    !Number.isInteger(decimalPlaces) ? invariant$1(false) : void 0;
    !(decimalPlaces >= 0) ? invariant$1(false) : void 0;
    Big$4.DP = decimalPlaces;
    Big$4.RM = toFixedRounding$3[rounding];
    return new Big$4(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
  };
  _createClass$6(Fraction2, [{
    key: "quotient",
    get: function get2() {
      return JSBI.divide(this.numerator, this.denominator);
    }
    // remainder after floor division
  }, {
    key: "remainder",
    get: function get2() {
      return new Fraction2(JSBI.remainder(this.numerator, this.denominator), this.denominator);
    }
  }, {
    key: "asFraction",
    get: function get2() {
      return new Fraction2(this.numerator, this.denominator);
    }
  }]);
  return Fraction2;
}();
var Big$1$3 = /* @__PURE__ */ toFormat(Big$5);
var CurrencyAmount$4 = /* @__PURE__ */ function(_Fraction) {
  _inheritsLoose$5(CurrencyAmount22, _Fraction);
  function CurrencyAmount22(currency, numerator, denominator) {
    var _this;
    _this = _Fraction.call(this, numerator, denominator) || this;
    !JSBI.lessThanOrEqual(_this.quotient, MaxUint256$5) ? invariant$1(false) : void 0;
    _this.currency = currency;
    _this.decimalScale = JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(currency.decimals));
    return _this;
  }
  CurrencyAmount22.fromRawAmount = function fromRawAmount(currency, rawAmount) {
    return new CurrencyAmount22(currency, rawAmount);
  };
  CurrencyAmount22.fromFractionalAmount = function fromFractionalAmount(currency, numerator, denominator) {
    return new CurrencyAmount22(currency, numerator, denominator);
  };
  var _proto = CurrencyAmount22.prototype;
  _proto.add = function add4(other) {
    !this.currency.equals(other.currency) ? invariant$1(false) : void 0;
    var added = _Fraction.prototype.add.call(this, other);
    return CurrencyAmount22.fromFractionalAmount(this.currency, added.numerator, added.denominator);
  };
  _proto.subtract = function subtract2(other) {
    !this.currency.equals(other.currency) ? invariant$1(false) : void 0;
    var subtracted = _Fraction.prototype.subtract.call(this, other);
    return CurrencyAmount22.fromFractionalAmount(this.currency, subtracted.numerator, subtracted.denominator);
  };
  _proto.multiply = function multiply(other) {
    var multiplied = _Fraction.prototype.multiply.call(this, other);
    return CurrencyAmount22.fromFractionalAmount(this.currency, multiplied.numerator, multiplied.denominator);
  };
  _proto.divide = function divide2(other) {
    var divided = _Fraction.prototype.divide.call(this, other);
    return CurrencyAmount22.fromFractionalAmount(this.currency, divided.numerator, divided.denominator);
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 6;
    }
    if (rounding === void 0) {
      rounding = Rounding$3.ROUND_DOWN;
    }
    return _Fraction.prototype.divide.call(this, this.decimalScale).toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = this.currency.decimals;
    }
    if (rounding === void 0) {
      rounding = Rounding$3.ROUND_DOWN;
    }
    !(decimalPlaces <= this.currency.decimals) ? invariant$1(false) : void 0;
    return _Fraction.prototype.divide.call(this, this.decimalScale).toFixed(decimalPlaces, format, rounding);
  };
  _proto.toExact = function toExact(format) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    Big$1$3.DP = this.currency.decimals;
    return new Big$1$3(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(format);
  };
  _createClass$6(CurrencyAmount22, [{
    key: "wrapped",
    get: function get2() {
      if (this.currency.isToken)
        return this;
      return CurrencyAmount22.fromFractionalAmount(this.currency.wrapped, this.numerator, this.denominator);
    }
  }]);
  return CurrencyAmount22;
}(Fraction$3);
var ONE_HUNDRED$3 = /* @__PURE__ */ new Fraction$3(/* @__PURE__ */ JSBI.BigInt(100));
function toPercent$3(fraction) {
  return new Percent$3(fraction.numerator, fraction.denominator);
}
var Percent$3 = /* @__PURE__ */ function(_Fraction) {
  _inheritsLoose$5(Percent2, _Fraction);
  function Percent2() {
    var _this;
    _this = _Fraction.apply(this, arguments) || this;
    _this.isPercent = true;
    return _this;
  }
  var _proto = Percent2.prototype;
  _proto.add = function add4(other) {
    return toPercent$3(_Fraction.prototype.add.call(this, other));
  };
  _proto.subtract = function subtract2(other) {
    return toPercent$3(_Fraction.prototype.subtract.call(this, other));
  };
  _proto.multiply = function multiply(other) {
    return toPercent$3(_Fraction.prototype.multiply.call(this, other));
  };
  _proto.divide = function divide2(other) {
    return toPercent$3(_Fraction.prototype.divide.call(this, other));
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 5;
    }
    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED$3).toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = 2;
    }
    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED$3).toFixed(decimalPlaces, format, rounding);
  };
  return Percent2;
}(Fraction$3);
var BaseCurrency$3 = (
  /**
   * Constructs an instance of the base class `BaseCurrency`.
   * @param chainId the chain ID on which this currency resides
   * @param decimals decimals of the currency
   * @param symbol symbol of the currency
   * @param name of the currency
   */
  function BaseCurrency2(chainId2, decimals, symbol, name2) {
    !Number.isSafeInteger(chainId2) ? invariant$1(false) : void 0;
    !(decimals >= 0 && decimals < 255 && Number.isInteger(decimals)) ? invariant$1(false) : void 0;
    this.chainId = chainId2;
    this.decimals = decimals;
    this.symbol = symbol;
    this.name = name2;
  }
);
function validateAndParseAddress$3(address) {
  try {
    return getAddress$1(address);
  } catch (error) {
    throw new Error(address + " is not a valid address.");
  }
}
var startsWith0xLen42HexRegex$3 = /^0x[0-9a-fA-F]{40}$/;
function checkValidAddress$3(address) {
  if (startsWith0xLen42HexRegex$3.test(address)) {
    return address;
  }
  throw new Error(address + " is not a valid address.");
}
var Token$4 = /* @__PURE__ */ function(_BaseCurrency) {
  _inheritsLoose$5(Token2, _BaseCurrency);
  function Token2(chainId2, address, decimals, symbol, name2, bypassChecksum) {
    var _this;
    _this = _BaseCurrency.call(this, chainId2, decimals, symbol, name2) || this;
    _this.isNative = false;
    _this.isToken = true;
    if (bypassChecksum) {
      _this.address = checkValidAddress$3(address);
    } else {
      _this.address = validateAndParseAddress$3(address);
    }
    return _this;
  }
  var _proto = Token2.prototype;
  _proto.equals = function equals(other) {
    return other.isToken && this.chainId === other.chainId && this.address.toLowerCase() === other.address.toLowerCase();
  };
  _proto.sortsBefore = function sortsBefore(other) {
    !(this.chainId === other.chainId) ? invariant$1(false) : void 0;
    !(this.address.toLowerCase() !== other.address.toLowerCase()) ? invariant$1(false) : void 0;
    return this.address.toLowerCase() < other.address.toLowerCase();
  };
  _createClass$6(Token2, [{
    key: "wrapped",
    get: function get2() {
      return this;
    }
  }]);
  return Token2;
}(BaseCurrency$3);
var _WETH$3;
_WETH$3 = {}, _WETH$3[1] = /* @__PURE__ */ new Token$4(1, "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", 18, "WETH", "Wrapped Ether"), _WETH$3[3] = /* @__PURE__ */ new Token$4(3, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"), _WETH$3[4] = /* @__PURE__ */ new Token$4(4, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"), _WETH$3[5] = /* @__PURE__ */ new Token$4(5, "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6", 18, "WETH", "Wrapped Ether"), _WETH$3[42] = /* @__PURE__ */ new Token$4(42, "0xd0A1E359811322d97991E03f863a0C30C2cF029C", 18, "WETH", "Wrapped Ether"), _WETH$3[10] = /* @__PURE__ */ new Token$4(10, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH$3[69] = /* @__PURE__ */ new Token$4(69, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH$3[42161] = /* @__PURE__ */ new Token$4(42161, "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1", 18, "WETH", "Wrapped Ether"), _WETH$3[421611] = /* @__PURE__ */ new Token$4(421611, "0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681", 18, "WETH", "Wrapped Ether"), _WETH$3;
var axios$3 = { exports: {} };
var bind$2 = function bind(fn2, thisArg) {
  return function wrap2() {
    var args = new Array(arguments.length);
    for (var i3 = 0; i3 < args.length; i3++) {
      args[i3] = arguments[i3];
    }
    return fn2.apply(thisArg, args);
  };
};
var bind$1 = bind$2;
var toString$2 = Object.prototype.toString;
function isArray$1(val) {
  return toString$2.call(val) === "[object Array]";
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString$2.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return typeof FormData !== "undefined" && val instanceof FormData;
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}
function isString$1(val) {
  return typeof val === "string";
}
function isNumber$2(val) {
  return typeof val === "number";
}
function isObject$2(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (toString$2.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate(val) {
  return toString$2.call(val) === "[object Date]";
}
function isFile(val) {
  return toString$2.call(val) === "[object File]";
}
function isBlob(val) {
  return toString$2.call(val) === "[object Blob]";
}
function isFunction(val) {
  return toString$2.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$2(val) && isFunction(val.pipe);
}
function isURLSearchParams(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function trim$1(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach$3(obj, fn2) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$1(obj)) {
    for (var i3 = 0, l2 = obj.length; i3 < l2; i3++) {
      fn2.call(null, obj[i3], i3, obj);
    }
  } else {
    for (var key2 in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key2)) {
        fn2.call(null, obj[key2], key2, obj);
      }
    }
  }
}
function merge() {
  var result = {};
  function assignValue(val, key2) {
    if (isPlainObject(result[key2]) && isPlainObject(val)) {
      result[key2] = merge(result[key2], val);
    } else if (isPlainObject(val)) {
      result[key2] = merge({}, val);
    } else if (isArray$1(val)) {
      result[key2] = val.slice();
    } else {
      result[key2] = val;
    }
  }
  for (var i3 = 0, l2 = arguments.length; i3 < l2; i3++) {
    forEach$3(arguments[i3], assignValue);
  }
  return result;
}
function extend(a2, b3, thisArg) {
  forEach$3(b3, function assignValue(val, key2) {
    if (thisArg && typeof val === "function") {
      a2[key2] = bind$1(val, thisArg);
    } else {
      a2[key2] = val;
    }
  });
  return a2;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
var utils$n = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber: isNumber$2,
  isObject: isObject$2,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach: forEach$3,
  merge,
  extend,
  trim: trim$1,
  stripBOM
};
var utils$m = utils$n;
function encode$4(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function buildURL(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$m.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$m.forEach(params, function serialize2(val, key2) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$m.isArray(val)) {
        key2 = key2 + "[]";
      } else {
        val = [val];
      }
      utils$m.forEach(val, function parseValue(v2) {
        if (utils$m.isDate(v2)) {
          v2 = v2.toISOString();
        } else if (utils$m.isObject(v2)) {
          v2 = JSON.stringify(v2);
        }
        parts.push(encode$4(key2) + "=" + encode$4(v2));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
var utils$l = utils$n;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id2) {
  if (this.handlers[id2]) {
    this.handlers[id2] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach(fn2) {
  utils$l.forEach(this.handlers, function forEachHandler(h4) {
    if (h4 !== null) {
      fn2(h4);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$k = utils$n;
var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
  utils$k.forEach(headers, function processHeader(value, name2) {
    if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name2];
    }
  });
};
var enhanceError$1 = function enhanceError(error, config2, code2, request2, response) {
  error.config = config2;
  if (code2) {
    error.code = code2;
  }
  error.request = request2;
  error.response = response;
  error.isAxiosError = true;
  error.toJSON = function toJSON2() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};
var createError;
var hasRequiredCreateError;
function requireCreateError() {
  if (hasRequiredCreateError)
    return createError;
  hasRequiredCreateError = 1;
  var enhanceError3 = enhanceError$1;
  createError = function createError2(message, config2, code2, request2, response) {
    var error = new Error(message);
    return enhanceError3(error, config2, code2, request2, response);
  };
  return createError;
}
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var createError2 = requireCreateError();
  settle = function settle2(resolve, reject, response) {
    var validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve(response);
    } else {
      reject(createError2(
        "Request failed with status code " + response.status,
        response.config,
        null,
        response.request,
        response
      ));
    }
  };
  return settle;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var utils2 = utils$n;
  cookies = utils2.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    /* @__PURE__ */ function standardBrowserEnv() {
      return {
        write: function write3(name2, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name2 + "=" + encodeURIComponent(value));
          if (utils2.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils2.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils2.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name2) {
          var match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
          return match2 ? decodeURIComponent(match2[3]) : null;
        },
        remove: function remove(name2) {
          this.write(name2, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    /* @__PURE__ */ function nonStandardBrowserEnv() {
      return {
        write: function write3() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }()
  );
  return cookies;
}
var isAbsoluteURL;
var hasRequiredIsAbsoluteURL;
function requireIsAbsoluteURL() {
  if (hasRequiredIsAbsoluteURL)
    return isAbsoluteURL;
  hasRequiredIsAbsoluteURL = 1;
  isAbsoluteURL = function isAbsoluteURL2(url) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };
  return isAbsoluteURL;
}
var combineURLs;
var hasRequiredCombineURLs;
function requireCombineURLs() {
  if (hasRequiredCombineURLs)
    return combineURLs;
  hasRequiredCombineURLs = 1;
  combineURLs = function combineURLs2(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
  return combineURLs;
}
var buildFullPath;
var hasRequiredBuildFullPath;
function requireBuildFullPath() {
  if (hasRequiredBuildFullPath)
    return buildFullPath;
  hasRequiredBuildFullPath = 1;
  var isAbsoluteURL2 = requireIsAbsoluteURL();
  var combineURLs2 = requireCombineURLs();
  buildFullPath = function buildFullPath2(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL2(requestedURL)) {
      return combineURLs2(baseURL, requestedURL);
    }
    return requestedURL;
  };
  return buildFullPath;
}
var parseHeaders;
var hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var utils2 = utils$n;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  parseHeaders = function parseHeaders2(headers) {
    var parsed = {};
    var key2;
    var val;
    var i3;
    if (!headers) {
      return parsed;
    }
    utils2.forEach(headers.split("\n"), function parser(line2) {
      i3 = line2.indexOf(":");
      key2 = utils2.trim(line2.substr(0, i3)).toLowerCase();
      val = utils2.trim(line2.substr(i3 + 1));
      if (key2) {
        if (parsed[key2] && ignoreDuplicateOf.indexOf(key2) >= 0) {
          return;
        }
        if (key2 === "set-cookie") {
          parsed[key2] = (parsed[key2] ? parsed[key2] : []).concat([val]);
        } else {
          parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  return parseHeaders;
}
var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var utils2 = utils$n;
  isURLSameOrigin = utils2.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    /* @__PURE__ */ function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  return isURLSameOrigin;
}
var xhr;
var hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var utils2 = utils$n;
  var settle2 = requireSettle();
  var cookies2 = requireCookies();
  var buildURL3 = buildURL$1;
  var buildFullPath2 = requireBuildFullPath();
  var parseHeaders2 = requireParseHeaders();
  var isURLSameOrigin2 = requireIsURLSameOrigin();
  var createError2 = requireCreateError();
  xhr = function xhrAdapter(config2) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config2.data;
      var requestHeaders = config2.headers;
      var responseType = config2.responseType;
      if (utils2.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      var request2 = new XMLHttpRequest();
      if (config2.auth) {
        var username = config2.auth.username || "";
        var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath2(config2.baseURL, config2.url);
      request2.open(config2.method.toUpperCase(), buildURL3(fullPath, config2.params, config2.paramsSerializer), true);
      request2.timeout = config2.timeout;
      function onloadend() {
        if (!request2) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
        var response = {
          data: responseData,
          status: request2.status,
          statusText: request2.statusText,
          headers: responseHeaders,
          config: config2,
          request: request2
        };
        settle2(resolve, reject, response);
        request2 = null;
      }
      if ("onloadend" in request2) {
        request2.onloadend = onloadend;
      } else {
        request2.onreadystatechange = function handleLoad() {
          if (!request2 || request2.readyState !== 4) {
            return;
          }
          if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request2.onabort = function handleAbort() {
        if (!request2) {
          return;
        }
        reject(createError2("Request aborted", config2, "ECONNABORTED", request2));
        request2 = null;
      };
      request2.onerror = function handleError() {
        reject(createError2("Network Error", config2, null, request2));
        request2 = null;
      };
      request2.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = "timeout of " + config2.timeout + "ms exceeded";
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject(createError2(
          timeoutErrorMessage,
          config2,
          config2.transitional && config2.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          request2
        ));
        request2 = null;
      };
      if (utils2.isStandardBrowserEnv()) {
        var xsrfValue = (config2.withCredentials || isURLSameOrigin2(fullPath)) && config2.xsrfCookieName ? cookies2.read(config2.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config2.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request2) {
        utils2.forEach(requestHeaders, function setRequestHeader(val, key2) {
          if (typeof requestData === "undefined" && key2.toLowerCase() === "content-type") {
            delete requestHeaders[key2];
          } else {
            request2.setRequestHeader(key2, val);
          }
        });
      }
      if (!utils2.isUndefined(config2.withCredentials)) {
        request2.withCredentials = !!config2.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request2.responseType = config2.responseType;
      }
      if (typeof config2.onDownloadProgress === "function") {
        request2.addEventListener("progress", config2.onDownloadProgress);
      }
      if (typeof config2.onUploadProgress === "function" && request2.upload) {
        request2.upload.addEventListener("progress", config2.onUploadProgress);
      }
      if (config2.cancelToken) {
        config2.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request2) {
            return;
          }
          request2.abort();
          reject(cancel);
          request2 = null;
        });
      }
      if (!requestData) {
        requestData = null;
      }
      request2.send(requestData);
    });
  };
  return xhr;
}
var utils$j = utils$n;
var normalizeHeaderName2 = normalizeHeaderName$1;
var enhanceError2 = enhanceError$1;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils$j.isUndefined(headers) && utils$j.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = requireXhr();
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = requireXhr();
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder2) {
  if (utils$j.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$j.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder2 || JSON.stringify)(rawValue);
}
var defaults$3 = {
  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data2, headers) {
    normalizeHeaderName2(headers, "Accept");
    normalizeHeaderName2(headers, "Content-Type");
    if (utils$j.isFormData(data2) || utils$j.isArrayBuffer(data2) || utils$j.isBuffer(data2) || utils$j.isStream(data2) || utils$j.isFile(data2) || utils$j.isBlob(data2)) {
      return data2;
    }
    if (utils$j.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$j.isURLSearchParams(data2)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data2.toString();
    }
    if (utils$j.isObject(data2) || headers && headers["Content-Type"] === "application/json") {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    var transitional2 = this.transitional;
    var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
    var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$j.isString(data2) && data2.length) {
      try {
        return JSON.parse(data2);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw enhanceError2(e2, this, "E_JSON_PARSE");
          }
          throw e2;
        }
      }
    }
    return data2;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults$3.headers = {
  common: {
    "Accept": "application/json, text/plain, */*"
  }
};
utils$j.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$3.headers[method] = {};
});
utils$j.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$3.headers[method] = utils$j.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3;
var utils$i = utils$n;
var defaults$2 = defaults_1;
var transformData$1 = function transformData(data2, headers, fns) {
  var context = this || defaults$2;
  utils$i.forEach(fns, function transform(fn2) {
    data2 = fn2.call(context, data2, headers);
  });
  return data2;
};
var isCancel$1;
var hasRequiredIsCancel;
function requireIsCancel() {
  if (hasRequiredIsCancel)
    return isCancel$1;
  hasRequiredIsCancel = 1;
  isCancel$1 = function isCancel2(value) {
    return !!(value && value.__CANCEL__);
  };
  return isCancel$1;
}
var utils$h = utils$n;
var transformData2 = transformData$1;
var isCancel = requireIsCancel();
var defaults$1 = defaults_1;
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
}
var dispatchRequest$1 = function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = config2.headers || {};
  config2.data = transformData2.call(
    config2,
    config2.data,
    config2.headers,
    config2.transformRequest
  );
  config2.headers = utils$h.merge(
    config2.headers.common || {},
    config2.headers[config2.method] || {},
    config2.headers
  );
  utils$h.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method) {
      delete config2.headers[method];
    }
  );
  var adapter = config2.adapter || defaults$1.adapter;
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData2.call(
      config2,
      response.data,
      response.headers,
      config2.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData2.call(
          config2,
          reason.response.data,
          reason.response.headers,
          config2.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var utils$g = utils$n;
var mergeConfig$2 = function mergeConfig(config1, config2) {
  config2 = config2 || {};
  var config3 = {};
  var valueFromConfig2Keys = ["url", "method", "data"];
  var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
  var defaultToConfig2Keys = [
    "baseURL",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "timeoutMessage",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "decompress",
    "maxContentLength",
    "maxBodyLength",
    "maxRedirects",
    "transport",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath",
    "responseEncoding"
  ];
  var directMergeKeys = ["validateStatus"];
  function getMergedValue(target, source) {
    if (utils$g.isPlainObject(target) && utils$g.isPlainObject(source)) {
      return utils$g.merge(target, source);
    } else if (utils$g.isPlainObject(source)) {
      return utils$g.merge({}, source);
    } else if (utils$g.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(prop) {
    if (!utils$g.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$g.isUndefined(config1[prop])) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  }
  utils$g.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils$g.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(void 0, config2[prop]);
    }
  });
  utils$g.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils$g.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils$g.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(void 0, config2[prop]);
    } else if (!utils$g.isUndefined(config1[prop])) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  utils$g.forEach(directMergeKeys, function merge2(prop) {
    if (prop in config2) {
      config3[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key2) {
    return axiosKeys.indexOf(key2) === -1;
  });
  utils$g.forEach(otherKeys, mergeDeepProperties);
  return config3;
};
const name$1 = "axios";
const version$h = "0.21.4";
const description = "Promise based HTTP client for the browser and node.js";
const main = "index.js";
const scripts = {
  test: "grunt test",
  start: "node ./sandbox/server.js",
  build: "NODE_ENV=production grunt build",
  preversion: "npm test",
  version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
  postversion: "git push && git push --tags",
  examples: "node ./examples/server.js",
  coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
  fix: "eslint --fix lib/**/*.js"
};
const repository = {
  type: "git",
  url: "https://github.com/axios/axios.git"
};
const keywords$1 = [
  "xhr",
  "http",
  "ajax",
  "promise",
  "node"
];
const author = "Matt Zabriskie";
const license = "MIT";
const bugs = {
  url: "https://github.com/axios/axios/issues"
};
const homepage = "https://axios-http.com";
const devDependencies = {
  coveralls: "^3.0.0",
  "es6-promise": "^4.2.4",
  grunt: "^1.3.0",
  "grunt-banner": "^0.6.0",
  "grunt-cli": "^1.2.0",
  "grunt-contrib-clean": "^1.1.0",
  "grunt-contrib-watch": "^1.0.0",
  "grunt-eslint": "^23.0.0",
  "grunt-karma": "^4.0.0",
  "grunt-mocha-test": "^0.13.3",
  "grunt-ts": "^6.0.0-beta.19",
  "grunt-webpack": "^4.0.2",
  "istanbul-instrumenter-loader": "^1.0.0",
  "jasmine-core": "^2.4.1",
  karma: "^6.3.2",
  "karma-chrome-launcher": "^3.1.0",
  "karma-firefox-launcher": "^2.1.0",
  "karma-jasmine": "^1.1.1",
  "karma-jasmine-ajax": "^0.1.13",
  "karma-safari-launcher": "^1.0.0",
  "karma-sauce-launcher": "^4.3.6",
  "karma-sinon": "^1.0.5",
  "karma-sourcemap-loader": "^0.3.8",
  "karma-webpack": "^4.0.2",
  "load-grunt-tasks": "^3.5.2",
  minimist: "^1.2.0",
  mocha: "^8.2.1",
  sinon: "^4.5.0",
  "terser-webpack-plugin": "^4.2.3",
  typescript: "^4.0.5",
  "url-search-params": "^0.10.0",
  webpack: "^4.44.2",
  "webpack-dev-server": "^3.11.0"
};
const browser$3 = {
  "./lib/adapters/http.js": "./lib/adapters/xhr.js"
};
const jsdelivr = "dist/axios.min.js";
const unpkg = "dist/axios.min.js";
const typings = "./index.d.ts";
const dependencies = {
  "follow-redirects": "^1.14.0"
};
const bundlesize = [
  {
    path: "./dist/axios.min.js",
    threshold: "5kB"
  }
];
const require$$0$3 = {
  name: name$1,
  version: version$h,
  description,
  main,
  scripts,
  repository,
  keywords: keywords$1,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  browser: browser$3,
  jsdelivr,
  unpkg,
  typings,
  dependencies,
  bundlesize
};
var pkg = require$$0$3;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i3) {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i3 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
var currentVerArr = pkg.version.split(".");
function isOlderVersion(version2, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
  var destVer = version2.split(".");
  for (var i3 = 0; i3 < 3; i3++) {
    if (pkgVersionArr[i3] > destVer[i3]) {
      return true;
    } else if (pkgVersionArr[i3] < destVer[i3]) {
      return false;
    }
  }
  return false;
}
validators$1.transitional = function transitional(validator2, version2, message) {
  var isDeprecated = version2 && isOlderVersion(version2);
  function formatMessage(opt, desc) {
    return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new Error(formatMessage(opt, " has been removed in " + version2));
    }
    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new TypeError("options must be an object");
  }
  var keys = Object.keys(options);
  var i3 = keys.length;
  while (i3-- > 0) {
    var opt = keys[i3];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new TypeError("option " + opt + " must be " + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error("Unknown option " + opt);
    }
  }
}
var validator$1 = {
  isOlderVersion,
  assertOptions,
  validators: validators$1
};
var utils$f = utils$n;
var buildURL2 = buildURL$1;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest2 = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(config2) {
  if (typeof config2 === "string") {
    config2 = arguments[1] || {};
    config2.url = arguments[0];
  } else {
    config2 = config2 || {};
  }
  config2 = mergeConfig$1(this.defaults, config2);
  if (config2.method) {
    config2.method = config2.method.toLowerCase();
  } else if (this.defaults.method) {
    config2.method = this.defaults.method.toLowerCase();
  } else {
    config2.method = "get";
  }
  var transitional2 = config2.transitional;
  if (transitional2 !== void 0) {
    validator.assertOptions(transitional2, {
      silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
      forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
      clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest2, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config2);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config2;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }
  try {
    promise = dispatchRequest2(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config2) {
  config2 = mergeConfig$1(this.defaults, config2);
  return buildURL2(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
};
utils$f.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios$1.prototype[method] = function(url, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$f.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  Axios$1.prototype[method] = function(url, data2, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: data2
    }));
  };
});
var Axios_1 = Axios$1;
var Cancel_1;
var hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel)
    return Cancel_1;
  hasRequiredCancel = 1;
  function Cancel(message) {
    this.message = message;
  }
  Cancel.prototype.toString = function toString2() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  };
  Cancel.prototype.__CANCEL__ = true;
  Cancel_1 = Cancel;
  return Cancel_1;
}
var CancelToken_1;
var hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var Cancel = requireCancel();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token2 = this;
    executor(function cancel(message) {
      if (token2.reason) {
        return;
      }
      token2.reason = new Cancel(message);
      resolvePromise(token2.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  };
  CancelToken_1 = CancelToken;
  return CancelToken_1;
}
var spread;
var hasRequiredSpread;
function requireSpread() {
  if (hasRequiredSpread)
    return spread;
  hasRequiredSpread = 1;
  spread = function spread2(callback) {
    return function wrap2(arr) {
      return callback.apply(null, arr);
    };
  };
  return spread;
}
var isAxiosError;
var hasRequiredIsAxiosError;
function requireIsAxiosError() {
  if (hasRequiredIsAxiosError)
    return isAxiosError;
  hasRequiredIsAxiosError = 1;
  isAxiosError = function isAxiosError2(payload) {
    return typeof payload === "object" && payload.isAxiosError === true;
  };
  return isAxiosError;
}
var utils$e = utils$n;
var bind2 = bind$2;
var Axios = Axios_1;
var mergeConfig2 = mergeConfig$2;
var defaults = defaults_1;
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind2(Axios.prototype.request, context);
  utils$e.extend(instance, Axios.prototype, context);
  utils$e.extend(instance, context);
  return instance;
}
var axios$2 = createInstance(defaults);
axios$2.Axios = Axios;
axios$2.create = function create(instanceConfig) {
  return createInstance(mergeConfig2(axios$2.defaults, instanceConfig));
};
axios$2.Cancel = requireCancel();
axios$2.CancelToken = requireCancelToken();
axios$2.isCancel = requireIsCancel();
axios$2.all = function all(promises) {
  return Promise.all(promises);
};
axios$2.spread = requireSpread();
axios$2.isAxiosError = requireIsAxiosError();
axios$3.exports = axios$2;
axios$3.exports.default = axios$2;
var axiosExports = axios$3.exports;
var axios = axiosExports;
const axios$1 = /* @__PURE__ */ getDefaultExportFromCjs(axios);
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
lodash.exports;
(function(module, exports) {
  (function() {
    var undefined$1;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH2 = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH2 - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH2 >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "c",
      "": "D",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "N",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "Y",
      "": "y",
      "": "y",
      "": "Ae",
      "": "ae",
      "": "Th",
      "": "th",
      "": "ss",
      // Latin Extended-A block.
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "D",
      "": "D",
      "": "d",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "H",
      "": "H",
      "": "h",
      "": "h",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "J",
      "": "j",
      "": "K",
      "": "k",
      "": "k",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "R",
      "": "R",
      "": "R",
      "": "r",
      "": "r",
      "": "r",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "T",
      "": "T",
      "": "T",
      "": "t",
      "": "t",
      "": "t",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "W",
      "": "w",
      "": "Y",
      "": "y",
      "": "Y",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "z",
      "": "z",
      "": "z",
      "": "IJ",
      "": "ij",
      "": "Oe",
      "": "oe",
      "": "'n",
      "": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index2 = -1, length2 = array == null ? 0 : array.length;
      while (++index2 < length2) {
        var value = array[index2];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index2 = -1, length2 = array == null ? 0 : array.length;
      while (++index2 < length2) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length2 = array == null ? 0 : array.length;
      while (length2--) {
        if (iteratee(array[length2], length2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index2 = -1, length2 = array == null ? 0 : array.length;
      while (++index2 < length2) {
        if (!predicate(array[index2], index2, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value = array[index2];
        if (predicate(value, index2, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length2 = array == null ? 0 : array.length;
      return !!length2 && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index2 = -1, length2 = array == null ? 0 : array.length;
      while (++index2 < length2) {
        if (comparator(value, array[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
      while (++index2 < length2) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    function arrayPush(array, values2) {
      var index2 = -1, length2 = values2.length, offset = array.length;
      while (++index2 < length2) {
        array[offset + index2] = values2[index2];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length2 = array == null ? 0 : array.length;
      if (initAccum && length2) {
        accumulator = array[++index2];
      }
      while (++index2 < length2) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length2 = array == null ? 0 : array.length;
      if (initAccum && length2) {
        accumulator = array[--length2];
      }
      while (length2--) {
        accumulator = iteratee(accumulator, array[length2], length2, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index2 = -1, length2 = array == null ? 0 : array.length;
      while (++index2 < length2) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string2) {
      return string2.split("");
    }
    function asciiWords(string2) {
      return string2.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key2, collection2) {
        if (predicate(value, key2, collection2)) {
          result = key2;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length2 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length2) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index2 = fromIndex - 1, length2 = array.length;
      while (++index2 < length2) {
        if (comparator(array[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length2 = array == null ? 0 : array.length;
      return length2 ? baseSum(array, iteratee) / length2 : NAN;
    }
    function baseProperty(key2) {
      return function(object) {
        return object == null ? undefined$1 : object[key2];
      };
    }
    function basePropertyOf(object) {
      return function(key2) {
        return object == null ? undefined$1 : object[key2];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length2 = array.length;
      array.sort(comparer);
      while (length2--) {
        array[length2] = array[length2].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index2 = -1, length2 = array.length;
      while (++index2 < length2) {
        var current = iteratee(array[index2]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n4, iteratee) {
      var index2 = -1, result = Array(n4);
      while (++index2 < n4) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key2) {
        return [key2, object[key2]];
      });
    }
    function baseTrim(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key2) {
        return object[key2];
      });
    }
    function cacheHas(cache, key2) {
      return cache.has(key2);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length2 = strSymbols.length;
      while (++index2 < length2 && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array, placeholder) {
      var length2 = array.length, result = 0;
      while (length2--) {
        if (array[length2] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue2(object, key2) {
      return object == null ? undefined$1 : object[key2];
    }
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    function hasUnicodeWord(string2) {
      return reHasUnicodeWord.test(string2);
    }
    function iteratorToArray(iterator2) {
      var data2, result = [];
      while (!(data2 = iterator2.next()).done) {
        result.push(data2.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value, key2) {
        result[++index2] = [key2, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index2 = -1, length2 = array.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value = array[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    function setToPairs(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index2 = fromIndex - 1, length2 = array.length;
      while (++index2 < length2) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string2) {
      return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
    }
    function stringToArray(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    function trimmedEndIndex(string2) {
      var index2 = string2.length;
      while (index2-- && reWhitespace.test(string2.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string2) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string2)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string2) {
      return string2.match(reUnicode) || [];
    }
    function unicodeWords(string2) {
      return string2.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe2 = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = /* @__PURE__ */ function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "escape": reEscape,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "evaluate": reEvaluate,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "interpolate": reInterpolate,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        "variable": "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        "imports": {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH2;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length2 = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length2, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length2-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array[index2];
            while (++iterIndex < iterLength) {
              var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash2(entries2) {
        var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
        this.clear();
        while (++index2 < length2) {
          var entry = entries2[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key2) {
        var result2 = this.has(key2) && delete this.__data__[key2];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key2) {
        var data2 = this.__data__;
        if (nativeCreate) {
          var result2 = data2[key2];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data2, key2) ? data2[key2] : undefined$1;
      }
      function hashHas(key2) {
        var data2 = this.__data__;
        return nativeCreate ? data2[key2] !== undefined$1 : hasOwnProperty2.call(data2, key2);
      }
      function hashSet(key2, value) {
        var data2 = this.__data__;
        this.size += this.has(key2) ? 0 : 1;
        data2[key2] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash2.prototype.clear = hashClear;
      Hash2.prototype["delete"] = hashDelete;
      Hash2.prototype.get = hashGet;
      Hash2.prototype.has = hashHas;
      Hash2.prototype.set = hashSet;
      function ListCache(entries2) {
        var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
        this.clear();
        while (++index2 < length2) {
          var entry = entries2[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key2) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index2 == lastIndex) {
          data2.pop();
        } else {
          splice.call(data2, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key2) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
        return index2 < 0 ? undefined$1 : data2[index2][1];
      }
      function listCacheHas(key2) {
        return assocIndexOf(this.__data__, key2) > -1;
      }
      function listCacheSet(key2, value) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
        if (index2 < 0) {
          ++this.size;
          data2.push([key2, value]);
        } else {
          data2[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries2) {
        var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
        this.clear();
        while (++index2 < length2) {
          var entry = entries2[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash2(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash2()
        };
      }
      function mapCacheDelete(key2) {
        var result2 = getMapData(this, key2)["delete"](key2);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key2) {
        return getMapData(this, key2).get(key2);
      }
      function mapCacheHas(key2) {
        return getMapData(this, key2).has(key2);
      }
      function mapCacheSet(key2, value) {
        var data2 = getMapData(this, key2), size3 = data2.size;
        data2.set(key2, value);
        this.size += data2.size == size3 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values3) {
        var index2 = -1, length2 = values3 == null ? 0 : values3.length;
        this.__data__ = new MapCache();
        while (++index2 < length2) {
          this.add(values3[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack2(entries2) {
        var data2 = this.__data__ = new ListCache(entries2);
        this.size = data2.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key2) {
        var data2 = this.__data__, result2 = data2["delete"](key2);
        this.size = data2.size;
        return result2;
      }
      function stackGet(key2) {
        return this.__data__.get(key2);
      }
      function stackHas(key2) {
        return this.__data__.has(key2);
      }
      function stackSet(key2, value) {
        var data2 = this.__data__;
        if (data2 instanceof ListCache) {
          var pairs = data2.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key2, value]);
            this.size = ++data2.size;
            return this;
          }
          data2 = this.__data__ = new MapCache(pairs);
        }
        data2.set(key2, value);
        this.size = data2.size;
        return this;
      }
      Stack2.prototype.clear = stackClear;
      Stack2.prototype["delete"] = stackDelete;
      Stack2.prototype.get = stackGet;
      Stack2.prototype.has = stackHas;
      Stack2.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length2 = result2.length;
        for (var key2 in value) {
          if ((inherited || hasOwnProperty2.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
          isIndex(key2, length2)))) {
            result2.push(key2);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length2 = array.length;
        return length2 ? array[baseRandom(0, length2 - 1)] : undefined$1;
      }
      function arraySampleSize(array, n4) {
        return shuffleSelf(copyArray(array), baseClamp(n4, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key2, value) {
        if (value !== undefined$1 && !eq4(object[key2], value) || value === undefined$1 && !(key2 in object)) {
          baseAssignValue(object, key2, value);
        }
      }
      function assignValue(object, key2, value) {
        var objValue = object[key2];
        if (!(hasOwnProperty2.call(object, key2) && eq4(objValue, value)) || value === undefined$1 && !(key2 in object)) {
          baseAssignValue(object, key2, value);
        }
      }
      function assocIndexOf(array, key2) {
        var length2 = array.length;
        while (length2--) {
          if (eq4(array[length2][0], key2)) {
            return length2;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key2, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key2, value) {
        if (key2 == "__proto__" && defineProperty) {
          defineProperty(object, key2, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key2] = value;
        }
      }
      function baseAt(object, paths) {
        var index2 = -1, length2 = paths.length, result2 = Array2(length2), skip = object == null;
        while (++index2 < length2) {
          result2[index2] = skip ? undefined$1 : get2(object, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number2, lower, upper) {
        if (number2 === number2) {
          if (upper !== undefined$1) {
            number2 = number2 <= upper ? number2 : upper;
          }
          if (lower !== undefined$1) {
            number2 = number2 >= lower ? number2 : lower;
          }
        }
        return number2;
      }
      function baseClone(value, bitmask, customizer, key2, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key2, object, stack) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer2(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack2());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap2(value)) {
          value.forEach(function(subValue, key3) {
            result2.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach(props || value, function(subValue, key3) {
          if (props) {
            key3 = subValue;
            subValue = value[key3];
          }
          assignValue(result2, key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length2 = props.length;
        if (object == null) {
          return !length2;
        }
        object = Object2(object);
        while (length2--) {
          var key2 = props[length2], predicate = source[key2], value = object[key2];
          if (value === undefined$1 && !(key2 in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait2, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait2);
      }
      function baseDifference(array, values3, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length2 = array.length, result2 = [], valuesLength = values3.length;
        if (!length2) {
          return result2;
        }
        if (iteratee2) {
          values3 = arrayMap(values3, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values3.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values3 = new SetCache(values3);
        }
        outer:
          while (++index2 < length2) {
            var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values3[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values3, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index2, collection2) {
          result2 = !!predicate(value, index2, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index2 = -1, length2 = array.length;
        while (++index2 < length2) {
          var value = array[index2], current = iteratee2(value);
          if (current != null && (computed === undefined$1 ? current === current && !isSymbol2(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length2 = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length2 ? 0 : length2 + start;
        }
        end = end === undefined$1 || end > length2 ? length2 : toInteger(end);
        if (end < 0) {
          end += length2;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index2, collection2) {
          if (predicate(value, index2, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index2 = -1, length2 = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length2) {
          var value = array[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key2) {
          return isFunction2(object[key2]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index2 = 0, length2 = path.length;
        while (object != null && index2 < length2) {
          object = object[toKey(path[index2++])];
        }
        return index2 && index2 == length2 ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString2(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key2) {
        return object != null && hasOwnProperty2.call(object, key2);
      }
      function baseHasIn(object, key2) {
        return object != null && key2 in Object2(object);
      }
      function baseInRange(number2, start, end) {
        return number2 >= nativeMin(start, end) && number2 < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index2 = -1, seen2 = caches[0];
        outer:
          while (++index2 < length2 && result2.length < maxLength) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen2 ? cacheHas(seen2, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen2) {
                seen2.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key2, object2) {
          setter(accumulator, iteratee2(value), key2, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent2(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$1 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object)) {
          if (!isBuffer2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack2());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack2());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length2;
        }
        object = Object2(object);
        while (index2--) {
          var data2 = matchData[index2];
          if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
            return false;
          }
        }
        while (++index2 < length2) {
          data2 = matchData[index2];
          var key2 = data2[0], objValue = object[key2], srcValue = data2[1];
          if (noCustomizer && data2[2]) {
            if (objValue === undefined$1 && !(key2 in object)) {
              return false;
            }
          } else {
            var stack = new Stack2();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key2, object, source, stack);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity2;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key2 in Object2(object)) {
          if (hasOwnProperty2.call(object, key2) && key2 != "constructor") {
            result2.push(key2);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key2 in object) {
          if (!(key2 == "constructor" && (isProto || !hasOwnProperty2.call(object, key2)))) {
            result2.push(key2);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key2, collection2) {
          result2[++index2] = iteratee2(value, key2, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get2(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key2) {
          stack || (stack = new Stack2());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source, key2, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key2, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key2, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key2), srcValue = safeGet(source, key2), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key2, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key2, newValue);
      }
      function baseNth(array, n4) {
        var length2 = array.length;
        if (!length2) {
          return;
        }
        n4 += n4 < 0 ? length2 : 0;
        return isIndex(n4, length2) ? array[n4] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity2];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key2, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length2 = paths.length, result2 = {};
        while (++index2 < length2) {
          var path = paths[index2], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values3, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length2 = values3.length, seen2 = array;
        if (array === values3) {
          values3 = copyArray(values3);
        }
        if (iteratee2) {
          seen2 = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index2 < length2) {
          var fromIndex = 0, value = values3[index2], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen2, computed, fromIndex, comparator)) > -1) {
            if (seen2 !== array) {
              splice.call(seen2, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length2 = array ? indexes.length : 0, lastIndex = length2 - 1;
        while (length2--) {
          var index2 = indexes[length2];
          if (length2 == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex(index2)) {
              splice.call(array, index2, 1);
            } else {
              baseUnset(array, index2);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index2 = -1, length2 = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length2);
        while (length2--) {
          result2[fromRight ? length2 : ++index2] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string2, n4) {
        var result2 = "";
        if (!string2 || n4 < 1 || n4 > MAX_SAFE_INTEGER2) {
          return result2;
        }
        do {
          if (n4 % 2) {
            result2 += string2;
          }
          n4 = nativeFloor(n4 / 2);
          if (n4) {
            string2 += string2;
          }
        } while (n4);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity2), func + "");
      }
      function baseSample(collection) {
        return arraySample(values2(collection));
      }
      function baseSampleSize(collection, n4) {
        var array = values2(collection);
        return shuffleSelf(array, baseClamp(n4, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath(path, object);
        var index2 = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
        while (nested != null && ++index2 < length2) {
          var key2 = toKey(path[index2]), newValue = value;
          if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key2];
            newValue = customizer ? customizer(objValue, key2, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key2, newValue);
          nested = nested[key2];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity2 : function(func, data2) {
        metaMap.set(func, data2);
        return func;
      };
      var baseSetToString = !defineProperty ? identity2 : function(func, string2) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string2),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values2(collection));
      }
      function baseSlice(array, start, end) {
        var index2 = -1, length2 = array.length;
        if (start < 0) {
          start = -start > length2 ? 0 : length2 + start;
        }
        end = end > length2 ? length2 : end;
        if (end < 0) {
          end += length2;
        }
        length2 = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length2);
        while (++index2 < length2) {
          result2[index2] = array[index2 + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index2, collection2) {
          result2 = predicate(value, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol2(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity2, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol2(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index2 = -1, length2 = array.length, resIndex = 0, result2 = [];
        while (++index2 < length2) {
          var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq4(computed, seen2)) {
            var seen2 = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol2(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, length2 = array.length, isCommon = true, result2 = [], seen2 = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length2 >= LARGE_ARRAY_SIZE) {
          var set3 = iteratee2 ? null : createSet(array);
          if (set3) {
            return setToArray(set3);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen2 = new SetCache();
        } else {
          seen2 = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length2) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen2.length;
              while (seenIndex--) {
                if (seen2[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen2.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen2, computed, comparator)) {
              if (seen2 !== result2) {
                seen2.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent2(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length2 = array.length, index2 = fromRight ? length2 : -1;
        while ((fromRight ? index2-- : ++index2 < length2) && predicate(array[index2], index2, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length2) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length2 : index2);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length2 = arrays.length;
        if (length2 < 2) {
          return length2 ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length2);
        while (++index2 < length2) {
          var array = arrays[index2], othIndex = -1;
          while (++othIndex < length2) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values3, assignFunc) {
        var index2 = -1, length2 = props.length, valsLength = values3.length, result2 = {};
        while (++index2 < length2) {
          var value = index2 < valsLength ? values3[index2] : undefined$1;
          assignFunc(result2, props[index2], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity2;
      }
      function castPath(value, object) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString2(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length2 = array.length;
        end = end === undefined$1 ? length2 : end;
        return !start && end >= length2 ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id2) {
        return root.clearTimeout(id2);
      };
      function cloneBuffer(buffer2, isDeep) {
        if (isDeep) {
          return buffer2.slice();
        }
        var length2 = buffer2.length, result2 = allocUnsafe2 ? allocUnsafe2(length2) : new buffer2.constructor(length2);
        buffer2.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length2) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order = orders[index2];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index2 = -1, length2 = source.length;
        array || (array = Array2(length2));
        while (++index2 < length2) {
          array[index2] = source[index2];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length2 = props.length;
        while (++index2 < length2) {
          var key2 = props[index2];
          var newValue = customizer ? customizer(object[key2], source[key2], key2, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key2];
          }
          if (isNew) {
            baseAssignValue(object, key2, newValue);
          } else {
            assignValue(object, key2, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined$1, guard = length2 > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length2 < 3 ? undefined$1 : customizer;
            length2 = 1;
          }
          object = Object2(object);
          while (++index2 < length2) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike2(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length2) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object), props = keysFunc(object), length2 = props.length;
          while (length2--) {
            var key2 = props[fromRight ? length2 : ++index2];
            if (iteratee2(iterable[key2], key2, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn2.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string2) {
          string2 = toString2(string2);
          var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string2) {
          return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length2 = arguments.length, args = Array2(length2), index2 = length2, placeholder = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length2 -= holders.length;
          if (length2 < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$1,
              args,
              holders,
              undefined$1,
              undefined$1,
              arity - length2
            );
          }
          var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn2, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike2(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key2) {
              return iteratee2(iterable[key2], key2, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length2 = funcs.length, index2 = length2, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length2;
          while (++index2 < length2) {
            func = funcs[index2];
            var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData2(func) : undefined$1;
            if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
              wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index3 = 0, result2 = length2 ? funcs[index3].apply(this, args) : value;
            while (++index3 < length2) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length2 = arguments.length, args = Array2(length2), index2 = length2;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length2 -= holdersCount;
          if (isCurried && length2 < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length2
            );
          }
          var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
          length2 = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length2 > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length2) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn2 = Ctor || createCtor(fn2);
          }
          return fn2.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length2, chars) {
        chars = chars === undefined$1 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length2) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length2 / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length2).join("") : result2.slice(0, length2);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn2, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined$1;
          }
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number2, precision) {
          number2 = toNumber(number2);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number2)) {
            var pair = (toString2(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number2);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values3) {
        return new Set2(values3);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length2 = partials ? partials.length : 0;
        if (!length2) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length2 -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data2 = isBindKey ? undefined$1 : getData2(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data2) {
          mergeData(newData, data2);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length2, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data2 ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key2, object) {
        if (objValue === undefined$1 || eq4(objValue, objectProto[key2]) && !hasOwnProperty2.call(object, key2)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key2, object, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject2(value) ? undefined$1 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result2 = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen2) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen2.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq4(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert2 = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert2 || (convert2 = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key2 = objProps[index2];
          if (!(isPartial ? key2 in other : hasOwnProperty2.call(other, key2))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key2 = objProps[index2];
          var objValue = object[key2], othValue = other[key2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key2 == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData2 = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length2 = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length2--) {
          var data2 = array[length2], otherFunc = data2.func;
          if (otherFunc == null || otherFunc == func) {
            return data2.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key2) {
        var data2 = map2.__data__;
        return isKeyable(key2) ? data2[typeof key2 == "string" ? "string" : "hash"] : data2.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length2 = result2.length;
        while (length2--) {
          var key2 = result2[length2], value = object[key2];
          result2[length2] = [key2, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key2) {
        var value = getValue2(object, key2);
        return baseIsNative(value) ? value : undefined$1;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e2) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index2 = -1, length2 = transforms.length;
        while (++index2 < length2) {
          var data2 = transforms[index2], size3 = data2.size;
          switch (data2.type) {
            case "drop":
              start += size3;
              break;
            case "dropRight":
              end -= size3;
              break;
            case "take":
              end = nativeMin(end, start + size3);
              break;
            case "takeRight":
              start = nativeMax(start, end - size3);
              break;
          }
        }
        return { "start": start, "end": end };
      }
      function getWrapDetails(source) {
        var match2 = source.match(reWrapDetails);
        return match2 ? match2[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index2 = -1, length2 = path.length, result2 = false;
        while (++index2 < length2) {
          var key2 = toKey(path[index2]);
          if (!(result2 = object != null && hasFunc(object, key2))) {
            break;
          }
          object = object[key2];
        }
        if (result2 || ++index2 != length2) {
          return result2;
        }
        length2 = object == null ? 0 : object.length;
        return !!length2 && isLength(length2) && isIndex(key2, length2) && (isArray2(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length2 = array.length, result2 = new array.constructor(length2);
        if (length2 && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length2 = details.length;
        if (!length2) {
          return source;
        }
        var lastIndex = length2 - 1;
        details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length2 > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length2) {
        var type = typeof value;
        length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
        return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
      }
      function isIterateeCall(value, index2, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike2(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
          return eq4(object[index2], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data2 = getData2(other);
        return !!data2 && func === data2[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key2, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key2] === srcValue && (srcValue !== undefined$1 || key2 in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize2(func, function(key2) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key2;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data2, source) {
        var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data2;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data2[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data2[3];
          data2[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data2[5];
          data2[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data2[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data2[8] = data2[8] == null ? source[8] : nativeMin(data2[8], source[8]);
        }
        if (data2[9] == null) {
          data2[9] = source[9];
        }
        data2[0] = source[0];
        data2[1] = newBitmask;
        return data2;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key2 in Object2(object)) {
            result2.push(key2);
          }
        }
        return result2;
      }
      function objectToString2(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index2 = -1, length2 = nativeMax(args.length - start, 0), array = Array2(length2);
          while (++index2 < length2) {
            array[index2] = args[start + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start + 1);
          while (++index2 < start) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent2(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length2--) {
          var index2 = indexes[length2];
          array[length2] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array;
      }
      function safeGet(object, key2) {
        if (key2 === "constructor" && typeof object[key2] === "function") {
          return;
        }
        if (key2 == "__proto__") {
          return;
        }
        return object[key2];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait2) {
        return root.setTimeout(func, wait2);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size3) {
        var index2 = -1, length2 = array.length, lastIndex = length2 - 1;
        size3 = size3 === undefined$1 ? length2 : size3;
        while (++index2 < size3) {
          var rand2 = baseRandom(index2, lastIndex), value = array[rand2];
          array[rand2] = array[index2];
          array[index2] = value;
        }
        array.length = size3;
        return array;
      }
      var stringToPath = memoizeCapped(function(string2) {
        var result2 = [];
        if (string2.charCodeAt(0) === 46) {
          result2.push("");
        }
        string2.replace(rePropName, function(match2, number2, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol2(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size3, guard) {
        if (guard ? isIterateeCall(array, size3, guard) : size3 === undefined$1) {
          size3 = 1;
        } else {
          size3 = nativeMax(toInteger(size3), 0);
        }
        var length2 = array == null ? 0 : array.length;
        if (!length2 || size3 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size3));
        while (index2 < length2) {
          result2[resIndex++] = baseSlice(array, index2, index2 += size3);
        }
        return result2;
      }
      function compact(array) {
        var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index2 < length2) {
          var value = array[index2];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat2() {
        var length2 = arguments.length;
        if (!length2) {
          return [];
        }
        var args = Array2(length2 - 1), array = arguments[0], index2 = length2;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values3) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values3) {
        var iteratee2 = last(values3);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values3) {
        var comparator = last(values3);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
      });
      function drop(array, n4, guard) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        n4 = guard || n4 === undefined$1 ? 1 : toInteger(n4);
        return baseSlice(array, n4 < 0 ? 0 : n4, length2);
      }
      function dropRight(array, n4, guard) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        n4 = guard || n4 === undefined$1 ? 1 : toInteger(n4);
        n4 = length2 - n4;
        return baseSlice(array, 0, n4 < 0 ? 0 : n4);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length2;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length2 + index2, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return -1;
        }
        var index2 = length2 - 1;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length2 + index2, 0) : nativeMin(index2, length2 - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
      }
      function flatten(array) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index2 = -1, length2 = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length2) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf(array, value, fromIndex) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length2 + index2, 0);
        }
        return baseIndexOf(array, value, index2);
      }
      function initial(array) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join2(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? array[length2 - 1] : undefined$1;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return -1;
        }
        var index2 = length2;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = index2 < 0 ? nativeMax(length2 + index2, 0) : nativeMin(index2, length2 - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
      }
      function nth(array, n4) {
        return array && array.length ? baseNth(array, toInteger(n4)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values3) {
        return array && array.length && values3 && values3.length ? basePullAll(array, values3) : array;
      }
      function pullAllBy(array, values3, iteratee2) {
        return array && array.length && values3 && values3.length ? basePullAll(array, values3, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values3, comparator) {
        return array && array.length && values3 && values3.length ? basePullAll(array, values3, undefined$1, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length2 = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index2) {
          return isIndex(index2, length2) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length2 = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length2) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result2.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice2(array, start, end) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length2;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined$1 ? length2 : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length2 = array == null ? 0 : array.length;
        if (length2) {
          var index2 = baseSortedIndex(array, value);
          if (index2 < length2 && eq4(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length2 = array == null ? 0 : array.length;
        if (length2) {
          var index2 = baseSortedIndex(array, value, true) - 1;
          if (eq4(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? baseSlice(array, 1, length2) : [];
      }
      function take(array, n4, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n4 = guard || n4 === undefined$1 ? 1 : toInteger(n4);
        return baseSlice(array, 0, n4 < 0 ? 0 : n4);
      }
      function takeRight(array, n4, guard) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        n4 = guard || n4 === undefined$1 ? 1 : toInteger(n4);
        n4 = length2 - n4;
        return baseSlice(array, n4 < 0 ? 0 : n4, length2);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length2 = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length2 = nativeMax(group.length, length2);
            return true;
          }
        });
        return baseTimes(length2, function(index2) {
          return arrayMap(array, baseProperty(index2));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array, values3) {
        return isArrayLikeObject(array) ? baseDifference(array, values3) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values3) {
        return baseZipObject(props || [], values3 || [], assignValue);
      }
      function zipObjectDeep(props, values3) {
        return baseZipObject(props || [], values3 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length2 = paths.length, start = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length2 ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length2 && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent3 = this;
        while (parent3 instanceof baseLodash) {
          var clone3 = wrapperClone(parent3);
          clone3.__index__ = 0;
          clone3.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone3;
          } else {
            result2 = clone3;
          }
          var previous = clone3;
          parent3 = parent3.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key2) {
        if (hasOwnProperty2.call(result2, key2)) {
          ++result2[key2];
        } else {
          baseAssignValue(result2, key2, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach4(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key2) {
        if (hasOwnProperty2.call(result2, key2)) {
          result2[key2].push(value);
        } else {
          baseAssignValue(result2, key2, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike2(collection) ? collection : values2(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length2 = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length2 + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key2) {
        baseAssignValue(result2, key2, value);
      });
      function map(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key2) {
        result2[key2 ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n4, guard) {
        if (guard ? isIterateeCall(collection, n4, guard) : n4 === undefined$1) {
          n4 = 1;
        } else {
          n4 = toInteger(n4);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n4);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size2(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike2(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length2 = iteratees.length;
        if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n4, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n4 = toInteger(n4);
        return function() {
          if (--n4 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n4, guard) {
        n4 = guard ? undefined$1 : n4;
        n4 = func && n4 == null ? func.length : n4;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n4);
      }
      function before(n4, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n4 = toInteger(n4);
        return function() {
          if (--n4 > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n4 <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind3 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind3));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key2, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key2, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce2(func, wait2, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait2 = toNumber(wait2) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait2) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time2) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time2;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time2) {
          lastInvokeTime = time2;
          timerId = setTimeout2(timerExpired, wait2);
          return leading ? invokeFunc(time2) : result2;
        }
        function remainingWait(time2) {
          var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait2 - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time2) {
          var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait2 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time2 = now();
          if (shouldInvoke(time2)) {
            return trailingEdge(time2);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time2));
        }
        function trailingEdge(time2) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time2);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time2 = now(), isInvoking = shouldInvoke(time2);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time2;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait2);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait2);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay2 = baseRest(function(func, wait2, args) {
        return baseDelay(func, toNumber(wait2) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize2(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key2)) {
            return cache.get(key2);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key2, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize2.Cache || MapCache)();
        return memoized;
      }
      memoize2.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once3(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length2 = nativeMin(args.length, funcsLength);
          while (++index2 < length2) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined$1 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread2(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait2, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce2(func, wait2, {
          "leading": leading,
          "maxWait": wait2,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap2(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone2(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq4(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt2 = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike2(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike2(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer2 = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty2(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key2 in value) {
          if (hasOwnProperty2.call(value, key2)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger2(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
      }
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject2(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger2(value) && value >= -MAX_SAFE_INTEGER2 && value <= MAX_SAFE_INTEGER2;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined2(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt2 = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike2(value)) {
          return isString2(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign3 = value < 0 ? -1 : 1;
          return sign3 * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH2) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2) : value === 0 ? value : 0;
      }
      function toString2(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign2 = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike2(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key2 in source) {
          if (hasOwnProperty2.call(source, key2)) {
            assignValue(object, key2, source[key2]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at2 = flatRest(baseAt);
      function create3(prototype, properties2) {
        var result2 = baseCreate(prototype);
        return properties2 == null ? result2 : baseAssign(result2, properties2);
      }
      var defaults2 = baseRest(function(object, sources) {
        object = Object2(object);
        var index2 = -1;
        var length2 = sources.length;
        var guard = length2 > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length2 = 1;
        }
        while (++index2 < length2) {
          var source = sources[index2];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key2 = props[propsIndex];
            var value = object[key2];
            if (value === undefined$1 || eq4(value, objectProto[key2]) && !hasOwnProperty2.call(object, key2)) {
              object[key2] = source[key2];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith, undefined$1, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get2(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has2(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key2) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key2;
      }, constant(identity2));
      var invertBy = createInverter(function(result2, value, key2) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key2);
        } else {
          result2[value] = [key2];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key2, object2) {
          baseAssignValue(result2, iteratee2(value, key2, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key2, object2) {
          baseAssignValue(result2, key2, iteratee2(value, key2, object2));
        });
        return result2;
      }
      var merge2 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length2 = paths.length;
        while (length2--) {
          baseUnset(result2, paths[length2]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index2 = -1, length2 = path.length;
        if (!length2) {
          length2 = 1;
          object = undefined$1;
        }
        while (++index2 < length2) {
          var value = object == null ? undefined$1 : object[toKey(path[index2])];
          if (value === undefined$1) {
            index2 = length2;
            value = defaultValue;
          }
          object = isFunction2(value) ? value.call(object) : value;
        }
        return object;
      }
      function set2(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
          return iteratee2(accumulator, value, index2, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update5(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values2(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp2(number2, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number2), lower, upper);
      }
      function inRange(number2, start, end) {
        start = toFinite(start);
        if (end === undefined$1) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number2 = toNumber(number2);
        return baseInRange(number2, start, end);
      }
      function random2(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand2 = nativeRandom();
          return nativeMin(lower + rand2 * (upper - lower + freeParseFloat("1e-" + ((rand2 + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize2(word) : word);
      });
      function capitalize2(string2) {
        return upperFirst(toString2(string2).toLowerCase());
      }
      function deburr(string2) {
        string2 = toString2(string2);
        return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string2, target, position2) {
        string2 = toString2(string2);
        target = baseToString(target);
        var length2 = string2.length;
        position2 = position2 === undefined$1 ? length2 : baseClamp(toInteger(position2), 0, length2);
        var end = position2;
        position2 -= target.length;
        return position2 >= 0 && string2.slice(position2, end) == target;
      }
      function escape2(string2) {
        string2 = toString2(string2);
        return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
      }
      function escapeRegExp(string2) {
        string2 = toString2(string2);
        return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
      }
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad3(string2, length2, chars) {
        string2 = toString2(string2);
        length2 = toInteger(length2);
        var strLength = length2 ? stringSize(string2) : 0;
        if (!length2 || strLength >= length2) {
          return string2;
        }
        var mid = (length2 - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string2 + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string2, length2, chars) {
        string2 = toString2(string2);
        length2 = toInteger(length2);
        var strLength = length2 ? stringSize(string2) : 0;
        return length2 && strLength < length2 ? string2 + createPadding(length2 - strLength, chars) : string2;
      }
      function padStart(string2, length2, chars) {
        string2 = toString2(string2);
        length2 = toInteger(length2);
        var strLength = length2 ? stringSize(string2) : 0;
        return length2 && strLength < length2 ? createPadding(length2 - strLength, chars) + string2 : string2;
      }
      function parseInt2(string2, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString2(string2).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string2, n4, guard) {
        if (guard ? isIterateeCall(string2, n4, guard) : n4 === undefined$1) {
          n4 = 1;
        } else {
          n4 = toInteger(n4);
        }
        return baseRepeat(toString2(string2), n4);
      }
      function replace2() {
        var args = arguments, string2 = toString2(args[0]);
        return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split2(string2, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH2 : limit >>> 0;
        if (!limit) {
          return [];
        }
        string2 = toString2(string2);
        if (string2 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string2)) {
            return castSlice(stringToArray(string2), 0, limit);
          }
        }
        return string2.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith(string2, target, position2) {
        string2 = toString2(string2);
        position2 = position2 == null ? 0 : baseClamp(toInteger(position2), 0, string2.length);
        target = baseToString(target);
        return string2.slice(position2, position2 + target.length) == target;
      }
      function template(string2, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string2, options, guard)) {
          options = undefined$1;
        }
        string2 = toString2(string2);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2(
          (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string2.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string2.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset + match2.length;
          return match2;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString2(value).toLowerCase();
      }
      function toUpper(value) {
        return toString2(value).toUpperCase();
      }
      function trim2(string2, chars, guard) {
        string2 = toString2(string2);
        if (string2 && (guard || chars === undefined$1)) {
          return baseTrim(string2);
        }
        if (!string2 || !(chars = baseToString(chars))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string2, chars, guard) {
        string2 = toString2(string2);
        if (string2 && (guard || chars === undefined$1)) {
          return string2.slice(0, trimmedEndIndex(string2) + 1);
        }
        if (!string2 || !(chars = baseToString(chars))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string2, chars, guard) {
        string2 = toString2(string2);
        if (string2 && (guard || chars === undefined$1)) {
          return string2.replace(reTrimStart, "");
        }
        if (!string2 || !(chars = baseToString(chars))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate2(string2, options) {
        var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length2 = "length" in options ? toInteger(options.length) : length2;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string2 = toString2(string2);
        var strLength = string2.length;
        if (hasUnicode(string2)) {
          var strSymbols = stringToArray(string2);
          strLength = strSymbols.length;
        }
        if (length2 >= strLength) {
          return string2;
        }
        var end = length2 - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string2.slice(end).search(separator)) {
            var match2, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match2 = separator.exec(substring)) {
              var newEnd = match2.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string2.indexOf(baseToString(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape2(string2) {
        string2 = toString2(string2);
        return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
      }
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string2, pattern, guard) {
        string2 = toString2(string2);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
        }
        return string2.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e2) {
          return isError(e2) ? e2 : new Error2(e2);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key2) {
          key2 = toKey(key2);
          baseAssignValue(object, key2, bind3(object[key2], object));
        });
        return object;
      });
      function cond(pairs) {
        var length2 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length2 ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length2) {
            var pair = pairs[index2];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity2(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n4) {
        n4 = toInteger(n4);
        return baseRest(function(args) {
          return baseNth(args, n4);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n4, iteratee2) {
        n4 = toInteger(n4);
        if (n4 < 1 || n4 > MAX_SAFE_INTEGER2) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH2, length2 = nativeMin(n4, MAX_ARRAY_LENGTH2);
        iteratee2 = getIteratee(iteratee2);
        n4 -= MAX_ARRAY_LENGTH2;
        var result2 = baseTimes(length2, iteratee2);
        while (++index2 < n4) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol2(value) ? [value] : copyArray(stringToPath(toString2(value)));
      }
      function uniqueId(prefix2) {
        var id2 = ++idCounter;
        return toString2(prefix2) + id2;
      }
      var add4 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide2 = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean2(array) {
        return baseMean(array, identity2);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined$1;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round2 = createRound("round");
      var subtract2 = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum2(array) {
        return array && array.length ? baseSum(array, identity2) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign2;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at2;
      lodash2.before = before;
      lodash2.bind = bind3;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat2;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create3;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce2;
      lodash2.defaults = defaults2;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay2;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys;
      lodash2.keysIn = keysIn;
      lodash2.map = map;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize2;
      lodash2.merge = merge2;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit;
      lodash2.omitBy = omitBy;
      lodash2.once = once3;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set2;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice2;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split2;
      lodash2.spread = spread2;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle;
      lodash2.thru = thru;
      lodash2.toArray = toArray2;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update5;
      lodash2.updateWith = updateWith;
      lodash2.values = values2;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap2;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add4;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize2;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp2;
      lodash2.clone = clone2;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide2;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq4;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach4;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get2;
      lodash2.gt = gt2;
      lodash2.gte = gte;
      lodash2.has = has2;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity2;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer2;
      lodash2.isArrayLike = isArrayLike2;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean;
      lodash2.isBuffer = isBuffer2;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement;
      lodash2.isEmpty = isEmpty2;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger2;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap2;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet;
      lodash2.isString = isString2;
      lodash2.isSymbol = isSymbol2;
      lodash2.isTypedArray = isTypedArray;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join2;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt2;
      lodash2.lte = lte;
      lodash2.max = max;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean2;
      lodash2.meanBy = meanBy;
      lodash2.min = min;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now;
      lodash2.pad = pad3;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random2;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace2;
      lodash2.result = result;
      lodash2.round = round2;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size2;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract2;
      lodash2.sum = sum2;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString2;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim2;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate2;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach4;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n4) {
          n4 = n4 === undefined$1 ? 1 : nativeMax(toInteger(n4), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n4, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n4, MAX_ARRAY_LENGTH2),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n4) {
          return this.reverse()[methodName](n4).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity2);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined$1) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH2);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key2 = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key2)) {
            realNames[key2] = [];
          }
          realNames[key2].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _2 = runInContext();
    if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root._ = _2;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
var lodashExports = lodash.exports;
const _$3 = /* @__PURE__ */ getDefaultExportFromCjs(lodashExports);
var MetricLoggerUnit;
(function(MetricLoggerUnit2) {
  MetricLoggerUnit2["Seconds"] = "Seconds";
  MetricLoggerUnit2["Microseconds"] = "Microseconds";
  MetricLoggerUnit2["Milliseconds"] = "Milliseconds";
  MetricLoggerUnit2["Bytes"] = "Bytes";
  MetricLoggerUnit2["Kilobytes"] = "Kilobytes";
  MetricLoggerUnit2["Megabytes"] = "Megabytes";
  MetricLoggerUnit2["Gigabytes"] = "Gigabytes";
  MetricLoggerUnit2["Terabytes"] = "Terabytes";
  MetricLoggerUnit2["Bits"] = "Bits";
  MetricLoggerUnit2["Kilobits"] = "Kilobits";
  MetricLoggerUnit2["Megabits"] = "Megabits";
  MetricLoggerUnit2["Gigabits"] = "Gigabits";
  MetricLoggerUnit2["Terabits"] = "Terabits";
  MetricLoggerUnit2["Percent"] = "Percent";
  MetricLoggerUnit2["Count"] = "Count";
  MetricLoggerUnit2["BytesPerSecond"] = "Bytes/Second";
  MetricLoggerUnit2["KilobytesPerSecond"] = "Kilobytes/Second";
  MetricLoggerUnit2["MegabytesPerSecond"] = "Megabytes/Second";
  MetricLoggerUnit2["GigabytesPerSecond"] = "Gigabytes/Second";
  MetricLoggerUnit2["TerabytesPerSecond"] = "Terabytes/Second";
  MetricLoggerUnit2["BitsPerSecond"] = "Bits/Second";
  MetricLoggerUnit2["KilobitsPerSecond"] = "Kilobits/Second";
  MetricLoggerUnit2["MegabitsPerSecond"] = "Megabits/Second";
  MetricLoggerUnit2["GigabitsPerSecond"] = "Gigabits/Second";
  MetricLoggerUnit2["TerabitsPerSecond"] = "Terabits/Second";
  MetricLoggerUnit2["CountPerSecond"] = "Count/Second";
  MetricLoggerUnit2["None"] = "None";
})(MetricLoggerUnit || (MetricLoggerUnit = {}));
class IMetric {
}
class MetricLogger extends IMetric {
  constructor(context) {
    super();
    this.log = log.child(context || {});
  }
  putDimensions(dimensions) {
    this.log = this.log.child(dimensions);
  }
  putMetric(key2, value, unit) {
    this.log.info({ key: key2, value, unit }, `[Metric]: ${key2}: ${value} | ${unit ? unit : ""}`);
  }
}
let metric = new MetricLogger();
class CachingTokenListProvider {
  /**
   * Creates an instance of CachingTokenListProvider.
   * Token metadata (e.g. symbol and decimals) generally don't change so can be cached indefinitely.
   *
   * @param chainId The chain id to use.
   * @param tokenList The token list to get the tokens from.
   * @param tokenCache Cache instance to hold cached tokens.
   */
  constructor(chainId2, tokenList, tokenCache) {
    this.tokenCache = tokenCache;
    this.CACHE_KEY = (tokenInfo) => `token-list-token-${this.chainId}/${this.tokenList.name}/${this.tokenList.timestamp}/${this.tokenList.version}/${tokenInfo.address.toLowerCase()}/${tokenInfo.decimals}/${tokenInfo.symbol}/${tokenInfo.name}`;
    this.chainId = chainId2;
    this.tokenList = tokenList;
    this.chainToTokenInfos = _$3.reduce(this.tokenList.tokens, (result, tokenInfo) => {
      const chainId3 = tokenInfo.chainId.toString();
      if (!result[chainId3]) {
        result[chainId3] = [];
      }
      result[chainId3].push(tokenInfo);
      return result;
    }, {});
    this.chainSymbolToTokenInfo = _$3.mapValues(this.chainToTokenInfos, (tokenInfos) => _$3.keyBy(tokenInfos, "symbol"));
    this.chainAddressToTokenInfo = _$3.mapValues(this.chainToTokenInfos, (tokenInfos) => _$3.keyBy(tokenInfos, (tokenInfo) => tokenInfo.address.toLowerCase()));
  }
  static async fromTokenListURI(chainId2, tokenListURI, tokenCache) {
    const now = Date.now();
    const tokenList = await this.buildTokenList(tokenListURI);
    metric.putMetric("TokenListLoad", Date.now() - now, MetricLoggerUnit.Milliseconds);
    return new CachingTokenListProvider(chainId2, tokenList, tokenCache);
  }
  static async buildTokenList(tokenListURI) {
    log.info(`Getting tokenList from ${tokenListURI}.`);
    const response = await axios$1.get(tokenListURI);
    log.info(`Got tokenList from ${tokenListURI}.`);
    const { data: tokenList, status } = response;
    if (status != 200) {
      log.error({ response }, `Unabled to get token list from ${tokenListURI}.`);
      throw new Error(`Unable to get token list from ${tokenListURI}`);
    }
    return tokenList;
  }
  static async fromTokenList(chainId2, tokenList, tokenCache) {
    const now = Date.now();
    const tokenProvider = new CachingTokenListProvider(chainId2, tokenList, tokenCache);
    metric.putMetric("TokenListLoad", Date.now() - now, MetricLoggerUnit.Milliseconds);
    return tokenProvider;
  }
  async getTokens(_addresses) {
    const addressToToken = {};
    const symbolToToken = {};
    for (const address of _addresses) {
      const token2 = await this.getTokenByAddress(address);
      if (!token2) {
        continue;
      }
      addressToToken[address.toLowerCase()] = token2;
      if (!token2.symbol) {
        continue;
      }
      symbolToToken[token2.symbol.toLowerCase()] = token2;
    }
    return {
      getTokenByAddress: (address) => addressToToken[address.toLowerCase()],
      getTokenBySymbol: (symbol) => symbolToToken[symbol.toLowerCase()],
      getAllTokens: () => {
        return Object.values(addressToToken);
      }
    };
  }
  async getTokenBySymbol(_symbol) {
    let symbol = _symbol;
    if (_symbol == "ETH") {
      symbol = "WETH";
    }
    if (!this.chainSymbolToTokenInfo[this.chainId.toString()]) {
      return void 0;
    }
    const tokenInfo = this.chainSymbolToTokenInfo[this.chainId.toString()][symbol];
    if (!tokenInfo) {
      return void 0;
    }
    const token2 = await this.buildToken(tokenInfo);
    return token2;
  }
  async getTokenByAddress(address) {
    if (!this.chainAddressToTokenInfo[this.chainId.toString()]) {
      return void 0;
    }
    const tokenInfo = this.chainAddressToTokenInfo[this.chainId.toString()][address.toLowerCase()];
    if (!tokenInfo) {
      return void 0;
    }
    const token2 = await this.buildToken(tokenInfo);
    return token2;
  }
  async buildToken(tokenInfo) {
    const cacheKey2 = this.CACHE_KEY(tokenInfo);
    const cachedToken = await this.tokenCache.get(cacheKey2);
    if (cachedToken) {
      return cachedToken;
    }
    const token2 = new Token$4(this.chainId, tokenInfo.address, tokenInfo.decimals, tokenInfo.symbol, tokenInfo.name);
    await this.tokenCache.set(cacheKey2, token2);
    return token2;
  }
}
function _defineProperties$5(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$5(Constructor, staticProps);
  return Constructor;
}
function _extends$3() {
  _extends$3 = Object.assign || function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
function _inheritsLoose$4(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var ChainId$3;
(function(ChainId2) {
  ChainId2[ChainId2["MAINNET"] = 1] = "MAINNET";
  ChainId2[ChainId2["GOERLI"] = 5] = "GOERLI";
  ChainId2[ChainId2["SEPOLIA"] = 11155111] = "SEPOLIA";
  ChainId2[ChainId2["OPTIMISM"] = 10] = "OPTIMISM";
  ChainId2[ChainId2["OPTIMISM_GOERLI"] = 420] = "OPTIMISM_GOERLI";
  ChainId2[ChainId2["OPTIMISM_SEPOLIA"] = 11155420] = "OPTIMISM_SEPOLIA";
  ChainId2[ChainId2["ARBITRUM_ONE"] = 42161] = "ARBITRUM_ONE";
  ChainId2[ChainId2["ARBITRUM_GOERLI"] = 421613] = "ARBITRUM_GOERLI";
  ChainId2[ChainId2["POLYGON"] = 137] = "POLYGON";
  ChainId2[ChainId2["POLYGON_MUMBAI"] = 80001] = "POLYGON_MUMBAI";
  ChainId2[ChainId2["CELO"] = 42220] = "CELO";
  ChainId2[ChainId2["CELO_ALFAJORES"] = 44787] = "CELO_ALFAJORES";
  ChainId2[ChainId2["GNOSIS"] = 100] = "GNOSIS";
  ChainId2[ChainId2["MOONBEAM"] = 1284] = "MOONBEAM";
  ChainId2[ChainId2["BNB"] = 56] = "BNB";
  ChainId2[ChainId2["AVALANCHE"] = 43114] = "AVALANCHE";
  ChainId2[ChainId2["BASE_GOERLI"] = 84531] = "BASE_GOERLI";
  ChainId2[ChainId2["BASE"] = 8453] = "BASE";
})(ChainId$3 || (ChainId$3 = {}));
[ChainId$3.MAINNET, ChainId$3.OPTIMISM, ChainId$3.OPTIMISM_GOERLI, ChainId$3.OPTIMISM_SEPOLIA, ChainId$3.ARBITRUM_ONE, ChainId$3.ARBITRUM_GOERLI, ChainId$3.POLYGON, ChainId$3.POLYGON_MUMBAI, ChainId$3.GOERLI, ChainId$3.SEPOLIA, ChainId$3.CELO_ALFAJORES, ChainId$3.CELO, ChainId$3.BNB, ChainId$3.AVALANCHE, ChainId$3.BASE, ChainId$3.BASE_GOERLI];
var NativeCurrencyName$3;
(function(NativeCurrencyName2) {
  NativeCurrencyName2["ETHER"] = "ETH";
  NativeCurrencyName2["MATIC"] = "MATIC";
  NativeCurrencyName2["CELO"] = "CELO";
  NativeCurrencyName2["GNOSIS"] = "XDAI";
  NativeCurrencyName2["MOONBEAM"] = "GLMR";
  NativeCurrencyName2["BNB"] = "BNB";
  NativeCurrencyName2["AVAX"] = "AVAX";
})(NativeCurrencyName$3 || (NativeCurrencyName$3 = {}));
var _CHAIN_TO_ADDRESSES_M$2, _GOVERNANCE_ALPHA_V1_$2, _GOVERNANCE_BRAVO_ADD$2, _MERKLE_DISTRIBUTOR_A$2, _ARGENT_WALLET_DETECT$2, _SOCKS_CONTROLLER_ADD$2;
var DEFAULT_NETWORKS$2 = [ChainId$3.MAINNET, ChainId$3.GOERLI, ChainId$3.SEPOLIA];
function constructSameAddressMap$3(address, additionalNetworks) {
  if (additionalNetworks === void 0) {
    additionalNetworks = [];
  }
  return DEFAULT_NETWORKS$2.concat(additionalNetworks).reduce(function(memo, chainId2) {
    memo[chainId2] = address;
    return memo;
  }, {});
}
/* @__PURE__ */ constructSameAddressMap$3("0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984", [ChainId$3.OPTIMISM, ChainId$3.ARBITRUM_ONE, ChainId$3.POLYGON, ChainId$3.POLYGON_MUMBAI, ChainId$3.SEPOLIA]);
var V2_FACTORY_ADDRESS$2 = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f";
/* @__PURE__ */ constructSameAddressMap$3(V2_FACTORY_ADDRESS$2, [ChainId$3.POLYGON, ChainId$3.OPTIMISM, ChainId$3.CELO, ChainId$3.ARBITRUM_ONE, ChainId$3.BNB, ChainId$3.AVALANCHE, ChainId$3.BASE]);
var DEFAULT_ADDRESSES$2 = {
  v3CoreFactoryAddress: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
  multicallAddress: "0x1F98415757620B543A52E61c46B32eB19261F984",
  quoterAddress: "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6",
  v3MigratorAddress: "0xA5644E29708357803b5A882D272c41cC0dF92B34",
  nonfungiblePositionManagerAddress: "0xC36442b4a4522E871399CD717aBDD847Ab11FE88"
};
var MAINNET_ADDRESSES$2 = /* @__PURE__ */ _extends$3({}, DEFAULT_ADDRESSES$2, {
  v1MixedRouteQuoterAddress: "0x84E44095eeBfEC7793Cd7d5b57B7e401D7f1cA2E"
});
var GOERLI_ADDRESSES$2 = /* @__PURE__ */ _extends$3({}, DEFAULT_ADDRESSES$2, {
  v1MixedRouteQuoterAddress: "0xBa60b6e6fF25488308789E6e0A65D838be34194e"
});
var OPTIMISM_ADDRESSES$2 = DEFAULT_ADDRESSES$2;
var ARBITRUM_ONE_ADDRESSES$2 = /* @__PURE__ */ _extends$3({}, DEFAULT_ADDRESSES$2, {
  multicallAddress: "0xadF885960B47eA2CD9B55E6DAc6B42b7Cb2806dB",
  tickLensAddress: "0xbfd8137f7d1516D3ea5cA83523914859ec47F573"
});
var POLYGON_ADDRESSES$2 = DEFAULT_ADDRESSES$2;
var CELO_ADDRESSES$2 = {
  v3CoreFactoryAddress: "0xAfE208a311B21f13EF87E33A90049fC17A7acDEc",
  multicallAddress: "0x633987602DE5C4F337e3DbF265303A1080324204",
  quoterAddress: "0x82825d0554fA07f7FC52Ab63c961F330fdEFa8E8",
  v3MigratorAddress: "0x3cFd4d48EDfDCC53D3f173F596f621064614C582",
  nonfungiblePositionManagerAddress: "0x3d79EdAaBC0EaB6F08ED885C05Fc0B014290D95A",
  tickLensAddress: "0x5f115D9113F88e0a0Db1b5033D90D4a9690AcD3D"
};
var BNB_ADDRESSES$2 = {
  v3CoreFactoryAddress: "0xdB1d10011AD0Ff90774D0C6Bb92e5C5c8b4461F7",
  multicallAddress: "0x963Df249eD09c358A4819E39d9Cd5736c3087184",
  quoterAddress: "0x78D78E420Da98ad378D7799bE8f4AF69033EB077",
  v3MigratorAddress: "0x32681814957e0C13117ddc0c2aba232b5c9e760f",
  nonfungiblePositionManagerAddress: "0x7b8A01B39D58278b5DE7e48c8449c9f4F5170613",
  tickLensAddress: "0xD9270014D396281579760619CCf4c3af0501A47C",
  swapRouter02Address: "0xB971eF87ede563556b2ED4b1C0b0019111Dd85d2"
};
var OPTIMISM_GOERLI_ADDRESSES$2 = {
  v3CoreFactoryAddress: "0xB656dA17129e7EB733A557f4EBc57B76CFbB5d10",
  multicallAddress: "0x07F2D8a2a02251B62af965f22fC4744A5f96BCCd",
  quoterAddress: "0x9569CbA925c8ca2248772A9A4976A516743A246F",
  v3MigratorAddress: "0xf6c55fBe84B1C8c3283533c53F51bC32F5C7Aba8",
  nonfungiblePositionManagerAddress: "0x39Ca85Af2F383190cBf7d7c41ED9202D27426EF6",
  tickLensAddress: "0xe6140Bd164b63E8BfCfc40D5dF952f83e171758e"
};
var OPTIMISM_SEPOLIA_ADDRESSES$2 = {
  v3CoreFactoryAddress: "0x8CE191193D15ea94e11d327b4c7ad8bbE520f6aF",
  multicallAddress: "0x80e4e06841bb76AA9735E0448cB8d003C0EF009a",
  quoterAddress: "0x0FBEa6cf957d95ee9313490050F6A0DA68039404",
  v3MigratorAddress: "0xE7EcbAAaA54D007A00dbb6c1d2f150066D69dA07",
  nonfungiblePositionManagerAddress: "0xdA75cEf1C93078e8b736FCA5D5a30adb97C8957d",
  tickLensAddress: "0xCb7f54747F58F8944973cea5b8f4ac2209BadDC5"
};
var ARBITRUM_GOERLI_ADDRESSES$2 = {
  v3CoreFactoryAddress: "0x4893376342d5D7b3e31d4184c08b265e5aB2A3f6",
  multicallAddress: "0x8260CB40247290317a4c062F3542622367F206Ee",
  quoterAddress: "0x1dd92b83591781D0C6d98d07391eea4b9a6008FA",
  v3MigratorAddress: "0xA815919D2584Ac3F76ea9CB62E6Fd40a43BCe0C3",
  nonfungiblePositionManagerAddress: "0x622e4726a167799826d1E1D150b076A7725f5D81",
  tickLensAddress: "0xb52429333da969a0C79a60930a4Bf0020E5D1DE8"
};
var SEPOLIA_ADDRESSES$2 = {
  v3CoreFactoryAddress: "0x0227628f3F023bb0B980b67D528571c95c6DaC1c",
  multicallAddress: "0xD7F33bCdb21b359c8ee6F0251d30E94832baAd07",
  quoterAddress: "0xEd1f6473345F45b75F8179591dd5bA1888cf2FB3",
  v3MigratorAddress: "0x729004182cF005CEC8Bd85df140094b6aCbe8b15",
  nonfungiblePositionManagerAddress: "0x1238536071E1c677A632429e3655c799b22cDA52",
  tickLensAddress: "0xd7f33bcdb21b359c8ee6f0251d30e94832baad07"
};
var AVALANCHE_ADDRESSES$2 = {
  v3CoreFactoryAddress: "0x740b1c1de25031C31FF4fC9A62f554A55cdC1baD",
  multicallAddress: "0x0139141Cd4Ee88dF3Cdb65881D411bAE271Ef0C2",
  quoterAddress: "0xbe0F5544EC67e9B3b2D979aaA43f18Fd87E6257F",
  v3MigratorAddress: "0x44f5f1f5E452ea8d29C890E8F6e893fC0f1f0f97",
  nonfungiblePositionManagerAddress: "0x655C406EBFa14EE2006250925e54ec43AD184f8B",
  tickLensAddress: "0xEB9fFC8bf81b4fFd11fb6A63a6B0f098c6e21950",
  swapRouter02Address: "0xbb00FF08d01D300023C629E8fFfFcb65A5a578cE"
};
var BASE_ADDRESSES$2 = {
  v3CoreFactoryAddress: "0x33128a8fC17869897dcE68Ed026d694621f6FDfD",
  multicallAddress: "0x091e99cb1C49331a94dD62755D168E941AbD0693",
  quoterAddress: "0x3d4e44Eb1374240CE5F1B871ab261CD16335B76a",
  v3MigratorAddress: "0x23cF10b1ee3AdfCA73B0eF17C07F7577e7ACd2d7",
  nonfungiblePositionManagerAddress: "0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1",
  tickLensAddress: "0x0CdeE061c75D43c82520eD998C23ac2991c9ac6d",
  swapRouter02Address: "0x2626664c2603336E57B271c5C0b26F421741e481"
};
var BASE_GOERLI_ADDRESSES$2 = {
  v3CoreFactoryAddress: "0x9323c1d6D800ed51Bd7C6B216cfBec678B7d0BC2",
  multicallAddress: "0xB206027a9E0E13F05eBEFa5D2402Bab3eA716439",
  quoterAddress: "0xedf539058e28E5937dAef3f69cEd0b25fbE66Ae9",
  v3MigratorAddress: "0x3efe5d02a04b7351D671Db7008ec6eBA9AD9e3aE",
  nonfungiblePositionManagerAddress: "0x3c61369ef0D1D2AFa70d8feC2F31C5D6Ce134F30",
  tickLensAddress: "0x1acB873Ee909D0c98adB18e4474943249F931b92",
  swapRouter02Address: "0x8357227D4eDc78991Db6FDB9bD6ADE250536dE1d"
};
_CHAIN_TO_ADDRESSES_M$2 = {}, _CHAIN_TO_ADDRESSES_M$2[ChainId$3.MAINNET] = MAINNET_ADDRESSES$2, _CHAIN_TO_ADDRESSES_M$2[ChainId$3.OPTIMISM] = OPTIMISM_ADDRESSES$2, _CHAIN_TO_ADDRESSES_M$2[ChainId$3.ARBITRUM_ONE] = ARBITRUM_ONE_ADDRESSES$2, _CHAIN_TO_ADDRESSES_M$2[ChainId$3.POLYGON] = POLYGON_ADDRESSES$2, _CHAIN_TO_ADDRESSES_M$2[ChainId$3.POLYGON_MUMBAI] = POLYGON_ADDRESSES$2, _CHAIN_TO_ADDRESSES_M$2[ChainId$3.GOERLI] = GOERLI_ADDRESSES$2, _CHAIN_TO_ADDRESSES_M$2[ChainId$3.CELO] = CELO_ADDRESSES$2, _CHAIN_TO_ADDRESSES_M$2[ChainId$3.CELO_ALFAJORES] = CELO_ADDRESSES$2, _CHAIN_TO_ADDRESSES_M$2[ChainId$3.BNB] = BNB_ADDRESSES$2, _CHAIN_TO_ADDRESSES_M$2[ChainId$3.OPTIMISM_GOERLI] = OPTIMISM_GOERLI_ADDRESSES$2, _CHAIN_TO_ADDRESSES_M$2[ChainId$3.OPTIMISM_SEPOLIA] = OPTIMISM_SEPOLIA_ADDRESSES$2, _CHAIN_TO_ADDRESSES_M$2[ChainId$3.ARBITRUM_GOERLI] = ARBITRUM_GOERLI_ADDRESSES$2, _CHAIN_TO_ADDRESSES_M$2[ChainId$3.SEPOLIA] = SEPOLIA_ADDRESSES$2, _CHAIN_TO_ADDRESSES_M$2[ChainId$3.AVALANCHE] = AVALANCHE_ADDRESSES$2, _CHAIN_TO_ADDRESSES_M$2[ChainId$3.BASE] = BASE_ADDRESSES$2, _CHAIN_TO_ADDRESSES_M$2[ChainId$3.BASE_GOERLI] = BASE_GOERLI_ADDRESSES$2, _CHAIN_TO_ADDRESSES_M$2;
_GOVERNANCE_ALPHA_V1_$2 = {}, _GOVERNANCE_ALPHA_V1_$2[ChainId$3.MAINNET] = "0xC4e172459f1E7939D522503B81AFAaC1014CE6F6", _GOVERNANCE_ALPHA_V1_$2;
_GOVERNANCE_BRAVO_ADD$2 = {}, _GOVERNANCE_BRAVO_ADD$2[ChainId$3.MAINNET] = "0x408ED6354d4973f66138C91495F2f2FCbd8724C3", _GOVERNANCE_BRAVO_ADD$2;
_MERKLE_DISTRIBUTOR_A$2 = {}, _MERKLE_DISTRIBUTOR_A$2[ChainId$3.MAINNET] = "0x090D4613473dEE047c3f2706764f49E0821D256e", _MERKLE_DISTRIBUTOR_A$2;
_ARGENT_WALLET_DETECT$2 = {}, _ARGENT_WALLET_DETECT$2[ChainId$3.MAINNET] = "0xeca4B0bDBf7c55E9b7925919d03CbF8Dc82537E8", _ARGENT_WALLET_DETECT$2;
_SOCKS_CONTROLLER_ADD$2 = {}, _SOCKS_CONTROLLER_ADD$2[ChainId$3.MAINNET] = "0x65770b5283117639760beA3F867b69b3697a91dd", _SOCKS_CONTROLLER_ADD$2;
var TradeType$2;
(function(TradeType2) {
  TradeType2[TradeType2["EXACT_INPUT"] = 0] = "EXACT_INPUT";
  TradeType2[TradeType2["EXACT_OUTPUT"] = 1] = "EXACT_OUTPUT";
})(TradeType$2 || (TradeType$2 = {}));
var Rounding$2;
(function(Rounding2) {
  Rounding2[Rounding2["ROUND_DOWN"] = 0] = "ROUND_DOWN";
  Rounding2[Rounding2["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
  Rounding2[Rounding2["ROUND_UP"] = 2] = "ROUND_UP";
})(Rounding$2 || (Rounding$2 = {}));
var MaxUint256$4 = /* @__PURE__ */ JSBI.BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var _toSignificantRoundin$2, _toFixedRounding$2;
var Decimal$2 = /* @__PURE__ */ toFormat(_Decimal);
var Big$3 = /* @__PURE__ */ toFormat(Big$5);
var toSignificantRounding$2 = (_toSignificantRoundin$2 = {}, _toSignificantRoundin$2[Rounding$2.ROUND_DOWN] = Decimal$2.ROUND_DOWN, _toSignificantRoundin$2[Rounding$2.ROUND_HALF_UP] = Decimal$2.ROUND_HALF_UP, _toSignificantRoundin$2[Rounding$2.ROUND_UP] = Decimal$2.ROUND_UP, _toSignificantRoundin$2);
var toFixedRounding$2 = (_toFixedRounding$2 = {}, _toFixedRounding$2[Rounding$2.ROUND_DOWN] = 0, _toFixedRounding$2[Rounding$2.ROUND_HALF_UP] = 1, _toFixedRounding$2[Rounding$2.ROUND_UP] = 3, _toFixedRounding$2);
var Fraction$2 = /* @__PURE__ */ function() {
  function Fraction2(numerator, denominator) {
    if (denominator === void 0) {
      denominator = JSBI.BigInt(1);
    }
    this.numerator = JSBI.BigInt(numerator);
    this.denominator = JSBI.BigInt(denominator);
  }
  Fraction2.tryParseFraction = function tryParseFraction(fractionish) {
    if (fractionish instanceof JSBI || typeof fractionish === "number" || typeof fractionish === "string")
      return new Fraction2(fractionish);
    if ("numerator" in fractionish && "denominator" in fractionish)
      return fractionish;
    throw new Error("Could not parse fraction");
  };
  var _proto = Fraction2.prototype;
  _proto.invert = function invert() {
    return new Fraction2(this.denominator, this.numerator);
  };
  _proto.add = function add4(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    if (JSBI.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction2(JSBI.add(this.numerator, otherParsed.numerator), this.denominator);
    }
    return new Fraction2(JSBI.add(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.subtract = function subtract2(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    if (JSBI.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction2(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator);
    }
    return new Fraction2(JSBI.subtract(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.lessThan = function lessThan(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return JSBI.lessThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.equalTo = function equalTo(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return JSBI.equal(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.greaterThan = function greaterThan(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return JSBI.greaterThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.multiply = function multiply(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return new Fraction2(JSBI.multiply(this.numerator, otherParsed.numerator), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.divide = function divide2(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return new Fraction2(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(this.denominator, otherParsed.numerator));
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    if (rounding === void 0) {
      rounding = Rounding$2.ROUND_HALF_UP;
    }
    !Number.isInteger(significantDigits) ? invariant$1(false) : void 0;
    !(significantDigits > 0) ? invariant$1(false) : void 0;
    Decimal$2.set({
      precision: significantDigits + 1,
      rounding: toSignificantRounding$2[rounding]
    });
    var quotient = new Decimal$2(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
    return quotient.toFormat(quotient.decimalPlaces(), format);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    if (rounding === void 0) {
      rounding = Rounding$2.ROUND_HALF_UP;
    }
    !Number.isInteger(decimalPlaces) ? invariant$1(false) : void 0;
    !(decimalPlaces >= 0) ? invariant$1(false) : void 0;
    Big$3.DP = decimalPlaces;
    Big$3.RM = toFixedRounding$2[rounding];
    return new Big$3(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
  };
  _createClass$5(Fraction2, [{
    key: "quotient",
    get: function get2() {
      return JSBI.divide(this.numerator, this.denominator);
    }
    // remainder after floor division
  }, {
    key: "remainder",
    get: function get2() {
      return new Fraction2(JSBI.remainder(this.numerator, this.denominator), this.denominator);
    }
  }, {
    key: "asFraction",
    get: function get2() {
      return new Fraction2(this.numerator, this.denominator);
    }
  }]);
  return Fraction2;
}();
var Big$1$2 = /* @__PURE__ */ toFormat(Big$5);
var CurrencyAmount$3 = /* @__PURE__ */ function(_Fraction) {
  _inheritsLoose$4(CurrencyAmount22, _Fraction);
  function CurrencyAmount22(currency, numerator, denominator) {
    var _this;
    _this = _Fraction.call(this, numerator, denominator) || this;
    !JSBI.lessThanOrEqual(_this.quotient, MaxUint256$4) ? invariant$1(false) : void 0;
    _this.currency = currency;
    _this.decimalScale = JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(currency.decimals));
    return _this;
  }
  CurrencyAmount22.fromRawAmount = function fromRawAmount(currency, rawAmount) {
    return new CurrencyAmount22(currency, rawAmount);
  };
  CurrencyAmount22.fromFractionalAmount = function fromFractionalAmount(currency, numerator, denominator) {
    return new CurrencyAmount22(currency, numerator, denominator);
  };
  var _proto = CurrencyAmount22.prototype;
  _proto.add = function add4(other) {
    !this.currency.equals(other.currency) ? invariant$1(false) : void 0;
    var added = _Fraction.prototype.add.call(this, other);
    return CurrencyAmount22.fromFractionalAmount(this.currency, added.numerator, added.denominator);
  };
  _proto.subtract = function subtract2(other) {
    !this.currency.equals(other.currency) ? invariant$1(false) : void 0;
    var subtracted = _Fraction.prototype.subtract.call(this, other);
    return CurrencyAmount22.fromFractionalAmount(this.currency, subtracted.numerator, subtracted.denominator);
  };
  _proto.multiply = function multiply(other) {
    var multiplied = _Fraction.prototype.multiply.call(this, other);
    return CurrencyAmount22.fromFractionalAmount(this.currency, multiplied.numerator, multiplied.denominator);
  };
  _proto.divide = function divide2(other) {
    var divided = _Fraction.prototype.divide.call(this, other);
    return CurrencyAmount22.fromFractionalAmount(this.currency, divided.numerator, divided.denominator);
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 6;
    }
    if (rounding === void 0) {
      rounding = Rounding$2.ROUND_DOWN;
    }
    return _Fraction.prototype.divide.call(this, this.decimalScale).toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = this.currency.decimals;
    }
    if (rounding === void 0) {
      rounding = Rounding$2.ROUND_DOWN;
    }
    !(decimalPlaces <= this.currency.decimals) ? invariant$1(false) : void 0;
    return _Fraction.prototype.divide.call(this, this.decimalScale).toFixed(decimalPlaces, format, rounding);
  };
  _proto.toExact = function toExact(format) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    Big$1$2.DP = this.currency.decimals;
    return new Big$1$2(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(format);
  };
  _createClass$5(CurrencyAmount22, [{
    key: "wrapped",
    get: function get2() {
      if (this.currency.isToken)
        return this;
      return CurrencyAmount22.fromFractionalAmount(this.currency.wrapped, this.numerator, this.denominator);
    }
  }]);
  return CurrencyAmount22;
}(Fraction$2);
var ONE_HUNDRED$2 = /* @__PURE__ */ new Fraction$2(/* @__PURE__ */ JSBI.BigInt(100));
function toPercent$2(fraction) {
  return new Percent$2(fraction.numerator, fraction.denominator);
}
var Percent$2 = /* @__PURE__ */ function(_Fraction) {
  _inheritsLoose$4(Percent2, _Fraction);
  function Percent2() {
    var _this;
    _this = _Fraction.apply(this, arguments) || this;
    _this.isPercent = true;
    return _this;
  }
  var _proto = Percent2.prototype;
  _proto.add = function add4(other) {
    return toPercent$2(_Fraction.prototype.add.call(this, other));
  };
  _proto.subtract = function subtract2(other) {
    return toPercent$2(_Fraction.prototype.subtract.call(this, other));
  };
  _proto.multiply = function multiply(other) {
    return toPercent$2(_Fraction.prototype.multiply.call(this, other));
  };
  _proto.divide = function divide2(other) {
    return toPercent$2(_Fraction.prototype.divide.call(this, other));
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 5;
    }
    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED$2).toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = 2;
    }
    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED$2).toFixed(decimalPlaces, format, rounding);
  };
  return Percent2;
}(Fraction$2);
var Price$2 = /* @__PURE__ */ function(_Fraction) {
  _inheritsLoose$4(Price2, _Fraction);
  function Price2() {
    var _this;
    var baseCurrency, quoteCurrency, denominator, numerator;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 4) {
      baseCurrency = args[0];
      quoteCurrency = args[1];
      denominator = args[2];
      numerator = args[3];
    } else {
      var result = args[0].quoteAmount.divide(args[0].baseAmount);
      var _ref = [args[0].baseAmount.currency, args[0].quoteAmount.currency, result.denominator, result.numerator];
      baseCurrency = _ref[0];
      quoteCurrency = _ref[1];
      denominator = _ref[2];
      numerator = _ref[3];
    }
    _this = _Fraction.call(this, numerator, denominator) || this;
    _this.baseCurrency = baseCurrency;
    _this.quoteCurrency = quoteCurrency;
    _this.scalar = new Fraction$2(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(baseCurrency.decimals)), JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(quoteCurrency.decimals)));
    return _this;
  }
  var _proto = Price2.prototype;
  _proto.invert = function invert() {
    return new Price2(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);
  };
  _proto.multiply = function multiply(other) {
    !this.quoteCurrency.equals(other.baseCurrency) ? invariant$1(false) : void 0;
    var fraction = _Fraction.prototype.multiply.call(this, other);
    return new Price2(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);
  };
  _proto.quote = function quote(currencyAmount) {
    !currencyAmount.currency.equals(this.baseCurrency) ? invariant$1(false) : void 0;
    var result = _Fraction.prototype.multiply.call(this, currencyAmount);
    return CurrencyAmount$3.fromFractionalAmount(this.quoteCurrency, result.numerator, result.denominator);
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 6;
    }
    return this.adjustedForDecimals.toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = 4;
    }
    return this.adjustedForDecimals.toFixed(decimalPlaces, format, rounding);
  };
  _createClass$5(Price2, [{
    key: "adjustedForDecimals",
    get: function get2() {
      return _Fraction.prototype.multiply.call(this, this.scalar);
    }
  }]);
  return Price2;
}(Fraction$2);
var BaseCurrency$2 = (
  /**
   * Constructs an instance of the base class `BaseCurrency`.
   * @param chainId the chain ID on which this currency resides
   * @param decimals decimals of the currency
   * @param symbol symbol of the currency
   * @param name of the currency
   */
  function BaseCurrency22(chainId2, decimals, symbol, name2) {
    !Number.isSafeInteger(chainId2) ? invariant$1(false) : void 0;
    !(decimals >= 0 && decimals < 255 && Number.isInteger(decimals)) ? invariant$1(false) : void 0;
    this.chainId = chainId2;
    this.decimals = decimals;
    this.symbol = symbol;
    this.name = name2;
  }
);
function validateAndParseAddress$2(address) {
  try {
    return getAddress$1(address);
  } catch (error) {
    throw new Error(address + " is not a valid address.");
  }
}
var startsWith0xLen42HexRegex$2 = /^0x[0-9a-fA-F]{40}$/;
function checkValidAddress$2(address) {
  if (startsWith0xLen42HexRegex$2.test(address)) {
    return address;
  }
  throw new Error(address + " is not a valid address.");
}
var Token$3 = /* @__PURE__ */ function(_BaseCurrency) {
  _inheritsLoose$4(Token2, _BaseCurrency);
  function Token2(chainId2, address, decimals, symbol, name2, bypassChecksum, buyFeeBps, sellFeeBps) {
    var _this;
    _this = _BaseCurrency.call(this, chainId2, decimals, symbol, name2) || this;
    _this.isNative = false;
    _this.isToken = true;
    if (bypassChecksum) {
      _this.address = checkValidAddress$2(address);
    } else {
      _this.address = validateAndParseAddress$2(address);
    }
    if (buyFeeBps) {
      !buyFeeBps.gte(BigNumber.from(0)) ? invariant$1(false) : void 0;
    }
    if (sellFeeBps) {
      !sellFeeBps.gte(BigNumber.from(0)) ? invariant$1(false) : void 0;
    }
    _this.buyFeeBps = buyFeeBps;
    _this.sellFeeBps = sellFeeBps;
    return _this;
  }
  var _proto = Token2.prototype;
  _proto.equals = function equals(other) {
    return other.isToken && this.chainId === other.chainId && this.address.toLowerCase() === other.address.toLowerCase();
  };
  _proto.sortsBefore = function sortsBefore(other) {
    !(this.chainId === other.chainId) ? invariant$1(false) : void 0;
    !(this.address.toLowerCase() !== other.address.toLowerCase()) ? invariant$1(false) : void 0;
    return this.address.toLowerCase() < other.address.toLowerCase();
  };
  _createClass$5(Token2, [{
    key: "wrapped",
    get: function get2() {
      return this;
    }
  }]);
  return Token2;
}(BaseCurrency$2);
var _WETH$2;
_WETH$2 = {}, _WETH$2[1] = /* @__PURE__ */ new Token$3(1, "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", 18, "WETH", "Wrapped Ether"), _WETH$2[3] = /* @__PURE__ */ new Token$3(3, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"), _WETH$2[4] = /* @__PURE__ */ new Token$3(4, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"), _WETH$2[5] = /* @__PURE__ */ new Token$3(5, "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6", 18, "WETH", "Wrapped Ether"), _WETH$2[42] = /* @__PURE__ */ new Token$3(42, "0xd0A1E359811322d97991E03f863a0C30C2cF029C", 18, "WETH", "Wrapped Ether"), _WETH$2[10] = /* @__PURE__ */ new Token$3(10, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH$2[69] = /* @__PURE__ */ new Token$3(69, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH$2[11155420] = /* @__PURE__ */ new Token$3(11155420, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH$2[42161] = /* @__PURE__ */ new Token$3(42161, "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1", 18, "WETH", "Wrapped Ether"), _WETH$2[421611] = /* @__PURE__ */ new Token$3(421611, "0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681", 18, "WETH", "Wrapped Ether"), _WETH$2[8453] = /* @__PURE__ */ new Token$3(8453, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH$2[56] = /* @__PURE__ */ new Token$3(56, "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", 18, "WBNB", "Wrapped BNB"), _WETH$2[137] = /* @__PURE__ */ new Token$3(137, "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270", 18, "WMATIC", "Wrapped MATIC"), _WETH$2[43114] = /* @__PURE__ */ new Token$3(43114, "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7", 18, "WAVAX", "Wrapped AVAX"), _WETH$2;
function sortedInsert$1(items, add4, maxSize, comparator) {
  !(maxSize > 0) ? invariant$1(false) : void 0;
  !(items.length <= maxSize) ? invariant$1(false) : void 0;
  if (items.length === 0) {
    items.push(add4);
    return null;
  } else {
    var isFull = items.length === maxSize;
    if (isFull && comparator(items[items.length - 1], add4) <= 0) {
      return add4;
    }
    var lo = 0, hi2 = items.length;
    while (lo < hi2) {
      var mid = lo + hi2 >>> 1;
      if (comparator(items[mid], add4) <= 0) {
        lo = mid + 1;
      } else {
        hi2 = mid;
      }
    }
    items.splice(lo, 0, add4);
    return isFull ? items.pop() : null;
  }
}
var MAX_SAFE_INTEGER$2 = /* @__PURE__ */ JSBI.BigInt(Number.MAX_SAFE_INTEGER);
var ZERO$5 = /* @__PURE__ */ JSBI.BigInt(0);
var ONE$5 = /* @__PURE__ */ JSBI.BigInt(1);
var TWO$3 = /* @__PURE__ */ JSBI.BigInt(2);
function sqrt$2(value) {
  !JSBI.greaterThanOrEqual(value, ZERO$5) ? invariant$1(false) : void 0;
  if (JSBI.lessThan(value, MAX_SAFE_INTEGER$2)) {
    return JSBI.BigInt(Math.floor(Math.sqrt(JSBI.toNumber(value))));
  }
  var z2;
  var x2;
  z2 = value;
  x2 = JSBI.add(JSBI.divide(value, TWO$3), ONE$5);
  while (JSBI.lessThan(x2, z2)) {
    z2 = x2;
    x2 = JSBI.divide(JSBI.add(JSBI.divide(value, x2), x2), TWO$3);
  }
  return z2;
}
const version$g = "properties/5.7.0";
var __awaiter$9 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$l = new Logger(version$g);
function defineReadOnly(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic(ctor, key2) {
  for (let i3 = 0; i3 < 32; i3++) {
    if (ctor[key2]) {
      return ctor[key2];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties(object) {
  return __awaiter$9(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key2) => {
      const value = object[key2];
      return Promise.resolve(value).then((v2) => ({ key: key2, value: v2 }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object, properties2) {
  if (!object || typeof object !== "object") {
    logger$l.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key2) => {
    if (!properties2[key2]) {
      logger$l.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object);
    }
  });
}
function shallowCopy(object) {
  const result = {};
  for (const key2 in object) {
    result[key2] = object[key2];
  }
  return result;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
  if (object === void 0 || object === null || opaque[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i3 = 0; i3 < keys.length; i3++) {
      let value = null;
      try {
        value = object[keys[i3]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger$l.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key2 in object) {
      const value = object[key2];
      if (value === void 0) {
        continue;
      }
      defineReadOnly(result, key2, deepCopy(value));
    }
    return result;
  }
  return logger$l.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy(object) {
  return _deepCopy(object);
}
class Description {
  constructor(info) {
    for (const key2 in info) {
      this[key2] = deepCopy(info[key2]);
    }
  }
}
const version$f = "abi/5.7.0";
const logger$k = new Logger(version$f);
const _constructorGuard$1 = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name2) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name2]) {
      return true;
    }
  } else if (type === "address") {
    if (name2 === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name2]) {
      return true;
    }
  }
  if (ModifiersBytes[name2] || name2 === "payable") {
    logger$k.throwArgumentError("invalid modifier", "name", name2);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError(i3) {
    logger$k.throwArgumentError(`unexpected character at position ${i3}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent3) {
    let node3 = { type: "", name: "", parent: parent3, state: { allowType: true } };
    if (allowIndexed) {
      node3.indexed = false;
    }
    return node3;
  }
  let parent2 = { type: "", name: "", state: { allowType: true } };
  let node2 = parent2;
  for (let i3 = 0; i3 < param.length; i3++) {
    let c2 = param[i3];
    switch (c2) {
      case "(":
        if (node2.state.allowType && node2.type === "") {
          node2.type = "tuple";
        } else if (!node2.state.allowParams) {
          throwError(i3);
        }
        node2.state.allowType = false;
        node2.type = verifyType(node2.type);
        node2.components = [newNode(node2)];
        node2 = node2.components[0];
        break;
      case ")":
        delete node2.state;
        if (node2.name === "indexed") {
          if (!allowIndexed) {
            throwError(i3);
          }
          node2.indexed = true;
          node2.name = "";
        }
        if (checkModifier(node2.type, node2.name)) {
          node2.name = "";
        }
        node2.type = verifyType(node2.type);
        let child = node2;
        node2 = node2.parent;
        if (!node2) {
          throwError(i3);
        }
        delete child.parent;
        node2.state.allowParams = false;
        node2.state.allowName = true;
        node2.state.allowArray = true;
        break;
      case ",":
        delete node2.state;
        if (node2.name === "indexed") {
          if (!allowIndexed) {
            throwError(i3);
          }
          node2.indexed = true;
          node2.name = "";
        }
        if (checkModifier(node2.type, node2.name)) {
          node2.name = "";
        }
        node2.type = verifyType(node2.type);
        let sibling = newNode(node2.parent);
        node2.parent.components.push(sibling);
        delete node2.parent;
        node2 = sibling;
        break;
      case " ":
        if (node2.state.allowType) {
          if (node2.type !== "") {
            node2.type = verifyType(node2.type);
            delete node2.state.allowType;
            node2.state.allowName = true;
            node2.state.allowParams = true;
          }
        }
        if (node2.state.allowName) {
          if (node2.name !== "") {
            if (node2.name === "indexed") {
              if (!allowIndexed) {
                throwError(i3);
              }
              if (node2.indexed) {
                throwError(i3);
              }
              node2.indexed = true;
              node2.name = "";
            } else if (checkModifier(node2.type, node2.name)) {
              node2.name = "";
            } else {
              node2.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node2.state.allowArray) {
          throwError(i3);
        }
        node2.type += c2;
        node2.state.allowArray = false;
        node2.state.allowName = false;
        node2.state.readArray = true;
        break;
      case "]":
        if (!node2.state.readArray) {
          throwError(i3);
        }
        node2.type += c2;
        node2.state.readArray = false;
        node2.state.allowArray = true;
        node2.state.allowName = true;
        break;
      default:
        if (node2.state.allowType) {
          node2.type += c2;
          node2.state.allowParams = true;
          node2.state.allowArray = true;
        } else if (node2.state.allowName) {
          node2.name += c2;
          delete node2.state.allowArray;
        } else if (node2.state.readArray) {
          node2.type += c2;
        } else {
          throwError(i3);
        }
    }
  }
  if (node2.parent) {
    logger$k.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent2.state;
  if (node2.name === "indexed") {
    if (!allowIndexed) {
      throwError(originalParam.length - 7);
    }
    if (node2.indexed) {
      throwError(originalParam.length - 7);
    }
    node2.indexed = true;
    node2.name = "";
  } else if (checkModifier(node2.type, node2.name)) {
    node2.name = "";
  }
  parent2.type = verifyType(parent2.type);
  return parent2;
}
function populate(object, params) {
  for (let key2 in params) {
    defineReadOnly(object, key2, params[key2]);
  }
}
const FormatTypes = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$1) {
      logger$k.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match2 = this.type.match(paramTypeArray);
    if (match2) {
      populate(this, {
        arrayLength: parseInt(match2[2] || "-1"),
        arrayChildren: ParamType.fromObject({
          type: match2[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$k.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      let result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.components) {
        result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return ParamType.fromString(value, allowIndexed);
    }
    return ParamType.fromObject(value);
  }
  static fromObject(value) {
    if (ParamType.isParamType(value)) {
      return value;
    }
    return new ParamType(_constructorGuard$1, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(value, allowIndexed) {
    function ParamTypify(node2) {
      return ParamType.fromObject({
        name: node2.name,
        type: node2.type,
        indexed: node2.indexed,
        components: node2.components
      });
    }
    return ParamTypify(parseParamType(value, !!allowIndexed));
  }
  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }
}
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$1) {
      logger$k.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }
    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }
  static from(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    if (typeof value === "string") {
      return Fragment.fromString(value);
    }
    return Fragment.fromObject(value);
  }
  static fromObject(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    switch (value.type) {
      case "function":
        return FunctionFragment.fromObject(value);
      case "event":
        return EventFragment.fromObject(value);
      case "constructor":
        return ConstructorFragment.fromObject(value);
      case "error":
        return ErrorFragment.fromObject(value);
      case "fallback":
      case "receive":
        return null;
    }
    return logger$k.throwArgumentError("invalid fragment object", "value", value);
  }
  static fromString(value) {
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();
    if (value.split(" ")[0] === "event") {
      return EventFragment.fromString(value.substring(5).trim());
    } else if (value.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value.substring(8).trim());
    } else if (value.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value.trim());
    } else if (value.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value.substring(5).trim());
    }
    return logger$k.throwArgumentError("unsupported fragment", "value", value);
  }
  static isFragment(value) {
    return !!(value && value._isFragment);
  }
}
class EventFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$k.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "event ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return EventFragment.fromString(value);
    }
    return EventFragment.fromObject(value);
  }
  static fromObject(value) {
    if (EventFragment.isEventFragment(value)) {
      return value;
    }
    if (value.type !== "event") {
      logger$k.throwArgumentError("invalid event object", "value", value);
    }
    const params = {
      name: verifyIdentifier(value.name),
      anonymous: value.anonymous,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard$1, params);
  }
  static fromString(value) {
    let match2 = value.match(regexParen);
    if (!match2) {
      logger$k.throwArgumentError("invalid event string", "value", value);
    }
    let anonymous = false;
    match2[3].split(" ").forEach((modifier) => {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;
        case "":
          break;
        default:
          logger$k.warn("unknown modifier: " + modifier);
      }
    });
    return EventFragment.fromObject({
      name: match2[1].trim(),
      anonymous,
      inputs: parseParams(match2[2], true),
      type: "event"
    });
  }
  static isEventFragment(value) {
    return value && value._isFragment && value.type === "event";
  }
}
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger$k.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger$k.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger$k.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger$k.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger$k.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger$k.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger$k.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
class ConstructorFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$k.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    if (format === FormatTypes.sighash) {
      logger$k.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }
    let result = "constructor(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ConstructorFragment.fromString(value);
    }
    return ConstructorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ConstructorFragment.isConstructorFragment(value)) {
      return value;
    }
    if (value.type !== "constructor") {
      logger$k.throwArgumentError("invalid constructor object", "value", value);
    }
    let state2 = verifyState(value);
    if (state2.constant) {
      logger$k.throwArgumentError("constructor cannot be constant", "value", value);
    }
    const params = {
      name: null,
      type: value.type,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      payable: state2.payable,
      stateMutability: state2.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new ConstructorFragment(_constructorGuard$1, params);
  }
  static fromString(value) {
    let params = { type: "constructor" };
    value = parseGas(value, params);
    let parens = value.match(regexParen);
    if (!parens || parens[1].trim() !== "constructor") {
      logger$k.throwArgumentError("invalid constructor string", "value", value);
    }
    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return ConstructorFragment.fromObject(params);
  }
  static isConstructorFragment(value) {
    return value && value._isFragment && value.type === "constructor";
  }
}
class FunctionFragment extends ConstructorFragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$k.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
        outputs: this.outputs.map((output2) => JSON.parse(output2.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "function ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }
      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map((output2) => output2.format(format)).join(", ") + ") ";
      }
      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return FunctionFragment.fromString(value);
    }
    return FunctionFragment.fromObject(value);
  }
  static fromObject(value) {
    if (FunctionFragment.isFunctionFragment(value)) {
      return value;
    }
    if (value.type !== "function") {
      logger$k.throwArgumentError("invalid function object", "value", value);
    }
    let state2 = verifyState(value);
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      constant: state2.constant,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
      payable: state2.payable,
      stateMutability: state2.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new FunctionFragment(_constructorGuard$1, params);
  }
  static fromString(value) {
    let params = { type: "function" };
    value = parseGas(value, params);
    let comps = value.split(" returns ");
    if (comps.length > 2) {
      logger$k.throwArgumentError("invalid function string", "value", value);
    }
    let parens = comps[0].match(regexParen);
    if (!parens) {
      logger$k.throwArgumentError("invalid function signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params);
    if (comps.length > 1) {
      let returns = comps[1].match(regexParen);
      if (returns[1].trim() != "" || returns[3].trim() != "") {
        logger$k.throwArgumentError("unexpected tokens", "value", value);
      }
      params.outputs = parseParams(returns[2], false);
    } else {
      params.outputs = [];
    }
    return FunctionFragment.fromObject(params);
  }
  static isFunctionFragment(value) {
    return value && value._isFragment && value.type === "function";
  }
}
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger$k.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
class ErrorFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$k.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "error ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ErrorFragment.fromString(value);
    }
    return ErrorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ErrorFragment.isErrorFragment(value)) {
      return value;
    }
    if (value.type !== "error") {
      logger$k.throwArgumentError("invalid error object", "value", value);
    }
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard$1, params));
  }
  static fromString(value) {
    let params = { type: "error" };
    let parens = value.match(regexParen);
    if (!parens) {
      logger$k.throwArgumentError("invalid error signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    return checkForbidden(ErrorFragment.fromObject(params));
  }
  static isErrorFragment(value) {
    return value && value._isFragment && value.type === "error";
  }
}
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger$k.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value.length; offset++) {
    let c2 = value[offset];
    if (c2 === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c2;
      if (c2 === "(") {
        depth++;
      } else if (c2 === ")") {
        depth--;
        if (depth === -1) {
          logger$k.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}
const logger$j = new Logger(version$f);
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key2 in object) {
      const childPath = path.slice();
      childPath.push(key2);
      try {
        checkErrors(childPath, object[key2]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
class Coder {
  constructor(name2, type, localName, dynamic) {
    this.name = name2;
    this.type = type;
    this.localName = localName;
    this.dynamic = dynamic;
  }
  _throwError(message, value) {
    logger$j.throwArgumentError(message, this.localName, value);
  }
}
class Writer {
  constructor(wordSize) {
    defineReadOnly(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data2) {
    this._data.push(data2);
    this._dataLength += data2.length;
    return data2.length;
  }
  appendWriter(writer) {
    return this._writeData(concat$2(writer._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(value) {
    let bytes2 = arrayify(value);
    const paddingOffset = bytes2.length % this.wordSize;
    if (paddingOffset) {
      bytes2 = concat$2([bytes2, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes2);
  }
  _getValue(value) {
    let bytes2 = arrayify(BigNumber.from(value));
    if (bytes2.length > this.wordSize) {
      logger$j.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes2.length
      });
    }
    if (bytes2.length % this.wordSize) {
      bytes2 = concat$2([this._padding.slice(bytes2.length % this.wordSize), bytes2]);
    }
    return bytes2;
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(value) {
    return this._writeData(this._getValue(value));
  }
  writeUpdatableValue() {
    const offset = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return (value) => {
      this._data[offset] = this._getValue(value);
    };
  }
}
class Reader {
  constructor(data2, wordSize, coerceFunc, allowLoose) {
    defineReadOnly(this, "_data", arrayify(data2));
    defineReadOnly(this, "wordSize", wordSize || 32);
    defineReadOnly(this, "_coerceFunc", coerceFunc);
    defineReadOnly(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(name2, value) {
    let match2 = name2.match("^u?int([0-9]+)$");
    if (match2 && parseInt(match2[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  }
  coerce(name2, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name2, value);
    }
    return Reader.coerce(name2, value);
  }
  _peekBytes(offset, length2, loose) {
    let alignedLength = Math.ceil(length2 / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length2 <= this._data.length) {
        alignedLength = length2;
      } else {
        logger$j.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset) {
    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length2, loose) {
    let bytes2 = this._peekBytes(0, length2, !!loose);
    this._offset += bytes2.length;
    return bytes2.slice(0, length2);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
}
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, value) {
    try {
      value = getAddress$1(value);
    } catch (error) {
      this._throwError(error.message, value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress$1(hexZeroPad(reader.readValue().toHexString(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, void 0, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}
const logger$i = new Logger(version$f);
function pack$1(writer, coders, values2) {
  let arrayValues = null;
  if (Array.isArray(values2)) {
    arrayValues = values2;
  } else if (values2 && typeof values2 === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name2 = coder.localName;
      if (!name2) {
        logger$i.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values2
        });
      }
      if (unique[name2]) {
        logger$i.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values2
        });
      }
      unique[name2] = true;
      return values2[name2];
    });
  } else {
    logger$i.throwArgumentError("invalid tuple value", "tuple", values2);
  }
  if (coders.length !== arrayValues.length) {
    logger$i.throwArgumentError("types/value length mismatch", "tuple", values2);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index2) => {
    let value = arrayValues[index2];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length2 = writer.appendWriter(staticWriter);
  length2 += writer.appendWriter(dynamicWriter);
  return length2;
}
function unpack(reader, coders) {
  let values2 = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values2.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name2 = coder.localName;
    if (name2) {
      if (!accum[name2]) {
        accum[name2] = 0;
      }
      accum[name2]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index2) => {
    let name2 = coder.localName;
    if (!name2 || uniqueNames[name2] !== 1) {
      return;
    }
    if (name2 === "length") {
      name2 = "_length";
    }
    if (values2[name2] != null) {
      return;
    }
    const value = values2[index2];
    if (value instanceof Error) {
      Object.defineProperty(values2, name2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values2[name2] = value;
    }
  });
  for (let i3 = 0; i3 < values2.length; i3++) {
    const value = values2[i3];
    if (value instanceof Error) {
      Object.defineProperty(values2, i3, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values2);
}
class ArrayCoder extends Coder {
  constructor(coder, length2, localName) {
    const type = coder.type + "[" + (length2 >= 0 ? length2 : "") + "]";
    const dynamic = length2 === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    this.coder = coder;
    this.length = length2;
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i3 = 0; i3 < this.length; i3++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    logger$i.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i3 = 0; i3 < value.length; i3++) {
      coders.push(this.coder);
    }
    return pack$1(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readValue().toNumber();
      if (count * 32 > reader._data.length) {
        logger$i.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
          length: reader._data.length,
          count
        });
      }
    }
    let coders = [];
    for (let i3 = 0; i3 < count; i3++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return reader.coerce(this.name, unpack(reader, coders));
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, value) {
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return reader.coerce(this.type, !reader.readValue().isZero());
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = arrayify(value);
    let length2 = writer.writeValue(value.length);
    length2 += writer.writeBytes(value);
    return length2;
  }
  decode(reader) {
    return reader.readBytes(reader.readValue().toNumber(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(super.decode(reader)));
  }
}
class FixedBytesCoder extends Coder {
  constructor(size2, localName) {
    let name2 = "bytes" + String(size2);
    super(name2, name2, localName, false);
    this.size = size2;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, value) {
    let data2 = arrayify(value);
    if (data2.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer.writeBytes(data2);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
  }
}
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes([]);
  }
  decode(reader) {
    reader.readBytes(0);
    return reader.coerce(this.name, null);
  }
}
const AddressZero = "0x0000000000000000000000000000000000000000";
const NegativeOne$1 = /* @__PURE__ */ BigNumber.from(-1);
const Zero$1 = /* @__PURE__ */ BigNumber.from(0);
const One$1 = /* @__PURE__ */ BigNumber.from(1);
const MaxUint256$3 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
class NumberCoder extends Coder {
  constructor(size2, signed2, localName) {
    const name2 = (signed2 ? "int" : "uint") + size2 * 8;
    super(name2, name2, localName, false);
    this.size = size2;
    this.signed = signed2;
  }
  defaultValue() {
    return 0;
  }
  encode(writer, value) {
    let v2 = BigNumber.from(value);
    let maxUintValue = MaxUint256$3.mask(writer.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v2.gt(bounds) || v2.lt(bounds.add(One$1).mul(NegativeOne$1))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v2.lt(Zero$1) || v2.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v2 = v2.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v2 = v2.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }
    return writer.writeValue(v2);
  }
  decode(reader) {
    let value = reader.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader.coerce(this.name, value);
  }
}
const version$e = "strings/5.7.0";
const logger$h = new Logger(version$e);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes2, output2, badCodepoint) {
  return logger$h.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes2);
}
function ignoreFunc(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i3 = 0;
    for (let o2 = offset + 1; o2 < bytes2.length; o2++) {
      if (bytes2[o2] >> 6 !== 2) {
        break;
      }
      i3++;
    }
    return i3;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes2.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output2.push(badCodepoint);
    return 0;
  }
  output2.push(65533);
  return ignoreFunc(reason, offset, bytes2);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes2, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes2 = arrayify(bytes2);
  const result = [];
  let i3 = 0;
  while (i3 < bytes2.length) {
    const c2 = bytes2[i3++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i3 += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i3 - 1, bytes2, result);
      } else {
        i3 += onError(Utf8ErrorReason.BAD_PREFIX, i3 - 1, bytes2, result);
      }
      continue;
    }
    if (i3 - 1 + extraLength >= bytes2.length) {
      i3 += onError(Utf8ErrorReason.OVERRUN, i3 - 1, bytes2, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes2[i3];
      if ((nextChar & 192) != 128) {
        i3 += onError(Utf8ErrorReason.MISSING_CONTINUE, i3, bytes2, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i3++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i3 += onError(Utf8ErrorReason.OUT_OF_RANGE, i3 - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i3 += onError(Utf8ErrorReason.UTF16_SURROGATE, i3 - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i3 += onError(Utf8ErrorReason.OVERLONG, i3 - 1 - extraLength, bytes2, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger$h.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i3 = 0; i3 < str.length; i3++) {
    const c2 = str.charCodeAt(i3);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i3++;
      const c22 = str.charCodeAt(i3);
      if (i3 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes2, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes2, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, value) {
    return super.encode(writer, toUtf8Bytes(value));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}
class TupleCoder extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types2 = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types2.push(coder.type);
    });
    const type = "tuple(" + types2.join(",") + ")";
    super("tuple", type, localName, dynamic);
    this.coders = coders;
  }
  defaultValue() {
    const values2 = [];
    this.coders.forEach((coder) => {
      values2.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name2 = coder.localName;
      if (name2) {
        if (!accum[name2]) {
          accum[name2] = 0;
        }
        accum[name2]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index2) => {
      let name2 = coder.localName;
      if (!name2 || uniqueNames[name2] !== 1) {
        return;
      }
      if (name2 === "length") {
        name2 = "_length";
      }
      if (values2[name2] != null) {
        return;
      }
      values2[name2] = values2[index2];
    });
    return Object.freeze(values2);
  }
  encode(writer, value) {
    return pack$1(writer, this.coders, value);
  }
  decode(reader) {
    return reader.coerce(this.name, unpack(reader, this.coders));
  }
}
const logger$g = new Logger(version$f);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
  constructor(coerceFunc) {
    defineReadOnly(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map((component) => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match2 = param.type.match(paramTypeNumber);
    if (match2) {
      let size2 = parseInt(match2[2] || "256");
      if (size2 === 0 || size2 > 256 || size2 % 8 !== 0) {
        logger$g.throwArgumentError("invalid " + match2[1] + " bit length", "param", param);
      }
      return new NumberCoder(size2 / 8, match2[1] === "int", param.name);
    }
    match2 = param.type.match(paramTypeBytes);
    if (match2) {
      let size2 = parseInt(match2[1]);
      if (size2 === 0 || size2 > 32) {
        logger$g.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size2, param.name);
    }
    return logger$g.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data2, allowLoose) {
    return new Reader(data2, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(types2) {
    const coders = types2.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types2, values2) {
    if (types2.length !== values2.length) {
      logger$g.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
        count: { types: types2.length, values: values2.length },
        value: { types: types2, values: values2 }
      });
    }
    const coders = types2.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = this._getWriter();
    coder.encode(writer, values2);
    return writer.data;
  }
  decode(types2, data2, loose) {
    const coders = types2.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(this._getReader(arrayify(data2), loose));
  }
}
const defaultAbiCoder = new AbiCoder();
function id$1(text) {
  return keccak256$2(toUtf8Bytes(text));
}
const version$d = "hash/5.7.0";
function decode$4(textData) {
  textData = atob(textData);
  const data2 = [];
  for (let i3 = 0; i3 < textData.length; i3++) {
    data2.push(textData.charCodeAt(i3));
  }
  return arrayify(data2);
}
function encode$3(data2) {
  data2 = arrayify(data2);
  let textData = "";
  for (let i3 = 0; i3 < data2.length; i3++) {
    textData += String.fromCharCode(data2[i3]);
  }
  return btoa(textData);
}
function flat(array, depth) {
  if (depth == null) {
    depth = 1;
  }
  const result = [];
  const forEach4 = result.forEach;
  const flatDeep = function(arr, depth2) {
    forEach4.call(arr, function(val) {
      if (depth2 > 0 && Array.isArray(val)) {
        flatDeep(val, depth2 - 1);
      } else {
        result.push(val);
      }
    });
  };
  flatDeep(array, depth);
  return result;
}
function fromEntries(array) {
  const result = {};
  for (let i3 = 0; i3 < array.length; i3++) {
    const value = array[i3];
    result[value[0]] = value[1];
  }
  return result;
}
function decode_arithmetic(bytes2) {
  let pos = 0;
  function u16() {
    return bytes2[pos++] << 8 | bytes2[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i3 = 1; i3 < symbol_count; i3++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes2[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N2 = 31;
  const FULL = Math.pow(2, N2);
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i3 = 0; i3 < N2; i3++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a2 = low + Math.floor(range * acc[start] / total);
    let b3 = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a2 ^ b3) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a2 = a2 << 1 & MASK;
      b3 = b3 << 1 & MASK | 1;
    }
    while (a2 & ~b3 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a2 = a2 << 1 ^ HALF;
      b3 = (b3 ^ HALF) << 1 | HALF | 1;
    }
    low = a2;
    range = 1 + b3 - a2;
  }
  let offset = symbol_count - 4;
  return symbols.map((x2) => {
    switch (x2 - offset) {
      case 3:
        return offset + 65792 + (bytes2[pos_payload++] << 16 | bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 2:
        return offset + 256 + (bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 1:
        return offset + bytes2[pos_payload++];
      default:
        return x2 - 1;
    }
  });
}
function read_payload(v2) {
  let pos = 0;
  return () => v2[pos++];
}
function read_compressed_payload(bytes2) {
  return read_payload(decode_arithmetic(bytes2));
}
function signed(i3) {
  return i3 & 1 ? ~i3 >> 1 : i3 >> 1;
}
function read_counts(n4, next2) {
  let v2 = Array(n4);
  for (let i3 = 0; i3 < n4; i3++)
    v2[i3] = 1 + next2();
  return v2;
}
function read_ascending(n4, next2) {
  let v2 = Array(n4);
  for (let i3 = 0, x2 = -1; i3 < n4; i3++)
    v2[i3] = x2 += 1 + next2();
  return v2;
}
function read_deltas(n4, next2) {
  let v2 = Array(n4);
  for (let i3 = 0, x2 = 0; i3 < n4; i3++)
    v2[i3] = x2 += signed(next2());
  return v2;
}
function read_member_array(next2, lookup2) {
  let v2 = read_ascending(next2(), next2);
  let n4 = next2();
  let vX = read_ascending(n4, next2);
  let vN = read_counts(n4, next2);
  for (let i3 = 0; i3 < n4; i3++) {
    for (let j2 = 0; j2 < vN[i3]; j2++) {
      v2.push(vX[i3] + j2);
    }
  }
  return lookup2 ? v2.map((x2) => lookup2[x2]) : v2;
}
function read_mapped_map(next2) {
  let ret = [];
  while (true) {
    let w2 = next2();
    if (w2 == 0)
      break;
    ret.push(read_linear_table(w2, next2));
  }
  while (true) {
    let w2 = next2() - 1;
    if (w2 < 0)
      break;
    ret.push(read_replacement_table(w2, next2));
  }
  return fromEntries(flat(ret));
}
function read_zero_terminated_array(next2) {
  let v2 = [];
  while (true) {
    let i3 = next2();
    if (i3 == 0)
      break;
    v2.push(i3);
  }
  return v2;
}
function read_transposed(n4, w2, next2) {
  let m2 = Array(n4).fill(void 0).map(() => []);
  for (let i3 = 0; i3 < w2; i3++) {
    read_deltas(n4, next2).forEach((x2, j2) => m2[j2].push(x2));
  }
  return m2;
}
function read_linear_table(w2, next2) {
  let dx = 1 + next2();
  let dy = next2();
  let vN = read_zero_terminated_array(next2);
  let m2 = read_transposed(vN.length, 1 + w2, next2);
  return flat(m2.map((v2, i3) => {
    const x2 = v2[0], ys = v2.slice(1);
    return Array(vN[i3]).fill(void 0).map((_2, j2) => {
      let j_dy = j2 * dy;
      return [x2 + j2 * dx, ys.map((y2) => y2 + j_dy)];
    });
  }));
}
function read_replacement_table(w2, next2) {
  let n4 = 1 + next2();
  let m2 = read_transposed(n4, 1 + w2, next2);
  return m2.map((v2) => [v2[0], v2.slice(1)]);
}
function read_emoji_trie(next2) {
  let sorted = read_member_array(next2).sort((a2, b3) => a2 - b3);
  return read();
  function read() {
    let branches = [];
    while (true) {
      let keys = read_member_array(next2, sorted);
      if (keys.length == 0)
        break;
      branches.push({ set: new Set(keys), node: read() });
    }
    branches.sort((a2, b3) => b3.set.size - a2.set.size);
    let temp = next2();
    let valid = temp % 3;
    temp = temp / 3 | 0;
    let fe0f = !!(temp & 1);
    temp >>= 1;
    let save = temp == 1;
    let check = temp == 2;
    return { branches, valid, fe0f, save, check };
  }
}
function getData() {
  return read_compressed_payload(decode$4("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
const r$f = getData();
const VALID = new Set(read_member_array(r$f));
const IGNORED = new Set(read_member_array(r$f));
const MAPPED = read_mapped_map(r$f);
const EMOJI_ROOT = read_emoji_trie(r$f);
const HYPHEN = 45;
const UNDERSCORE = 95;
function explode_cp(name2) {
  return toUtf8CodePoints(name2);
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != 65039);
}
function ens_normalize_post_check(name2) {
  for (let label of name2.split(".")) {
    let cps = explode_cp(label);
    try {
      for (let i3 = cps.lastIndexOf(UNDERSCORE) - 1; i3 >= 0; i3--) {
        if (cps[i3] !== UNDERSCORE) {
          throw new Error(`underscore only allowed at start`);
        }
      }
      if (cps.length >= 4 && cps.every((cp) => cp < 128) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
        throw new Error(`invalid label extension`);
      }
    } catch (err) {
      throw new Error(`Invalid label "${label}": ${err.message}`);
    }
  }
  return name2;
}
function ens_normalize(name2) {
  return ens_normalize_post_check(normalize(name2, filter_fe0f));
}
function normalize(name2, emoji_filter) {
  let input = explode_cp(name2).reverse();
  let output2 = [];
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      output2.push(...emoji_filter(emoji));
      continue;
    }
    let cp = input.pop();
    if (VALID.has(cp)) {
      output2.push(cp);
      continue;
    }
    if (IGNORED.has(cp)) {
      continue;
    }
    let cps = MAPPED[cp];
    if (cps) {
      output2.push(...cps);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint(...output2)));
}
function nfc(s4) {
  return s4.normalize("NFC");
}
function consume_emoji_reversed(cps, eaten) {
  var _a;
  let node2 = EMOJI_ROOT;
  let emoji;
  let saved;
  let stack = [];
  let pos = cps.length;
  if (eaten)
    eaten.length = 0;
  while (pos) {
    let cp = cps[--pos];
    node2 = (_a = node2.branches.find((x2) => x2.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;
    if (!node2)
      break;
    if (node2.save) {
      saved = cp;
    } else if (node2.check) {
      if (cp === saved)
        break;
    }
    stack.push(cp);
    if (node2.fe0f) {
      stack.push(65039);
      if (pos > 0 && cps[pos - 1] == 65039)
        pos--;
    }
    if (node2.valid) {
      emoji = stack.slice();
      if (node2.valid == 2)
        emoji.splice(1, 1);
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}
const logger$f = new Logger(version$d);
const Zeros$1 = new Uint8Array(32);
Zeros$1.fill(0);
function checkComponent(comp) {
  if (comp.length === 0) {
    throw new Error("invalid ENS name; empty component");
  }
  return comp;
}
function ensNameSplit(name2) {
  const bytes2 = toUtf8Bytes(ens_normalize(name2));
  const comps = [];
  if (name2.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i3 = 0; i3 < bytes2.length; i3++) {
    const d2 = bytes2[i3];
    if (d2 === 46) {
      comps.push(checkComponent(bytes2.slice(last, i3)));
      last = i3 + 1;
    }
  }
  if (last >= bytes2.length) {
    throw new Error("invalid ENS name; empty component");
  }
  comps.push(checkComponent(bytes2.slice(last)));
  return comps;
}
function namehash$1(name2) {
  if (typeof name2 !== "string") {
    logger$f.throwArgumentError("invalid ENS name; not a string", "name", name2);
  }
  let result = Zeros$1;
  const comps = ensNameSplit(name2);
  while (comps.length) {
    result = keccak256$2(concat$2([result, keccak256$2(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name2) {
  return hexlify(concat$2(ensNameSplit(name2).map((comp) => {
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    const bytes2 = new Uint8Array(comp.length + 1);
    bytes2.set(comp, 1);
    bytes2[0] = bytes2.length - 1;
    return bytes2;
  }))) + "00";
}
var __awaiter$8 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$e = new Logger(version$d);
const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1);
const Zero = BigNumber.from(0);
const One = BigNumber.from(1);
const MaxUint256$2 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes2 = arrayify(value);
  const padOffset = bytes2.length % 32;
  if (padOffset) {
    return hexConcat([bytes2, padding.slice(padOffset)]);
  }
  return hexlify(bytes2);
}
const hexTrue = hexZeroPad(One.toHexString(), 32);
const hexFalse = hexZeroPad(Zero.toHexString(), 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key2) {
  return function(value) {
    if (typeof value !== "string") {
      logger$e.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
    }
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value) {
    try {
      return BigNumber.from(value).toString();
    } catch (error) {
    }
    return logger$e.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress$1(value).toLowerCase();
    } catch (error) {
    }
    return logger$e.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes2 = arrayify(value);
      if (bytes2.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify(bytes2);
    } catch (error) {
    }
    return logger$e.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder(type) {
  {
    const match2 = type.match(/^(u?)int(\d*)$/);
    if (match2) {
      const signed2 = match2[1] === "";
      const width2 = parseInt(match2[2] || "256");
      if (width2 % 8 !== 0 || width2 > 256 || match2[2] && match2[2] !== String(width2)) {
        logger$e.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint256$2.mask(signed2 ? width2 - 1 : width2);
      const boundsLower = signed2 ? boundsUpper.add(One).mul(NegativeOne) : Zero;
      return function(value) {
        const v2 = BigNumber.from(value);
        if (v2.lt(boundsLower) || v2.gt(boundsUpper)) {
          logger$e.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }
        return hexZeroPad(v2.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match2 = type.match(/^bytes(\d+)$/);
    if (match2) {
      const width2 = parseInt(match2[1]);
      if (width2 === 0 || width2 > 32 || match2[1] !== String(width2)) {
        logger$e.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value) {
        const bytes2 = arrayify(value);
        if (bytes2.length !== width2) {
          logger$e.throwArgumentError(`invalid length for ${type}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return hexZeroPad(getAddress$1(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256$2(value);
      };
    case "string":
      return function(value) {
        return id$1(value);
      };
  }
  return null;
}
function encodeType$1(name2, fields) {
  return `${name2}(${fields.map(({ name: name3, type }) => type + " " + name3).join(",")})`;
}
class TypedDataEncoder {
  constructor(types2) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(types2)));
    defineReadOnly(this, "_encoderCache", {});
    defineReadOnly(this, "_types", {});
    const links = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types2).forEach((type) => {
      links[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });
    for (const name2 in types2) {
      const uniqueNames = {};
      types2[name2].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger$e.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types2);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name2) {
          logger$e.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types2);
        }
        const encoder2 = getBaseEncoder(baseType);
        if (encoder2) {
          return;
        }
        if (!parents[baseType]) {
          logger$e.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types2);
        }
        parents[baseType].push(name2);
        links[name2][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n4) => parents[n4].length === 0);
    if (primaryTypes.length === 0) {
      logger$e.throwArgumentError("missing primary type", "types", types2);
    } else if (primaryTypes.length > 1) {
      logger$e.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", types2);
    }
    defineReadOnly(this, "primaryType", primaryTypes[0]);
    function checkCircular(type, found) {
      if (found[type]) {
        logger$e.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types2);
      }
      found[type] = true;
      Object.keys(links[type]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }
    checkCircular(this.primaryType, {});
    for (const name2 in subtypes) {
      const st = Object.keys(subtypes[name2]);
      st.sort();
      this._types[name2] = encodeType$1(name2, types2[name2]) + st.map((t2) => encodeType$1(t2, types2[t2])).join("");
    }
  }
  getEncoder(type) {
    let encoder2 = this._encoderCache[type];
    if (!encoder2) {
      encoder2 = this._encoderCache[type] = this._getEncoder(type);
    }
    return encoder2;
  }
  _getEncoder(type) {
    {
      const encoder2 = getBaseEncoder(type);
      if (encoder2) {
        return encoder2;
      }
    }
    const match2 = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match2) {
      const subtype = match2[1];
      const subEncoder = this.getEncoder(subtype);
      const length2 = parseInt(match2[3]);
      return (value) => {
        if (length2 >= 0 && value.length !== length2) {
          logger$e.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak256$2);
        }
        return keccak256$2(hexConcat(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id$1(this._types[type]);
      return (value) => {
        const values2 = fields.map(({ name: name2, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name2]);
          if (this._types[type2]) {
            return keccak256$2(result);
          }
          return result;
        });
        values2.unshift(encodedType);
        return hexConcat(values2);
      };
    }
    return logger$e.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  encodeType(name2) {
    const result = this._types[name2];
    if (!result) {
      logger$e.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
    }
    return result;
  }
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  hashStruct(name2, value) {
    return keccak256$2(this.encodeData(name2, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type, value, callback) {
    {
      const encoder2 = getBaseEncoder(type);
      if (encoder2) {
        return callback(type, value);
      }
    }
    const match2 = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match2) {
      const subtype = match2[1];
      const length2 = parseInt(match2[3]);
      if (length2 >= 0 && value.length !== length2) {
        logger$e.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map((v2) => this._visit(subtype, v2, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name: name2, type: type2 }) => {
        accum[name2] = this._visit(type2, value[name2], callback);
        return accum;
      }, {});
    }
    return logger$e.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types2) {
    return new TypedDataEncoder(types2);
  }
  static getPrimaryType(types2) {
    return TypedDataEncoder.from(types2).primaryType;
  }
  static hashStruct(name2, types2, value) {
    return TypedDataEncoder.from(types2).hashStruct(name2, value);
  }
  static hashDomain(domain) {
    const domainFields = [];
    for (const name2 in domain) {
      const type = domainFieldTypes[name2];
      if (!type) {
        logger$e.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain);
      }
      domainFields.push({ name: name2, type });
    }
    domainFields.sort((a2, b3) => {
      return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b3.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  static encode(domain, types2, value) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder.hashDomain(domain),
      TypedDataEncoder.from(types2).hash(value)
    ]);
  }
  static hash(domain, types2, value) {
    return keccak256$2(TypedDataEncoder.encode(domain, types2, value));
  }
  // Replaces all address types with ENS names with their looked up address
  static resolveNames(domain, types2, value, resolveName2) {
    return __awaiter$8(this, void 0, void 0, function* () {
      domain = shallowCopy(domain);
      const ensCache = {};
      if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
        ensCache[domain.verifyingContract] = "0x";
      }
      const encoder2 = TypedDataEncoder.from(types2);
      encoder2.visit(value, (type, value2) => {
        if (type === "address" && !isHexString(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name2 in ensCache) {
        ensCache[name2] = yield resolveName2(name2);
      }
      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
        domain.verifyingContract = ensCache[domain.verifyingContract];
      }
      value = encoder2.visit(value, (type, value2) => {
        if (type === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return { domain, value };
    });
  }
  static getPayload(domain, types2, value) {
    TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name2) => {
      const value2 = domain[name2];
      if (value2 == null) {
        return;
      }
      domainValues[name2] = domainChecks[name2](value2);
      domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
    });
    const encoder2 = TypedDataEncoder.from(types2);
    const typesWithDomain = shallowCopy(types2);
    if (typesWithDomain.EIP712Domain) {
      logger$e.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types2);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder2.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder2.primaryType,
      message: encoder2.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(arrayify(value2));
        }
        if (type.match(/^u?int/)) {
          return BigNumber.from(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            if (typeof value2 !== "string") {
              logger$e.throwArgumentError(`invalid string`, "value", value2);
            }
            return value2;
        }
        return logger$e.throwArgumentError("unsupported type", "type", type);
      })
    };
  }
}
const logger$d = new Logger(version$f);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
}
const BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
  const wrap2 = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap2.error = error;
  return wrap2;
}
class Interface {
  constructor(fragments) {
    let abi2 = [];
    if (typeof fragments === "string") {
      abi2 = JSON.parse(fragments);
    } else {
      abi2 = fragments;
    }
    defineReadOnly(this, "fragments", abi2.map((fragment) => {
      return Fragment.from(fragment);
    }).filter((fragment) => fragment != null));
    defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "errors", {});
    defineReadOnly(this, "events", {});
    defineReadOnly(this, "structs", {});
    this.fragments.forEach((fragment) => {
      let bucket = null;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            logger$d.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly(this, "deploy", fragment);
          return;
        case "function":
          bucket = this.functions;
          break;
        case "event":
          bucket = this.events;
          break;
        case "error":
          bucket = this.errors;
          break;
        default:
          return;
      }
      let signature2 = fragment.format();
      if (bucket[signature2]) {
        logger$d.warn("duplicate definition - " + signature2);
        return;
      }
      bucket[signature2] = fragment;
    });
    if (!this.deploy) {
      defineReadOnly(this, "deploy", ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }
    defineReadOnly(this, "_isInterface", true);
  }
  format(format) {
    if (!format) {
      format = FormatTypes.full;
    }
    if (format === FormatTypes.sighash) {
      logger$d.throwArgumentError("interface does not support formatting sighash", "format", format);
    }
    const abi2 = this.fragments.map((fragment) => fragment.format(format));
    if (format === FormatTypes.json) {
      return JSON.stringify(abi2.map((j2) => JSON.parse(j2)));
    }
    return abi2;
  }
  // Sub-classes can override these to handle other blockchains
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(address) {
    return getAddress$1(address);
  }
  static getSighash(fragment) {
    return hexDataSlice(id$1(fragment.format()), 0, 4);
  }
  static getEventTopic(eventFragment) {
    return id$1(eventFragment.format());
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getFunction(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      for (const name2 in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name2)) {
          return this.functions[name2];
        }
      }
      logger$d.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.functions).filter((f3) => f3.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger$d.throwArgumentError("no matching function", "name", name2);
      } else if (matching.length > 1) {
        logger$d.throwArgumentError("multiple matching functions", "name", name2);
      }
      return this.functions[matching[0]];
    }
    const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$d.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  getEvent(nameOrSignatureOrTopic) {
    if (isHexString(nameOrSignatureOrTopic)) {
      const topichash = nameOrSignatureOrTopic.toLowerCase();
      for (const name2 in this.events) {
        if (topichash === this.getEventTopic(name2)) {
          return this.events[name2];
        }
      }
      logger$d.throwArgumentError("no matching event", "topichash", topichash);
    }
    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrTopic.trim();
      const matching = Object.keys(this.events).filter((f3) => f3.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger$d.throwArgumentError("no matching event", "name", name2);
      } else if (matching.length > 1) {
        logger$d.throwArgumentError("multiple matching events", "name", name2);
      }
      return this.events[matching[0]];
    }
    const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
    if (!result) {
      logger$d.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }
    return result;
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getError(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      const getSighash = getStatic(this.constructor, "getSighash");
      for (const name2 in this.errors) {
        const error = this.errors[name2];
        if (nameOrSignatureOrSighash === getSighash(error)) {
          return this.errors[name2];
        }
      }
      logger$d.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.errors).filter((f3) => f3.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger$d.throwArgumentError("no matching error", "name", name2);
      } else if (matching.length > 1) {
        logger$d.throwArgumentError("multiple matching errors", "name", name2);
      }
      return this.errors[matching[0]];
    }
    const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$d.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  getSighash(fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error) {
        try {
          fragment = this.getError(fragment);
        } catch (_2) {
          throw error;
        }
      }
    }
    return getStatic(this.constructor, "getSighash")(fragment);
  }
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  getEventTopic(eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    return getStatic(this.constructor, "getEventTopic")(eventFragment);
  }
  _decodeParams(params, data2) {
    return this._abiCoder.decode(params, data2);
  }
  _encodeParams(params, values2) {
    return this._abiCoder.encode(params, values2);
  }
  encodeDeploy(values2) {
    return this._encodeParams(this.deploy.inputs, values2 || []);
  }
  decodeErrorResult(fragment, data2) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    const bytes2 = arrayify(data2);
    if (hexlify(bytes2.slice(0, 4)) !== this.getSighash(fragment)) {
      logger$d.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes2));
    }
    return this._decodeParams(fragment.inputs, bytes2.slice(4));
  }
  encodeErrorResult(fragment, values2) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    return hexlify(concat$2([
      this.getSighash(fragment),
      this._encodeParams(fragment.inputs, values2 || [])
    ]));
  }
  // Decode the data for a function call (e.g. tx.data)
  decodeFunctionData(functionFragment, data2) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    const bytes2 = arrayify(data2);
    if (hexlify(bytes2.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger$d.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes2));
    }
    return this._decodeParams(functionFragment.inputs, bytes2.slice(4));
  }
  // Encode the data for a function call (e.g. tx.data)
  encodeFunctionData(functionFragment, values2) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(concat$2([
      this.getSighash(functionFragment),
      this._encodeParams(functionFragment.inputs, values2 || [])
    ]));
  }
  // Decode the result from a function call (e.g. from eth_call)
  decodeFunctionResult(functionFragment, data2) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    let bytes2 = arrayify(data2);
    let reason = null;
    let message = "";
    let errorArgs = null;
    let errorName = null;
    let errorSignature = null;
    switch (bytes2.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes2);
        } catch (error) {
        }
        break;
      case 4: {
        const selector = hexlify(bytes2.slice(0, 4));
        const builtin = BuiltinErrors[selector];
        if (builtin) {
          errorArgs = this._abiCoder.decode(builtin.inputs, bytes2.slice(4));
          errorName = builtin.name;
          errorSignature = builtin.signature;
          if (builtin.reason) {
            reason = errorArgs[0];
          }
          if (errorName === "Error") {
            message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
          } else if (errorName === "Panic") {
            message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
          }
        } else {
          try {
            const error = this.getError(selector);
            errorArgs = this._abiCoder.decode(error.inputs, bytes2.slice(4));
            errorName = error.name;
            errorSignature = error.format();
          } catch (error) {
          }
        }
        break;
      }
    }
    return logger$d.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      data: hexlify(data2),
      errorArgs,
      errorName,
      errorSignature,
      reason
    });
  }
  // Encode the result for a function call (e.g. for eth_call)
  encodeFunctionResult(functionFragment, values2) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(this._abiCoder.encode(functionFragment.outputs, values2 || []));
  }
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(eventFragment, values2) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (values2.length > eventFragment.inputs.length) {
      logger$d.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values2
      });
    }
    let topics = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id$1(value);
      } else if (param.type === "bytes") {
        return keccak256$2(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      }
      if (param.type.match(/^u?int/)) {
        value = BigNumber.from(value).toHexString();
      }
      if (param.type === "address") {
        this._abiCoder.encode(["address"], [value]);
      }
      return hexZeroPad(hexlify(value), 32);
    };
    values2.forEach((value, index2) => {
      let param = eventFragment.inputs[index2];
      if (!param.indexed) {
        if (value != null) {
          logger$d.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        }
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger$d.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(eventFragment, values2) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    if (values2.length !== eventFragment.inputs.length) {
      logger$d.throwArgumentError("event arguments/values mismatch", "values", values2);
    }
    eventFragment.inputs.forEach((param, index2) => {
      const value = values2[index2];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id$1(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256$2(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this._abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(eventFragment, data2, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (topics != null && !eventFragment.anonymous) {
      let topicHash = this.getEventTopic(eventFragment);
      if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger$d.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
      }
      topics = topics.slice(1);
    }
    let indexed = [];
    let nonIndexed = [];
    let dynamic = [];
    eventFragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat$2(topics)) : null;
    let resultNonIndexed = this._abiCoder.decode(nonIndexed, data2, true);
    let result = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    eventFragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index2] = new Indexed({ _isIndexed: true, hash: null });
        } else if (dynamic[index2]) {
          result[index2] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
        } else {
          try {
            result[index2] = resultIndexed[indexedIndex++];
          } catch (error) {
            result[index2] = error;
          }
        }
      } else {
        try {
          result[index2] = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          result[index2] = error;
        }
      }
      if (param.name && result[param.name] == null) {
        const value = result[index2];
        if (value instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
            }
          });
        } else {
          result[param.name] = value;
        }
      }
    });
    for (let i3 = 0; i3 < result.length; i3++) {
      const value = result[i3];
      if (value instanceof Error) {
        Object.defineProperty(result, i3, {
          enumerable: true,
          get: () => {
            throw wrapAccessError(`index ${i3}`, value);
          }
        });
      }
    }
    return Object.freeze(result);
  }
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  parseTransaction(tx) {
    let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: BigNumber.from(tx.value || "0")
    });
  }
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  parseLog(log3) {
    let fragment = this.getEvent(log3.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log3.data, log3.topics)
    });
  }
  parseError(data2) {
    const hexData = hexlify(data2);
    let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  static isInterface(value) {
    return !!(value && value._isInterface);
  }
}
const lib_esm$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbiCoder,
  ConstructorFragment,
  ErrorFragment,
  EventFragment,
  FormatTypes,
  Fragment,
  FunctionFragment,
  Indexed,
  Interface,
  LogDescription,
  ParamType,
  TransactionDescription,
  checkResultErrors,
  defaultAbiCoder
}, Symbol.toStringTag, { value: "Module" }));
var hash$4 = {};
var utils$d = {};
var minimalisticAssert$1 = assert$b;
function assert$b(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$b.equal = function assertEqual(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var inherits_browser$1 = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits_browserExports = inherits_browser$1.exports;
var assert$a = minimalisticAssert$1;
var inherits = inherits_browserExports;
utils$d.inherits = inherits;
function isSurrogatePair(msg, i3) {
  if ((msg.charCodeAt(i3) & 64512) !== 55296) {
    return false;
  }
  if (i3 < 0 || i3 + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i3 + 1) & 64512) === 56320;
}
function toArray$1(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === "string") {
    if (!enc) {
      var p2 = 0;
      for (var i3 = 0; i3 < msg.length; i3++) {
        var c2 = msg.charCodeAt(i3);
        if (c2 < 128) {
          res[p2++] = c2;
        } else if (c2 < 2048) {
          res[p2++] = c2 >> 6 | 192;
          res[p2++] = c2 & 63 | 128;
        } else if (isSurrogatePair(msg, i3)) {
          c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i3) & 1023);
          res[p2++] = c2 >> 18 | 240;
          res[p2++] = c2 >> 12 & 63 | 128;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        } else {
          res[p2++] = c2 >> 12 | 224;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        }
      }
    } else if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (i3 = 0; i3 < msg.length; i3 += 2)
        res.push(parseInt(msg[i3] + msg[i3 + 1], 16));
    }
  } else {
    for (i3 = 0; i3 < msg.length; i3++)
      res[i3] = msg[i3] | 0;
  }
  return res;
}
utils$d.toArray = toArray$1;
function toHex$3(msg) {
  var res = "";
  for (var i3 = 0; i3 < msg.length; i3++)
    res += zero2(msg[i3].toString(16));
  return res;
}
utils$d.toHex = toHex$3;
function htonl(w2) {
  var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
  return res >>> 0;
}
utils$d.htonl = htonl;
function toHex32(msg, endian) {
  var res = "";
  for (var i3 = 0; i3 < msg.length; i3++) {
    var w2 = msg[i3];
    if (endian === "little")
      w2 = htonl(w2);
    res += zero8(w2.toString(16));
  }
  return res;
}
utils$d.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1)
    return "0" + word;
  else
    return word;
}
utils$d.zero2 = zero2;
function zero8(word) {
  if (word.length === 7)
    return "0" + word;
  else if (word.length === 6)
    return "00" + word;
  else if (word.length === 5)
    return "000" + word;
  else if (word.length === 4)
    return "0000" + word;
  else if (word.length === 3)
    return "00000" + word;
  else if (word.length === 2)
    return "000000" + word;
  else if (word.length === 1)
    return "0000000" + word;
  else
    return word;
}
utils$d.zero8 = zero8;
function join32(msg, start, end, endian) {
  var len = end - start;
  assert$a(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i3 = 0, k4 = start; i3 < res.length; i3++, k4 += 4) {
    var w2;
    if (endian === "big")
      w2 = msg[k4] << 24 | msg[k4 + 1] << 16 | msg[k4 + 2] << 8 | msg[k4 + 3];
    else
      w2 = msg[k4 + 3] << 24 | msg[k4 + 2] << 16 | msg[k4 + 1] << 8 | msg[k4];
    res[i3] = w2 >>> 0;
  }
  return res;
}
utils$d.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i3 = 0, k4 = 0; i3 < msg.length; i3++, k4 += 4) {
    var m2 = msg[i3];
    if (endian === "big") {
      res[k4] = m2 >>> 24;
      res[k4 + 1] = m2 >>> 16 & 255;
      res[k4 + 2] = m2 >>> 8 & 255;
      res[k4 + 3] = m2 & 255;
    } else {
      res[k4 + 3] = m2 >>> 24;
      res[k4 + 2] = m2 >>> 16 & 255;
      res[k4 + 1] = m2 >>> 8 & 255;
      res[k4] = m2 & 255;
    }
  }
  return res;
}
utils$d.split32 = split32;
function rotr32$1(w2, b3) {
  return w2 >>> b3 | w2 << 32 - b3;
}
utils$d.rotr32 = rotr32$1;
function rotl32$2(w2, b3) {
  return w2 << b3 | w2 >>> 32 - b3;
}
utils$d.rotl32 = rotl32$2;
function sum32$3(a2, b3) {
  return a2 + b3 >>> 0;
}
utils$d.sum32 = sum32$3;
function sum32_3$1(a2, b3, c2) {
  return a2 + b3 + c2 >>> 0;
}
utils$d.sum32_3 = sum32_3$1;
function sum32_4$2(a2, b3, c2, d2) {
  return a2 + b3 + c2 + d2 >>> 0;
}
utils$d.sum32_4 = sum32_4$2;
function sum32_5$2(a2, b3, c2, d2, e2) {
  return a2 + b3 + c2 + d2 + e2 >>> 0;
}
utils$d.sum32_5 = sum32_5$2;
function sum64$1(buf, pos, ah2, al2) {
  var bh2 = buf[pos];
  var bl2 = buf[pos + 1];
  var lo = al2 + bl2 >>> 0;
  var hi2 = (lo < al2 ? 1 : 0) + ah2 + bh2;
  buf[pos] = hi2 >>> 0;
  buf[pos + 1] = lo;
}
utils$d.sum64 = sum64$1;
function sum64_hi$1(ah2, al2, bh2, bl2) {
  var lo = al2 + bl2 >>> 0;
  var hi2 = (lo < al2 ? 1 : 0) + ah2 + bh2;
  return hi2 >>> 0;
}
utils$d.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah2, al2, bh2, bl2) {
  var lo = al2 + bl2;
  return lo >>> 0;
}
utils$d.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
  var carry = 0;
  var lo = al2;
  lo = lo + bl2 >>> 0;
  carry += lo < al2 ? 1 : 0;
  lo = lo + cl2 >>> 0;
  carry += lo < cl2 ? 1 : 0;
  lo = lo + dl2 >>> 0;
  carry += lo < dl2 ? 1 : 0;
  var hi2 = ah2 + bh2 + ch2 + dh2 + carry;
  return hi2 >>> 0;
}
utils$d.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
  var lo = al2 + bl2 + cl2 + dl2;
  return lo >>> 0;
}
utils$d.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
  var carry = 0;
  var lo = al2;
  lo = lo + bl2 >>> 0;
  carry += lo < al2 ? 1 : 0;
  lo = lo + cl2 >>> 0;
  carry += lo < cl2 ? 1 : 0;
  lo = lo + dl2 >>> 0;
  carry += lo < dl2 ? 1 : 0;
  lo = lo + el2 >>> 0;
  carry += lo < el2 ? 1 : 0;
  var hi2 = ah2 + bh2 + ch2 + dh2 + eh2 + carry;
  return hi2 >>> 0;
}
utils$d.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
  var lo = al2 + bl2 + cl2 + dl2 + el2;
  return lo >>> 0;
}
utils$d.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah2, al2, num) {
  var r2 = al2 << 32 - num | ah2 >>> num;
  return r2 >>> 0;
}
utils$d.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah2, al2, num) {
  var r2 = ah2 << 32 - num | al2 >>> num;
  return r2 >>> 0;
}
utils$d.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah2, al2, num) {
  return ah2 >>> num;
}
utils$d.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah2, al2, num) {
  var r2 = ah2 << 32 - num | al2 >>> num;
  return r2 >>> 0;
}
utils$d.shr64_lo = shr64_lo$1;
var common$5 = {};
var utils$c = utils$d;
var assert$9 = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = "big";
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update(msg, enc) {
  msg = utils$c.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r2 = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r2, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$c.join32(msg, 0, msg.length - r2, this.endian);
    for (var i3 = 0; i3 < msg.length; i3 += this._delta32)
      this._update(msg, i3, i3 + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$9(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes2 = this._delta8;
  var k4 = bytes2 - (len + this.padLength) % bytes2;
  var res = new Array(k4 + this.padLength);
  res[0] = 128;
  for (var i3 = 1; i3 < k4; i3++)
    res[i3] = 0;
  len <<= 3;
  if (this.endian === "big") {
    for (var t2 = 8; t2 < this.padLength; t2++)
      res[i3++] = 0;
    res[i3++] = 0;
    res[i3++] = 0;
    res[i3++] = 0;
    res[i3++] = 0;
    res[i3++] = len >>> 24 & 255;
    res[i3++] = len >>> 16 & 255;
    res[i3++] = len >>> 8 & 255;
    res[i3++] = len & 255;
  } else {
    res[i3++] = len & 255;
    res[i3++] = len >>> 8 & 255;
    res[i3++] = len >>> 16 & 255;
    res[i3++] = len >>> 24 & 255;
    res[i3++] = 0;
    res[i3++] = 0;
    res[i3++] = 0;
    res[i3++] = 0;
    for (t2 = 8; t2 < this.padLength; t2++)
      res[i3++] = 0;
  }
  return res;
};
var sha = {};
var common$4 = {};
var utils$b = utils$d;
var rotr32 = utils$b.rotr32;
function ft_1$1(s4, x2, y2, z2) {
  if (s4 === 0)
    return ch32$1(x2, y2, z2);
  if (s4 === 1 || s4 === 3)
    return p32(x2, y2, z2);
  if (s4 === 2)
    return maj32$1(x2, y2, z2);
}
common$4.ft_1 = ft_1$1;
function ch32$1(x2, y2, z2) {
  return x2 & y2 ^ ~x2 & z2;
}
common$4.ch32 = ch32$1;
function maj32$1(x2, y2, z2) {
  return x2 & y2 ^ x2 & z2 ^ y2 & z2;
}
common$4.maj32 = maj32$1;
function p32(x2, y2, z2) {
  return x2 ^ y2 ^ z2;
}
common$4.p32 = p32;
function s0_256$1(x2) {
  return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(x2) {
  return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(x2) {
  return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(x2) {
  return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$a = utils$d;
var common$3 = common$5;
var shaCommon$1 = common$4;
var rotl32$1 = utils$a.rotl32;
var sum32$2 = utils$a.sum32;
var sum32_5$1 = utils$a.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;
var sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this);
  this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ];
  this.W = new Array(80);
}
utils$a.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
  var W2 = this.W;
  for (var i3 = 0; i3 < 16; i3++)
    W2[i3] = msg[start + i3];
  for (; i3 < W2.length; i3++)
    W2[i3] = rotl32$1(W2[i3 - 3] ^ W2[i3 - 8] ^ W2[i3 - 14] ^ W2[i3 - 16], 1);
  var a2 = this.h[0];
  var b3 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  for (i3 = 0; i3 < W2.length; i3++) {
    var s4 = ~~(i3 / 20);
    var t2 = sum32_5$1(rotl32$1(a2, 5), ft_1(s4, b3, c2, d2), e2, W2[i3], sha1_K[s4]);
    e2 = d2;
    d2 = c2;
    c2 = rotl32$1(b3, 30);
    b3 = a2;
    a2 = t2;
  }
  this.h[0] = sum32$2(this.h[0], a2);
  this.h[1] = sum32$2(this.h[1], b3);
  this.h[2] = sum32$2(this.h[2], c2);
  this.h[3] = sum32$2(this.h[3], d2);
  this.h[4] = sum32$2(this.h[4], e2);
};
SHA1.prototype._digest = function digest2(enc) {
  if (enc === "hex")
    return utils$a.toHex32(this.h, "big");
  else
    return utils$a.split32(this.h, "big");
};
var utils$9 = utils$d;
var common$2 = common$5;
var shaCommon = common$4;
var assert$8 = minimalisticAssert$1;
var sum32$1 = utils$9.sum32;
var sum32_4$1 = utils$9.sum32_4;
var sum32_5 = utils$9.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$2.BlockHash;
var sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this);
  this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$9.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function _update2(msg, start) {
  var W2 = this.W;
  for (var i3 = 0; i3 < 16; i3++)
    W2[i3] = msg[start + i3];
  for (; i3 < W2.length; i3++)
    W2[i3] = sum32_4$1(g1_256(W2[i3 - 2]), W2[i3 - 7], g0_256(W2[i3 - 15]), W2[i3 - 16]);
  var a2 = this.h[0];
  var b3 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  var f3 = this.h[5];
  var g2 = this.h[6];
  var h4 = this.h[7];
  assert$8(this.k.length === W2.length);
  for (i3 = 0; i3 < W2.length; i3++) {
    var T1 = sum32_5(h4, s1_256(e2), ch32(e2, f3, g2), this.k[i3], W2[i3]);
    var T2 = sum32$1(s0_256(a2), maj32(a2, b3, c2));
    h4 = g2;
    g2 = f3;
    f3 = e2;
    e2 = sum32$1(d2, T1);
    d2 = c2;
    c2 = b3;
    b3 = a2;
    a2 = sum32$1(T1, T2);
  }
  this.h[0] = sum32$1(this.h[0], a2);
  this.h[1] = sum32$1(this.h[1], b3);
  this.h[2] = sum32$1(this.h[2], c2);
  this.h[3] = sum32$1(this.h[3], d2);
  this.h[4] = sum32$1(this.h[4], e2);
  this.h[5] = sum32$1(this.h[5], f3);
  this.h[6] = sum32$1(this.h[6], g2);
  this.h[7] = sum32$1(this.h[7], h4);
};
SHA256$1.prototype._digest = function digest3(enc) {
  if (enc === "hex")
    return utils$9.toHex32(this.h, "big");
  else
    return utils$9.split32(this.h, "big");
};
var utils$8 = utils$d;
var SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this);
  this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$8.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest4(enc) {
  if (enc === "hex")
    return utils$8.toHex32(this.h.slice(0, 7), "big");
  else
    return utils$8.split32(this.h.slice(0, 7), "big");
};
var utils$7 = utils$d;
var common$1 = common$5;
var assert$7 = minimalisticAssert$1;
var rotr64_hi = utils$7.rotr64_hi;
var rotr64_lo = utils$7.rotr64_lo;
var shr64_hi = utils$7.shr64_hi;
var shr64_lo = utils$7.shr64_lo;
var sum64 = utils$7.sum64;
var sum64_hi = utils$7.sum64_hi;
var sum64_lo = utils$7.sum64_lo;
var sum64_4_hi = utils$7.sum64_4_hi;
var sum64_4_lo = utils$7.sum64_4_lo;
var sum64_5_hi = utils$7.sum64_5_hi;
var sum64_5_lo = utils$7.sum64_5_lo;
var BlockHash$1 = common$1.BlockHash;
var sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this);
  this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$7.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W2 = this.W;
  for (var i3 = 0; i3 < 32; i3++)
    W2[i3] = msg[start + i3];
  for (; i3 < W2.length; i3 += 2) {
    var c0_hi = g1_512_hi(W2[i3 - 4], W2[i3 - 3]);
    var c0_lo = g1_512_lo(W2[i3 - 4], W2[i3 - 3]);
    var c1_hi = W2[i3 - 14];
    var c1_lo = W2[i3 - 13];
    var c2_hi = g0_512_hi(W2[i3 - 30], W2[i3 - 29]);
    var c2_lo = g0_512_lo(W2[i3 - 30], W2[i3 - 29]);
    var c3_hi = W2[i3 - 32];
    var c3_lo = W2[i3 - 31];
    W2[i3] = sum64_4_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
    W2[i3 + 1] = sum64_4_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
  }
};
SHA512$1.prototype._update = function _update3(msg, start) {
  this._prepareBlock(msg, start);
  var W2 = this.W;
  var ah2 = this.h[0];
  var al2 = this.h[1];
  var bh2 = this.h[2];
  var bl2 = this.h[3];
  var ch2 = this.h[4];
  var cl2 = this.h[5];
  var dh2 = this.h[6];
  var dl2 = this.h[7];
  var eh2 = this.h[8];
  var el2 = this.h[9];
  var fh2 = this.h[10];
  var fl2 = this.h[11];
  var gh2 = this.h[12];
  var gl2 = this.h[13];
  var hh2 = this.h[14];
  var hl2 = this.h[15];
  assert$7(this.k.length === W2.length);
  for (var i3 = 0; i3 < W2.length; i3 += 2) {
    var c0_hi = hh2;
    var c0_lo = hl2;
    var c1_hi = s1_512_hi(eh2, el2);
    var c1_lo = s1_512_lo(eh2, el2);
    var c2_hi = ch64_hi(eh2, el2, fh2, fl2, gh2);
    var c2_lo = ch64_lo(eh2, el2, fh2, fl2, gh2, gl2);
    var c3_hi = this.k[i3];
    var c3_lo = this.k[i3 + 1];
    var c4_hi = W2[i3];
    var c4_lo = W2[i3 + 1];
    var T1_hi = sum64_5_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    var T1_lo = sum64_5_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    c0_hi = s0_512_hi(ah2, al2);
    c0_lo = s0_512_lo(ah2, al2);
    c1_hi = maj64_hi(ah2, al2, bh2, bl2, ch2);
    c1_lo = maj64_lo(ah2, al2, bh2, bl2, ch2, cl2);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh2 = gh2;
    hl2 = gl2;
    gh2 = fh2;
    gl2 = fl2;
    fh2 = eh2;
    fl2 = el2;
    eh2 = sum64_hi(dh2, dl2, T1_hi, T1_lo);
    el2 = sum64_lo(dl2, dl2, T1_hi, T1_lo);
    dh2 = ch2;
    dl2 = cl2;
    ch2 = bh2;
    cl2 = bl2;
    bh2 = ah2;
    bl2 = al2;
    ah2 = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al2 = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah2, al2);
  sum64(this.h, 2, bh2, bl2);
  sum64(this.h, 4, ch2, cl2);
  sum64(this.h, 6, dh2, dl2);
  sum64(this.h, 8, eh2, el2);
  sum64(this.h, 10, fh2, fl2);
  sum64(this.h, 12, gh2, gl2);
  sum64(this.h, 14, hh2, hl2);
};
SHA512$1.prototype._digest = function digest5(enc) {
  if (enc === "hex")
    return utils$7.toHex32(this.h, "big");
  else
    return utils$7.split32(this.h, "big");
};
function ch64_hi(xh2, xl, yh2, yl, zh2) {
  var r2 = xh2 & yh2 ^ ~xh2 & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function ch64_lo(xh2, xl, yh2, yl, zh2, zl) {
  var r2 = xl & yl ^ ~xl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_hi(xh2, xl, yh2, yl, zh2) {
  var r2 = xh2 & yh2 ^ xh2 & zh2 ^ yh2 & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_lo(xh2, xl, yh2, yl, zh2, zl) {
  var r2 = xl & yl ^ xl & zl ^ yl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 28);
  var c1_hi = rotr64_hi(xl, xh2, 2);
  var c2_hi = rotr64_hi(xl, xh2, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 28);
  var c1_lo = rotr64_lo(xl, xh2, 2);
  var c2_lo = rotr64_lo(xl, xh2, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 14);
  var c1_hi = rotr64_hi(xh2, xl, 18);
  var c2_hi = rotr64_hi(xl, xh2, 9);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 14);
  var c1_lo = rotr64_lo(xh2, xl, 18);
  var c2_lo = rotr64_lo(xl, xh2, 9);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 1);
  var c1_hi = rotr64_hi(xh2, xl, 8);
  var c2_hi = shr64_hi(xh2, xl, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 1);
  var c1_lo = rotr64_lo(xh2, xl, 8);
  var c2_lo = shr64_lo(xh2, xl, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 19);
  var c1_hi = rotr64_hi(xl, xh2, 29);
  var c2_hi = shr64_hi(xh2, xl, 6);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 19);
  var c1_lo = rotr64_lo(xl, xh2, 29);
  var c2_lo = shr64_lo(xh2, xl, 6);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
var utils$6 = utils$d;
var SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this);
  this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$6.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest6(enc) {
  if (enc === "hex")
    return utils$6.toHex32(this.h.slice(0, 12), "big");
  else
    return utils$6.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {};
var utils$5 = utils$d;
var common = common$5;
var rotl32 = utils$5.rotl32;
var sum32 = utils$5.sum32;
var sum32_3 = utils$5.sum32_3;
var sum32_4 = utils$5.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.endian = "little";
}
utils$5.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update2(msg, start) {
  var A2 = this.h[0];
  var B2 = this.h[1];
  var C2 = this.h[2];
  var D2 = this.h[3];
  var E2 = this.h[4];
  var Ah2 = A2;
  var Bh2 = B2;
  var Ch2 = C2;
  var Dh2 = D2;
  var Eh2 = E2;
  for (var j2 = 0; j2 < 80; j2++) {
    var T2 = sum32(
      rotl32(
        sum32_4(A2, f$8(j2, B2, C2, D2), msg[r$e[j2] + start], K$1(j2)),
        s$9[j2]
      ),
      E2
    );
    A2 = E2;
    E2 = D2;
    D2 = rotl32(C2, 10);
    C2 = B2;
    B2 = T2;
    T2 = sum32(
      rotl32(
        sum32_4(Ah2, f$8(79 - j2, Bh2, Ch2, Dh2), msg[rh[j2] + start], Kh(j2)),
        sh[j2]
      ),
      Eh2
    );
    Ah2 = Eh2;
    Eh2 = Dh2;
    Dh2 = rotl32(Ch2, 10);
    Ch2 = Bh2;
    Bh2 = T2;
  }
  T2 = sum32_3(this.h[1], C2, Dh2);
  this.h[1] = sum32_3(this.h[2], D2, Eh2);
  this.h[2] = sum32_3(this.h[3], E2, Ah2);
  this.h[3] = sum32_3(this.h[4], A2, Bh2);
  this.h[4] = sum32_3(this.h[0], B2, Ch2);
  this.h[0] = T2;
};
RIPEMD160.prototype._digest = function digest7(enc) {
  if (enc === "hex")
    return utils$5.toHex32(this.h, "little");
  else
    return utils$5.split32(this.h, "little");
};
function f$8(j2, x2, y2, z2) {
  if (j2 <= 15)
    return x2 ^ y2 ^ z2;
  else if (j2 <= 31)
    return x2 & y2 | ~x2 & z2;
  else if (j2 <= 47)
    return (x2 | ~y2) ^ z2;
  else if (j2 <= 63)
    return x2 & z2 | y2 & ~z2;
  else
    return x2 ^ (y2 | ~z2);
}
function K$1(j2) {
  if (j2 <= 15)
    return 0;
  else if (j2 <= 31)
    return 1518500249;
  else if (j2 <= 47)
    return 1859775393;
  else if (j2 <= 63)
    return 2400959708;
  else
    return 2840853838;
}
function Kh(j2) {
  if (j2 <= 15)
    return 1352829926;
  else if (j2 <= 31)
    return 1548603684;
  else if (j2 <= 47)
    return 1836072691;
  else if (j2 <= 63)
    return 2053994217;
  else
    return 0;
}
var r$e = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var s$9 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var utils$4 = utils$d;
var assert$6 = minimalisticAssert$1;
function Hmac(hash2, key2, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash2, key2, enc);
  this.Hash = hash2;
  this.blockSize = hash2.blockSize / 8;
  this.outSize = hash2.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils$4.toArray(key2, enc));
}
var hmac$2 = Hmac;
Hmac.prototype._init = function init(key2) {
  if (key2.length > this.blockSize)
    key2 = new this.Hash().update(key2).digest();
  assert$6(key2.length <= this.blockSize);
  for (var i3 = key2.length; i3 < this.blockSize; i3++)
    key2.push(0);
  for (i3 = 0; i3 < key2.length; i3++)
    key2[i3] ^= 54;
  this.inner = new this.Hash().update(key2);
  for (i3 = 0; i3 < key2.length; i3++)
    key2[i3] ^= 106;
  this.outer = new this.Hash().update(key2);
};
Hmac.prototype.update = function update3(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest8(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};
(function(exports) {
  var hash2 = exports;
  hash2.utils = utils$d;
  hash2.common = common$5;
  hash2.sha = sha;
  hash2.ripemd = ripemd;
  hash2.hmac = hmac$2;
  hash2.sha1 = hash2.sha.sha1;
  hash2.sha256 = hash2.sha.sha256;
  hash2.sha224 = hash2.sha.sha224;
  hash2.sha384 = hash2.sha.sha384;
  hash2.sha512 = hash2.sha.sha512;
  hash2.ripemd160 = hash2.ripemd.ripemd160;
})(hash$4);
const hash$3 = /* @__PURE__ */ getDefaultExportFromCjs(hash$4);
function sha256$2(data2) {
  return "0x" + hash$3.sha256().update(arrayify(data2)).digest("hex");
}
const version$c = "solidity/5.7.0";
const regexBytes = new RegExp("^bytes([0-9]+)$");
const regexNumber = new RegExp("^(u?int)([0-9]*)$");
const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
const Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
const logger$c = new Logger(version$c);
function _pack(type, value, isArray2) {
  switch (type) {
    case "address":
      if (isArray2) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return arrayify(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray2) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
  }
  let match2 = type.match(regexNumber);
  if (match2) {
    let size2 = parseInt(match2[2] || "256");
    if (match2[2] && String(size2) !== match2[2] || size2 % 8 !== 0 || size2 === 0 || size2 > 256) {
      logger$c.throwArgumentError("invalid number type", "type", type);
    }
    if (isArray2) {
      size2 = 256;
    }
    value = BigNumber.from(value).toTwos(size2);
    return zeroPad(value, size2 / 8);
  }
  match2 = type.match(regexBytes);
  if (match2) {
    const size2 = parseInt(match2[1]);
    if (String(size2) !== match2[1] || size2 === 0 || size2 > 32) {
      logger$c.throwArgumentError("invalid bytes type", "type", type);
    }
    if (arrayify(value).byteLength !== size2) {
      logger$c.throwArgumentError(`invalid value for ${type}`, "value", value);
    }
    if (isArray2) {
      return arrayify((value + Zeros).substring(0, 66));
    }
    return value;
  }
  match2 = type.match(regexArray);
  if (match2 && Array.isArray(value)) {
    const baseType = match2[1];
    const count = parseInt(match2[2] || String(value.length));
    if (count != value.length) {
      logger$c.throwArgumentError(`invalid array length for ${type}`, "value", value);
    }
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return concat$2(result);
  }
  return logger$c.throwArgumentError("invalid type", "type", type);
}
function pack(types2, values2) {
  if (types2.length != values2.length) {
    logger$c.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values2);
  }
  const tight = [];
  types2.forEach(function(type, index2) {
    tight.push(_pack(type, values2[index2]));
  });
  return hexlify(concat$2(tight));
}
function keccak256$1(types2, values2) {
  return keccak256$2(pack(types2, values2));
}
function sha256$1(types2, values2) {
  return sha256$2(pack(types2, values2));
}
const lib_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  keccak256: keccak256$1,
  pack,
  sha256: sha256$1
}, Symbol.toStringTag, { value: "Module" }));
const _format$b = "hh-sol-artifact-1";
const contractName$b = "IMulticall";
const sourceName$b = "contracts/interfaces/IMulticall.sol";
const abi$b = [
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  }
];
const bytecode$b = "0x";
const deployedBytecode$b = "0x";
const linkReferences$b = {};
const deployedLinkReferences$b = {};
const IMulticall = {
  _format: _format$b,
  contractName: contractName$b,
  sourceName: sourceName$b,
  abi: abi$b,
  bytecode: bytecode$b,
  deployedBytecode: deployedBytecode$b,
  linkReferences: linkReferences$b,
  deployedLinkReferences: deployedLinkReferences$b
};
const _format$a = "hh-sol-artifact-1";
const contractName$a = "NonfungiblePositionManager";
const sourceName$a = "contracts/NonfungiblePositionManager.sol";
const abi$a = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_factory",
        type: "address"
      },
      {
        internalType: "address",
        name: "_WETH9",
        type: "address"
      },
      {
        internalType: "address",
        name: "_tokenDescriptor_",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "approved",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      }
    ],
    name: "Collect",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint128",
        name: "liquidity",
        type: "uint128"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      }
    ],
    name: "DecreaseLiquidity",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint128",
        name: "liquidity",
        type: "uint128"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      }
    ],
    name: "IncreaseLiquidity",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PERMIT_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "WETH9",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "baseURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "amount0Max",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "amount1Max",
            type: "uint128"
          }
        ],
        internalType: "struct INonfungiblePositionManager.CollectParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "collect",
    outputs: [
      {
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token0",
        type: "address"
      },
      {
        internalType: "address",
        name: "token1",
        type: "address"
      },
      {
        internalType: "uint24",
        name: "fee",
        type: "uint24"
      },
      {
        internalType: "uint160",
        name: "sqrtPriceX96",
        type: "uint160"
      }
    ],
    name: "createAndInitializePoolIfNecessary",
    outputs: [
      {
        internalType: "address",
        name: "pool",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "liquidity",
            type: "uint128"
          },
          {
            internalType: "uint256",
            name: "amount0Min",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount1Min",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          }
        ],
        internalType: "struct INonfungiblePositionManager.DecreaseLiquidityParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "decreaseLiquidity",
    outputs: [
      {
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "factory",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount0Desired",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount1Desired",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount0Min",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount1Min",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          }
        ],
        internalType: "struct INonfungiblePositionManager.IncreaseLiquidityParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "increaseLiquidity",
    outputs: [
      {
        internalType: "uint128",
        name: "liquidity",
        type: "uint128"
      },
      {
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "token0",
            type: "address"
          },
          {
            internalType: "address",
            name: "token1",
            type: "address"
          },
          {
            internalType: "uint24",
            name: "fee",
            type: "uint24"
          },
          {
            internalType: "int24",
            name: "tickLower",
            type: "int24"
          },
          {
            internalType: "int24",
            name: "tickUpper",
            type: "int24"
          },
          {
            internalType: "uint256",
            name: "amount0Desired",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount1Desired",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount0Min",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount1Min",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          }
        ],
        internalType: "struct INonfungiblePositionManager.MintParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "mint",
    outputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint128",
        name: "liquidity",
        type: "uint128"
      },
      {
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "positions",
    outputs: [
      {
        internalType: "uint96",
        name: "nonce",
        type: "uint96"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "address",
        name: "token0",
        type: "address"
      },
      {
        internalType: "address",
        name: "token1",
        type: "address"
      },
      {
        internalType: "uint24",
        name: "fee",
        type: "uint24"
      },
      {
        internalType: "int24",
        name: "tickLower",
        type: "int24"
      },
      {
        internalType: "int24",
        name: "tickUpper",
        type: "int24"
      },
      {
        internalType: "uint128",
        name: "liquidity",
        type: "uint128"
      },
      {
        internalType: "uint256",
        name: "feeGrowthInside0LastX128",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "feeGrowthInside1LastX128",
        type: "uint256"
      },
      {
        internalType: "uint128",
        name: "tokensOwed0",
        type: "uint128"
      },
      {
        internalType: "uint128",
        name: "tokensOwed1",
        type: "uint128"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "refundETH",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "expiry",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermitAllowed",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "expiry",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermitAllowedIfNecessary",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermitIfNecessary",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "sweepToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "tokenByIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "tokenOfOwnerByIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "tokenURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount0Owed",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount1Owed",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "uniswapV3MintCallback",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "unwrapWETH9",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];
const bytecode$a = "0x610120604052600d80546001600160b01b0319166001176001600160b01b0316600160b01b1790553480156200003457600080fd5b50604051620062e9380380620062e98339810160408190526200005791620002db565b82826040518060400160405280601b81526020017f556e697377617020563320506f736974696f6e73204e46542d563100000000008152506040518060400160405280600a815260200169554e492d56332d504f5360b01b815250604051806040016040528060018152602001603160f81b8152508282620000e66301ffc9a760e01b6200018d60201b60201c565b8151620000fb90600690602085019062000212565b5080516200011190600790602084019062000212565b50620001246380ac58cd60e01b6200018d565b62000136635b5e139f60e01b6200018d565b6200014863780e9d6360e01b6200018d565b50508251602093840120608052805192019190912060a052506001600160601b0319606092831b811660c05290821b811660e05291901b166101005250620003249050565b6001600160e01b03198082161415620001ed576040805162461bcd60e51b815260206004820152601c60248201527f4552433136353a20696e76616c696420696e7465726661636520696400000000604482015290519081900360640190fd5b6001600160e01b0319166000908152602081905260409020805460ff19166001179055565b828054600181600116156101000203166002900490600052602060002090601f0160209004810192826200024a576000855562000295565b82601f106200026557805160ff191683800117855562000295565b8280016001018555821562000295579182015b828111156200029557825182559160200191906001019062000278565b50620002a3929150620002a7565b5090565b5b80821115620002a35760008155600101620002a8565b80516001600160a01b0381168114620002d657600080fd5b919050565b600080600060608486031215620002f0578283fd5b620002fb84620002be565b92506200030b60208501620002be565b91506200031b60408501620002be565b90509250925092565b60805160a05160c05160601c60e05160601c6101005160601c615f40620003a960003980612a835250806102995280611718528061180e52806118965280613e5d5280613ea35280613f17525080610aa75280610dde5280610ea55280612a1d5280612b235280612e4452806136e15250806114ff5250806114de5250615f406000f3fe6080604052600436106102895760003560e01c80636352211e11610153578063ac9650d8116100cb578063d34879971161007f578063e985e9c511610064578063e985e9c5146106f5578063f3995c6714610715578063fc6f7865146107285761030d565b8063d3487997146106c2578063df2ab5bb146106e25761030d565b8063c2e3140a116100b0578063c2e3140a1461067a578063c45a01551461068d578063c87b56dd146106a25761030d565b8063ac9650d81461063a578063b88d4fde1461065a5761030d565b8063883164561161012257806399fbab881161010757806399fbab88146105cf578063a22cb46514610607578063a4a78f0c146106275761030d565b8063883164561461059757806395d89b41146105ba5761030d565b80636352211e1461052f5780636c0360eb1461054f57806370a08231146105645780637ac2ff7b146105845761030d565b806323b872dd1161020157806342966c68116101b557806349404b7c1161019a57806349404b7c146104e75780634aa4a4fc146104fa5780634f6ccce71461050f5761030d565b806342966c68146104c15780634659a494146104d45761030d565b806330adf81f116101e657806330adf81f146104775780633644e5151461048c57806342842e0e146104a15761030d565b806323b872dd146104375780632f745c59146104575761030d565b80630c49ccbe1161025857806313ead5621161023d57806313ead562146103e057806318160ddd146103f3578063219f5d17146104155761030d565b80630c49ccbe146103b757806312210e8a146103d85761030d565b806301ffc9a71461031257806306fdde0314610348578063081812fc1461036a578063095ea7b3146103975761030d565b3661030d57336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461030b576040805162461bcd60e51b815260206004820152600960248201527f4e6f742057455448390000000000000000000000000000000000000000000000604482015290519081900360640190fd5b005b600080fd5b34801561031e57600080fd5b5061033261032d3660046153a6565b61073b565b60405161033f919061591e565b60405180910390f35b34801561035457600080fd5b5061035d610776565b60405161033f9190615971565b34801561037657600080fd5b5061038a6103853660046156b8565b61080c565b60405161033f91906157e2565b3480156103a357600080fd5b5061030b6103b2366004615270565b610868565b6103ca6103c5366004615483565b61093e565b60405161033f929190615b42565b61030b610daa565b61038a6103ee366004615103565b610dbc565b3480156103ff57600080fd5b506104086110c9565b60405161033f9190615929565b610428610423366004615494565b6110da565b60405161033f93929190615afd565b34801561044357600080fd5b5061030b61045236600461515c565b611413565b34801561046357600080fd5b50610408610472366004615270565b61146a565b34801561048357600080fd5b50610408611495565b34801561049857600080fd5b506104086114b9565b3480156104ad57600080fd5b5061030b6104bc36600461515c565b611577565b61030b6104cf3660046156b8565b611592565b61030b6104e23660046152dc565b611661565b61030b6104f53660046156d0565b611714565b34801561050657600080fd5b5061038a611894565b34801561051b57600080fd5b5061040861052a3660046156b8565b6118b8565b34801561053b57600080fd5b5061038a61054a3660046156b8565b6118ce565b34801561055b57600080fd5b5061035d6118f6565b34801561057057600080fd5b5061040861057f3660046150af565b6118fb565b61030b6105923660046152dc565b611963565b6105aa6105a5366004615550565b611e0f565b60405161033f9493929190615b1e565b3480156105c657600080fd5b5061035d612370565b3480156105db57600080fd5b506105ef6105ea3660046156b8565b6123d1565b60405161033f9c9b9a99989796959493929190615b50565b34801561061357600080fd5b5061030b610622366004615243565b612600565b61030b6106353660046152dc565b612723565b61064d610648366004615337565b6127d5565b60405161033f91906158a0565b34801561066657600080fd5b5061030b61067536600461519c565b612915565b61030b6106883660046152dc565b612973565b34801561069957600080fd5b5061038a612a1b565b3480156106ae57600080fd5b5061035d6106bd3660046156b8565b612a3f565b3480156106ce57600080fd5b5061030b6106dd366004615717565b612b0e565b61030b6106f036600461529b565b612b8c565b34801561070157600080fd5b506103326107103660046150cb565b612c6f565b61030b6107233660046152dc565b612c9d565b6103ca61073636600461546c565b612d28565b7fffffffff00000000000000000000000000000000000000000000000000000000811660009081526020819052604090205460ff165b919050565b60068054604080516020601f60026000196101006001881615020190951694909404938401819004810282018101909252828152606093909290918301828280156108025780601f106107d757610100808354040283529160200191610802565b820191906000526020600020905b8154815290600101906020018083116107e557829003601f168201915b5050505050905090565b600061081782613246565b61083c5760405162461bcd60e51b8152600401610833906159bb565b60405180910390fd5b506000908152600c60205260409020546c0100000000000000000000000090046001600160a01b031690565b6000610873826118ce565b9050806001600160a01b0316836001600160a01b031614156108c65760405162461bcd60e51b8152600401808060200182810382526021815260200180615ee26021913960400191505060405180910390fd5b806001600160a01b03166108d8613253565b6001600160a01b031614806108f457506108f481610710613253565b61092f5760405162461bcd60e51b8152600401808060200182810382526038815260200180615e0c6038913960400191505060405180910390fd5b6109398383613257565b505050565b600080823561094d33826132db565b6109695760405162461bcd60e51b815260040161083390615984565b836080013580610977613377565b11156109ca576040805162461bcd60e51b815260206004820152601360248201527f5472616e73616374696f6e20746f6f206f6c6400000000000000000000000000604482015290519081900360640190fd5b60006109dc6040870160208801615562565b6001600160801b0316116109ef57600080fd5b84356000908152600c602090815260409182902060018101549092600160801b9091046001600160801b031691610a2a918901908901615562565b6001600160801b0316816001600160801b03161015610a4857600080fd5b60018281015469ffffffffffffffffffff166000908152600b60209081526040808320815160608101835281546001600160a01b039081168252919095015490811692850192909252600160a01b90910462ffffff1690830152610acc7f00000000000000000000000000000000000000000000000000000000000000008361337b565b60018501549091506001600160a01b0382169063a34123a7906a01000000000000000000008104600290810b91600160681b9004900b610b1260408e0160208f01615562565b6040518463ffffffff1660e01b8152600401610b309392919061594b565b6040805180830381600087803b158015610b4957600080fd5b505af1158015610b5d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b8191906156f4565b909850965060408901358810801590610b9e575088606001358710155b610bba5760405162461bcd60e51b815260040161083390615a18565b6001840154600090610bea9030906a01000000000000000000008104600290810b91600160681b9004900b613477565b9050600080836001600160a01b031663514ea4bf846040518263ffffffff1660e01b8152600401610c1b9190615929565b60a06040518083038186803b158015610c3357600080fd5b505afa158015610c47573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c6b91906155ac565b50509250925050610c9087600201548303876001600160801b0316600160801b6134d1565b6004880180546fffffffffffffffffffffffffffffffff198116928e016001600160801b039182160181169290921790556003880154610cda91908303908816600160801b6134d1565b6004880180546001600160801b03808216938e01600160801b9283900482160116029190911790556002870182905560038701819055610d2060408d0160208e01615562565b86038760010160106101000a8154816001600160801b0302191690836001600160801b031602179055508b600001357f26f6a048ee9138f2c0ce266f322cb99228e8d619ae2bff30c67f8dcf9d2377b48d6020016020810190610d839190615562565b8d8d604051610d9493929190615afd565b60405180910390a2505050505050505050915091565b4715610dba57610dba3347613580565b565b6000836001600160a01b0316856001600160a01b031610610ddc57600080fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316631698ee828686866040518463ffffffff1660e01b815260040180846001600160a01b03168152602001836001600160a01b031681526020018262ffffff168152602001935050505060206040518083038186803b158015610e6757600080fd5b505afa158015610e7b573d6000803e3d6000fd5b505050506040513d6020811015610e9157600080fd5b505190506001600160a01b038116610fe0577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663a16712958686866040518463ffffffff1660e01b815260040180846001600160a01b03168152602001836001600160a01b031681526020018262ffffff1681526020019350505050602060405180830381600087803b158015610f3057600080fd5b505af1158015610f44573d6000803e3d6000fd5b505050506040513d6020811015610f5a57600080fd5b5051604080517ff637731d0000000000000000000000000000000000000000000000000000000081526001600160a01b03858116600483015291519293509083169163f637731d9160248082019260009290919082900301818387803b158015610fc357600080fd5b505af1158015610fd7573d6000803e3d6000fd5b505050506110c1565b6000816001600160a01b0316633850c7bd6040518163ffffffff1660e01b815260040160e06040518083038186803b15801561101b57600080fd5b505afa15801561102f573d6000803e3d6000fd5b505050506040513d60e081101561104557600080fd5b505190506001600160a01b0381166110bf57816001600160a01b031663f637731d846040518263ffffffff1660e01b815260040180826001600160a01b03168152602001915050600060405180830381600087803b1580156110a657600080fd5b505af11580156110ba573d6000803e3d6000fd5b505050505b505b949350505050565b60006110d56002613689565b905090565b60008060008360a00135806110ed613377565b1115611140576040805162461bcd60e51b815260206004820152601360248201527f5472616e73616374696f6e20746f6f206f6c6400000000000000000000000000604482015290519081900360640190fd5b84356000908152600c6020908152604080832060018082015469ffffffffffffffffffff81168652600b855283862084516060808201875282546001600160a01b039081168352929094015480831682890190815262ffffff600160a01b9092048216838901908152885161014081018a528451861681529151909416818a01529251168287015230828501526a01000000000000000000008304600290810b810b608080850191909152600160681b909404810b900b60a0830152958c013560c0820152938b013560e0850152908a0135610100840152890135610120830152929061122c90613694565b6001870154939a50919850965091506000906112669030906a01000000000000000000008104600290810b91600160681b9004900b613477565b9050600080836001600160a01b031663514ea4bf846040518263ffffffff1660e01b81526004016112979190615929565b60a06040518083038186803b1580156112af57600080fd5b505afa1580156112c3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112e791906155ac565b50509250925050611323866002015483038760010160109054906101000a90046001600160801b03166001600160801b0316600160801b6134d1565b6004870180546001600160801b0380821690930183166fffffffffffffffffffffffffffffffff19909116179055600387015460018801546113739291840391600160801b9182900416906134d1565b6004870180546001600160801b03600160801b80830482169094018116840291811691909117909155600288018490556003880183905560018801805483810483168e018316909302929091169190911790556040518b35907f3067048beee31b25b2f1681f88dac838c8bba36af25bfb2b7cf7473a5847e35f906113fd908d908d908d90615afd565b60405180910390a2505050505050509193909250565b61142461141e613253565b826132db565b61145f5760405162461bcd60e51b8152600401808060200182810382526031815260200180615f036031913960400191505060405180910390fd5b6109398383836138cf565b6001600160a01b038216600090815260016020526040812061148c9083613a1b565b90505b92915050565b7f49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad81565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f7f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000611526613a27565b3060405160200180868152602001858152602001848152602001838152602001826001600160a01b031681526020019550505050505060405160208183030381529060405280519060200120905090565b61093983838360405180602001604052806000815250612915565b8061159d33826132db565b6115b95760405162461bcd60e51b815260040161083390615984565b6000828152600c602052604090206001810154600160801b90046001600160801b03161580156115f4575060048101546001600160801b0316155b801561161257506004810154600160801b90046001600160801b0316155b61162e5760405162461bcd60e51b815260040161083390615a86565b6000838152600c602052604081208181556001810182905560028101829055600381018290556004015561093983613a2b565b604080517f8fcbaf0c00000000000000000000000000000000000000000000000000000000815233600482015230602482015260448101879052606481018690526001608482015260ff851660a482015260c4810184905260e4810183905290516001600160a01b03881691638fcbaf0c9161010480830192600092919082900301818387803b1580156116f457600080fd5b505af1158015611708573d6000803e3d6000fd5b50505050505050505050565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166370a08231306040518263ffffffff1660e01b815260040180826001600160a01b0316815260200191505060206040518083038186803b15801561178357600080fd5b505afa158015611797573d6000803e3d6000fd5b505050506040513d60208110156117ad57600080fd5b5051905082811015611806576040805162461bcd60e51b815260206004820152601260248201527f496e73756666696369656e742057455448390000000000000000000000000000604482015290519081900360640190fd5b8015610939577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316632e1a7d4d826040518263ffffffff1660e01b815260040180828152602001915050600060405180830381600087803b15801561187257600080fd5b505af1158015611886573d6000803e3d6000fd5b505050506109398282613580565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000806118c6600284613af8565b509392505050565b600061148f82604051806060016040528060298152602001615e6e6029913960029190613b16565b606090565b60006001600160a01b0382166119425760405162461bcd60e51b815260040180806020018281038252602a815260200180615e44602a913960400191505060405180910390fd5b6001600160a01b038216600090815260016020526040902061148f90613689565b8361196c613377565b11156119bf576040805162461bcd60e51b815260206004820152600e60248201527f5065726d69742065787069726564000000000000000000000000000000000000604482015290519081900360640190fd5b60006119c96114b9565b7f49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad88886119f581613b23565b604080516020808201969096526001600160a01b03909416848201526060840192909252608083015260a08083018a90528151808403909101815260c0830182528051908401207f190100000000000000000000000000000000000000000000000000000000000060e084015260e283019490945261010280830194909452805180830390940184526101229091019052815191012090506000611a98876118ce565b9050806001600160a01b0316886001600160a01b03161415611aeb5760405162461bcd60e51b8152600401808060200182810382526027815260200180615d6f6027913960400191505060405180910390fd5b611af481613b62565b15611ccf576040805160208082018790528183018690527fff0000000000000000000000000000000000000000000000000000000000000060f889901b16606083015282516041818403018152606183018085527f1626ba7e0000000000000000000000000000000000000000000000000000000090526065830186815260858401948552815160a585015281516001600160a01b03871695631626ba7e958995919260c59091019185019080838360005b83811015611bbe578181015183820152602001611ba6565b50505050905090810190601f168015611beb5780820380516001836020036101000a031916815260200191505b50935050505060206040518083038186803b158015611c0957600080fd5b505afa158015611c1d573d6000803e3d6000fd5b505050506040513d6020811015611c3357600080fd5b50517fffffffff00000000000000000000000000000000000000000000000000000000167f1626ba7e0000000000000000000000000000000000000000000000000000000014611cca576040805162461bcd60e51b815260206004820152600c60248201527f556e617574686f72697a65640000000000000000000000000000000000000000604482015290519081900360640190fd5b611dfb565b600060018387878760405160008152602001604052604051808581526020018460ff1681526020018381526020018281526020019450505050506020604051602081039080840390855afa158015611d2b573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116611d93576040805162461bcd60e51b815260206004820152601160248201527f496e76616c6964207369676e6174757265000000000000000000000000000000604482015290519081900360640190fd5b816001600160a01b0316816001600160a01b031614611df9576040805162461bcd60e51b815260206004820152600c60248201527f556e617574686f72697a65640000000000000000000000000000000000000000604482015290519081900360640190fd5b505b611e058888613257565b5050505050505050565b60008060008084610140013580611e24613377565b1115611e77576040805162461bcd60e51b815260206004820152601360248201527f5472616e73616374696f6e20746f6f206f6c6400000000000000000000000000604482015290519081900360640190fd5b604080516101408101909152600090611f439080611e9860208b018b6150af565b6001600160a01b03168152602001896020016020810190611eb991906150af565b6001600160a01b03168152602001611ed760608b0160408c0161569e565b62ffffff168152306020820152604001611ef760808b0160608c016153e6565b60020b8152602001611f0f60a08b0160808c016153e6565b60020b81526020018960a0013581526020018960c0013581526020018960e001358152602001896101000135815250613694565b92975090955093509050611fb7611f6261014089016101208a016150af565b600d80547fffffffffffffffffffff000000000000000000000000000000000000000000008116600175ffffffffffffffffffffffffffffffffffffffffffff92831690810190921617909155975087613b68565b6000611fe230611fcd60808b0160608c016153e6565b611fdd60a08c0160808d016153e6565b613477565b9050600080836001600160a01b031663514ea4bf846040518263ffffffff1660e01b81526004016120139190615929565b60a06040518083038186803b15801561202b57600080fd5b505afa15801561203f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061206391906155ac565b5050925092505060006120dc8560405180606001604052808e600001602081019061208e91906150af565b6001600160a01b031681526020018e60200160208101906120af91906150af565b6001600160a01b031681526020018e60400160208101906120d0919061569e565b62ffffff169052613c96565b905060405180610140016040528060006bffffffffffffffffffffffff16815260200160006001600160a01b031681526020018269ffffffffffffffffffff1681526020018c606001602081019061213491906153e6565b60020b815260200161214c60a08e0160808f016153e6565b60020b81526020018a6001600160801b0316815260200184815260200183815260200160006001600160801b0316815260200160006001600160801b0316815250600c60008c815260200190815260200160002060008201518160000160006101000a8154816bffffffffffffffffffffffff02191690836bffffffffffffffffffffffff160217905550602082015181600001600c6101000a8154816001600160a01b0302191690836001600160a01b0316021790555060408201518160010160006101000a81548169ffffffffffffffffffff021916908369ffffffffffffffffffff160217905550606082015181600101600a6101000a81548162ffffff021916908360020b62ffffff160217905550608082015181600101600d6101000a81548162ffffff021916908360020b62ffffff16021790555060a08201518160010160106101000a8154816001600160801b0302191690836001600160801b0316021790555060c0820151816002015560e082015181600301556101008201518160040160006101000a8154816001600160801b0302191690836001600160801b031602179055506101208201518160040160106101000a8154816001600160801b0302191690836001600160801b03160217905550905050897f3067048beee31b25b2f1681f88dac838c8bba36af25bfb2b7cf7473a5847e35f8a8a8a60405161235b93929190615afd565b60405180910390a25050505050509193509193565b60078054604080516020601f60026000196101006001881615020190951694909404938401819004810282018101909252828152606093909290918301828280156108025780601f106107d757610100808354040283529160200191610802565b6000818152600c6020908152604080832081516101408101835281546bffffffffffffffffffffffff811682526001600160a01b036c010000000000000000000000009091041693810193909352600181015469ffffffffffffffffffff81169284018390526a01000000000000000000008104600290810b810b810b6060860152600160681b8204810b810b810b60808601526001600160801b03600160801b92839004811660a08701529083015460c0860152600383015460e0860152600490920154808316610100860152041661012083015282918291829182918291829182918291829182918291906124da5760405162461bcd60e51b815260040161083390615a4f565b6000600b6000836040015169ffffffffffffffffffff1669ffffffffffffffffffff1681526020019081526020016000206040518060600160405290816000820160009054906101000a90046001600160a01b03166001600160a01b03166001600160a01b031681526020016001820160009054906101000a90046001600160a01b03166001600160a01b03166001600160a01b031681526020016001820160149054906101000a900462ffffff1662ffffff1662ffffff1681525050905081600001518260200151826000015183602001518460400151866060015187608001518860a001518960c001518a60e001518b61010001518c61012001519d509d509d509d509d509d509d509d509d509d509d509d50505091939597999b5091939597999b565b612608613253565b6001600160a01b0316826001600160a01b0316141561266e576040805162461bcd60e51b815260206004820152601960248201527f4552433732313a20617070726f766520746f2063616c6c657200000000000000604482015290519081900360640190fd5b806005600061267b613253565b6001600160a01b0390811682526020808301939093526040918201600090812091871680825291909352912080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016921515929092179091556126dd613253565b6001600160a01b03167f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c318360405180821515815260200191505060405180910390a35050565b604080517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523360048201523060248201529051600019916001600160a01b0389169163dd62ed3e91604480820192602092909190829003018186803b15801561278d57600080fd5b505afa1580156127a1573d6000803e3d6000fd5b505050506040513d60208110156127b757600080fd5b505110156127cd576127cd868686868686611661565b505050505050565b60608167ffffffffffffffff811180156127ee57600080fd5b5060405190808252806020026020018201604052801561282257816020015b606081526020019060019003908161280d5790505b50905060005b8281101561290e576000803086868581811061284057fe5b90506020028101906128529190615bef565b6040516128609291906157d2565b600060405180830381855af49150503d806000811461289b576040519150601f19603f3d011682016040523d82523d6000602084013e6128a0565b606091505b5091509150816128ec576044815110156128b957600080fd5b600481019050808060200190518101906128d39190615402565b60405162461bcd60e51b81526004016108339190615971565b808484815181106128f957fe5b60209081029190910101525050600101612828565b5092915050565b612926612920613253565b836132db565b6129615760405162461bcd60e51b8152600401808060200182810382526031815260200180615f036031913960400191505060405180910390fd5b61296d84848484613de6565b50505050565b604080517fdd62ed3e000000000000000000000000000000000000000000000000000000008152336004820152306024820152905186916001600160a01b0389169163dd62ed3e91604480820192602092909190829003018186803b1580156129db57600080fd5b505afa1580156129ef573d6000803e3d6000fd5b505050506040513d6020811015612a0557600080fd5b505110156127cd576127cd868686868686612c9d565b7f000000000000000000000000000000000000000000000000000000000000000081565b6060612a4a82613246565b612a5357600080fd5b6040517fe9dc63750000000000000000000000000000000000000000000000000000000081526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063e9dc637590612aba9030908690600401615932565b60006040518083038186803b158015612ad257600080fd5b505afa158015612ae6573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261148f9190810190615402565b6000612b1c828401846154a5565b9050612b4c7f00000000000000000000000000000000000000000000000000000000000000008260000151613e38565b508415612b67578051516020820151612b6791903388613e5b565b8315612b8557612b8581600001516020015182602001513387613e5b565b5050505050565b6000836001600160a01b03166370a08231306040518263ffffffff1660e01b815260040180826001600160a01b0316815260200191505060206040518083038186803b158015612bdb57600080fd5b505afa158015612bef573d6000803e3d6000fd5b505050506040513d6020811015612c0557600080fd5b5051905082811015612c5e576040805162461bcd60e51b815260206004820152601260248201527f496e73756666696369656e7420746f6b656e0000000000000000000000000000604482015290519081900360640190fd5b801561296d5761296d848383613feb565b6001600160a01b03918216600090815260056020908152604080832093909416825291909152205460ff1690565b604080517fd505accf000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018790526064810186905260ff8516608482015260a4810184905260c4810183905290516001600160a01b0388169163d505accf9160e480830192600092919082900301818387803b1580156116f457600080fd5b6000808235612d3733826132db565b612d535760405162461bcd60e51b815260040161083390615984565b6000612d656060860160408701615562565b6001600160801b03161180612d9257506000612d876080860160608701615562565b6001600160801b0316115b612d9b57600080fd5b600080612dae60408701602088016150af565b6001600160a01b031614612dd157612dcc60408601602087016150af565b612dd3565b305b85356000908152600c6020908152604080832060018082015469ffffffffffffffffffff168552600b8452828520835160608101855281546001600160a01b039081168252919092015490811694820194909452600160a01b90930462ffffff169183019190915292935090612e697f00000000000000000000000000000000000000000000000000000000000000008361337b565b600484015460018501549192506001600160801b0380821692600160801b92839004821692900416156130865760018501546040517fa34123a70000000000000000000000000000000000000000000000000000000081526001600160a01b0385169163a34123a791612f00916a01000000000000000000008104600290810b92600160681b909204900b9060009060040161594b565b6040805180830381600087803b158015612f1957600080fd5b505af1158015612f2d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f5191906156f4565b5050600185015460009081906001600160a01b0386169063514ea4bf90612f969030906a01000000000000000000008104600290810b91600160681b9004900b613477565b6040518263ffffffff1660e01b8152600401612fb29190615929565b60a06040518083038186803b158015612fca57600080fd5b505afa158015612fde573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061300291906155ac565b5050925092505061303e876002015483038860010160109054906101000a90046001600160801b03166001600160801b0316600160801b6134d1565b84019350613077876003015482038860010160109054906101000a90046001600160801b03166001600160801b0316600160801b6134d1565b60028801929092556003870155015b6000806001600160801b0384166130a360608e0160408f01615562565b6001600160801b0316116130c6576130c160608d0160408e01615562565b6130c8565b835b836001600160801b03168d60600160208101906130e59190615562565b6001600160801b0316116131085761310360808e0160608f01615562565b61310a565b835b60018901546040517f4f1eb3d80000000000000000000000000000000000000000000000000000000081529294509092506001600160a01b03871691634f1eb3d89161317d918c916a01000000000000000000008104600290810b92600160681b909204900b9088908890600401615839565b6040805180830381600087803b15801561319657600080fd5b505af11580156131aa573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131ce919061557e565b6004890180546fffffffffffffffffffffffffffffffff196001600160801b03918216600160801b878a0384160217168689038216179091556040519281169d50169a508c35907f40d0efd1a53d60ecbf40971b9daf7dc90178c3aadc7aab1765632738fa8b8f0190610d94908b9086908690615876565b600061148f60028361417b565b3390565b6000818152600c6020526040902080546bffffffffffffffffffffffff166c010000000000000000000000006001600160a01b0385169081029190911790915581906132a2826118ce565b6001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b60006132e682613246565b6133215760405162461bcd60e51b815260040180806020018281038252602c815260200180615de0602c913960400191505060405180910390fd5b600061332c836118ce565b9050806001600160a01b0316846001600160a01b031614806133675750836001600160a01b031661335c8461080c565b6001600160a01b0316145b806110c157506110c18185612c6f565b4290565b600081602001516001600160a01b031682600001516001600160a01b0316106133a357600080fd5b50805160208083015160409384015184516001600160a01b0394851681850152939091168385015262ffffff166060808401919091528351808403820181526080840185528051908301207fff0000000000000000000000000000000000000000000000000000000000000060a085015294901b6bffffffffffffffffffffffff191660a183015260b58201939093527fe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b5460d5808301919091528251808303909101815260f5909101909152805191012090565b604080516bffffffffffffffffffffffff19606086901b16602080830191909152600285810b60e890811b60348501529085900b901b60378301528251601a818403018152603a90920190925280519101205b9392505050565b600080806000198587098686029250828110908390030390508061350757600084116134fc57600080fd5b5082900490506134ca565b80841161351357600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150509392505050565b604080516000808252602082019092526001600160a01b0384169083906040518082805190602001908083835b602083106135cc5780518252601f1990920191602091820191016135ad565b6001836020036101000a03801982511681845116808217855250505050505090500191505060006040518083038185875af1925050503d806000811461362e576040519150601f19603f3d011682016040523d82523d6000602084013e613633565b606091505b5050905080610939576040805162461bcd60e51b815260206004820152600360248201527f5354450000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b600061148f82614187565b6000806000806000604051806060016040528087600001516001600160a01b0316815260200187602001516001600160a01b03168152602001876040015162ffffff1681525090506137067f00000000000000000000000000000000000000000000000000000000000000008261337b565b91506000826001600160a01b0316633850c7bd6040518163ffffffff1660e01b815260040160e06040518083038186803b15801561374357600080fd5b505afa158015613757573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061377b919061560d565b50505050505090506000613792886080015161418b565b905060006137a38960a0015161418b565b90506137ba8383838c60c001518d60e001516144d9565b9750505050816001600160a01b0316633c8a7d8d876060015188608001518960a00151896040518060400160405280888152602001336001600160a01b031681525060405160200161380c9190615abd565b6040516020818303038152906040526040518663ffffffff1660e01b815260040161383b9594939291906157f6565b6040805180830381600087803b15801561385457600080fd5b505af1158015613868573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061388c91906156f4565b610100880151919550935084108015906138ab57508561012001518310155b6138c75760405162461bcd60e51b815260040161083390615a18565b509193509193565b826001600160a01b03166138e2826118ce565b6001600160a01b0316146139275760405162461bcd60e51b8152600401808060200182810382526029815260200180615eb96029913960400191505060405180910390fd5b6001600160a01b03821661396c5760405162461bcd60e51b8152600401808060200182810382526024815260200180615d966024913960400191505060405180910390fd5b613977838383610939565b613982600082613257565b6001600160a01b03831660009081526001602052604090206139a4908261459d565b506001600160a01b03821660009081526001602052604090206139c790826145a9565b506139d4600282846145b5565b5080826001600160a01b0316846001600160a01b03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a4505050565b600061148c83836145cb565b4690565b6000613a36826118ce565b9050613a4481600084610939565b613a4f600083613257565b6000828152600860205260409020546002600019610100600184161502019091160415613a8d576000828152600860205260408120613a8d9161501f565b6001600160a01b0381166000908152600160205260409020613aaf908361459d565b50613abb60028361462f565b5060405182906000906001600160a01b038416907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908390a45050565b6000808080613b07868661463b565b909450925050505b9250929050565b60006110c18484846146b6565b6000908152600c6020526040902080546bffffffffffffffffffffffff19811660016bffffffffffffffffffffffff9283169081019092161790915590565b3b151590565b6001600160a01b038216613bc3576040805162461bcd60e51b815260206004820181905260248201527f4552433732313a206d696e7420746f20746865207a65726f2061646472657373604482015290519081900360640190fd5b613bcc81613246565b15613c1e576040805162461bcd60e51b815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e74656400000000604482015290519081900360640190fd5b613c2a60008383610939565b6001600160a01b0382166000908152600160205260409020613c4c90826145a9565b50613c59600282846145b5565b5060405181906001600160a01b038416906000907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a45050565b6001600160a01b0382166000908152600a602052604090205469ffffffffffffffffffff168061148f5750600d8054600169ffffffffffffffffffff76010000000000000000000000000000000000000000000080840482168381019092160275ffffffffffffffffffffffffffffffffffffffffffff909316929092179092556001600160a01b038085166000908152600a6020908152604080832080547fffffffffffffffffffffffffffffffffffffffffffff000000000000000000001686179055848352600b825291829020865181549085167fffffffffffffffffffffffff000000000000000000000000000000000000000091821617825591870151950180549287015162ffffff16600160a01b027fffffffffffffffffff000000ffffffffffffffffffffffffffffffffffffffff969094169290911691909117939093161790915592915050565b613df18484846138cf565b613dfd84848484614780565b61296d5760405162461bcd60e51b8152600401808060200182810382526032815260200180615d3d6032913960400191505060405180910390fd5b6000613e44838361337b565b9050336001600160a01b0382161461148f57600080fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316846001600160a01b0316148015613e9c5750804710155b15613fbe577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b158015613efc57600080fd5b505af1158015613f10573d6000803e3d6000fd5b50505050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663a9059cbb83836040518363ffffffff1660e01b815260040180836001600160a01b0316815260200182815260200192505050602060405180830381600087803b158015613f8c57600080fd5b505af1158015613fa0573d6000803e3d6000fd5b505050506040513d6020811015613fb657600080fd5b5061296d9050565b6001600160a01b038316301415613fdf57613fda848383613feb565b61296d565b61296d8484848461495c565b604080516001600160a01b038481166024830152604480830185905283518084039091018152606490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb000000000000000000000000000000000000000000000000000000001781529251825160009485949389169392918291908083835b602083106140955780518252601f199092019160209182019101614076565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d80600081146140f7576040519150601f19603f3d011682016040523d82523d6000602084013e6140fc565b606091505b509150915081801561412a57508051158061412a575080806020019051602081101561412757600080fd5b50515b612b85576040805162461bcd60e51b815260206004820152600260248201527f5354000000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b600061148c8383614af4565b5490565b60008060008360020b126141a2578260020b6141aa565b8260020b6000035b9050620d89e8811115614204576040805162461bcd60e51b815260206004820152600160248201527f5400000000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b60006001821661421857600160801b61422a565b6ffffcb933bd6fad37aa2d162d1a5940015b70ffffffffffffffffffffffffffffffffff169050600282161561425e576ffff97272373d413259a46990580e213a0260801c5b600482161561427d576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b600882161561429c576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b60108216156142bb576fffcb9843d60f6159c9db58835c9266440260801c5b60208216156142da576fff973b41fa98c081472e6896dfb254c00260801c5b60408216156142f9576fff2ea16466c96a3843ec78b326b528610260801c5b6080821615614318576ffe5dee046a99a2a811c461f1969c30530260801c5b610100821615614338576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b610200821615614358576ff987a7253ac413176f2b074cf7815e540260801c5b610400821615614378576ff3392b0822b70005940c7a398e4b70f30260801c5b610800821615614398576fe7159475a2c29b7443b29c7fa6e889d90260801c5b6110008216156143b8576fd097f3bdfd2022b8845ad8f792aa58250260801c5b6120008216156143d8576fa9f746462d870fdf8a65dc1f90e061e50260801c5b6140008216156143f8576f70d869a156d2a1b890bb3df62baf32f70260801c5b618000821615614418576f31be135f97d08fd981231505542fcfa60260801c5b62010000821615614439576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b62020000821615614459576e5d6af8dedb81196699c329225ee6040260801c5b62040000821615614478576d2216e584f5fa1ea926041bedfe980260801c5b62080000821615614495576b048a170391f7dc42444e8fa20260801c5b60008460020b13156144b05780600019816144ac57fe5b0490505b6401000000008106156144c45760016144c7565b60005b60ff16602082901c0192505050919050565b6000836001600160a01b0316856001600160a01b031611156144f9579293925b846001600160a01b0316866001600160a01b0316116145245761451d858585614b0c565b9050614594565b836001600160a01b0316866001600160a01b0316101561458657600061454b878686614b0c565b9050600061455a878986614b78565b9050806001600160801b0316826001600160801b03161061457b578061457d565b815b92505050614594565b614591858584614b78565b90505b95945050505050565b600061148c8383614bbe565b600061148c8383614c84565b60006110c184846001600160a01b038516614cce565b8154600090821061460d5760405162461bcd60e51b8152600401808060200182810382526022815260200180615d1b6022913960400191505060405180910390fd5b82600001828154811061461c57fe5b9060005260206000200154905092915050565b600061148c8383614d65565b81546000908190831061467f5760405162461bcd60e51b8152600401808060200182810382526022815260200180615e976022913960400191505060405180910390fd5b600084600001848154811061469057fe5b906000526020600020906002020190508060000154816001015492509250509250929050565b600082815260018401602052604081205482816147515760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156147165781810151838201526020016146fe565b50505050905090810190601f1680156147435780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5084600001600182038154811061476457fe5b9060005260206000209060020201600101549150509392505050565b6000614794846001600160a01b0316613b62565b6147a0575060016110c1565b60006148f17f150b7a02000000000000000000000000000000000000000000000000000000006147ce613253565b88878760405160240180856001600160a01b03168152602001846001600160a01b0316815260200183815260200180602001828103825283818151815260200191508051906020019080838360005b8381101561483557818101518382015260200161481d565b50505050905090810190601f1680156148625780820380516001836020036101000a031916815260200191505b5095505050505050604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050604051806060016040528060328152602001615d3d603291396001600160a01b0388169190614e39565b9050600081806020019051602081101561490a57600080fd5b50517fffffffff00000000000000000000000000000000000000000000000000000000167f150b7a02000000000000000000000000000000000000000000000000000000001492505050949350505050565b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f23b872dd00000000000000000000000000000000000000000000000000000000178152925182516000948594938a169392918291908083835b60208310614a0e5780518252601f1990920191602091820191016149ef565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114614a70576040519150601f19603f3d011682016040523d82523d6000602084013e614a75565b606091505b5091509150818015614aa3575080511580614aa35750808060200190516020811015614aa057600080fd5b50515b6127cd576040805162461bcd60e51b815260206004820152600360248201527f5354460000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b60009081526001919091016020526040902054151590565b6000826001600160a01b0316846001600160a01b03161115614b2c579192915b6000614b58856001600160a01b0316856001600160a01b03166c010000000000000000000000006134d1565b9050614594614b7384838888036001600160a01b03166134d1565b614e48565b6000826001600160a01b0316846001600160a01b03161115614b98579192915b6110c1614b73836c010000000000000000000000008787036001600160a01b03166134d1565b60008181526001830160205260408120548015614c7a5783546000198083019190810190600090879083908110614bf157fe5b9060005260206000200154905080876000018481548110614c0e57fe5b600091825260208083209091019290925582815260018981019092526040902090840190558654879080614c3e57fe5b6001900381819060005260206000200160009055905586600101600087815260200190815260200160002060009055600194505050505061148f565b600091505061148f565b6000614c908383614af4565b614cc65750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915561148f565b50600061148f565b600082815260018401602052604081205480614d335750506040805180820182528381526020808201848152865460018181018955600089815284812095516002909302909501918255915190820155865486845281880190925292909120556134ca565b82856000016001830381548110614d4657fe5b90600052602060002090600202016001018190555060009150506134ca565b60008181526001830160205260408120548015614c7a5783546000198083019190810190600090879083908110614d9857fe5b9060005260206000209060020201905080876000018481548110614db857fe5b600091825260208083208454600290930201918255600193840154918401919091558354825289830190526040902090840190558654879080614df757fe5b600082815260208082206002600019909401938402018281556001908101839055929093558881528982019092526040822091909155945061148f9350505050565b60606110c18484600085614e5e565b806001600160801b038116811461077157600080fd5b606082471015614e9f5760405162461bcd60e51b8152600401808060200182810382526026815260200180615dba6026913960400191505060405180910390fd5b614ea885613b62565b614ef9576040805162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015290519081900360640190fd5b600080866001600160a01b031685876040518082805190602001908083835b60208310614f375780518252601f199092019160209182019101614f18565b6001836020036101000a03801982511681845116808217855250505050505090500191505060006040518083038185875af1925050503d8060008114614f99576040519150601f19603f3d011682016040523d82523d6000602084013e614f9e565b606091505b5091509150614fae828286614fb9565b979650505050505050565b60608315614fc85750816134ca565b825115614fd85782518084602001fd5b60405162461bcd60e51b81526020600482018181528451602484015284518593919283926044019190850190808383600083156147165781810151838201526020016146fe565b50805460018160011615610100020316600290046000825580601f106150455750615063565b601f0160209004906000526020600020908101906150639190615066565b50565b5b8082111561507b5760008155600101615067565b5090565b803561077181615cc4565b805161ffff8116811461077157600080fd5b803562ffffff8116811461077157600080fd5b6000602082840312156150c0578081fd5b81356134ca81615cc4565b600080604083850312156150dd578081fd5b82356150e881615cc4565b915060208301356150f881615cc4565b809150509250929050565b60008060008060808587031215615118578182fd5b843561512381615cc4565b9350602085013561513381615cc4565b92506151416040860161509c565b9150606085013561515181615cc4565b939692955090935050565b600080600060608486031215615170578081fd5b833561517b81615cc4565b9250602084013561518b81615cc4565b929592945050506040919091013590565b600080600080608085870312156151b1578182fd5b84356151bc81615cc4565b935060208501356151cc81615cc4565b925060408501359150606085013567ffffffffffffffff8111156151ee578182fd5b8501601f810187136151fe578182fd5b803561521161520c82615c76565b615c52565b818152886020838501011115615225578384fd5b81602084016020830137908101602001929092525092959194509250565b60008060408385031215615255578182fd5b823561526081615cc4565b915060208301356150f881615cd9565b60008060408385031215615282578182fd5b823561528d81615cc4565b946020939093013593505050565b6000806000606084860312156152af578081fd5b83356152ba81615cc4565b92506020840135915060408401356152d181615cc4565b809150509250925092565b60008060008060008060c087890312156152f4578384fd5b86356152ff81615cc4565b95506020870135945060408701359350606087013561531d81615d0b565b9598949750929560808101359460a0909101359350915050565b60008060208385031215615349578182fd5b823567ffffffffffffffff80821115615360578384fd5b818501915085601f830112615373578384fd5b813581811115615381578485fd5b8660208083028501011115615394578485fd5b60209290920196919550909350505050565b6000602082840312156153b7578081fd5b81357fffffffff00000000000000000000000000000000000000000000000000000000811681146134ca578182fd5b6000602082840312156153f7578081fd5b81356134ca81615ce7565b600060208284031215615413578081fd5b815167ffffffffffffffff811115615429578182fd5b8201601f81018413615439578182fd5b805161544761520c82615c76565b81815285602083850101111561545b578384fd5b614594826020830160208601615c98565b60006080828403121561547d578081fd5b50919050565b600060a0828403121561547d578081fd5b600060c0828403121561547d578081fd5b600081830360808112156154b7578182fd5b6040516040810167ffffffffffffffff82821081831117156154d557fe5b8160405260608412156154e6578485fd5b60a08301935081841081851117156154fa57fe5b50826040528435925061550c83615cc4565b91825260208401359161551e83615cc4565b8260608301526155306040860161509c565b608083015281526155436060850161507f565b6020820152949350505050565b6000610160828403121561547d578081fd5b600060208284031215615573578081fd5b81356134ca81615cf6565b60008060408385031215615590578182fd5b825161559b81615cf6565b60208401519092506150f881615cf6565b600080600080600060a086880312156155c3578283fd5b85516155ce81615cf6565b80955050602086015193506040860151925060608601516155ee81615cf6565b60808701519092506155ff81615cf6565b809150509295509295909350565b600080600080600080600060e0888a031215615627578485fd5b875161563281615cc4565b602089015190975061564381615ce7565b95506156516040890161508a565b945061565f6060890161508a565b935061566d6080890161508a565b925060a088015161567d81615d0b565b60c089015190925061568e81615cd9565b8091505092959891949750929550565b6000602082840312156156af578081fd5b61148c8261509c565b6000602082840312156156c9578081fd5b5035919050565b600080604083850312156156e2578182fd5b8235915060208301356150f881615cc4565b60008060408385031215615706578182fd5b505080516020909101519092909150565b6000806000806060858703121561572c578182fd5b8435935060208501359250604085013567ffffffffffffffff80821115615751578384fd5b818701915087601f830112615764578384fd5b813581811115615772578485fd5b886020828501011115615783578485fd5b95989497505060200194505050565b600081518084526157aa816020860160208601615c98565b601f01601f19169290920160200192915050565b60020b9052565b6001600160801b03169052565b6000828483379101908152919050565b6001600160a01b0391909116815260200190565b60006001600160a01b03871682528560020b60208301528460020b60408301526001600160801b038416606083015260a06080830152614fae60a0830184615792565b6001600160a01b03959095168552600293840b60208601529190920b60408401526001600160801b03918216606084015216608082015260a00190565b6001600160a01b039390931683526001600160801b03918216602084015216604082015260600190565b6000602080830181845280855180835260408601915060408482028701019250838701855b82811015615911577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08886030184526158ff858351615792565b945092850192908501906001016158c5565b5092979650505050505050565b901515815260200190565b90815260200190565b6001600160a01b03929092168252602082015260400190565b600293840b81529190920b60208201526001600160801b03909116604082015260600190565b60006020825261148c6020830184615792565b6020808252600c908201527f4e6f7420617070726f7665640000000000000000000000000000000000000000604082015260600190565b6020808252602c908201527f4552433732313a20617070726f76656420717565727920666f72206e6f6e657860408201527f697374656e7420746f6b656e0000000000000000000000000000000000000000606082015260800190565b60208082526014908201527f507269636520736c69707061676520636865636b000000000000000000000000604082015260600190565b60208082526010908201527f496e76616c696420746f6b656e20494400000000000000000000000000000000604082015260600190565b6020808252600b908201527f4e6f7420636c6561726564000000000000000000000000000000000000000000604082015260600190565b815180516001600160a01b03908116835260208083015182168185015260409283015162ffffff1692840192909252920151909116606082015260800190565b6001600160801b039390931683526020830191909152604082015260600190565b9384526001600160801b039290921660208401526040830152606082015260800190565b918252602082015260400190565b6bffffffffffffffffffffffff8d1681526001600160a01b038c811660208301528b811660408301528a16606082015262ffffff89166080820152600288900b60a08201526101808101615ba760c08301896157be565b615bb460e08301886157c5565b8561010083015284610120830152615bd06101408301856157c5565b615bde6101608301846157c5565b9d9c50505050505050505050505050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112615c23578283fd5b83018035915067ffffffffffffffff821115615c3d578283fd5b602001915036819003821315613b0f57600080fd5b60405181810167ffffffffffffffff81118282101715615c6e57fe5b604052919050565b600067ffffffffffffffff821115615c8a57fe5b50601f01601f191660200190565b60005b83811015615cb3578181015183820152602001615c9b565b8381111561296d5750506000910152565b6001600160a01b038116811461506357600080fd5b801515811461506357600080fd5b8060020b811461506357600080fd5b6001600160801b038116811461506357600080fd5b60ff8116811461506357600080fdfe456e756d657261626c655365743a20696e646578206f7574206f6620626f756e64734552433732313a207472616e7366657220746f206e6f6e20455243373231526563656976657220696d706c656d656e7465724552433732315065726d69743a20617070726f76616c20746f2063757272656e74206f776e65724552433732313a207472616e7366657220746f20746865207a65726f2061646472657373416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c6c4552433732313a206f70657261746f7220717565727920666f72206e6f6e6578697374656e7420746f6b656e4552433732313a20617070726f76652063616c6c6572206973206e6f74206f776e6572206e6f7220617070726f76656420666f7220616c6c4552433732313a2062616c616e636520717565727920666f7220746865207a65726f20616464726573734552433732313a206f776e657220717565727920666f72206e6f6e6578697374656e7420746f6b656e456e756d657261626c654d61703a20696e646578206f7574206f6620626f756e64734552433732313a207472616e73666572206f6620746f6b656e2074686174206973206e6f74206f776e4552433732313a20617070726f76616c20746f2063757272656e74206f776e65724552433732313a207472616e736665722063616c6c6572206973206e6f74206f776e6572206e6f7220617070726f766564a164736f6c6343000706000a";
const deployedBytecode$a = "0x6080604052600436106102895760003560e01c80636352211e11610153578063ac9650d8116100cb578063d34879971161007f578063e985e9c511610064578063e985e9c5146106f5578063f3995c6714610715578063fc6f7865146107285761030d565b8063d3487997146106c2578063df2ab5bb146106e25761030d565b8063c2e3140a116100b0578063c2e3140a1461067a578063c45a01551461068d578063c87b56dd146106a25761030d565b8063ac9650d81461063a578063b88d4fde1461065a5761030d565b8063883164561161012257806399fbab881161010757806399fbab88146105cf578063a22cb46514610607578063a4a78f0c146106275761030d565b8063883164561461059757806395d89b41146105ba5761030d565b80636352211e1461052f5780636c0360eb1461054f57806370a08231146105645780637ac2ff7b146105845761030d565b806323b872dd1161020157806342966c68116101b557806349404b7c1161019a57806349404b7c146104e75780634aa4a4fc146104fa5780634f6ccce71461050f5761030d565b806342966c68146104c15780634659a494146104d45761030d565b806330adf81f116101e657806330adf81f146104775780633644e5151461048c57806342842e0e146104a15761030d565b806323b872dd146104375780632f745c59146104575761030d565b80630c49ccbe1161025857806313ead5621161023d57806313ead562146103e057806318160ddd146103f3578063219f5d17146104155761030d565b80630c49ccbe146103b757806312210e8a146103d85761030d565b806301ffc9a71461031257806306fdde0314610348578063081812fc1461036a578063095ea7b3146103975761030d565b3661030d57336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461030b576040805162461bcd60e51b815260206004820152600960248201527f4e6f742057455448390000000000000000000000000000000000000000000000604482015290519081900360640190fd5b005b600080fd5b34801561031e57600080fd5b5061033261032d3660046153a6565b61073b565b60405161033f919061591e565b60405180910390f35b34801561035457600080fd5b5061035d610776565b60405161033f9190615971565b34801561037657600080fd5b5061038a6103853660046156b8565b61080c565b60405161033f91906157e2565b3480156103a357600080fd5b5061030b6103b2366004615270565b610868565b6103ca6103c5366004615483565b61093e565b60405161033f929190615b42565b61030b610daa565b61038a6103ee366004615103565b610dbc565b3480156103ff57600080fd5b506104086110c9565b60405161033f9190615929565b610428610423366004615494565b6110da565b60405161033f93929190615afd565b34801561044357600080fd5b5061030b61045236600461515c565b611413565b34801561046357600080fd5b50610408610472366004615270565b61146a565b34801561048357600080fd5b50610408611495565b34801561049857600080fd5b506104086114b9565b3480156104ad57600080fd5b5061030b6104bc36600461515c565b611577565b61030b6104cf3660046156b8565b611592565b61030b6104e23660046152dc565b611661565b61030b6104f53660046156d0565b611714565b34801561050657600080fd5b5061038a611894565b34801561051b57600080fd5b5061040861052a3660046156b8565b6118b8565b34801561053b57600080fd5b5061038a61054a3660046156b8565b6118ce565b34801561055b57600080fd5b5061035d6118f6565b34801561057057600080fd5b5061040861057f3660046150af565b6118fb565b61030b6105923660046152dc565b611963565b6105aa6105a5366004615550565b611e0f565b60405161033f9493929190615b1e565b3480156105c657600080fd5b5061035d612370565b3480156105db57600080fd5b506105ef6105ea3660046156b8565b6123d1565b60405161033f9c9b9a99989796959493929190615b50565b34801561061357600080fd5b5061030b610622366004615243565b612600565b61030b6106353660046152dc565b612723565b61064d610648366004615337565b6127d5565b60405161033f91906158a0565b34801561066657600080fd5b5061030b61067536600461519c565b612915565b61030b6106883660046152dc565b612973565b34801561069957600080fd5b5061038a612a1b565b3480156106ae57600080fd5b5061035d6106bd3660046156b8565b612a3f565b3480156106ce57600080fd5b5061030b6106dd366004615717565b612b0e565b61030b6106f036600461529b565b612b8c565b34801561070157600080fd5b506103326107103660046150cb565b612c6f565b61030b6107233660046152dc565b612c9d565b6103ca61073636600461546c565b612d28565b7fffffffff00000000000000000000000000000000000000000000000000000000811660009081526020819052604090205460ff165b919050565b60068054604080516020601f60026000196101006001881615020190951694909404938401819004810282018101909252828152606093909290918301828280156108025780601f106107d757610100808354040283529160200191610802565b820191906000526020600020905b8154815290600101906020018083116107e557829003601f168201915b5050505050905090565b600061081782613246565b61083c5760405162461bcd60e51b8152600401610833906159bb565b60405180910390fd5b506000908152600c60205260409020546c0100000000000000000000000090046001600160a01b031690565b6000610873826118ce565b9050806001600160a01b0316836001600160a01b031614156108c65760405162461bcd60e51b8152600401808060200182810382526021815260200180615ee26021913960400191505060405180910390fd5b806001600160a01b03166108d8613253565b6001600160a01b031614806108f457506108f481610710613253565b61092f5760405162461bcd60e51b8152600401808060200182810382526038815260200180615e0c6038913960400191505060405180910390fd5b6109398383613257565b505050565b600080823561094d33826132db565b6109695760405162461bcd60e51b815260040161083390615984565b836080013580610977613377565b11156109ca576040805162461bcd60e51b815260206004820152601360248201527f5472616e73616374696f6e20746f6f206f6c6400000000000000000000000000604482015290519081900360640190fd5b60006109dc6040870160208801615562565b6001600160801b0316116109ef57600080fd5b84356000908152600c602090815260409182902060018101549092600160801b9091046001600160801b031691610a2a918901908901615562565b6001600160801b0316816001600160801b03161015610a4857600080fd5b60018281015469ffffffffffffffffffff166000908152600b60209081526040808320815160608101835281546001600160a01b039081168252919095015490811692850192909252600160a01b90910462ffffff1690830152610acc7f00000000000000000000000000000000000000000000000000000000000000008361337b565b60018501549091506001600160a01b0382169063a34123a7906a01000000000000000000008104600290810b91600160681b9004900b610b1260408e0160208f01615562565b6040518463ffffffff1660e01b8152600401610b309392919061594b565b6040805180830381600087803b158015610b4957600080fd5b505af1158015610b5d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b8191906156f4565b909850965060408901358810801590610b9e575088606001358710155b610bba5760405162461bcd60e51b815260040161083390615a18565b6001840154600090610bea9030906a01000000000000000000008104600290810b91600160681b9004900b613477565b9050600080836001600160a01b031663514ea4bf846040518263ffffffff1660e01b8152600401610c1b9190615929565b60a06040518083038186803b158015610c3357600080fd5b505afa158015610c47573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c6b91906155ac565b50509250925050610c9087600201548303876001600160801b0316600160801b6134d1565b6004880180546fffffffffffffffffffffffffffffffff198116928e016001600160801b039182160181169290921790556003880154610cda91908303908816600160801b6134d1565b6004880180546001600160801b03808216938e01600160801b9283900482160116029190911790556002870182905560038701819055610d2060408d0160208e01615562565b86038760010160106101000a8154816001600160801b0302191690836001600160801b031602179055508b600001357f26f6a048ee9138f2c0ce266f322cb99228e8d619ae2bff30c67f8dcf9d2377b48d6020016020810190610d839190615562565b8d8d604051610d9493929190615afd565b60405180910390a2505050505050505050915091565b4715610dba57610dba3347613580565b565b6000836001600160a01b0316856001600160a01b031610610ddc57600080fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316631698ee828686866040518463ffffffff1660e01b815260040180846001600160a01b03168152602001836001600160a01b031681526020018262ffffff168152602001935050505060206040518083038186803b158015610e6757600080fd5b505afa158015610e7b573d6000803e3d6000fd5b505050506040513d6020811015610e9157600080fd5b505190506001600160a01b038116610fe0577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663a16712958686866040518463ffffffff1660e01b815260040180846001600160a01b03168152602001836001600160a01b031681526020018262ffffff1681526020019350505050602060405180830381600087803b158015610f3057600080fd5b505af1158015610f44573d6000803e3d6000fd5b505050506040513d6020811015610f5a57600080fd5b5051604080517ff637731d0000000000000000000000000000000000000000000000000000000081526001600160a01b03858116600483015291519293509083169163f637731d9160248082019260009290919082900301818387803b158015610fc357600080fd5b505af1158015610fd7573d6000803e3d6000fd5b505050506110c1565b6000816001600160a01b0316633850c7bd6040518163ffffffff1660e01b815260040160e06040518083038186803b15801561101b57600080fd5b505afa15801561102f573d6000803e3d6000fd5b505050506040513d60e081101561104557600080fd5b505190506001600160a01b0381166110bf57816001600160a01b031663f637731d846040518263ffffffff1660e01b815260040180826001600160a01b03168152602001915050600060405180830381600087803b1580156110a657600080fd5b505af11580156110ba573d6000803e3d6000fd5b505050505b505b949350505050565b60006110d56002613689565b905090565b60008060008360a00135806110ed613377565b1115611140576040805162461bcd60e51b815260206004820152601360248201527f5472616e73616374696f6e20746f6f206f6c6400000000000000000000000000604482015290519081900360640190fd5b84356000908152600c6020908152604080832060018082015469ffffffffffffffffffff81168652600b855283862084516060808201875282546001600160a01b039081168352929094015480831682890190815262ffffff600160a01b9092048216838901908152885161014081018a528451861681529151909416818a01529251168287015230828501526a01000000000000000000008304600290810b810b608080850191909152600160681b909404810b900b60a0830152958c013560c0820152938b013560e0850152908a0135610100840152890135610120830152929061122c90613694565b6001870154939a50919850965091506000906112669030906a01000000000000000000008104600290810b91600160681b9004900b613477565b9050600080836001600160a01b031663514ea4bf846040518263ffffffff1660e01b81526004016112979190615929565b60a06040518083038186803b1580156112af57600080fd5b505afa1580156112c3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112e791906155ac565b50509250925050611323866002015483038760010160109054906101000a90046001600160801b03166001600160801b0316600160801b6134d1565b6004870180546001600160801b0380821690930183166fffffffffffffffffffffffffffffffff19909116179055600387015460018801546113739291840391600160801b9182900416906134d1565b6004870180546001600160801b03600160801b80830482169094018116840291811691909117909155600288018490556003880183905560018801805483810483168e018316909302929091169190911790556040518b35907f3067048beee31b25b2f1681f88dac838c8bba36af25bfb2b7cf7473a5847e35f906113fd908d908d908d90615afd565b60405180910390a2505050505050509193909250565b61142461141e613253565b826132db565b61145f5760405162461bcd60e51b8152600401808060200182810382526031815260200180615f036031913960400191505060405180910390fd5b6109398383836138cf565b6001600160a01b038216600090815260016020526040812061148c9083613a1b565b90505b92915050565b7f49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad81565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f7f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000611526613a27565b3060405160200180868152602001858152602001848152602001838152602001826001600160a01b031681526020019550505050505060405160208183030381529060405280519060200120905090565b61093983838360405180602001604052806000815250612915565b8061159d33826132db565b6115b95760405162461bcd60e51b815260040161083390615984565b6000828152600c602052604090206001810154600160801b90046001600160801b03161580156115f4575060048101546001600160801b0316155b801561161257506004810154600160801b90046001600160801b0316155b61162e5760405162461bcd60e51b815260040161083390615a86565b6000838152600c602052604081208181556001810182905560028101829055600381018290556004015561093983613a2b565b604080517f8fcbaf0c00000000000000000000000000000000000000000000000000000000815233600482015230602482015260448101879052606481018690526001608482015260ff851660a482015260c4810184905260e4810183905290516001600160a01b03881691638fcbaf0c9161010480830192600092919082900301818387803b1580156116f457600080fd5b505af1158015611708573d6000803e3d6000fd5b50505050505050505050565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166370a08231306040518263ffffffff1660e01b815260040180826001600160a01b0316815260200191505060206040518083038186803b15801561178357600080fd5b505afa158015611797573d6000803e3d6000fd5b505050506040513d60208110156117ad57600080fd5b5051905082811015611806576040805162461bcd60e51b815260206004820152601260248201527f496e73756666696369656e742057455448390000000000000000000000000000604482015290519081900360640190fd5b8015610939577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316632e1a7d4d826040518263ffffffff1660e01b815260040180828152602001915050600060405180830381600087803b15801561187257600080fd5b505af1158015611886573d6000803e3d6000fd5b505050506109398282613580565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000806118c6600284613af8565b509392505050565b600061148f82604051806060016040528060298152602001615e6e6029913960029190613b16565b606090565b60006001600160a01b0382166119425760405162461bcd60e51b815260040180806020018281038252602a815260200180615e44602a913960400191505060405180910390fd5b6001600160a01b038216600090815260016020526040902061148f90613689565b8361196c613377565b11156119bf576040805162461bcd60e51b815260206004820152600e60248201527f5065726d69742065787069726564000000000000000000000000000000000000604482015290519081900360640190fd5b60006119c96114b9565b7f49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad88886119f581613b23565b604080516020808201969096526001600160a01b03909416848201526060840192909252608083015260a08083018a90528151808403909101815260c0830182528051908401207f190100000000000000000000000000000000000000000000000000000000000060e084015260e283019490945261010280830194909452805180830390940184526101229091019052815191012090506000611a98876118ce565b9050806001600160a01b0316886001600160a01b03161415611aeb5760405162461bcd60e51b8152600401808060200182810382526027815260200180615d6f6027913960400191505060405180910390fd5b611af481613b62565b15611ccf576040805160208082018790528183018690527fff0000000000000000000000000000000000000000000000000000000000000060f889901b16606083015282516041818403018152606183018085527f1626ba7e0000000000000000000000000000000000000000000000000000000090526065830186815260858401948552815160a585015281516001600160a01b03871695631626ba7e958995919260c59091019185019080838360005b83811015611bbe578181015183820152602001611ba6565b50505050905090810190601f168015611beb5780820380516001836020036101000a031916815260200191505b50935050505060206040518083038186803b158015611c0957600080fd5b505afa158015611c1d573d6000803e3d6000fd5b505050506040513d6020811015611c3357600080fd5b50517fffffffff00000000000000000000000000000000000000000000000000000000167f1626ba7e0000000000000000000000000000000000000000000000000000000014611cca576040805162461bcd60e51b815260206004820152600c60248201527f556e617574686f72697a65640000000000000000000000000000000000000000604482015290519081900360640190fd5b611dfb565b600060018387878760405160008152602001604052604051808581526020018460ff1681526020018381526020018281526020019450505050506020604051602081039080840390855afa158015611d2b573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116611d93576040805162461bcd60e51b815260206004820152601160248201527f496e76616c6964207369676e6174757265000000000000000000000000000000604482015290519081900360640190fd5b816001600160a01b0316816001600160a01b031614611df9576040805162461bcd60e51b815260206004820152600c60248201527f556e617574686f72697a65640000000000000000000000000000000000000000604482015290519081900360640190fd5b505b611e058888613257565b5050505050505050565b60008060008084610140013580611e24613377565b1115611e77576040805162461bcd60e51b815260206004820152601360248201527f5472616e73616374696f6e20746f6f206f6c6400000000000000000000000000604482015290519081900360640190fd5b604080516101408101909152600090611f439080611e9860208b018b6150af565b6001600160a01b03168152602001896020016020810190611eb991906150af565b6001600160a01b03168152602001611ed760608b0160408c0161569e565b62ffffff168152306020820152604001611ef760808b0160608c016153e6565b60020b8152602001611f0f60a08b0160808c016153e6565b60020b81526020018960a0013581526020018960c0013581526020018960e001358152602001896101000135815250613694565b92975090955093509050611fb7611f6261014089016101208a016150af565b600d80547fffffffffffffffffffff000000000000000000000000000000000000000000008116600175ffffffffffffffffffffffffffffffffffffffffffff92831690810190921617909155975087613b68565b6000611fe230611fcd60808b0160608c016153e6565b611fdd60a08c0160808d016153e6565b613477565b9050600080836001600160a01b031663514ea4bf846040518263ffffffff1660e01b81526004016120139190615929565b60a06040518083038186803b15801561202b57600080fd5b505afa15801561203f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061206391906155ac565b5050925092505060006120dc8560405180606001604052808e600001602081019061208e91906150af565b6001600160a01b031681526020018e60200160208101906120af91906150af565b6001600160a01b031681526020018e60400160208101906120d0919061569e565b62ffffff169052613c96565b905060405180610140016040528060006bffffffffffffffffffffffff16815260200160006001600160a01b031681526020018269ffffffffffffffffffff1681526020018c606001602081019061213491906153e6565b60020b815260200161214c60a08e0160808f016153e6565b60020b81526020018a6001600160801b0316815260200184815260200183815260200160006001600160801b0316815260200160006001600160801b0316815250600c60008c815260200190815260200160002060008201518160000160006101000a8154816bffffffffffffffffffffffff02191690836bffffffffffffffffffffffff160217905550602082015181600001600c6101000a8154816001600160a01b0302191690836001600160a01b0316021790555060408201518160010160006101000a81548169ffffffffffffffffffff021916908369ffffffffffffffffffff160217905550606082015181600101600a6101000a81548162ffffff021916908360020b62ffffff160217905550608082015181600101600d6101000a81548162ffffff021916908360020b62ffffff16021790555060a08201518160010160106101000a8154816001600160801b0302191690836001600160801b0316021790555060c0820151816002015560e082015181600301556101008201518160040160006101000a8154816001600160801b0302191690836001600160801b031602179055506101208201518160040160106101000a8154816001600160801b0302191690836001600160801b03160217905550905050897f3067048beee31b25b2f1681f88dac838c8bba36af25bfb2b7cf7473a5847e35f8a8a8a60405161235b93929190615afd565b60405180910390a25050505050509193509193565b60078054604080516020601f60026000196101006001881615020190951694909404938401819004810282018101909252828152606093909290918301828280156108025780601f106107d757610100808354040283529160200191610802565b6000818152600c6020908152604080832081516101408101835281546bffffffffffffffffffffffff811682526001600160a01b036c010000000000000000000000009091041693810193909352600181015469ffffffffffffffffffff81169284018390526a01000000000000000000008104600290810b810b810b6060860152600160681b8204810b810b810b60808601526001600160801b03600160801b92839004811660a08701529083015460c0860152600383015460e0860152600490920154808316610100860152041661012083015282918291829182918291829182918291829182918291906124da5760405162461bcd60e51b815260040161083390615a4f565b6000600b6000836040015169ffffffffffffffffffff1669ffffffffffffffffffff1681526020019081526020016000206040518060600160405290816000820160009054906101000a90046001600160a01b03166001600160a01b03166001600160a01b031681526020016001820160009054906101000a90046001600160a01b03166001600160a01b03166001600160a01b031681526020016001820160149054906101000a900462ffffff1662ffffff1662ffffff1681525050905081600001518260200151826000015183602001518460400151866060015187608001518860a001518960c001518a60e001518b61010001518c61012001519d509d509d509d509d509d509d509d509d509d509d509d50505091939597999b5091939597999b565b612608613253565b6001600160a01b0316826001600160a01b0316141561266e576040805162461bcd60e51b815260206004820152601960248201527f4552433732313a20617070726f766520746f2063616c6c657200000000000000604482015290519081900360640190fd5b806005600061267b613253565b6001600160a01b0390811682526020808301939093526040918201600090812091871680825291909352912080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016921515929092179091556126dd613253565b6001600160a01b03167f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c318360405180821515815260200191505060405180910390a35050565b604080517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523360048201523060248201529051600019916001600160a01b0389169163dd62ed3e91604480820192602092909190829003018186803b15801561278d57600080fd5b505afa1580156127a1573d6000803e3d6000fd5b505050506040513d60208110156127b757600080fd5b505110156127cd576127cd868686868686611661565b505050505050565b60608167ffffffffffffffff811180156127ee57600080fd5b5060405190808252806020026020018201604052801561282257816020015b606081526020019060019003908161280d5790505b50905060005b8281101561290e576000803086868581811061284057fe5b90506020028101906128529190615bef565b6040516128609291906157d2565b600060405180830381855af49150503d806000811461289b576040519150601f19603f3d011682016040523d82523d6000602084013e6128a0565b606091505b5091509150816128ec576044815110156128b957600080fd5b600481019050808060200190518101906128d39190615402565b60405162461bcd60e51b81526004016108339190615971565b808484815181106128f957fe5b60209081029190910101525050600101612828565b5092915050565b612926612920613253565b836132db565b6129615760405162461bcd60e51b8152600401808060200182810382526031815260200180615f036031913960400191505060405180910390fd5b61296d84848484613de6565b50505050565b604080517fdd62ed3e000000000000000000000000000000000000000000000000000000008152336004820152306024820152905186916001600160a01b0389169163dd62ed3e91604480820192602092909190829003018186803b1580156129db57600080fd5b505afa1580156129ef573d6000803e3d6000fd5b505050506040513d6020811015612a0557600080fd5b505110156127cd576127cd868686868686612c9d565b7f000000000000000000000000000000000000000000000000000000000000000081565b6060612a4a82613246565b612a5357600080fd5b6040517fe9dc63750000000000000000000000000000000000000000000000000000000081526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063e9dc637590612aba9030908690600401615932565b60006040518083038186803b158015612ad257600080fd5b505afa158015612ae6573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261148f9190810190615402565b6000612b1c828401846154a5565b9050612b4c7f00000000000000000000000000000000000000000000000000000000000000008260000151613e38565b508415612b67578051516020820151612b6791903388613e5b565b8315612b8557612b8581600001516020015182602001513387613e5b565b5050505050565b6000836001600160a01b03166370a08231306040518263ffffffff1660e01b815260040180826001600160a01b0316815260200191505060206040518083038186803b158015612bdb57600080fd5b505afa158015612bef573d6000803e3d6000fd5b505050506040513d6020811015612c0557600080fd5b5051905082811015612c5e576040805162461bcd60e51b815260206004820152601260248201527f496e73756666696369656e7420746f6b656e0000000000000000000000000000604482015290519081900360640190fd5b801561296d5761296d848383613feb565b6001600160a01b03918216600090815260056020908152604080832093909416825291909152205460ff1690565b604080517fd505accf000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018790526064810186905260ff8516608482015260a4810184905260c4810183905290516001600160a01b0388169163d505accf9160e480830192600092919082900301818387803b1580156116f457600080fd5b6000808235612d3733826132db565b612d535760405162461bcd60e51b815260040161083390615984565b6000612d656060860160408701615562565b6001600160801b03161180612d9257506000612d876080860160608701615562565b6001600160801b0316115b612d9b57600080fd5b600080612dae60408701602088016150af565b6001600160a01b031614612dd157612dcc60408601602087016150af565b612dd3565b305b85356000908152600c6020908152604080832060018082015469ffffffffffffffffffff168552600b8452828520835160608101855281546001600160a01b039081168252919092015490811694820194909452600160a01b90930462ffffff169183019190915292935090612e697f00000000000000000000000000000000000000000000000000000000000000008361337b565b600484015460018501549192506001600160801b0380821692600160801b92839004821692900416156130865760018501546040517fa34123a70000000000000000000000000000000000000000000000000000000081526001600160a01b0385169163a34123a791612f00916a01000000000000000000008104600290810b92600160681b909204900b9060009060040161594b565b6040805180830381600087803b158015612f1957600080fd5b505af1158015612f2d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f5191906156f4565b5050600185015460009081906001600160a01b0386169063514ea4bf90612f969030906a01000000000000000000008104600290810b91600160681b9004900b613477565b6040518263ffffffff1660e01b8152600401612fb29190615929565b60a06040518083038186803b158015612fca57600080fd5b505afa158015612fde573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061300291906155ac565b5050925092505061303e876002015483038860010160109054906101000a90046001600160801b03166001600160801b0316600160801b6134d1565b84019350613077876003015482038860010160109054906101000a90046001600160801b03166001600160801b0316600160801b6134d1565b60028801929092556003870155015b6000806001600160801b0384166130a360608e0160408f01615562565b6001600160801b0316116130c6576130c160608d0160408e01615562565b6130c8565b835b836001600160801b03168d60600160208101906130e59190615562565b6001600160801b0316116131085761310360808e0160608f01615562565b61310a565b835b60018901546040517f4f1eb3d80000000000000000000000000000000000000000000000000000000081529294509092506001600160a01b03871691634f1eb3d89161317d918c916a01000000000000000000008104600290810b92600160681b909204900b9088908890600401615839565b6040805180830381600087803b15801561319657600080fd5b505af11580156131aa573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131ce919061557e565b6004890180546fffffffffffffffffffffffffffffffff196001600160801b03918216600160801b878a0384160217168689038216179091556040519281169d50169a508c35907f40d0efd1a53d60ecbf40971b9daf7dc90178c3aadc7aab1765632738fa8b8f0190610d94908b9086908690615876565b600061148f60028361417b565b3390565b6000818152600c6020526040902080546bffffffffffffffffffffffff166c010000000000000000000000006001600160a01b0385169081029190911790915581906132a2826118ce565b6001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b60006132e682613246565b6133215760405162461bcd60e51b815260040180806020018281038252602c815260200180615de0602c913960400191505060405180910390fd5b600061332c836118ce565b9050806001600160a01b0316846001600160a01b031614806133675750836001600160a01b031661335c8461080c565b6001600160a01b0316145b806110c157506110c18185612c6f565b4290565b600081602001516001600160a01b031682600001516001600160a01b0316106133a357600080fd5b50805160208083015160409384015184516001600160a01b0394851681850152939091168385015262ffffff166060808401919091528351808403820181526080840185528051908301207fff0000000000000000000000000000000000000000000000000000000000000060a085015294901b6bffffffffffffffffffffffff191660a183015260b58201939093527fe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b5460d5808301919091528251808303909101815260f5909101909152805191012090565b604080516bffffffffffffffffffffffff19606086901b16602080830191909152600285810b60e890811b60348501529085900b901b60378301528251601a818403018152603a90920190925280519101205b9392505050565b600080806000198587098686029250828110908390030390508061350757600084116134fc57600080fd5b5082900490506134ca565b80841161351357600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150509392505050565b604080516000808252602082019092526001600160a01b0384169083906040518082805190602001908083835b602083106135cc5780518252601f1990920191602091820191016135ad565b6001836020036101000a03801982511681845116808217855250505050505090500191505060006040518083038185875af1925050503d806000811461362e576040519150601f19603f3d011682016040523d82523d6000602084013e613633565b606091505b5050905080610939576040805162461bcd60e51b815260206004820152600360248201527f5354450000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b600061148f82614187565b6000806000806000604051806060016040528087600001516001600160a01b0316815260200187602001516001600160a01b03168152602001876040015162ffffff1681525090506137067f00000000000000000000000000000000000000000000000000000000000000008261337b565b91506000826001600160a01b0316633850c7bd6040518163ffffffff1660e01b815260040160e06040518083038186803b15801561374357600080fd5b505afa158015613757573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061377b919061560d565b50505050505090506000613792886080015161418b565b905060006137a38960a0015161418b565b90506137ba8383838c60c001518d60e001516144d9565b9750505050816001600160a01b0316633c8a7d8d876060015188608001518960a00151896040518060400160405280888152602001336001600160a01b031681525060405160200161380c9190615abd565b6040516020818303038152906040526040518663ffffffff1660e01b815260040161383b9594939291906157f6565b6040805180830381600087803b15801561385457600080fd5b505af1158015613868573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061388c91906156f4565b610100880151919550935084108015906138ab57508561012001518310155b6138c75760405162461bcd60e51b815260040161083390615a18565b509193509193565b826001600160a01b03166138e2826118ce565b6001600160a01b0316146139275760405162461bcd60e51b8152600401808060200182810382526029815260200180615eb96029913960400191505060405180910390fd5b6001600160a01b03821661396c5760405162461bcd60e51b8152600401808060200182810382526024815260200180615d966024913960400191505060405180910390fd5b613977838383610939565b613982600082613257565b6001600160a01b03831660009081526001602052604090206139a4908261459d565b506001600160a01b03821660009081526001602052604090206139c790826145a9565b506139d4600282846145b5565b5080826001600160a01b0316846001600160a01b03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a4505050565b600061148c83836145cb565b4690565b6000613a36826118ce565b9050613a4481600084610939565b613a4f600083613257565b6000828152600860205260409020546002600019610100600184161502019091160415613a8d576000828152600860205260408120613a8d9161501f565b6001600160a01b0381166000908152600160205260409020613aaf908361459d565b50613abb60028361462f565b5060405182906000906001600160a01b038416907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908390a45050565b6000808080613b07868661463b565b909450925050505b9250929050565b60006110c18484846146b6565b6000908152600c6020526040902080546bffffffffffffffffffffffff19811660016bffffffffffffffffffffffff9283169081019092161790915590565b3b151590565b6001600160a01b038216613bc3576040805162461bcd60e51b815260206004820181905260248201527f4552433732313a206d696e7420746f20746865207a65726f2061646472657373604482015290519081900360640190fd5b613bcc81613246565b15613c1e576040805162461bcd60e51b815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e74656400000000604482015290519081900360640190fd5b613c2a60008383610939565b6001600160a01b0382166000908152600160205260409020613c4c90826145a9565b50613c59600282846145b5565b5060405181906001600160a01b038416906000907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a45050565b6001600160a01b0382166000908152600a602052604090205469ffffffffffffffffffff168061148f5750600d8054600169ffffffffffffffffffff76010000000000000000000000000000000000000000000080840482168381019092160275ffffffffffffffffffffffffffffffffffffffffffff909316929092179092556001600160a01b038085166000908152600a6020908152604080832080547fffffffffffffffffffffffffffffffffffffffffffff000000000000000000001686179055848352600b825291829020865181549085167fffffffffffffffffffffffff000000000000000000000000000000000000000091821617825591870151950180549287015162ffffff16600160a01b027fffffffffffffffffff000000ffffffffffffffffffffffffffffffffffffffff969094169290911691909117939093161790915592915050565b613df18484846138cf565b613dfd84848484614780565b61296d5760405162461bcd60e51b8152600401808060200182810382526032815260200180615d3d6032913960400191505060405180910390fd5b6000613e44838361337b565b9050336001600160a01b0382161461148f57600080fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316846001600160a01b0316148015613e9c5750804710155b15613fbe577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b158015613efc57600080fd5b505af1158015613f10573d6000803e3d6000fd5b50505050507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663a9059cbb83836040518363ffffffff1660e01b815260040180836001600160a01b0316815260200182815260200192505050602060405180830381600087803b158015613f8c57600080fd5b505af1158015613fa0573d6000803e3d6000fd5b505050506040513d6020811015613fb657600080fd5b5061296d9050565b6001600160a01b038316301415613fdf57613fda848383613feb565b61296d565b61296d8484848461495c565b604080516001600160a01b038481166024830152604480830185905283518084039091018152606490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb000000000000000000000000000000000000000000000000000000001781529251825160009485949389169392918291908083835b602083106140955780518252601f199092019160209182019101614076565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d80600081146140f7576040519150601f19603f3d011682016040523d82523d6000602084013e6140fc565b606091505b509150915081801561412a57508051158061412a575080806020019051602081101561412757600080fd5b50515b612b85576040805162461bcd60e51b815260206004820152600260248201527f5354000000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b600061148c8383614af4565b5490565b60008060008360020b126141a2578260020b6141aa565b8260020b6000035b9050620d89e8811115614204576040805162461bcd60e51b815260206004820152600160248201527f5400000000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b60006001821661421857600160801b61422a565b6ffffcb933bd6fad37aa2d162d1a5940015b70ffffffffffffffffffffffffffffffffff169050600282161561425e576ffff97272373d413259a46990580e213a0260801c5b600482161561427d576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b600882161561429c576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b60108216156142bb576fffcb9843d60f6159c9db58835c9266440260801c5b60208216156142da576fff973b41fa98c081472e6896dfb254c00260801c5b60408216156142f9576fff2ea16466c96a3843ec78b326b528610260801c5b6080821615614318576ffe5dee046a99a2a811c461f1969c30530260801c5b610100821615614338576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b610200821615614358576ff987a7253ac413176f2b074cf7815e540260801c5b610400821615614378576ff3392b0822b70005940c7a398e4b70f30260801c5b610800821615614398576fe7159475a2c29b7443b29c7fa6e889d90260801c5b6110008216156143b8576fd097f3bdfd2022b8845ad8f792aa58250260801c5b6120008216156143d8576fa9f746462d870fdf8a65dc1f90e061e50260801c5b6140008216156143f8576f70d869a156d2a1b890bb3df62baf32f70260801c5b618000821615614418576f31be135f97d08fd981231505542fcfa60260801c5b62010000821615614439576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b62020000821615614459576e5d6af8dedb81196699c329225ee6040260801c5b62040000821615614478576d2216e584f5fa1ea926041bedfe980260801c5b62080000821615614495576b048a170391f7dc42444e8fa20260801c5b60008460020b13156144b05780600019816144ac57fe5b0490505b6401000000008106156144c45760016144c7565b60005b60ff16602082901c0192505050919050565b6000836001600160a01b0316856001600160a01b031611156144f9579293925b846001600160a01b0316866001600160a01b0316116145245761451d858585614b0c565b9050614594565b836001600160a01b0316866001600160a01b0316101561458657600061454b878686614b0c565b9050600061455a878986614b78565b9050806001600160801b0316826001600160801b03161061457b578061457d565b815b92505050614594565b614591858584614b78565b90505b95945050505050565b600061148c8383614bbe565b600061148c8383614c84565b60006110c184846001600160a01b038516614cce565b8154600090821061460d5760405162461bcd60e51b8152600401808060200182810382526022815260200180615d1b6022913960400191505060405180910390fd5b82600001828154811061461c57fe5b9060005260206000200154905092915050565b600061148c8383614d65565b81546000908190831061467f5760405162461bcd60e51b8152600401808060200182810382526022815260200180615e976022913960400191505060405180910390fd5b600084600001848154811061469057fe5b906000526020600020906002020190508060000154816001015492509250509250929050565b600082815260018401602052604081205482816147515760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156147165781810151838201526020016146fe565b50505050905090810190601f1680156147435780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5084600001600182038154811061476457fe5b9060005260206000209060020201600101549150509392505050565b6000614794846001600160a01b0316613b62565b6147a0575060016110c1565b60006148f17f150b7a02000000000000000000000000000000000000000000000000000000006147ce613253565b88878760405160240180856001600160a01b03168152602001846001600160a01b0316815260200183815260200180602001828103825283818151815260200191508051906020019080838360005b8381101561483557818101518382015260200161481d565b50505050905090810190601f1680156148625780820380516001836020036101000a031916815260200191505b5095505050505050604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050604051806060016040528060328152602001615d3d603291396001600160a01b0388169190614e39565b9050600081806020019051602081101561490a57600080fd5b50517fffffffff00000000000000000000000000000000000000000000000000000000167f150b7a02000000000000000000000000000000000000000000000000000000001492505050949350505050565b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f23b872dd00000000000000000000000000000000000000000000000000000000178152925182516000948594938a169392918291908083835b60208310614a0e5780518252601f1990920191602091820191016149ef565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114614a70576040519150601f19603f3d011682016040523d82523d6000602084013e614a75565b606091505b5091509150818015614aa3575080511580614aa35750808060200190516020811015614aa057600080fd5b50515b6127cd576040805162461bcd60e51b815260206004820152600360248201527f5354460000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b60009081526001919091016020526040902054151590565b6000826001600160a01b0316846001600160a01b03161115614b2c579192915b6000614b58856001600160a01b0316856001600160a01b03166c010000000000000000000000006134d1565b9050614594614b7384838888036001600160a01b03166134d1565b614e48565b6000826001600160a01b0316846001600160a01b03161115614b98579192915b6110c1614b73836c010000000000000000000000008787036001600160a01b03166134d1565b60008181526001830160205260408120548015614c7a5783546000198083019190810190600090879083908110614bf157fe5b9060005260206000200154905080876000018481548110614c0e57fe5b600091825260208083209091019290925582815260018981019092526040902090840190558654879080614c3e57fe5b6001900381819060005260206000200160009055905586600101600087815260200190815260200160002060009055600194505050505061148f565b600091505061148f565b6000614c908383614af4565b614cc65750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915561148f565b50600061148f565b600082815260018401602052604081205480614d335750506040805180820182528381526020808201848152865460018181018955600089815284812095516002909302909501918255915190820155865486845281880190925292909120556134ca565b82856000016001830381548110614d4657fe5b90600052602060002090600202016001018190555060009150506134ca565b60008181526001830160205260408120548015614c7a5783546000198083019190810190600090879083908110614d9857fe5b9060005260206000209060020201905080876000018481548110614db857fe5b600091825260208083208454600290930201918255600193840154918401919091558354825289830190526040902090840190558654879080614df757fe5b600082815260208082206002600019909401938402018281556001908101839055929093558881528982019092526040822091909155945061148f9350505050565b60606110c18484600085614e5e565b806001600160801b038116811461077157600080fd5b606082471015614e9f5760405162461bcd60e51b8152600401808060200182810382526026815260200180615dba6026913960400191505060405180910390fd5b614ea885613b62565b614ef9576040805162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015290519081900360640190fd5b600080866001600160a01b031685876040518082805190602001908083835b60208310614f375780518252601f199092019160209182019101614f18565b6001836020036101000a03801982511681845116808217855250505050505090500191505060006040518083038185875af1925050503d8060008114614f99576040519150601f19603f3d011682016040523d82523d6000602084013e614f9e565b606091505b5091509150614fae828286614fb9565b979650505050505050565b60608315614fc85750816134ca565b825115614fd85782518084602001fd5b60405162461bcd60e51b81526020600482018181528451602484015284518593919283926044019190850190808383600083156147165781810151838201526020016146fe565b50805460018160011615610100020316600290046000825580601f106150455750615063565b601f0160209004906000526020600020908101906150639190615066565b50565b5b8082111561507b5760008155600101615067565b5090565b803561077181615cc4565b805161ffff8116811461077157600080fd5b803562ffffff8116811461077157600080fd5b6000602082840312156150c0578081fd5b81356134ca81615cc4565b600080604083850312156150dd578081fd5b82356150e881615cc4565b915060208301356150f881615cc4565b809150509250929050565b60008060008060808587031215615118578182fd5b843561512381615cc4565b9350602085013561513381615cc4565b92506151416040860161509c565b9150606085013561515181615cc4565b939692955090935050565b600080600060608486031215615170578081fd5b833561517b81615cc4565b9250602084013561518b81615cc4565b929592945050506040919091013590565b600080600080608085870312156151b1578182fd5b84356151bc81615cc4565b935060208501356151cc81615cc4565b925060408501359150606085013567ffffffffffffffff8111156151ee578182fd5b8501601f810187136151fe578182fd5b803561521161520c82615c76565b615c52565b818152886020838501011115615225578384fd5b81602084016020830137908101602001929092525092959194509250565b60008060408385031215615255578182fd5b823561526081615cc4565b915060208301356150f881615cd9565b60008060408385031215615282578182fd5b823561528d81615cc4565b946020939093013593505050565b6000806000606084860312156152af578081fd5b83356152ba81615cc4565b92506020840135915060408401356152d181615cc4565b809150509250925092565b60008060008060008060c087890312156152f4578384fd5b86356152ff81615cc4565b95506020870135945060408701359350606087013561531d81615d0b565b9598949750929560808101359460a0909101359350915050565b60008060208385031215615349578182fd5b823567ffffffffffffffff80821115615360578384fd5b818501915085601f830112615373578384fd5b813581811115615381578485fd5b8660208083028501011115615394578485fd5b60209290920196919550909350505050565b6000602082840312156153b7578081fd5b81357fffffffff00000000000000000000000000000000000000000000000000000000811681146134ca578182fd5b6000602082840312156153f7578081fd5b81356134ca81615ce7565b600060208284031215615413578081fd5b815167ffffffffffffffff811115615429578182fd5b8201601f81018413615439578182fd5b805161544761520c82615c76565b81815285602083850101111561545b578384fd5b614594826020830160208601615c98565b60006080828403121561547d578081fd5b50919050565b600060a0828403121561547d578081fd5b600060c0828403121561547d578081fd5b600081830360808112156154b7578182fd5b6040516040810167ffffffffffffffff82821081831117156154d557fe5b8160405260608412156154e6578485fd5b60a08301935081841081851117156154fa57fe5b50826040528435925061550c83615cc4565b91825260208401359161551e83615cc4565b8260608301526155306040860161509c565b608083015281526155436060850161507f565b6020820152949350505050565b6000610160828403121561547d578081fd5b600060208284031215615573578081fd5b81356134ca81615cf6565b60008060408385031215615590578182fd5b825161559b81615cf6565b60208401519092506150f881615cf6565b600080600080600060a086880312156155c3578283fd5b85516155ce81615cf6565b80955050602086015193506040860151925060608601516155ee81615cf6565b60808701519092506155ff81615cf6565b809150509295509295909350565b600080600080600080600060e0888a031215615627578485fd5b875161563281615cc4565b602089015190975061564381615ce7565b95506156516040890161508a565b945061565f6060890161508a565b935061566d6080890161508a565b925060a088015161567d81615d0b565b60c089015190925061568e81615cd9565b8091505092959891949750929550565b6000602082840312156156af578081fd5b61148c8261509c565b6000602082840312156156c9578081fd5b5035919050565b600080604083850312156156e2578182fd5b8235915060208301356150f881615cc4565b60008060408385031215615706578182fd5b505080516020909101519092909150565b6000806000806060858703121561572c578182fd5b8435935060208501359250604085013567ffffffffffffffff80821115615751578384fd5b818701915087601f830112615764578384fd5b813581811115615772578485fd5b886020828501011115615783578485fd5b95989497505060200194505050565b600081518084526157aa816020860160208601615c98565b601f01601f19169290920160200192915050565b60020b9052565b6001600160801b03169052565b6000828483379101908152919050565b6001600160a01b0391909116815260200190565b60006001600160a01b03871682528560020b60208301528460020b60408301526001600160801b038416606083015260a06080830152614fae60a0830184615792565b6001600160a01b03959095168552600293840b60208601529190920b60408401526001600160801b03918216606084015216608082015260a00190565b6001600160a01b039390931683526001600160801b03918216602084015216604082015260600190565b6000602080830181845280855180835260408601915060408482028701019250838701855b82811015615911577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08886030184526158ff858351615792565b945092850192908501906001016158c5565b5092979650505050505050565b901515815260200190565b90815260200190565b6001600160a01b03929092168252602082015260400190565b600293840b81529190920b60208201526001600160801b03909116604082015260600190565b60006020825261148c6020830184615792565b6020808252600c908201527f4e6f7420617070726f7665640000000000000000000000000000000000000000604082015260600190565b6020808252602c908201527f4552433732313a20617070726f76656420717565727920666f72206e6f6e657860408201527f697374656e7420746f6b656e0000000000000000000000000000000000000000606082015260800190565b60208082526014908201527f507269636520736c69707061676520636865636b000000000000000000000000604082015260600190565b60208082526010908201527f496e76616c696420746f6b656e20494400000000000000000000000000000000604082015260600190565b6020808252600b908201527f4e6f7420636c6561726564000000000000000000000000000000000000000000604082015260600190565b815180516001600160a01b03908116835260208083015182168185015260409283015162ffffff1692840192909252920151909116606082015260800190565b6001600160801b039390931683526020830191909152604082015260600190565b9384526001600160801b039290921660208401526040830152606082015260800190565b918252602082015260400190565b6bffffffffffffffffffffffff8d1681526001600160a01b038c811660208301528b811660408301528a16606082015262ffffff89166080820152600288900b60a08201526101808101615ba760c08301896157be565b615bb460e08301886157c5565b8561010083015284610120830152615bd06101408301856157c5565b615bde6101608301846157c5565b9d9c50505050505050505050505050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112615c23578283fd5b83018035915067ffffffffffffffff821115615c3d578283fd5b602001915036819003821315613b0f57600080fd5b60405181810167ffffffffffffffff81118282101715615c6e57fe5b604052919050565b600067ffffffffffffffff821115615c8a57fe5b50601f01601f191660200190565b60005b83811015615cb3578181015183820152602001615c9b565b8381111561296d5750506000910152565b6001600160a01b038116811461506357600080fd5b801515811461506357600080fd5b8060020b811461506357600080fd5b6001600160801b038116811461506357600080fd5b60ff8116811461506357600080fdfe456e756d657261626c655365743a20696e646578206f7574206f6620626f756e64734552433732313a207472616e7366657220746f206e6f6e20455243373231526563656976657220696d706c656d656e7465724552433732315065726d69743a20617070726f76616c20746f2063757272656e74206f776e65724552433732313a207472616e7366657220746f20746865207a65726f2061646472657373416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c6c4552433732313a206f70657261746f7220717565727920666f72206e6f6e6578697374656e7420746f6b656e4552433732313a20617070726f76652063616c6c6572206973206e6f74206f776e6572206e6f7220617070726f76656420666f7220616c6c4552433732313a2062616c616e636520717565727920666f7220746865207a65726f20616464726573734552433732313a206f776e657220717565727920666f72206e6f6e6578697374656e7420746f6b656e456e756d657261626c654d61703a20696e646578206f7574206f6620626f756e64734552433732313a207472616e73666572206f6620746f6b656e2074686174206973206e6f74206f776e4552433732313a20617070726f76616c20746f2063757272656e74206f776e65724552433732313a207472616e736665722063616c6c6572206973206e6f74206f776e6572206e6f7220617070726f766564a164736f6c6343000706000a";
const linkReferences$a = {};
const deployedLinkReferences$a = {};
const INonfungiblePositionManager = {
  _format: _format$a,
  contractName: contractName$a,
  sourceName: sourceName$a,
  abi: abi$a,
  bytecode: bytecode$a,
  deployedBytecode: deployedBytecode$a,
  linkReferences: linkReferences$a,
  deployedLinkReferences: deployedLinkReferences$a
};
const _format$9 = "hh-sol-artifact-1";
const contractName$9 = "ISelfPermit";
const sourceName$9 = "contracts/interfaces/ISelfPermit.sol";
const abi$9 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "expiry",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermitAllowed",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "expiry",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermitAllowedIfNecessary",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermitIfNecessary",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
];
const bytecode$9 = "0x";
const deployedBytecode$9 = "0x";
const linkReferences$9 = {};
const deployedLinkReferences$9 = {};
const ISelfPermit = {
  _format: _format$9,
  contractName: contractName$9,
  sourceName: sourceName$9,
  abi: abi$9,
  bytecode: bytecode$9,
  deployedBytecode: deployedBytecode$9,
  linkReferences: linkReferences$9,
  deployedLinkReferences: deployedLinkReferences$9
};
const _format$8 = "hh-sol-artifact-1";
const contractName$8 = "IPeripheryPaymentsWithFee";
const sourceName$8 = "contracts/interfaces/IPeripheryPaymentsWithFee.sol";
const abi$8 = [
  {
    inputs: [],
    name: "refundETH",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "sweepToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "feeBips",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "feeRecipient",
        type: "address"
      }
    ],
    name: "sweepTokenWithFee",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "unwrapWETH9",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "feeBips",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "feeRecipient",
        type: "address"
      }
    ],
    name: "unwrapWETH9WithFee",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
];
const bytecode$8 = "0x";
const deployedBytecode$8 = "0x";
const linkReferences$8 = {};
const deployedLinkReferences$8 = {};
const IPeripheryPaymentsWithFee = {
  _format: _format$8,
  contractName: contractName$8,
  sourceName: sourceName$8,
  abi: abi$8,
  bytecode: bytecode$8,
  deployedBytecode: deployedBytecode$8,
  linkReferences: linkReferences$8,
  deployedLinkReferences: deployedLinkReferences$8
};
const _format$7 = "hh-sol-artifact-1";
const contractName$7 = "Quoter";
const sourceName$7 = "contracts/lens/Quoter.sol";
const abi$7 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_factory",
        type: "address"
      },
      {
        internalType: "address",
        name: "_WETH9",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "WETH9",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "factory",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "path",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      }
    ],
    name: "quoteExactInput",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "tokenIn",
        type: "address"
      },
      {
        internalType: "address",
        name: "tokenOut",
        type: "address"
      },
      {
        internalType: "uint24",
        name: "fee",
        type: "uint24"
      },
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      },
      {
        internalType: "uint160",
        name: "sqrtPriceLimitX96",
        type: "uint160"
      }
    ],
    name: "quoteExactInputSingle",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "path",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      }
    ],
    name: "quoteExactOutput",
    outputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "tokenIn",
        type: "address"
      },
      {
        internalType: "address",
        name: "tokenOut",
        type: "address"
      },
      {
        internalType: "uint24",
        name: "fee",
        type: "uint24"
      },
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      },
      {
        internalType: "uint160",
        name: "sqrtPriceLimitX96",
        type: "uint160"
      }
    ],
    name: "quoteExactOutputSingle",
    outputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "int256",
        name: "amount0Delta",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "amount1Delta",
        type: "int256"
      },
      {
        internalType: "bytes",
        name: "path",
        type: "bytes"
      }
    ],
    name: "uniswapV3SwapCallback",
    outputs: [],
    stateMutability: "view",
    type: "function"
  }
];
const bytecode$7 = "0x60c060405234801561001057600080fd5b506040516112e53803806112e583398101604081905261002f91610069565b6001600160601b0319606092831b8116608052911b1660a05261009b565b80516001600160a01b038116811461006457600080fd5b919050565b6000806040838503121561007b578182fd5b6100848361004d565b91506100926020840161004d565b90509250929050565b60805160601c60a05160601c6112176100ce60003980610342525080610366528061058652806106d552506112176000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c8063c45a01551161005b578063c45a0155146100d3578063cdca1753146100db578063f7729d43146100ee578063fa461e33146101015761007d565b80632f80bb1d1461008257806330d07f21146100ab5780634aa4a4fc146100be575b600080fd5b610095610090366004610e9e565b610116565b6040516100a29190611148565b60405180910390f35b6100956100b9366004610e30565b61017b565b6100c6610340565b6040516100a29190611084565b6100c6610364565b6100956100e9366004610e9e565b610388565b6100956100fc366004610e30565b6103d6565b61011461010f366004610f04565b610555565b005b60005b600061012484610660565b9050600080600061013487610668565b92509250925061014882848389600061017b565b955083156101605761015987610699565b965061016c565b85945050505050610175565b50505050610119565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff808616878216109083166101a65760008490555b6101b18787876106ce565b73ffffffffffffffffffffffffffffffffffffffff1663128acb0830836101d78861070c565b60000373ffffffffffffffffffffffffffffffffffffffff8816156101fc5787610222565b8561021b5773fffd8963efd1fc6a506488495d951d5263988d25610222565b6401000276a45b8b8b8e6040516020016102379392919061101e565b6040516020818303038152906040526040518663ffffffff1660e01b81526004016102669594939291906110a5565b6040805180830381600087803b15801561027f57600080fd5b505af19250505080156102cd575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526102ca91810190610ee1565b60015b610333573d8080156102fb576040519150601f19603f3d011682016040523d82523d6000602084013e610300565b606091505b5073ffffffffffffffffffffffffffffffffffffffff841661032157600080555b61032a8161073e565b92505050610337565b5050505b95945050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b60005b600061039684610660565b905060008060006103a687610668565b9250925092506103ba8383838960006103d6565b95508315610160576103cb87610699565b96505050505061038b565b600073ffffffffffffffffffffffffffffffffffffffff808616908716106103ff8787876106ce565b73ffffffffffffffffffffffffffffffffffffffff1663128acb0830836104258861070c565b73ffffffffffffffffffffffffffffffffffffffff881615610447578761046d565b856104665773fffd8963efd1fc6a506488495d951d5263988d2561046d565b6401000276a45b8c8b8d6040516020016104829392919061101e565b6040516020818303038152906040526040518663ffffffff1660e01b81526004016104b19594939291906110a5565b6040805180830381600087803b1580156104ca57600080fd5b505af1925050508015610518575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261051591810190610ee1565b60015b610333573d808015610546576040519150601f19603f3d011682016040523d82523d6000602084013e61054b565b606091505b5061032a8161073e565b60008313806105645750600082135b61056d57600080fd5b600080600061057b84610668565b9250925092506105ad7f00000000000000000000000000000000000000000000000000000000000000008484846107ef565b5060008060008089136105f3578573ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1610888a600003610628565b8473ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff161089896000035b925092509250821561063f57604051818152602081fd5b6000541561065557600054811461065557600080fd5b604051828152602081fd5b516042111590565b600080806106768482610805565b9250610683846014610905565b9050610690846017610805565b91509193909250565b80516060906101759083906017907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe9016109f5565b60006107047f00000000000000000000000000000000000000000000000000000000000000006106ff868686610bdc565b610c59565b949350505050565b60007f8000000000000000000000000000000000000000000000000000000000000000821061073a57600080fd5b5090565b600081516020146107db5760448251101561078e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161078590611111565b60405180910390fd5b600482019150818060200190518101906107a89190610f52565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161078591906110f7565b818060200190518101906101759190610fbc565b600061033785610800868686610bdc565b610d8f565b60008182601401101561087957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f746f416464726573735f6f766572666c6f770000000000000000000000000000604482015290519081900360640190fd5b81601401835110156108ec57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f746f416464726573735f6f75744f66426f756e64730000000000000000000000604482015290519081900360640190fd5b5001602001516c01000000000000000000000000900490565b60008182600301101561097957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f746f55696e7432345f6f766572666c6f77000000000000000000000000000000604482015290519081900360640190fd5b81600301835110156109ec57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f746f55696e7432345f6f75744f66426f756e6473000000000000000000000000604482015290519081900360640190fd5b50016003015190565b60608182601f011015610a6957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b828284011015610ada57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b81830184511015610b4c57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f736c6963655f6f75744f66426f756e6473000000000000000000000000000000604482015290519081900360640190fd5b606082158015610b6b5760405191506000825260208201604052610bd3565b6040519150601f8416801560200281840101858101878315602002848b0101015b81831015610ba4578051835260209283019201610b8c565b5050858452601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016604052505b50949350505050565b610be4610dbf565b8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161115610c1c579192915b506040805160608101825273ffffffffffffffffffffffffffffffffffffffff948516815292909316602083015262ffffff169181019190915290565b6000816020015173ffffffffffffffffffffffffffffffffffffffff16826000015173ffffffffffffffffffffffffffffffffffffffff1610610c9b57600080fd5b508051602080830151604093840151845173ffffffffffffffffffffffffffffffffffffffff94851681850152939091168385015262ffffff166060808401919091528351808403820181526080840185528051908301207fff0000000000000000000000000000000000000000000000000000000000000060a085015294901b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000001660a183015260b58201939093527fe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b5460d5808301919091528251808303909101815260f5909101909152805191012090565b6000610d9b8383610c59565b90503373ffffffffffffffffffffffffffffffffffffffff82161461017557600080fd5b604080516060810182526000808252602082018190529181019190915290565b600082601f830112610def578081fd5b8135610e02610dfd82611175565b611151565b818152846020838601011115610e16578283fd5b816020850160208301379081016020019190915292915050565b600080600080600060a08688031215610e47578081fd5b8535610e52816111e5565b94506020860135610e62816111e5565b9350604086013562ffffff81168114610e79578182fd5b9250606086013591506080860135610e90816111e5565b809150509295509295909350565b60008060408385031215610eb0578182fd5b823567ffffffffffffffff811115610ec6578283fd5b610ed285828601610ddf565b95602094909401359450505050565b60008060408385031215610ef3578182fd5b505080516020909101519092909150565b600080600060608486031215610f18578283fd5b8335925060208401359150604084013567ffffffffffffffff811115610f3c578182fd5b610f4886828701610ddf565b9150509250925092565b600060208284031215610f63578081fd5b815167ffffffffffffffff811115610f79578182fd5b8201601f81018413610f89578182fd5b8051610f97610dfd82611175565b818152856020838501011115610fab578384fd5b6103378260208301602086016111b5565b600060208284031215610fcd578081fd5b5051919050565b60008151808452610fec8160208601602086016111b5565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b606093841b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000908116825260e89390931b7fffffff0000000000000000000000000000000000000000000000000000000000166014820152921b166017820152602b0190565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b600073ffffffffffffffffffffffffffffffffffffffff8088168352861515602084015285604084015280851660608401525060a060808301526110ec60a0830184610fd4565b979650505050505050565b60006020825261110a6020830184610fd4565b9392505050565b60208082526010908201527f556e6578706563746564206572726f7200000000000000000000000000000000604082015260600190565b90815260200190565b60405181810167ffffffffffffffff8111828210171561116d57fe5b604052919050565b600067ffffffffffffffff82111561118957fe5b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b60005b838110156111d05781810151838201526020016111b8565b838111156111df576000848401525b50505050565b73ffffffffffffffffffffffffffffffffffffffff8116811461120757600080fd5b5056fea164736f6c6343000706000a";
const deployedBytecode$7 = "0x608060405234801561001057600080fd5b506004361061007d5760003560e01c8063c45a01551161005b578063c45a0155146100d3578063cdca1753146100db578063f7729d43146100ee578063fa461e33146101015761007d565b80632f80bb1d1461008257806330d07f21146100ab5780634aa4a4fc146100be575b600080fd5b610095610090366004610e9e565b610116565b6040516100a29190611148565b60405180910390f35b6100956100b9366004610e30565b61017b565b6100c6610340565b6040516100a29190611084565b6100c6610364565b6100956100e9366004610e9e565b610388565b6100956100fc366004610e30565b6103d6565b61011461010f366004610f04565b610555565b005b60005b600061012484610660565b9050600080600061013487610668565b92509250925061014882848389600061017b565b955083156101605761015987610699565b965061016c565b85945050505050610175565b50505050610119565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff808616878216109083166101a65760008490555b6101b18787876106ce565b73ffffffffffffffffffffffffffffffffffffffff1663128acb0830836101d78861070c565b60000373ffffffffffffffffffffffffffffffffffffffff8816156101fc5787610222565b8561021b5773fffd8963efd1fc6a506488495d951d5263988d25610222565b6401000276a45b8b8b8e6040516020016102379392919061101e565b6040516020818303038152906040526040518663ffffffff1660e01b81526004016102669594939291906110a5565b6040805180830381600087803b15801561027f57600080fd5b505af19250505080156102cd575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526102ca91810190610ee1565b60015b610333573d8080156102fb576040519150601f19603f3d011682016040523d82523d6000602084013e610300565b606091505b5073ffffffffffffffffffffffffffffffffffffffff841661032157600080555b61032a8161073e565b92505050610337565b5050505b95945050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b60005b600061039684610660565b905060008060006103a687610668565b9250925092506103ba8383838960006103d6565b95508315610160576103cb87610699565b96505050505061038b565b600073ffffffffffffffffffffffffffffffffffffffff808616908716106103ff8787876106ce565b73ffffffffffffffffffffffffffffffffffffffff1663128acb0830836104258861070c565b73ffffffffffffffffffffffffffffffffffffffff881615610447578761046d565b856104665773fffd8963efd1fc6a506488495d951d5263988d2561046d565b6401000276a45b8c8b8d6040516020016104829392919061101e565b6040516020818303038152906040526040518663ffffffff1660e01b81526004016104b19594939291906110a5565b6040805180830381600087803b1580156104ca57600080fd5b505af1925050508015610518575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261051591810190610ee1565b60015b610333573d808015610546576040519150601f19603f3d011682016040523d82523d6000602084013e61054b565b606091505b5061032a8161073e565b60008313806105645750600082135b61056d57600080fd5b600080600061057b84610668565b9250925092506105ad7f00000000000000000000000000000000000000000000000000000000000000008484846107ef565b5060008060008089136105f3578573ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1610888a600003610628565b8473ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff161089896000035b925092509250821561063f57604051818152602081fd5b6000541561065557600054811461065557600080fd5b604051828152602081fd5b516042111590565b600080806106768482610805565b9250610683846014610905565b9050610690846017610805565b91509193909250565b80516060906101759083906017907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe9016109f5565b60006107047f00000000000000000000000000000000000000000000000000000000000000006106ff868686610bdc565b610c59565b949350505050565b60007f8000000000000000000000000000000000000000000000000000000000000000821061073a57600080fd5b5090565b600081516020146107db5760448251101561078e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161078590611111565b60405180910390fd5b600482019150818060200190518101906107a89190610f52565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161078591906110f7565b818060200190518101906101759190610fbc565b600061033785610800868686610bdc565b610d8f565b60008182601401101561087957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f746f416464726573735f6f766572666c6f770000000000000000000000000000604482015290519081900360640190fd5b81601401835110156108ec57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f746f416464726573735f6f75744f66426f756e64730000000000000000000000604482015290519081900360640190fd5b5001602001516c01000000000000000000000000900490565b60008182600301101561097957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f746f55696e7432345f6f766572666c6f77000000000000000000000000000000604482015290519081900360640190fd5b81600301835110156109ec57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f746f55696e7432345f6f75744f66426f756e6473000000000000000000000000604482015290519081900360640190fd5b50016003015190565b60608182601f011015610a6957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b828284011015610ada57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b81830184511015610b4c57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f736c6963655f6f75744f66426f756e6473000000000000000000000000000000604482015290519081900360640190fd5b606082158015610b6b5760405191506000825260208201604052610bd3565b6040519150601f8416801560200281840101858101878315602002848b0101015b81831015610ba4578051835260209283019201610b8c565b5050858452601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016604052505b50949350505050565b610be4610dbf565b8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161115610c1c579192915b506040805160608101825273ffffffffffffffffffffffffffffffffffffffff948516815292909316602083015262ffffff169181019190915290565b6000816020015173ffffffffffffffffffffffffffffffffffffffff16826000015173ffffffffffffffffffffffffffffffffffffffff1610610c9b57600080fd5b508051602080830151604093840151845173ffffffffffffffffffffffffffffffffffffffff94851681850152939091168385015262ffffff166060808401919091528351808403820181526080840185528051908301207fff0000000000000000000000000000000000000000000000000000000000000060a085015294901b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000001660a183015260b58201939093527fe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b5460d5808301919091528251808303909101815260f5909101909152805191012090565b6000610d9b8383610c59565b90503373ffffffffffffffffffffffffffffffffffffffff82161461017557600080fd5b604080516060810182526000808252602082018190529181019190915290565b600082601f830112610def578081fd5b8135610e02610dfd82611175565b611151565b818152846020838601011115610e16578283fd5b816020850160208301379081016020019190915292915050565b600080600080600060a08688031215610e47578081fd5b8535610e52816111e5565b94506020860135610e62816111e5565b9350604086013562ffffff81168114610e79578182fd5b9250606086013591506080860135610e90816111e5565b809150509295509295909350565b60008060408385031215610eb0578182fd5b823567ffffffffffffffff811115610ec6578283fd5b610ed285828601610ddf565b95602094909401359450505050565b60008060408385031215610ef3578182fd5b505080516020909101519092909150565b600080600060608486031215610f18578283fd5b8335925060208401359150604084013567ffffffffffffffff811115610f3c578182fd5b610f4886828701610ddf565b9150509250925092565b600060208284031215610f63578081fd5b815167ffffffffffffffff811115610f79578182fd5b8201601f81018413610f89578182fd5b8051610f97610dfd82611175565b818152856020838501011115610fab578384fd5b6103378260208301602086016111b5565b600060208284031215610fcd578081fd5b5051919050565b60008151808452610fec8160208601602086016111b5565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b606093841b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000908116825260e89390931b7fffffff0000000000000000000000000000000000000000000000000000000000166014820152921b166017820152602b0190565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b600073ffffffffffffffffffffffffffffffffffffffff8088168352861515602084015285604084015280851660608401525060a060808301526110ec60a0830184610fd4565b979650505050505050565b60006020825261110a6020830184610fd4565b9392505050565b60208082526010908201527f556e6578706563746564206572726f7200000000000000000000000000000000604082015260600190565b90815260200190565b60405181810167ffffffffffffffff8111828210171561116d57fe5b604052919050565b600067ffffffffffffffff82111561118957fe5b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b60005b838110156111d05781810151838201526020016111b8565b838111156111df576000848401525b50505050565b73ffffffffffffffffffffffffffffffffffffffff8116811461120757600080fd5b5056fea164736f6c6343000706000a";
const linkReferences$7 = {};
const deployedLinkReferences$7 = {};
const IQuoter = {
  _format: _format$7,
  contractName: contractName$7,
  sourceName: sourceName$7,
  abi: abi$7,
  bytecode: bytecode$7,
  deployedBytecode: deployedBytecode$7,
  linkReferences: linkReferences$7,
  deployedLinkReferences: deployedLinkReferences$7
};
const _format$6 = "hh-sol-artifact-1";
const contractName$6 = "QuoterV2";
const sourceName$6 = "contracts/lens/QuoterV2.sol";
const abi$6 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_factory",
        type: "address"
      },
      {
        internalType: "address",
        name: "_WETH9",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "WETH9",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "factory",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "path",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      }
    ],
    name: "quoteExactInput",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      },
      {
        internalType: "uint160[]",
        name: "sqrtPriceX96AfterList",
        type: "uint160[]"
      },
      {
        internalType: "uint32[]",
        name: "initializedTicksCrossedList",
        type: "uint32[]"
      },
      {
        internalType: "uint256",
        name: "gasEstimate",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "address",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
          },
          {
            internalType: "uint24",
            name: "fee",
            type: "uint24"
          },
          {
            internalType: "uint160",
            name: "sqrtPriceLimitX96",
            type: "uint160"
          }
        ],
        internalType: "struct IQuoterV2.QuoteExactInputSingleParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "quoteExactInputSingle",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      },
      {
        internalType: "uint160",
        name: "sqrtPriceX96After",
        type: "uint160"
      },
      {
        internalType: "uint32",
        name: "initializedTicksCrossed",
        type: "uint32"
      },
      {
        internalType: "uint256",
        name: "gasEstimate",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "path",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      }
    ],
    name: "quoteExactOutput",
    outputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      },
      {
        internalType: "uint160[]",
        name: "sqrtPriceX96AfterList",
        type: "uint160[]"
      },
      {
        internalType: "uint32[]",
        name: "initializedTicksCrossedList",
        type: "uint32[]"
      },
      {
        internalType: "uint256",
        name: "gasEstimate",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "address",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "uint24",
            name: "fee",
            type: "uint24"
          },
          {
            internalType: "uint160",
            name: "sqrtPriceLimitX96",
            type: "uint160"
          }
        ],
        internalType: "struct IQuoterV2.QuoteExactOutputSingleParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "quoteExactOutputSingle",
    outputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      },
      {
        internalType: "uint160",
        name: "sqrtPriceX96After",
        type: "uint160"
      },
      {
        internalType: "uint32",
        name: "initializedTicksCrossed",
        type: "uint32"
      },
      {
        internalType: "uint256",
        name: "gasEstimate",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "int256",
        name: "amount0Delta",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "amount1Delta",
        type: "int256"
      },
      {
        internalType: "bytes",
        name: "path",
        type: "bytes"
      }
    ],
    name: "uniswapV3SwapCallback",
    outputs: [],
    stateMutability: "view",
    type: "function"
  }
];
const bytecode$6 = "0x60c06040523480156200001157600080fd5b506040516200212c3803806200212c833981016040819052620000349162000070565b6001600160601b0319606092831b8116608052911b1660a052620000a7565b80516001600160a01b03811681146200006b57600080fd5b919050565b6000806040838503121562000083578182fd5b6200008e8362000053565b91506200009e6020840162000053565b90509250929050565b60805160601c60a05160601c612051620000db60003980610321525080610577528061095d5280610b9252506120516000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c8063c45a01551161005b578063c45a0155146100e6578063c6a5026a146100ee578063cdca175314610101578063fa461e33146101145761007d565b80632f80bb1d146100825780634aa4a4fc146100ae578063bd21704a146100c3575b600080fd5b610095610090366004611b2b565b610129565b6040516100a59493929190611eac565b60405180910390f35b6100b661031f565b6040516100a59190611def565b6100d66100d1366004611c49565b610343565b6040516100a59493929190611f54565b6100b6610575565b6100d66100fc366004611c49565b610599565b61009561010f366004611b2b565b610754565b610127610122366004611b91565b61092c565b005b6000606080600061013986610ae8565b67ffffffffffffffff8111801561014f57600080fd5b50604051908082528060200260200182016040528015610179578160200160208202803683370190505b50925061018586610ae8565b67ffffffffffffffff8111801561019b57600080fd5b506040519080825280602002602001820160405280156101c5578160200160208202803683370190505b50915060005b60008060006101d98a610b17565b92509250925060008060008061025c6040518060a001604052808873ffffffffffffffffffffffffffffffffffffffff1681526020018973ffffffffffffffffffffffffffffffffffffffff1681526020018f81526020018762ffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff16815250610343565b9350935093509350828b898151811061027157fe5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050818a89815181106102b857fe5b63ffffffff90921660209283029190910190910152929b50968201966001909601958b926102e58e610b48565b156102fa576102f38e610b50565b9d5061030a565b8c9b505050505050505050610316565b505050505050506101cb565b92959194509250565b7f000000000000000000000000000000000000000000000000000000000000000081565b60208101518151606083015160009283928392839273ffffffffffffffffffffffffffffffffffffffff808216908416109284926103819290610b8b565b9050866080015173ffffffffffffffffffffffffffffffffffffffff16600014156103af5760408701516000555b60005a90508173ffffffffffffffffffffffffffffffffffffffff1663128acb0830856103df8c60400151610bc9565b6000038c6080015173ffffffffffffffffffffffffffffffffffffffff1660001461040e578c60800151610434565b8761042d5773fffd8963efd1fc6a506488495d951d5263988d25610434565b6401000276a45b8d602001518e606001518f6000015160405160200161045593929190611d89565b6040516020818303038152906040526040518663ffffffff1660e01b8152600401610484959493929190611e10565b6040805180830381600087803b15801561049d57600080fd5b505af19250505080156104eb575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526104e891810190611b6e565b60015b610568573d808015610519576040519150601f19603f3d011682016040523d82523d6000602084013e61051e565b606091505b505a82039450886080015173ffffffffffffffffffffffffffffffffffffffff166000141561054c57600080555b610557818487610bfb565b97509750975097505050505061056e565b50505050505b9193509193565b7f000000000000000000000000000000000000000000000000000000000000000081565b60208101518151606083015160009283928392839273ffffffffffffffffffffffffffffffffffffffff808216908416109284926105d79290610b8b565b905060005a90508173ffffffffffffffffffffffffffffffffffffffff1663128acb0830856106098c60400151610bc9565b60808d015173ffffffffffffffffffffffffffffffffffffffff1615610633578c60800151610659565b876106525773fffd8963efd1fc6a506488495d951d5263988d25610659565b6401000276a45b8d600001518e606001518f6020015160405160200161067a93929190611d89565b6040516020818303038152906040526040518663ffffffff1660e01b81526004016106a9959493929190611e10565b6040805180830381600087803b1580156106c257600080fd5b505af1925050508015610710575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261070d91810190611b6e565b60015b610568573d80801561073e576040519150601f19603f3d011682016040523d82523d6000602084013e610743565b606091505b505a82039450610557818487610bfb565b6000606080600061076486610ae8565b67ffffffffffffffff8111801561077a57600080fd5b506040519080825280602002602001820160405280156107a4578160200160208202803683370190505b5092506107b086610ae8565b67ffffffffffffffff811180156107c657600080fd5b506040519080825280602002602001820160405280156107f0578160200160208202803683370190505b50915060005b60008060006108048a610b17565b9250925092506000806000806108876040518060a001604052808973ffffffffffffffffffffffffffffffffffffffff1681526020018873ffffffffffffffffffffffffffffffffffffffff1681526020018f81526020018762ffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff16815250610599565b9350935093509350828b898151811061089c57fe5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050818a89815181106108e357fe5b63ffffffff90921660209283029190910190910152929b50968201966001909601958b926109108e610b48565b156102fa5761091e8e610b50565b9d50505050505050506107f6565b600083138061093b5750600082135b61094457600080fd5b600080600061095284610b17565b9250925092506109847f0000000000000000000000000000000000000000000000000000000000000000848484610ccf565b5060008060008089136109ca578573ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1610888a6000036109ff565b8473ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff161089896000035b9250925092506000610a12878787610b8b565b90506000808273ffffffffffffffffffffffffffffffffffffffff16633850c7bd6040518163ffffffff1660e01b815260040160e06040518083038186803b158015610a5d57600080fd5b505afa158015610a71573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a959190611c6b565b5050505050915091508515610abb57604051848152826020820152816040820152606081fd5b60005415610ad1576000548414610ad157600080fd5b604051858152826020820152816040820152606081fd5b805160177fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec909101045b919050565b60008080610b258482610cee565b9250610b32846014610dee565b9050610b3f846017610cee565b91509193909250565b516042111590565b8051606090610b859083906017907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe901610ede565b92915050565b6000610bc17f0000000000000000000000000000000000000000000000000000000000000000610bbc8686866110c5565b611142565b949350505050565b60007f80000000000000000000000000000000000000000000000000000000000000008210610bf757600080fd5b5090565b6000806000806000808773ffffffffffffffffffffffffffffffffffffffff16633850c7bd6040518163ffffffff1660e01b815260040160e06040518083038186803b158015610c4a57600080fd5b505afa158015610c5e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c829190611c6b565b50939650610c9794508d935061127892505050565b91975095509050610cbf73ffffffffffffffffffffffffffffffffffffffff89168383611339565b9350869250505093509350935093565b6000610ce585610ce08686866110c5565b611991565b95945050505050565b600081826014011015610d6257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f746f416464726573735f6f766572666c6f770000000000000000000000000000604482015290519081900360640190fd5b8160140183511015610dd557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f746f416464726573735f6f75744f66426f756e64730000000000000000000000604482015290519081900360640190fd5b5001602001516c01000000000000000000000000900490565b600081826003011015610e6257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f746f55696e7432345f6f766572666c6f77000000000000000000000000000000604482015290519081900360640190fd5b8160030183511015610ed557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f746f55696e7432345f6f75744f66426f756e6473000000000000000000000000604482015290519081900360640190fd5b50016003015190565b60608182601f011015610f5257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b828284011015610fc357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b8183018451101561103557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f736c6963655f6f75744f66426f756e6473000000000000000000000000000000604482015290519081900360640190fd5b60608215801561105457604051915060008252602082016040526110bc565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561108d578051835260209283019201611075565b5050858452601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016604052505b50949350505050565b6110cd6119fa565b8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161115611105579192915b506040805160608101825273ffffffffffffffffffffffffffffffffffffffff948516815292909316602083015262ffffff169181019190915290565b6000816020015173ffffffffffffffffffffffffffffffffffffffff16826000015173ffffffffffffffffffffffffffffffffffffffff161061118457600080fd5b508051602080830151604093840151845173ffffffffffffffffffffffffffffffffffffffff94851681850152939091168385015262ffffff166060808401919091528351808403820181526080840185528051908301207fff0000000000000000000000000000000000000000000000000000000000000060a085015294901b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000001660a183015260b58201939093527fe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b5460d5808301919091528251808303909101815260f5909101909152805191012090565b60008060008351606014611318576044845110156112cb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016112c290611e75565b60405180910390fd5b600484019350838060200190518101906112e59190611bdf565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016112c29190611e62565b8380602001905181019061132c9190611d02565b9250925092509193909250565b60008060008060008060008060088b73ffffffffffffffffffffffffffffffffffffffff1663d0c93a7c6040518163ffffffff1660e01b815260040160206040518083038186803b15801561138d57600080fd5b505afa1580156113a1573d6000803e3d6000fd5b505050506040513d60208110156113b757600080fd5b5051600290810b908c900b816113c957fe5b0560020b901d905060006101008c73ffffffffffffffffffffffffffffffffffffffff1663d0c93a7c6040518163ffffffff1660e01b815260040160206040518083038186803b15801561141c57600080fd5b505afa158015611430573d6000803e3d6000fd5b505050506040513d602081101561144657600080fd5b5051600290810b908d900b8161145857fe5b0560020b8161146357fe5b079050600060088d73ffffffffffffffffffffffffffffffffffffffff1663d0c93a7c6040518163ffffffff1660e01b815260040160206040518083038186803b1580156114b057600080fd5b505afa1580156114c4573d6000803e3d6000fd5b505050506040513d60208110156114da57600080fd5b5051600290810b908d900b816114ec57fe5b0560020b901d905060006101008e73ffffffffffffffffffffffffffffffffffffffff1663d0c93a7c6040518163ffffffff1660e01b815260040160206040518083038186803b15801561153f57600080fd5b505afa158015611553573d6000803e3d6000fd5b505050506040513d602081101561156957600080fd5b5051600290810b908e900b8161157b57fe5b0560020b8161158657fe5b07905060008160ff166001901b8f73ffffffffffffffffffffffffffffffffffffffff16635339c296856040518263ffffffff1660e01b8152600401808260010b815260200191505060206040518083038186803b1580156115e757600080fd5b505afa1580156115fb573d6000803e3d6000fd5b505050506040513d602081101561161157600080fd5b5051161180156116a457508d73ffffffffffffffffffffffffffffffffffffffff1663d0c93a7c6040518163ffffffff1660e01b815260040160206040518083038186803b15801561166257600080fd5b505afa158015611676573d6000803e3d6000fd5b505050506040513d602081101561168c57600080fd5b5051600290810b908d900b8161169e57fe5b0760020b155b80156116b557508b60020b8d60020b135b945060008360ff166001901b8f73ffffffffffffffffffffffffffffffffffffffff16635339c296876040518263ffffffff1660e01b8152600401808260010b815260200191505060206040518083038186803b15801561171557600080fd5b505afa158015611729573d6000803e3d6000fd5b505050506040513d602081101561173f57600080fd5b5051161180156117d257508d73ffffffffffffffffffffffffffffffffffffffff1663d0c93a7c6040518163ffffffff1660e01b815260040160206040518083038186803b15801561179057600080fd5b505afa1580156117a4573d6000803e3d6000fd5b505050506040513d60208110156117ba57600080fd5b5051600290810b908e900b816117cc57fe5b0760020b155b80156117e357508b60020b8d60020b125b95508160010b8460010b128061180f57508160010b8460010b14801561180f57508060ff168360ff1611155b1561182557839950829750819850809650611832565b8199508097508398508296505b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60ff87161b9150505b8560010b8760010b13611969578560010b8760010b14156118a3577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60ff858103161c165b6000818c73ffffffffffffffffffffffffffffffffffffffff16635339c2968a6040518263ffffffff1660e01b8152600401808260010b815260200191505060206040518083038186803b1580156118fa57600080fd5b505afa15801561190e573d6000803e3d6000fd5b505050506040513d602081101561192457600080fd5b5051169050611932816119c1565b61ffff16989098019750506001909501947fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61185e565b8115611976576001880397505b8215611983576001880397505b505050505050509392505050565b600061199d8383611142565b90503373ffffffffffffffffffffffffffffffffffffffff821614610b8557600080fd5b6000805b8215610b85577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8301909216916001016119c5565b604080516060810182526000808252602082018190529181019190915290565b600082601f830112611a2a578081fd5b8135611a3d611a3882611faf565b611f8b565b818152846020838601011115611a51578283fd5b816020850160208301379081016020019190915292915050565b8051600281900b8114610b1257600080fd5b600060a08284031215611a8e578081fd5b60405160a0810181811067ffffffffffffffff82111715611aab57fe5b6040529050808235611abc8161201f565b81526020830135611acc8161201f565b602082015260408381013590820152606083013562ffffff81168114611af157600080fd5b6060820152611b0260808401611b0e565b60808201525092915050565b8035610b128161201f565b805161ffff81168114610b1257600080fd5b60008060408385031215611b3d578182fd5b823567ffffffffffffffff811115611b53578283fd5b611b5f85828601611a1a565b95602094909401359450505050565b60008060408385031215611b80578182fd5b505080516020909101519092909150565b600080600060608486031215611ba5578081fd5b8335925060208401359150604084013567ffffffffffffffff811115611bc9578182fd5b611bd586828701611a1a565b9150509250925092565b600060208284031215611bf0578081fd5b815167ffffffffffffffff811115611c06578182fd5b8201601f81018413611c16578182fd5b8051611c24611a3882611faf565b818152856020838501011115611c38578384fd5b610ce5826020830160208601611fef565b600060a08284031215611c5a578081fd5b611c648383611a7d565b9392505050565b600080600080600080600060e0888a031215611c85578283fd5b8751611c908161201f565b9650611c9e60208901611a6b565b9550611cac60408901611b19565b9450611cba60608901611b19565b9350611cc860808901611b19565b925060a088015160ff81168114611cdd578283fd5b60c08901519092508015158114611cf2578182fd5b8091505092959891949750929550565b600080600060608486031215611d16578081fd5b835192506020840151611d288161201f565b9150611d3660408501611a6b565b90509250925092565b60008151808452611d57816020860160208601611fef565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b606093841b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000908116825260e89390931b7fffffff0000000000000000000000000000000000000000000000000000000000166014820152921b166017820152602b0190565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b600073ffffffffffffffffffffffffffffffffffffffff8088168352861515602084015285604084015280851660608401525060a06080830152611e5760a0830184611d3f565b979650505050505050565b600060208252611c646020830184611d3f565b60208082526010908201527f556e6578706563746564206572726f7200000000000000000000000000000000604082015260600190565b600060808201868352602060808185015281875180845260a0860191508289019350845b81811015611f0257845173ffffffffffffffffffffffffffffffffffffffff1683529383019391830191600101611ed0565b505084810360408601528651808252908201925081870190845b81811015611f3e57825163ffffffff1685529383019391830191600101611f1c565b5050505060609290920192909252949350505050565b93845273ffffffffffffffffffffffffffffffffffffffff92909216602084015263ffffffff166040830152606082015260800190565b60405181810167ffffffffffffffff81118282101715611fa757fe5b604052919050565b600067ffffffffffffffff821115611fc357fe5b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b60005b8381101561200a578181015183820152602001611ff2565b83811115612019576000848401525b50505050565b73ffffffffffffffffffffffffffffffffffffffff8116811461204157600080fd5b5056fea164736f6c6343000706000a";
const deployedBytecode$6 = "0x608060405234801561001057600080fd5b506004361061007d5760003560e01c8063c45a01551161005b578063c45a0155146100e6578063c6a5026a146100ee578063cdca175314610101578063fa461e33146101145761007d565b80632f80bb1d146100825780634aa4a4fc146100ae578063bd21704a146100c3575b600080fd5b610095610090366004611b2b565b610129565b6040516100a59493929190611eac565b60405180910390f35b6100b661031f565b6040516100a59190611def565b6100d66100d1366004611c49565b610343565b6040516100a59493929190611f54565b6100b6610575565b6100d66100fc366004611c49565b610599565b61009561010f366004611b2b565b610754565b610127610122366004611b91565b61092c565b005b6000606080600061013986610ae8565b67ffffffffffffffff8111801561014f57600080fd5b50604051908082528060200260200182016040528015610179578160200160208202803683370190505b50925061018586610ae8565b67ffffffffffffffff8111801561019b57600080fd5b506040519080825280602002602001820160405280156101c5578160200160208202803683370190505b50915060005b60008060006101d98a610b17565b92509250925060008060008061025c6040518060a001604052808873ffffffffffffffffffffffffffffffffffffffff1681526020018973ffffffffffffffffffffffffffffffffffffffff1681526020018f81526020018762ffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff16815250610343565b9350935093509350828b898151811061027157fe5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050818a89815181106102b857fe5b63ffffffff90921660209283029190910190910152929b50968201966001909601958b926102e58e610b48565b156102fa576102f38e610b50565b9d5061030a565b8c9b505050505050505050610316565b505050505050506101cb565b92959194509250565b7f000000000000000000000000000000000000000000000000000000000000000081565b60208101518151606083015160009283928392839273ffffffffffffffffffffffffffffffffffffffff808216908416109284926103819290610b8b565b9050866080015173ffffffffffffffffffffffffffffffffffffffff16600014156103af5760408701516000555b60005a90508173ffffffffffffffffffffffffffffffffffffffff1663128acb0830856103df8c60400151610bc9565b6000038c6080015173ffffffffffffffffffffffffffffffffffffffff1660001461040e578c60800151610434565b8761042d5773fffd8963efd1fc6a506488495d951d5263988d25610434565b6401000276a45b8d602001518e606001518f6000015160405160200161045593929190611d89565b6040516020818303038152906040526040518663ffffffff1660e01b8152600401610484959493929190611e10565b6040805180830381600087803b15801561049d57600080fd5b505af19250505080156104eb575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526104e891810190611b6e565b60015b610568573d808015610519576040519150601f19603f3d011682016040523d82523d6000602084013e61051e565b606091505b505a82039450886080015173ffffffffffffffffffffffffffffffffffffffff166000141561054c57600080555b610557818487610bfb565b97509750975097505050505061056e565b50505050505b9193509193565b7f000000000000000000000000000000000000000000000000000000000000000081565b60208101518151606083015160009283928392839273ffffffffffffffffffffffffffffffffffffffff808216908416109284926105d79290610b8b565b905060005a90508173ffffffffffffffffffffffffffffffffffffffff1663128acb0830856106098c60400151610bc9565b60808d015173ffffffffffffffffffffffffffffffffffffffff1615610633578c60800151610659565b876106525773fffd8963efd1fc6a506488495d951d5263988d25610659565b6401000276a45b8d600001518e606001518f6020015160405160200161067a93929190611d89565b6040516020818303038152906040526040518663ffffffff1660e01b81526004016106a9959493929190611e10565b6040805180830381600087803b1580156106c257600080fd5b505af1925050508015610710575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261070d91810190611b6e565b60015b610568573d80801561073e576040519150601f19603f3d011682016040523d82523d6000602084013e610743565b606091505b505a82039450610557818487610bfb565b6000606080600061076486610ae8565b67ffffffffffffffff8111801561077a57600080fd5b506040519080825280602002602001820160405280156107a4578160200160208202803683370190505b5092506107b086610ae8565b67ffffffffffffffff811180156107c657600080fd5b506040519080825280602002602001820160405280156107f0578160200160208202803683370190505b50915060005b60008060006108048a610b17565b9250925092506000806000806108876040518060a001604052808973ffffffffffffffffffffffffffffffffffffffff1681526020018873ffffffffffffffffffffffffffffffffffffffff1681526020018f81526020018762ffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff16815250610599565b9350935093509350828b898151811061089c57fe5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050818a89815181106108e357fe5b63ffffffff90921660209283029190910190910152929b50968201966001909601958b926109108e610b48565b156102fa5761091e8e610b50565b9d50505050505050506107f6565b600083138061093b5750600082135b61094457600080fd5b600080600061095284610b17565b9250925092506109847f0000000000000000000000000000000000000000000000000000000000000000848484610ccf565b5060008060008089136109ca578573ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1610888a6000036109ff565b8473ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff161089896000035b9250925092506000610a12878787610b8b565b90506000808273ffffffffffffffffffffffffffffffffffffffff16633850c7bd6040518163ffffffff1660e01b815260040160e06040518083038186803b158015610a5d57600080fd5b505afa158015610a71573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a959190611c6b565b5050505050915091508515610abb57604051848152826020820152816040820152606081fd5b60005415610ad1576000548414610ad157600080fd5b604051858152826020820152816040820152606081fd5b805160177fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec909101045b919050565b60008080610b258482610cee565b9250610b32846014610dee565b9050610b3f846017610cee565b91509193909250565b516042111590565b8051606090610b859083906017907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe901610ede565b92915050565b6000610bc17f0000000000000000000000000000000000000000000000000000000000000000610bbc8686866110c5565b611142565b949350505050565b60007f80000000000000000000000000000000000000000000000000000000000000008210610bf757600080fd5b5090565b6000806000806000808773ffffffffffffffffffffffffffffffffffffffff16633850c7bd6040518163ffffffff1660e01b815260040160e06040518083038186803b158015610c4a57600080fd5b505afa158015610c5e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c829190611c6b565b50939650610c9794508d935061127892505050565b91975095509050610cbf73ffffffffffffffffffffffffffffffffffffffff89168383611339565b9350869250505093509350935093565b6000610ce585610ce08686866110c5565b611991565b95945050505050565b600081826014011015610d6257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f746f416464726573735f6f766572666c6f770000000000000000000000000000604482015290519081900360640190fd5b8160140183511015610dd557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f746f416464726573735f6f75744f66426f756e64730000000000000000000000604482015290519081900360640190fd5b5001602001516c01000000000000000000000000900490565b600081826003011015610e6257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f746f55696e7432345f6f766572666c6f77000000000000000000000000000000604482015290519081900360640190fd5b8160030183511015610ed557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f746f55696e7432345f6f75744f66426f756e6473000000000000000000000000604482015290519081900360640190fd5b50016003015190565b60608182601f011015610f5257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b828284011015610fc357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b8183018451101561103557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f736c6963655f6f75744f66426f756e6473000000000000000000000000000000604482015290519081900360640190fd5b60608215801561105457604051915060008252602082016040526110bc565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561108d578051835260209283019201611075565b5050858452601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016604052505b50949350505050565b6110cd6119fa565b8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161115611105579192915b506040805160608101825273ffffffffffffffffffffffffffffffffffffffff948516815292909316602083015262ffffff169181019190915290565b6000816020015173ffffffffffffffffffffffffffffffffffffffff16826000015173ffffffffffffffffffffffffffffffffffffffff161061118457600080fd5b508051602080830151604093840151845173ffffffffffffffffffffffffffffffffffffffff94851681850152939091168385015262ffffff166060808401919091528351808403820181526080840185528051908301207fff0000000000000000000000000000000000000000000000000000000000000060a085015294901b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000001660a183015260b58201939093527fe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b5460d5808301919091528251808303909101815260f5909101909152805191012090565b60008060008351606014611318576044845110156112cb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016112c290611e75565b60405180910390fd5b600484019350838060200190518101906112e59190611bdf565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016112c29190611e62565b8380602001905181019061132c9190611d02565b9250925092509193909250565b60008060008060008060008060088b73ffffffffffffffffffffffffffffffffffffffff1663d0c93a7c6040518163ffffffff1660e01b815260040160206040518083038186803b15801561138d57600080fd5b505afa1580156113a1573d6000803e3d6000fd5b505050506040513d60208110156113b757600080fd5b5051600290810b908c900b816113c957fe5b0560020b901d905060006101008c73ffffffffffffffffffffffffffffffffffffffff1663d0c93a7c6040518163ffffffff1660e01b815260040160206040518083038186803b15801561141c57600080fd5b505afa158015611430573d6000803e3d6000fd5b505050506040513d602081101561144657600080fd5b5051600290810b908d900b8161145857fe5b0560020b8161146357fe5b079050600060088d73ffffffffffffffffffffffffffffffffffffffff1663d0c93a7c6040518163ffffffff1660e01b815260040160206040518083038186803b1580156114b057600080fd5b505afa1580156114c4573d6000803e3d6000fd5b505050506040513d60208110156114da57600080fd5b5051600290810b908d900b816114ec57fe5b0560020b901d905060006101008e73ffffffffffffffffffffffffffffffffffffffff1663d0c93a7c6040518163ffffffff1660e01b815260040160206040518083038186803b15801561153f57600080fd5b505afa158015611553573d6000803e3d6000fd5b505050506040513d602081101561156957600080fd5b5051600290810b908e900b8161157b57fe5b0560020b8161158657fe5b07905060008160ff166001901b8f73ffffffffffffffffffffffffffffffffffffffff16635339c296856040518263ffffffff1660e01b8152600401808260010b815260200191505060206040518083038186803b1580156115e757600080fd5b505afa1580156115fb573d6000803e3d6000fd5b505050506040513d602081101561161157600080fd5b5051161180156116a457508d73ffffffffffffffffffffffffffffffffffffffff1663d0c93a7c6040518163ffffffff1660e01b815260040160206040518083038186803b15801561166257600080fd5b505afa158015611676573d6000803e3d6000fd5b505050506040513d602081101561168c57600080fd5b5051600290810b908d900b8161169e57fe5b0760020b155b80156116b557508b60020b8d60020b135b945060008360ff166001901b8f73ffffffffffffffffffffffffffffffffffffffff16635339c296876040518263ffffffff1660e01b8152600401808260010b815260200191505060206040518083038186803b15801561171557600080fd5b505afa158015611729573d6000803e3d6000fd5b505050506040513d602081101561173f57600080fd5b5051161180156117d257508d73ffffffffffffffffffffffffffffffffffffffff1663d0c93a7c6040518163ffffffff1660e01b815260040160206040518083038186803b15801561179057600080fd5b505afa1580156117a4573d6000803e3d6000fd5b505050506040513d60208110156117ba57600080fd5b5051600290810b908e900b816117cc57fe5b0760020b155b80156117e357508b60020b8d60020b125b95508160010b8460010b128061180f57508160010b8460010b14801561180f57508060ff168360ff1611155b1561182557839950829750819850809650611832565b8199508097508398508296505b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60ff87161b9150505b8560010b8760010b13611969578560010b8760010b14156118a3577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60ff858103161c165b6000818c73ffffffffffffffffffffffffffffffffffffffff16635339c2968a6040518263ffffffff1660e01b8152600401808260010b815260200191505060206040518083038186803b1580156118fa57600080fd5b505afa15801561190e573d6000803e3d6000fd5b505050506040513d602081101561192457600080fd5b5051169050611932816119c1565b61ffff16989098019750506001909501947fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61185e565b8115611976576001880397505b8215611983576001880397505b505050505050509392505050565b600061199d8383611142565b90503373ffffffffffffffffffffffffffffffffffffffff821614610b8557600080fd5b6000805b8215610b85577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8301909216916001016119c5565b604080516060810182526000808252602082018190529181019190915290565b600082601f830112611a2a578081fd5b8135611a3d611a3882611faf565b611f8b565b818152846020838601011115611a51578283fd5b816020850160208301379081016020019190915292915050565b8051600281900b8114610b1257600080fd5b600060a08284031215611a8e578081fd5b60405160a0810181811067ffffffffffffffff82111715611aab57fe5b6040529050808235611abc8161201f565b81526020830135611acc8161201f565b602082015260408381013590820152606083013562ffffff81168114611af157600080fd5b6060820152611b0260808401611b0e565b60808201525092915050565b8035610b128161201f565b805161ffff81168114610b1257600080fd5b60008060408385031215611b3d578182fd5b823567ffffffffffffffff811115611b53578283fd5b611b5f85828601611a1a565b95602094909401359450505050565b60008060408385031215611b80578182fd5b505080516020909101519092909150565b600080600060608486031215611ba5578081fd5b8335925060208401359150604084013567ffffffffffffffff811115611bc9578182fd5b611bd586828701611a1a565b9150509250925092565b600060208284031215611bf0578081fd5b815167ffffffffffffffff811115611c06578182fd5b8201601f81018413611c16578182fd5b8051611c24611a3882611faf565b818152856020838501011115611c38578384fd5b610ce5826020830160208601611fef565b600060a08284031215611c5a578081fd5b611c648383611a7d565b9392505050565b600080600080600080600060e0888a031215611c85578283fd5b8751611c908161201f565b9650611c9e60208901611a6b565b9550611cac60408901611b19565b9450611cba60608901611b19565b9350611cc860808901611b19565b925060a088015160ff81168114611cdd578283fd5b60c08901519092508015158114611cf2578182fd5b8091505092959891949750929550565b600080600060608486031215611d16578081fd5b835192506020840151611d288161201f565b9150611d3660408501611a6b565b90509250925092565b60008151808452611d57816020860160208601611fef565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b606093841b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000908116825260e89390931b7fffffff0000000000000000000000000000000000000000000000000000000000166014820152921b166017820152602b0190565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b600073ffffffffffffffffffffffffffffffffffffffff8088168352861515602084015285604084015280851660608401525060a06080830152611e5760a0830184611d3f565b979650505050505050565b600060208252611c646020830184611d3f565b60208082526010908201527f556e6578706563746564206572726f7200000000000000000000000000000000604082015260600190565b600060808201868352602060808185015281875180845260a0860191508289019350845b81811015611f0257845173ffffffffffffffffffffffffffffffffffffffff1683529383019391830191600101611ed0565b505084810360408601528651808252908201925081870190845b81811015611f3e57825163ffffffff1685529383019391830191600101611f1c565b5050505060609290920192909252949350505050565b93845273ffffffffffffffffffffffffffffffffffffffff92909216602084015263ffffffff166040830152606082015260800190565b60405181810167ffffffffffffffff81118282101715611fa757fe5b604052919050565b600067ffffffffffffffff821115611fc357fe5b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b60005b8381101561200a578181015183820152602001611ff2565b83811115612019576000848401525b50505050565b73ffffffffffffffffffffffffffffffffffffffff8116811461204157600080fd5b5056fea164736f6c6343000706000a";
const linkReferences$6 = {};
const deployedLinkReferences$6 = {};
const IQuoterV2 = {
  _format: _format$6,
  contractName: contractName$6,
  sourceName: sourceName$6,
  abi: abi$6,
  bytecode: bytecode$6,
  deployedBytecode: deployedBytecode$6,
  linkReferences: linkReferences$6,
  deployedLinkReferences: deployedLinkReferences$6
};
const _format$5 = "hh-sol-artifact-1";
const contractName$5 = "UniswapV3Staker";
const sourceName$5 = "contracts/UniswapV3Staker.sol";
const abi$5 = [
  {
    inputs: [
      {
        internalType: "contract IUniswapV3Factory",
        name: "_factory",
        type: "address"
      },
      {
        internalType: "contract INonfungiblePositionManager",
        name: "_nonfungiblePositionManager",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_maxIncentiveStartLeadTime",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_maxIncentiveDuration",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "oldOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "DepositTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract IERC20Minimal",
        name: "rewardToken",
        type: "address"
      },
      {
        indexed: true,
        internalType: "contract IUniswapV3Pool",
        name: "pool",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTime",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "refundee",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "reward",
        type: "uint256"
      }
    ],
    name: "IncentiveCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "incentiveId",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "refund",
        type: "uint256"
      }
    ],
    name: "IncentiveEnded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "reward",
        type: "uint256"
      }
    ],
    name: "RewardClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "incentiveId",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint128",
        name: "liquidity",
        type: "uint128"
      }
    ],
    name: "TokenStaked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "incentiveId",
        type: "bytes32"
      }
    ],
    name: "TokenUnstaked",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20Minimal",
        name: "rewardToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amountRequested",
        type: "uint256"
      }
    ],
    name: "claimReward",
    outputs: [
      {
        internalType: "uint256",
        name: "reward",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "contract IERC20Minimal",
            name: "rewardToken",
            type: "address"
          },
          {
            internalType: "contract IUniswapV3Pool",
            name: "pool",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "startTime",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "endTime",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "refundee",
            type: "address"
          }
        ],
        internalType: "struct IUniswapV3Staker.IncentiveKey",
        name: "key",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "reward",
        type: "uint256"
      }
    ],
    name: "createIncentive",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "deposits",
    outputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "uint48",
        name: "numberOfStakes",
        type: "uint48"
      },
      {
        internalType: "int24",
        name: "tickLower",
        type: "int24"
      },
      {
        internalType: "int24",
        name: "tickUpper",
        type: "int24"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "contract IERC20Minimal",
            name: "rewardToken",
            type: "address"
          },
          {
            internalType: "contract IUniswapV3Pool",
            name: "pool",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "startTime",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "endTime",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "refundee",
            type: "address"
          }
        ],
        internalType: "struct IUniswapV3Staker.IncentiveKey",
        name: "key",
        type: "tuple"
      }
    ],
    name: "endIncentive",
    outputs: [
      {
        internalType: "uint256",
        name: "refund",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "factory",
    outputs: [
      {
        internalType: "contract IUniswapV3Factory",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "contract IERC20Minimal",
            name: "rewardToken",
            type: "address"
          },
          {
            internalType: "contract IUniswapV3Pool",
            name: "pool",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "startTime",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "endTime",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "refundee",
            type: "address"
          }
        ],
        internalType: "struct IUniswapV3Staker.IncentiveKey",
        name: "key",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getRewardInfo",
    outputs: [
      {
        internalType: "uint256",
        name: "reward",
        type: "uint256"
      },
      {
        internalType: "uint160",
        name: "secondsInsideX128",
        type: "uint160"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "incentives",
    outputs: [
      {
        internalType: "uint256",
        name: "totalRewardUnclaimed",
        type: "uint256"
      },
      {
        internalType: "uint160",
        name: "totalSecondsClaimedX128",
        type: "uint160"
      },
      {
        internalType: "uint96",
        name: "numberOfStakes",
        type: "uint96"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "maxIncentiveDuration",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "maxIncentiveStartLeadTime",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "nonfungiblePositionManager",
    outputs: [
      {
        internalType: "contract INonfungiblePositionManager",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "onERC721Received",
    outputs: [
      {
        internalType: "bytes4",
        name: "",
        type: "bytes4"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20Minimal",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "rewards",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "contract IERC20Minimal",
            name: "rewardToken",
            type: "address"
          },
          {
            internalType: "contract IUniswapV3Pool",
            name: "pool",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "startTime",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "endTime",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "refundee",
            type: "address"
          }
        ],
        internalType: "struct IUniswapV3Staker.IncentiveKey",
        name: "key",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "stakeToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "incentiveId",
        type: "bytes32"
      }
    ],
    name: "stakes",
    outputs: [
      {
        internalType: "uint160",
        name: "secondsPerLiquidityInsideInitialX128",
        type: "uint160"
      },
      {
        internalType: "uint128",
        name: "liquidity",
        type: "uint128"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "transferDeposit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "contract IERC20Minimal",
            name: "rewardToken",
            type: "address"
          },
          {
            internalType: "contract IUniswapV3Pool",
            name: "pool",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "startTime",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "endTime",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "refundee",
            type: "address"
          }
        ],
        internalType: "struct IUniswapV3Staker.IncentiveKey",
        name: "key",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "unstakeToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "withdrawToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const bytecode$5 = "0x6101006040523480156200001257600080fd5b5060405162003ba338038062003ba383398101604081905262000035916200005e565b6001600160601b0319606094851b81166080529290931b90911660a05260c05260e052620000c3565b6000806000806080858703121562000074578384fd5b84516200008181620000aa565b60208601519094506200009481620000aa565b6040860151606090960151949790965092505050565b6001600160a01b0381168114620000c057600080fd5b50565b60805160601c60a05160601c60c05160e051613a816200012260003980610bbd5280610cfa5250806103b15280610c595250806103ed52806104525280610b4852806110555280611ad552508061124c5280611ab45250613a816000f3fe6080604052600436106101295760003560e01c8063b02c43d0116100a5578063c45a015511610074578063e70b9e2711610059578063e70b9e271461034f578063f2d2909b1461036f578063f549ab421461038f57610129565b8063c45a01551461030c578063d953186e1461032157610129565b8063b02c43d01461026c578063b44a27221461029c578063b5ada6e4146102be578063c36c1ea5146102de57610129565b80633c423f0b116100fc5780635cc5e3d9116100e15780635cc5e3d9146101fd578063607777951461021d578063ac9650d81461024c57610129565b80633c423f0b146101c85780633dc0714b146101e857610129565b806301b754401461012e578063150b7a021461015957806326bfee04146101865780632f2d783d146101a8575b600080fd5b34801561013a57600080fd5b506101436103af565b60405161015091906138b9565b60405180910390f35b34801561016557600080fd5b5061017961017436600461273f565b6103d3565b6040516101509190612db4565b34801561019257600080fd5b506101a66101a1366004612a9c565b61071c565b005b3480156101b457600080fd5b506101436101c3366004612946565b61084a565b3480156101d457600080fd5b506101a66101e3366004612ac0565b610928565b3480156101f457600080fd5b50610143610bbb565b34801561020957600080fd5b506101a6610218366004612a72565b610bdf565b34801561022957600080fd5b5061023d6102383660046128f6565b610e10565b604051610150939291906138e6565b61025f61025a3660046127d9565b610e67565b6040516101509190612d36565b34801561027857600080fd5b5061028c6102873660046128f6565b610fc1565b6040516101509493929190612cf5565b3480156102a857600080fd5b506102b1611053565b6040516101509190612de1565b3480156102ca57600080fd5b506101436102d9366004612a57565b611077565b3480156102ea57600080fd5b506102fe6102f9366004612b52565b6111c5565b604051610150929190613881565b34801561031857600080fd5b506102b161124a565b34801561032d57600080fd5b5061034161033c366004612a72565b61126e565b6040516101509291906138c2565b34801561035b57600080fd5b5061014361036a36600461290e565b611493565b34801561037b57600080fd5b506101a661038a366004612a72565b6114b0565b34801561039b57600080fd5b506101a66103aa366004612a72565b61151b565b7f000000000000000000000000000000000000000000000000000000000000000081565b60003373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000161461044d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104449061375a565b60405180910390fd5b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166399fbab88876040518263ffffffff1660e01b81526004016104a991906138b9565b6101806040518083038186803b1580156104c257600080fd5b505afa1580156104d6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104fa9190612b73565b505050505096509650505050505060405180608001604052808873ffffffffffffffffffffffffffffffffffffffff168152602001600065ffffffffffff1681526020018360020b81526020018260020b8152506001600088815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060208201518160000160146101000a81548165ffffffffffff021916908365ffffffffffff160217905550604082015181600001601a6101000a81548162ffffff021916908360020b62ffffff160217905550606082015181600001601d6101000a81548162ffffff021916908360020b62ffffff1602179055509050508673ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff16877fcdfc765b85e1048bee3c6a0f9d1c91fc7c4631f5fe5745a55fc6843db5c3260f60405160405180910390a483156106ef5760a08414156106ab576106a66106a085870187612a57565b87611964565b6106ef565b60006106b985870187612848565b905060005b81518110156106ec576106e48282815181106106d657fe5b602002602001015189611964565b6001016106be565b50505b507f150b7a0200000000000000000000000000000000000000000000000000000000979650505050505050565b73ffffffffffffffffffffffffffffffffffffffff8116610769576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490613183565b60008281526001602052604090205473ffffffffffffffffffffffffffffffffffffffff163381146107c7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490612e86565b60008381526001602052604080822080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff868116918217909255915191929084169186917fcdfc765b85e1048bee3c6a0f9d1c91fc7c4631f5fe5745a55fc6843db5c3260f91a4505050565b73ffffffffffffffffffffffffffffffffffffffff83166000908152600360209081526040808320338452909152902054811580159061088957508082105b156108915750805b73ffffffffffffffffffffffffffffffffffffffff841660009081526003602090815260408083203384529091529020805482900390556108d3848483611ed1565b8273ffffffffffffffffffffffffffffffffffffffff167f106f923f993c2149d49b4255ff723acafa1f2d94393f561d3eda32ae348f72418260405161091991906138b9565b60405180910390a29392505050565b73ffffffffffffffffffffffffffffffffffffffff8216301415610978576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906137b7565b6000838152600160209081526040918290208251608081018452905473ffffffffffffffffffffffffffffffffffffffff8116825265ffffffffffff740100000000000000000000000000000000000000008204169282018390527a0100000000000000000000000000000000000000000000000000008104600290810b810b810b948301949094527d0100000000000000000000000000000000000000000000000000000000009004830b830b90920b606083015215610a65576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490613046565b805173ffffffffffffffffffffffffffffffffffffffff163314610ab5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490613481565b6000848152600160205260408082208290558251905173ffffffffffffffffffffffffffffffffffffffff9091169086907fcdfc765b85e1048bee3c6a0f9d1c91fc7c4631f5fe5745a55fc6843db5c3260f908490a46040517fb88d4fde00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063b88d4fde90610b83903090879089908890600401612cac565b600060405180830381600087803b158015610b9d57600080fd5b505af1158015610bb1573d6000803e3d6000fd5b5050505050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b60008111610c19576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906135be565b8160400151421115610c57576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906131e0565b7f0000000000000000000000000000000000000000000000000000000000000000428360400151031115610cb7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104449061361b565b8160600151826040015110610cf8576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906136d7565b7f000000000000000000000000000000000000000000000000000000000000000082604001518360600151031115610d5c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490613679565b6000610d67836120ad565b60008181526020819052604090208054840190558351909150610d8c903330856120de565b826020015173ffffffffffffffffffffffffffffffffffffffff16836000015173ffffffffffffffffffffffffffffffffffffffff167fa876344e28d4b5191ad03bc0d43f740e3695827ab0faccac739930b915ef8b0285604001518660600151876080015187604051610e039493929190613920565b60405180910390a3505050565b6000602081905290815260409020805460019091015473ffffffffffffffffffffffffffffffffffffffff8116907401000000000000000000000000000000000000000090046bffffffffffffffffffffffff1683565b60608167ffffffffffffffff81118015610e8057600080fd5b50604051908082528060200260200182016040528015610eb457816020015b6060815260200190600190039081610e9f5790505b50905060005b82811015610fba5760008030868685818110610ed257fe5b9050602002810190610ee49190613951565b604051610ef2929190612c9c565b600060405180830381855af49150503d8060008114610f2d576040519150601f19603f3d011682016040523d82523d6000602084013e610f32565b606091505b509150915081610f9857604481511015610f4b57600080fd5b60048101905080806020019051810190610f6591906129df565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104449190612e16565b80848481518110610fa557fe5b60209081029190910101525050600101610eba565b5092915050565b60016020526000908152604090205473ffffffffffffffffffffffffffffffffffffffff81169065ffffffffffff74010000000000000000000000000000000000000000820416907a0100000000000000000000000000000000000000000000000000008104600290810b917d0100000000000000000000000000000000000000000000000000000000009004900b84565b7f000000000000000000000000000000000000000000000000000000000000000081565b600081606001514210156110b7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490612f66565b60006110c2836120ad565b6000818152602081905260409020805493509091508261110e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490612e29565b60018101547401000000000000000000000000000000000000000090046bffffffffffffffffffffffff1615611170576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906134de565b6000815583516080850151611186919085611ed1565b817f65124e6175aa9904f40735e87e2a37c76e87a609b855287bb4d1aba8257d9763846040516111b691906138b9565b60405180910390a25050919050565b60008281526002602090815260408083208484529091529020805473ffffffffffffffffffffffffffffffffffffffff8116916bffffffffffffffffffffffff740100000000000000000000000000000000000000009092048216918214156112425760018101546fffffffffffffffffffffffffffffffff1691505b509250929050565b7f000000000000000000000000000000000000000000000000000000000000000081565b600080600061127c856120ad565b905060008061128b86846111c5565b915091506000816fffffffffffffffffffffffffffffffff16116112db576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490612f09565b60008681526001602081815260408084208151608081018352905473ffffffffffffffffffffffffffffffffffffffff80821683527401000000000000000000000000000000000000000080830465ffffffffffff16848701527a0100000000000000000000000000000000000000000000000000008304600290810b810b810b8587019081527d010000000000000000000000000000000000000000000000000000000000909404810b810b900b60608086019182528c8a52898852868a2087519182018852805482529098015480841689890152919091046bffffffffffffffffffffffff1687860152948e01519151945193517fa38807f200000000000000000000000000000000000000000000000000000000815292969491169263a38807f29261140e929190600401612e02565b60606040518083038186803b15801561142657600080fd5b505afa15801561143a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061145e9190612986565b50915050611482826000015183602001518c604001518d60600151888a87426122c3565b909b909a5098505050505050505050565b600360209081526000928352604080842090915290825290205481565b60008181526001602052604090205473ffffffffffffffffffffffffffffffffffffffff16331461150d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490613561565b6115178282611964565b5050565b6000818152600160209081526040918290208251608081018452905473ffffffffffffffffffffffffffffffffffffffff8116825265ffffffffffff74010000000000000000000000000000000000000000820416928201929092527a0100000000000000000000000000000000000000000000000000008204600290810b810b810b938201939093527d010000000000000000000000000000000000000000000000000000000000909104820b820b90910b60608083019190915283015142101561163157805173ffffffffffffffffffffffffffffffffffffffff163314611631576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104449061331e565b600061163c846120ad565b905060008061164b85846111c5565b91509150806fffffffffffffffffffffffffffffffff166000141561169c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490612fe9565b600083815260208181526040808320888452600180845282852080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff65ffffffffffff740100000000000000000000000000000000000000008084048216830190911681027fffffffffffff000000000000ffffffffffffffffffffffffffffffffffffffff9093169290921790925591830180546bffffffffffffffffffffffff848204811690930190921690920273ffffffffffffffffffffffffffffffffffffffff91821617909155928a01518883015160608a015193517fa38807f2000000000000000000000000000000000000000000000000000000008152929594919091169263a38807f2926117b7929190600401612e02565b60606040518083038186803b1580156117cf57600080fd5b505afa1580156117e3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118079190612986565b508354600185015460408c015160608d0151939550600094508493611848939273ffffffffffffffffffffffffffffffffffffffff169190898b89426122c3565b6001860180547fffffffffffffffffffffffff0000000000000000000000000000000000000000811673ffffffffffffffffffffffffffffffffffffffff9182168401821617909155865483900387558c51811660009081526003602090815260408083208e5190941683529281528282208054860190558d8252600281528282208c8352905290812090815591935091506bffffffffffffffffffffffff6fffffffffffffffffffffffffffffffff87161061192a576001810180547fffffffffffffffffffffffffffffffff000000000000000000000000000000001690555b60405188908b907fe1ba67e807ae0efa0a9549f9520ddc15c27f0a4dae2bc045e800ca66a940778f90600090a35050505050505050505050565b81604001514210156119a2576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906133a1565b816060015142106119df576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490613126565b60006119ea836120ad565b600081815260208190526040902054909150611a32576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906132c1565b60008281526002602090815260408083208484529091529020547401000000000000000000000000000000000000000090046bffffffffffffffffffffffff1615611aa9576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906130c9565b600080600080611afa7f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000088612345565b9350935093509350866020015173ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614611b6b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906133fe565b6000816fffffffffffffffffffffffffffffffff1611611bb7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490613263565b6000868152600160208181526040808420805465ffffffffffff740100000000000000000000000000000000000000008083048216870190911681027fffffffffffff000000000000ffffffffffffffffffffffffffffffffffffffff9092169190911790915589855291849052808420830180546bffffffffffffffffffffffff848204811690950190941690920273ffffffffffffffffffffffffffffffffffffffff93841617909155517fa38807f20000000000000000000000000000000000000000000000000000000081529086169063a38807f290611ca19087908790600401612e02565b60606040518083038186803b158015611cb957600080fd5b505afa158015611ccd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cf19190612986565b509150506bffffffffffffffffffffffff6fffffffffffffffffffffffffffffffff831610611e0a576040805160608101825273ffffffffffffffffffffffffffffffffffffffff80841682526bffffffffffffffffffffffff60208084018281526fffffffffffffffffffffffffffffffff80891686880190815260008f8152600285528881208f82529094529690922094518554915190931674010000000000000000000000000000000000000000029284167fffffffffffffffffffffffff000000000000000000000000000000000000000090911617909216178255915160019091018054919092167fffffffffffffffffffffffffffffffff00000000000000000000000000000000909116179055611e8e565b6000878152600260209081526040808320898452909152902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff8381169190911716740100000000000000000000000000000000000000006bffffffffffffffffffffffff8516021790555b85877f3fe90ccd0a34e28f2b4b7a1e8323415ed9dd595f4eec5dfd461d18c2df336dbd84604051611ebf9190613864565b60405180910390a35050505050505050565b6040805173ffffffffffffffffffffffffffffffffffffffff8481166024830152604480830185905283518084039091018152606490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb000000000000000000000000000000000000000000000000000000001781529251825160009485949389169392918291908083835b60208310611fa657805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09092019160209182019101611f69565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114612008576040519150601f19603f3d011682016040523d82523d6000602084013e61200d565b606091505b509150915081801561203b57508051158061203b575080806020019051602081101561203857600080fd5b50515b6120a657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600260248201527f5354000000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b5050505050565b6000816040516020016120c09190613814565b6040516020818303038152906040528051906020012090505b919050565b6040805173ffffffffffffffffffffffffffffffffffffffff85811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f23b872dd00000000000000000000000000000000000000000000000000000000178152925182516000948594938a169392918291908083835b602083106121bb57805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0909201916020918201910161217e565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d806000811461221d576040519150601f19603f3d011682016040523d82523d6000602084013e612222565b606091505b5091509150818015612250575080511580612250575080806020019051602081101561224d57600080fd5b50515b6122bb57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600360248201527f5354460000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b505050505050565b600080878310156122d057fe5b508383036fffffffffffffffffffffffffffffffff861602600073ffffffffffffffffffffffffffffffffffffffff8a1660808a61230e8b8861244e565b03901b0390506123358b8373ffffffffffffffffffffffffffffffffffffffff1683612467565b9250509850989650505050505050565b60008060008060008060008873ffffffffffffffffffffffffffffffffffffffff166399fbab88896040518263ffffffff1660e01b8152600401808281526020019150506101806040518083038186803b1580156123a257600080fd5b505afa1580156123b6573d6000803e3d6000fd5b505050506040513d6101808110156123cd57600080fd5b50604080820151606080840151608085015160a086015160c087015160e0909701518651948501875273ffffffffffffffffffffffffffffffffffffffff80871686528416602086015262ffffff8316968501969096529b50949950929750909550909350909150612440908b90612534565b965050505093509350935093565b60008183101561245e5781612460565b825b9392505050565b600080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff858709868602925082811090839003039050806124bb57600084116124b057600080fd5b508290049050612460565b8084116124c757600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150509392505050565b6000816020015173ffffffffffffffffffffffffffffffffffffffff16826000015173ffffffffffffffffffffffffffffffffffffffff161061257657600080fd5b508051602080830151604093840151845173ffffffffffffffffffffffffffffffffffffffff94851681850152939091168385015262ffffff166060808401919091528351808403820181526080840185528051908301207fff0000000000000000000000000000000000000000000000000000000000000060a085015294901b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000001660a183015260b58201939093527fe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b5460d5808301919091528251808303909101815260f5909101909152805191012090565b80516120d981613a4f565b8051600281900b81146120d957600080fd5b600060a08284031215612698578081fd5b60405160a0810181811067ffffffffffffffff821117156126b557fe5b60405290508082356126c681613a4f565b815260208301356126d681613a4f565b80602083015250604083013560408201526060830135606082015260808301356126ff81613a4f565b6080919091015292915050565b80516fffffffffffffffffffffffffffffffff811681146120d957600080fd5b805162ffffff811681146120d957600080fd5b600080600080600060808688031215612756578081fd5b853561276181613a4f565b9450602086013561277181613a4f565b935060408601359250606086013567ffffffffffffffff80821115612794578283fd5b818801915088601f8301126127a7578283fd5b8135818111156127b5578384fd5b8960208285010111156127c6578384fd5b9699959850939650602001949392505050565b600080602083850312156127eb578182fd5b823567ffffffffffffffff80821115612802578384fd5b818501915085601f830112612815578384fd5b813581811115612823578485fd5b8660208083028501011115612836578485fd5b60209290920196919550909350505050565b6000602080838503121561285a578182fd5b823567ffffffffffffffff80821115612871578384fd5b818501915085601f830112612884578384fd5b81358181111561289057fe5b61289d84858302016139bb565b818152848101925083850160a0808402860187018a10156128bc578788fd5b8795505b838610156128e8576128d28a83612687565b85526001959095019493860193908101906128c0565b509098975050505050505050565b600060208284031215612907578081fd5b5035919050565b60008060408385031215612920578182fd5b823561292b81613a4f565b9150602083013561293b81613a4f565b809150509250929050565b60008060006060848603121561295a578081fd5b833561296581613a4f565b9250602084013561297581613a4f565b929592945050506040919091013590565b60008060006060848603121561299a578081fd5b83518060060b81146129aa578182fd5b60208501519093506129bb81613a4f565b604085015190925063ffffffff811681146129d4578182fd5b809150509250925092565b6000602082840312156129f0578081fd5b815167ffffffffffffffff811115612a06578182fd5b8201601f81018413612a16578182fd5b8051612a29612a24826139df565b6139bb565b818152856020838501011115612a3d578384fd5b612a4e826020830160208601613a1f565b95945050505050565b600060a08284031215612a68578081fd5b6124608383612687565b60008060c08385031215612a84578182fd5b612a8e8484612687565b9460a0939093013593505050565b60008060408385031215612aae578182fd5b82359150602083013561293b81613a4f565b600080600060608486031215612ad4578081fd5b833592506020840135612ae681613a4f565b9150604084013567ffffffffffffffff811115612b01578182fd5b8401601f81018613612b11578182fd5b8035612b1f612a24826139df565b818152876020838501011115612b33578384fd5b8160208401602083013783602083830101528093505050509250925092565b60008060408385031215612b64578182fd5b50508035926020909101359150565b6000806000806000806000806000806000806101808d8f031215612b9557898afd5b8c516bffffffffffffffffffffffff81168114612bb0578a8bfd5b9b50612bbe60208e0161266a565b9a50612bcc60408e0161266a565b9950612bda60608e0161266a565b9850612be860808e0161272c565b9750612bf660a08e01612675565b9650612c0460c08e01612675565b9550612c1260e08e0161270c565b94506101008d015193506101208d01519250612c316101408e0161270c565b9150612c406101608e0161270c565b90509295989b509295989b509295989b565b60008151808452612c6a816020860160208601613a1f565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6000828483379101908152919050565b600073ffffffffffffffffffffffffffffffffffffffff808716835280861660208401525083604083015260806060830152612ceb6080830184612c52565b9695505050505050565b73ffffffffffffffffffffffffffffffffffffffff94909416845265ffffffffffff929092166020840152600290810b60408401520b606082015260800190565b6000602080830181845280855180835260408601915060408482028701019250838701855b82811015612da7577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0888603018452612d95858351612c52565b94509285019290850190600101612d5b565b5092979650505050505050565b7fffffffff0000000000000000000000000000000000000000000000000000000091909116815260200190565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b600292830b8152910b602082015260400190565b6000602082526124606020830184612c52565b60208082526032908201527f556e697377617056335374616b65723a3a656e64496e63656e746976653a206e60408201527f6f20726566756e6420617661696c61626c650000000000000000000000000000606082015260800190565b60208082526045908201527f556e697377617056335374616b65723a3a7472616e736665724465706f73697460408201527f3a2063616e206f6e6c792062652063616c6c6564206279206465706f7369742060608201527f6f776e6572000000000000000000000000000000000000000000000000000000608082015260a00190565b60208082526034908201527f556e697377617056335374616b65723a3a676574526577617264496e666f3a2060408201527f7374616b6520646f6573206e6f74206578697374000000000000000000000000606082015260800190565b60208082526043908201527f556e697377617056335374616b65723a3a656e64496e63656e746976653a206360408201527f616e6e6f7420656e6420696e63656e74697665206265666f726520656e64207460608201527f696d650000000000000000000000000000000000000000000000000000000000608082015260a00190565b60208082526033908201527f556e697377617056335374616b65723a3a756e7374616b65546f6b656e3a207360408201527f74616b6520646f6573206e6f7420657869737400000000000000000000000000606082015260800190565b60208082526042908201527f556e697377617056335374616b65723a3a7769746864726177546f6b656e3a2060408201527f63616e6e6f7420776974686472617720746f6b656e207768696c65207374616b60608201527f6564000000000000000000000000000000000000000000000000000000000000608082015260a00190565b60208082526031908201527f556e697377617056335374616b65723a3a7374616b65546f6b656e3a20746f6b60408201527f656e20616c7265616479207374616b6564000000000000000000000000000000606082015260800190565b6020808252602c908201527f556e697377617056335374616b65723a3a7374616b65546f6b656e3a20696e6360408201527f656e7469766520656e6465640000000000000000000000000000000000000000606082015260800190565b6020808252603c908201527f556e697377617056335374616b65723a3a7472616e736665724465706f73697460408201527f3a20696e76616c6964207472616e7366657220726563697069656e7400000000606082015260800190565b60208082526049908201527f556e697377617056335374616b65723a3a637265617465496e63656e7469766560408201527f3a2073746172742074696d65206d757374206265206e6f77206f7220696e207460608201527f6865206675747572650000000000000000000000000000000000000000000000608082015260a00190565b602080825260409082018190527f556e697377617056335374616b65723a3a7374616b65546f6b656e3a2063616e908201527f6e6f74207374616b6520746f6b656e20776974682030206c6971756964697479606082015260800190565b60208082526033908201527f556e697377617056335374616b65723a3a7374616b65546f6b656e3a206e6f6e60408201527f2d6578697374656e7420696e63656e7469766500000000000000000000000000606082015260800190565b60208082526056908201527f556e697377617056335374616b65723a3a756e7374616b65546f6b656e3a206f60408201527f6e6c79206f776e65722063616e20776974686472617720746f6b656e2062656660608201527f6f726520696e63656e7469766520656e642074696d6500000000000000000000608082015260a00190565b60208082526032908201527f556e697377617056335374616b65723a3a7374616b65546f6b656e3a20696e6360408201527f656e74697665206e6f7420737461727465640000000000000000000000000000606082015260800190565b60208082526041908201527f556e697377617056335374616b65723a3a7374616b65546f6b656e3a20746f6b60408201527f656e20706f6f6c206973206e6f742074686520696e63656e7469766520706f6f60608201527f6c00000000000000000000000000000000000000000000000000000000000000608082015260a00190565b6020808252603d908201527f556e697377617056335374616b65723a3a7769746864726177546f6b656e3a2060408201527f6f6e6c79206f776e65722063616e20776974686472617720746f6b656e000000606082015260800190565b6020808252604d908201527f556e697377617056335374616b65723a3a656e64496e63656e746976653a206360408201527f616e6e6f7420656e6420696e63656e74697665207768696c65206465706f736960608201527f747320617265207374616b656400000000000000000000000000000000000000608082015260a00190565b60208082526037908201527f556e697377617056335374616b65723a3a7374616b65546f6b656e3a206f6e6c60408201527f79206f776e65722063616e207374616b6520746f6b656e000000000000000000606082015260800190565b60208082526039908201527f556e697377617056335374616b65723a3a637265617465496e63656e7469766560408201527f3a20726577617264206d75737420626520706f73697469766500000000000000606082015260800190565b602080825260409082018190527f556e697377617056335374616b65723a3a637265617465496e63656e74697665908201527f3a2073746172742074696d6520746f6f2066617220696e746f20667574757265606082015260800190565b602080825260409082018190527f556e697377617056335374616b65723a3a637265617465496e63656e74697665908201527f3a20696e63656e74697665206475726174696f6e20697320746f6f206c6f6e67606082015260800190565b60208082526044908201527f556e697377617056335374616b65723a3a637265617465496e63656e7469766560408201527f3a2073746172742074696d65206d757374206265206265666f726520656e642060608201527f74696d6500000000000000000000000000000000000000000000000000000000608082015260a00190565b60208082526032908201527f556e697377617056335374616b65723a3a6f6e4552433732315265636569766560408201527f643a206e6f74206120756e697633206e66740000000000000000000000000000606082015260800190565b60208082526039908201527f556e697377617056335374616b65723a3a7769746864726177546f6b656e3a2060408201527f63616e6e6f7420776974686472617720746f207374616b657200000000000000606082015260800190565b815173ffffffffffffffffffffffffffffffffffffffff90811682526020808401518216908301526040808401519083015260608084015190830152608092830151169181019190915260a00190565b6fffffffffffffffffffffffffffffffff91909116815260200190565b73ffffffffffffffffffffffffffffffffffffffff9290921682526fffffffffffffffffffffffffffffffff16602082015260400190565b90815260200190565b91825273ffffffffffffffffffffffffffffffffffffffff16602082015260400190565b92835273ffffffffffffffffffffffffffffffffffffffff9190911660208301526bffffffffffffffffffffffff16604082015260600190565b938452602084019290925273ffffffffffffffffffffffffffffffffffffffff166040830152606082015260800190565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112613985578283fd5b83018035915067ffffffffffffffff82111561399f578283fd5b6020019150368190038213156139b457600080fd5b9250929050565b60405181810167ffffffffffffffff811182821017156139d757fe5b604052919050565b600067ffffffffffffffff8211156139f357fe5b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b60005b83811015613a3a578181015183820152602001613a22565b83811115613a49576000848401525b50505050565b73ffffffffffffffffffffffffffffffffffffffff81168114613a7157600080fd5b5056fea164736f6c6343000706000a";
const deployedBytecode$5 = "0x6080604052600436106101295760003560e01c8063b02c43d0116100a5578063c45a015511610074578063e70b9e2711610059578063e70b9e271461034f578063f2d2909b1461036f578063f549ab421461038f57610129565b8063c45a01551461030c578063d953186e1461032157610129565b8063b02c43d01461026c578063b44a27221461029c578063b5ada6e4146102be578063c36c1ea5146102de57610129565b80633c423f0b116100fc5780635cc5e3d9116100e15780635cc5e3d9146101fd578063607777951461021d578063ac9650d81461024c57610129565b80633c423f0b146101c85780633dc0714b146101e857610129565b806301b754401461012e578063150b7a021461015957806326bfee04146101865780632f2d783d146101a8575b600080fd5b34801561013a57600080fd5b506101436103af565b60405161015091906138b9565b60405180910390f35b34801561016557600080fd5b5061017961017436600461273f565b6103d3565b6040516101509190612db4565b34801561019257600080fd5b506101a66101a1366004612a9c565b61071c565b005b3480156101b457600080fd5b506101436101c3366004612946565b61084a565b3480156101d457600080fd5b506101a66101e3366004612ac0565b610928565b3480156101f457600080fd5b50610143610bbb565b34801561020957600080fd5b506101a6610218366004612a72565b610bdf565b34801561022957600080fd5b5061023d6102383660046128f6565b610e10565b604051610150939291906138e6565b61025f61025a3660046127d9565b610e67565b6040516101509190612d36565b34801561027857600080fd5b5061028c6102873660046128f6565b610fc1565b6040516101509493929190612cf5565b3480156102a857600080fd5b506102b1611053565b6040516101509190612de1565b3480156102ca57600080fd5b506101436102d9366004612a57565b611077565b3480156102ea57600080fd5b506102fe6102f9366004612b52565b6111c5565b604051610150929190613881565b34801561031857600080fd5b506102b161124a565b34801561032d57600080fd5b5061034161033c366004612a72565b61126e565b6040516101509291906138c2565b34801561035b57600080fd5b5061014361036a36600461290e565b611493565b34801561037b57600080fd5b506101a661038a366004612a72565b6114b0565b34801561039b57600080fd5b506101a66103aa366004612a72565b61151b565b7f000000000000000000000000000000000000000000000000000000000000000081565b60003373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000161461044d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104449061375a565b60405180910390fd5b6000807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166399fbab88876040518263ffffffff1660e01b81526004016104a991906138b9565b6101806040518083038186803b1580156104c257600080fd5b505afa1580156104d6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104fa9190612b73565b505050505096509650505050505060405180608001604052808873ffffffffffffffffffffffffffffffffffffffff168152602001600065ffffffffffff1681526020018360020b81526020018260020b8152506001600088815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060208201518160000160146101000a81548165ffffffffffff021916908365ffffffffffff160217905550604082015181600001601a6101000a81548162ffffff021916908360020b62ffffff160217905550606082015181600001601d6101000a81548162ffffff021916908360020b62ffffff1602179055509050508673ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff16877fcdfc765b85e1048bee3c6a0f9d1c91fc7c4631f5fe5745a55fc6843db5c3260f60405160405180910390a483156106ef5760a08414156106ab576106a66106a085870187612a57565b87611964565b6106ef565b60006106b985870187612848565b905060005b81518110156106ec576106e48282815181106106d657fe5b602002602001015189611964565b6001016106be565b50505b507f150b7a0200000000000000000000000000000000000000000000000000000000979650505050505050565b73ffffffffffffffffffffffffffffffffffffffff8116610769576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490613183565b60008281526001602052604090205473ffffffffffffffffffffffffffffffffffffffff163381146107c7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490612e86565b60008381526001602052604080822080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff868116918217909255915191929084169186917fcdfc765b85e1048bee3c6a0f9d1c91fc7c4631f5fe5745a55fc6843db5c3260f91a4505050565b73ffffffffffffffffffffffffffffffffffffffff83166000908152600360209081526040808320338452909152902054811580159061088957508082105b156108915750805b73ffffffffffffffffffffffffffffffffffffffff841660009081526003602090815260408083203384529091529020805482900390556108d3848483611ed1565b8273ffffffffffffffffffffffffffffffffffffffff167f106f923f993c2149d49b4255ff723acafa1f2d94393f561d3eda32ae348f72418260405161091991906138b9565b60405180910390a29392505050565b73ffffffffffffffffffffffffffffffffffffffff8216301415610978576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906137b7565b6000838152600160209081526040918290208251608081018452905473ffffffffffffffffffffffffffffffffffffffff8116825265ffffffffffff740100000000000000000000000000000000000000008204169282018390527a0100000000000000000000000000000000000000000000000000008104600290810b810b810b948301949094527d0100000000000000000000000000000000000000000000000000000000009004830b830b90920b606083015215610a65576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490613046565b805173ffffffffffffffffffffffffffffffffffffffff163314610ab5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490613481565b6000848152600160205260408082208290558251905173ffffffffffffffffffffffffffffffffffffffff9091169086907fcdfc765b85e1048bee3c6a0f9d1c91fc7c4631f5fe5745a55fc6843db5c3260f908490a46040517fb88d4fde00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063b88d4fde90610b83903090879089908890600401612cac565b600060405180830381600087803b158015610b9d57600080fd5b505af1158015610bb1573d6000803e3d6000fd5b5050505050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b60008111610c19576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906135be565b8160400151421115610c57576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906131e0565b7f0000000000000000000000000000000000000000000000000000000000000000428360400151031115610cb7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104449061361b565b8160600151826040015110610cf8576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906136d7565b7f000000000000000000000000000000000000000000000000000000000000000082604001518360600151031115610d5c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490613679565b6000610d67836120ad565b60008181526020819052604090208054840190558351909150610d8c903330856120de565b826020015173ffffffffffffffffffffffffffffffffffffffff16836000015173ffffffffffffffffffffffffffffffffffffffff167fa876344e28d4b5191ad03bc0d43f740e3695827ab0faccac739930b915ef8b0285604001518660600151876080015187604051610e039493929190613920565b60405180910390a3505050565b6000602081905290815260409020805460019091015473ffffffffffffffffffffffffffffffffffffffff8116907401000000000000000000000000000000000000000090046bffffffffffffffffffffffff1683565b60608167ffffffffffffffff81118015610e8057600080fd5b50604051908082528060200260200182016040528015610eb457816020015b6060815260200190600190039081610e9f5790505b50905060005b82811015610fba5760008030868685818110610ed257fe5b9050602002810190610ee49190613951565b604051610ef2929190612c9c565b600060405180830381855af49150503d8060008114610f2d576040519150601f19603f3d011682016040523d82523d6000602084013e610f32565b606091505b509150915081610f9857604481511015610f4b57600080fd5b60048101905080806020019051810190610f6591906129df565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104449190612e16565b80848481518110610fa557fe5b60209081029190910101525050600101610eba565b5092915050565b60016020526000908152604090205473ffffffffffffffffffffffffffffffffffffffff81169065ffffffffffff74010000000000000000000000000000000000000000820416907a0100000000000000000000000000000000000000000000000000008104600290810b917d0100000000000000000000000000000000000000000000000000000000009004900b84565b7f000000000000000000000000000000000000000000000000000000000000000081565b600081606001514210156110b7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490612f66565b60006110c2836120ad565b6000818152602081905260409020805493509091508261110e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490612e29565b60018101547401000000000000000000000000000000000000000090046bffffffffffffffffffffffff1615611170576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906134de565b6000815583516080850151611186919085611ed1565b817f65124e6175aa9904f40735e87e2a37c76e87a609b855287bb4d1aba8257d9763846040516111b691906138b9565b60405180910390a25050919050565b60008281526002602090815260408083208484529091529020805473ffffffffffffffffffffffffffffffffffffffff8116916bffffffffffffffffffffffff740100000000000000000000000000000000000000009092048216918214156112425760018101546fffffffffffffffffffffffffffffffff1691505b509250929050565b7f000000000000000000000000000000000000000000000000000000000000000081565b600080600061127c856120ad565b905060008061128b86846111c5565b915091506000816fffffffffffffffffffffffffffffffff16116112db576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490612f09565b60008681526001602081815260408084208151608081018352905473ffffffffffffffffffffffffffffffffffffffff80821683527401000000000000000000000000000000000000000080830465ffffffffffff16848701527a0100000000000000000000000000000000000000000000000000008304600290810b810b810b8587019081527d010000000000000000000000000000000000000000000000000000000000909404810b810b900b60608086019182528c8a52898852868a2087519182018852805482529098015480841689890152919091046bffffffffffffffffffffffff1687860152948e01519151945193517fa38807f200000000000000000000000000000000000000000000000000000000815292969491169263a38807f29261140e929190600401612e02565b60606040518083038186803b15801561142657600080fd5b505afa15801561143a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061145e9190612986565b50915050611482826000015183602001518c604001518d60600151888a87426122c3565b909b909a5098505050505050505050565b600360209081526000928352604080842090915290825290205481565b60008181526001602052604090205473ffffffffffffffffffffffffffffffffffffffff16331461150d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490613561565b6115178282611964565b5050565b6000818152600160209081526040918290208251608081018452905473ffffffffffffffffffffffffffffffffffffffff8116825265ffffffffffff74010000000000000000000000000000000000000000820416928201929092527a0100000000000000000000000000000000000000000000000000008204600290810b810b810b938201939093527d010000000000000000000000000000000000000000000000000000000000909104820b820b90910b60608083019190915283015142101561163157805173ffffffffffffffffffffffffffffffffffffffff163314611631576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104449061331e565b600061163c846120ad565b905060008061164b85846111c5565b91509150806fffffffffffffffffffffffffffffffff166000141561169c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490612fe9565b600083815260208181526040808320888452600180845282852080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff65ffffffffffff740100000000000000000000000000000000000000008084048216830190911681027fffffffffffff000000000000ffffffffffffffffffffffffffffffffffffffff9093169290921790925591830180546bffffffffffffffffffffffff848204811690930190921690920273ffffffffffffffffffffffffffffffffffffffff91821617909155928a01518883015160608a015193517fa38807f2000000000000000000000000000000000000000000000000000000008152929594919091169263a38807f2926117b7929190600401612e02565b60606040518083038186803b1580156117cf57600080fd5b505afa1580156117e3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118079190612986565b508354600185015460408c015160608d0151939550600094508493611848939273ffffffffffffffffffffffffffffffffffffffff169190898b89426122c3565b6001860180547fffffffffffffffffffffffff0000000000000000000000000000000000000000811673ffffffffffffffffffffffffffffffffffffffff9182168401821617909155865483900387558c51811660009081526003602090815260408083208e5190941683529281528282208054860190558d8252600281528282208c8352905290812090815591935091506bffffffffffffffffffffffff6fffffffffffffffffffffffffffffffff87161061192a576001810180547fffffffffffffffffffffffffffffffff000000000000000000000000000000001690555b60405188908b907fe1ba67e807ae0efa0a9549f9520ddc15c27f0a4dae2bc045e800ca66a940778f90600090a35050505050505050505050565b81604001514210156119a2576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906133a1565b816060015142106119df576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490613126565b60006119ea836120ad565b600081815260208190526040902054909150611a32576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906132c1565b60008281526002602090815260408083208484529091529020547401000000000000000000000000000000000000000090046bffffffffffffffffffffffff1615611aa9576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906130c9565b600080600080611afa7f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000088612345565b9350935093509350866020015173ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614611b6b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610444906133fe565b6000816fffffffffffffffffffffffffffffffff1611611bb7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161044490613263565b6000868152600160208181526040808420805465ffffffffffff740100000000000000000000000000000000000000008083048216870190911681027fffffffffffff000000000000ffffffffffffffffffffffffffffffffffffffff9092169190911790915589855291849052808420830180546bffffffffffffffffffffffff848204811690950190941690920273ffffffffffffffffffffffffffffffffffffffff93841617909155517fa38807f20000000000000000000000000000000000000000000000000000000081529086169063a38807f290611ca19087908790600401612e02565b60606040518083038186803b158015611cb957600080fd5b505afa158015611ccd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cf19190612986565b509150506bffffffffffffffffffffffff6fffffffffffffffffffffffffffffffff831610611e0a576040805160608101825273ffffffffffffffffffffffffffffffffffffffff80841682526bffffffffffffffffffffffff60208084018281526fffffffffffffffffffffffffffffffff80891686880190815260008f8152600285528881208f82529094529690922094518554915190931674010000000000000000000000000000000000000000029284167fffffffffffffffffffffffff000000000000000000000000000000000000000090911617909216178255915160019091018054919092167fffffffffffffffffffffffffffffffff00000000000000000000000000000000909116179055611e8e565b6000878152600260209081526040808320898452909152902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff8381169190911716740100000000000000000000000000000000000000006bffffffffffffffffffffffff8516021790555b85877f3fe90ccd0a34e28f2b4b7a1e8323415ed9dd595f4eec5dfd461d18c2df336dbd84604051611ebf9190613864565b60405180910390a35050505050505050565b6040805173ffffffffffffffffffffffffffffffffffffffff8481166024830152604480830185905283518084039091018152606490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb000000000000000000000000000000000000000000000000000000001781529251825160009485949389169392918291908083835b60208310611fa657805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09092019160209182019101611f69565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114612008576040519150601f19603f3d011682016040523d82523d6000602084013e61200d565b606091505b509150915081801561203b57508051158061203b575080806020019051602081101561203857600080fd5b50515b6120a657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600260248201527f5354000000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b5050505050565b6000816040516020016120c09190613814565b6040516020818303038152906040528051906020012090505b919050565b6040805173ffffffffffffffffffffffffffffffffffffffff85811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f23b872dd00000000000000000000000000000000000000000000000000000000178152925182516000948594938a169392918291908083835b602083106121bb57805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0909201916020918201910161217e565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d806000811461221d576040519150601f19603f3d011682016040523d82523d6000602084013e612222565b606091505b5091509150818015612250575080511580612250575080806020019051602081101561224d57600080fd5b50515b6122bb57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600360248201527f5354460000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b505050505050565b600080878310156122d057fe5b508383036fffffffffffffffffffffffffffffffff861602600073ffffffffffffffffffffffffffffffffffffffff8a1660808a61230e8b8861244e565b03901b0390506123358b8373ffffffffffffffffffffffffffffffffffffffff1683612467565b9250509850989650505050505050565b60008060008060008060008873ffffffffffffffffffffffffffffffffffffffff166399fbab88896040518263ffffffff1660e01b8152600401808281526020019150506101806040518083038186803b1580156123a257600080fd5b505afa1580156123b6573d6000803e3d6000fd5b505050506040513d6101808110156123cd57600080fd5b50604080820151606080840151608085015160a086015160c087015160e0909701518651948501875273ffffffffffffffffffffffffffffffffffffffff80871686528416602086015262ffffff8316968501969096529b50949950929750909550909350909150612440908b90612534565b965050505093509350935093565b60008183101561245e5781612460565b825b9392505050565b600080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff858709868602925082811090839003039050806124bb57600084116124b057600080fd5b508290049050612460565b8084116124c757600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150509392505050565b6000816020015173ffffffffffffffffffffffffffffffffffffffff16826000015173ffffffffffffffffffffffffffffffffffffffff161061257657600080fd5b508051602080830151604093840151845173ffffffffffffffffffffffffffffffffffffffff94851681850152939091168385015262ffffff166060808401919091528351808403820181526080840185528051908301207fff0000000000000000000000000000000000000000000000000000000000000060a085015294901b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000001660a183015260b58201939093527fe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b5460d5808301919091528251808303909101815260f5909101909152805191012090565b80516120d981613a4f565b8051600281900b81146120d957600080fd5b600060a08284031215612698578081fd5b60405160a0810181811067ffffffffffffffff821117156126b557fe5b60405290508082356126c681613a4f565b815260208301356126d681613a4f565b80602083015250604083013560408201526060830135606082015260808301356126ff81613a4f565b6080919091015292915050565b80516fffffffffffffffffffffffffffffffff811681146120d957600080fd5b805162ffffff811681146120d957600080fd5b600080600080600060808688031215612756578081fd5b853561276181613a4f565b9450602086013561277181613a4f565b935060408601359250606086013567ffffffffffffffff80821115612794578283fd5b818801915088601f8301126127a7578283fd5b8135818111156127b5578384fd5b8960208285010111156127c6578384fd5b9699959850939650602001949392505050565b600080602083850312156127eb578182fd5b823567ffffffffffffffff80821115612802578384fd5b818501915085601f830112612815578384fd5b813581811115612823578485fd5b8660208083028501011115612836578485fd5b60209290920196919550909350505050565b6000602080838503121561285a578182fd5b823567ffffffffffffffff80821115612871578384fd5b818501915085601f830112612884578384fd5b81358181111561289057fe5b61289d84858302016139bb565b818152848101925083850160a0808402860187018a10156128bc578788fd5b8795505b838610156128e8576128d28a83612687565b85526001959095019493860193908101906128c0565b509098975050505050505050565b600060208284031215612907578081fd5b5035919050565b60008060408385031215612920578182fd5b823561292b81613a4f565b9150602083013561293b81613a4f565b809150509250929050565b60008060006060848603121561295a578081fd5b833561296581613a4f565b9250602084013561297581613a4f565b929592945050506040919091013590565b60008060006060848603121561299a578081fd5b83518060060b81146129aa578182fd5b60208501519093506129bb81613a4f565b604085015190925063ffffffff811681146129d4578182fd5b809150509250925092565b6000602082840312156129f0578081fd5b815167ffffffffffffffff811115612a06578182fd5b8201601f81018413612a16578182fd5b8051612a29612a24826139df565b6139bb565b818152856020838501011115612a3d578384fd5b612a4e826020830160208601613a1f565b95945050505050565b600060a08284031215612a68578081fd5b6124608383612687565b60008060c08385031215612a84578182fd5b612a8e8484612687565b9460a0939093013593505050565b60008060408385031215612aae578182fd5b82359150602083013561293b81613a4f565b600080600060608486031215612ad4578081fd5b833592506020840135612ae681613a4f565b9150604084013567ffffffffffffffff811115612b01578182fd5b8401601f81018613612b11578182fd5b8035612b1f612a24826139df565b818152876020838501011115612b33578384fd5b8160208401602083013783602083830101528093505050509250925092565b60008060408385031215612b64578182fd5b50508035926020909101359150565b6000806000806000806000806000806000806101808d8f031215612b9557898afd5b8c516bffffffffffffffffffffffff81168114612bb0578a8bfd5b9b50612bbe60208e0161266a565b9a50612bcc60408e0161266a565b9950612bda60608e0161266a565b9850612be860808e0161272c565b9750612bf660a08e01612675565b9650612c0460c08e01612675565b9550612c1260e08e0161270c565b94506101008d015193506101208d01519250612c316101408e0161270c565b9150612c406101608e0161270c565b90509295989b509295989b509295989b565b60008151808452612c6a816020860160208601613a1f565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6000828483379101908152919050565b600073ffffffffffffffffffffffffffffffffffffffff808716835280861660208401525083604083015260806060830152612ceb6080830184612c52565b9695505050505050565b73ffffffffffffffffffffffffffffffffffffffff94909416845265ffffffffffff929092166020840152600290810b60408401520b606082015260800190565b6000602080830181845280855180835260408601915060408482028701019250838701855b82811015612da7577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0888603018452612d95858351612c52565b94509285019290850190600101612d5b565b5092979650505050505050565b7fffffffff0000000000000000000000000000000000000000000000000000000091909116815260200190565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b600292830b8152910b602082015260400190565b6000602082526124606020830184612c52565b60208082526032908201527f556e697377617056335374616b65723a3a656e64496e63656e746976653a206e60408201527f6f20726566756e6420617661696c61626c650000000000000000000000000000606082015260800190565b60208082526045908201527f556e697377617056335374616b65723a3a7472616e736665724465706f73697460408201527f3a2063616e206f6e6c792062652063616c6c6564206279206465706f7369742060608201527f6f776e6572000000000000000000000000000000000000000000000000000000608082015260a00190565b60208082526034908201527f556e697377617056335374616b65723a3a676574526577617264496e666f3a2060408201527f7374616b6520646f6573206e6f74206578697374000000000000000000000000606082015260800190565b60208082526043908201527f556e697377617056335374616b65723a3a656e64496e63656e746976653a206360408201527f616e6e6f7420656e6420696e63656e74697665206265666f726520656e64207460608201527f696d650000000000000000000000000000000000000000000000000000000000608082015260a00190565b60208082526033908201527f556e697377617056335374616b65723a3a756e7374616b65546f6b656e3a207360408201527f74616b6520646f6573206e6f7420657869737400000000000000000000000000606082015260800190565b60208082526042908201527f556e697377617056335374616b65723a3a7769746864726177546f6b656e3a2060408201527f63616e6e6f7420776974686472617720746f6b656e207768696c65207374616b60608201527f6564000000000000000000000000000000000000000000000000000000000000608082015260a00190565b60208082526031908201527f556e697377617056335374616b65723a3a7374616b65546f6b656e3a20746f6b60408201527f656e20616c7265616479207374616b6564000000000000000000000000000000606082015260800190565b6020808252602c908201527f556e697377617056335374616b65723a3a7374616b65546f6b656e3a20696e6360408201527f656e7469766520656e6465640000000000000000000000000000000000000000606082015260800190565b6020808252603c908201527f556e697377617056335374616b65723a3a7472616e736665724465706f73697460408201527f3a20696e76616c6964207472616e7366657220726563697069656e7400000000606082015260800190565b60208082526049908201527f556e697377617056335374616b65723a3a637265617465496e63656e7469766560408201527f3a2073746172742074696d65206d757374206265206e6f77206f7220696e207460608201527f6865206675747572650000000000000000000000000000000000000000000000608082015260a00190565b602080825260409082018190527f556e697377617056335374616b65723a3a7374616b65546f6b656e3a2063616e908201527f6e6f74207374616b6520746f6b656e20776974682030206c6971756964697479606082015260800190565b60208082526033908201527f556e697377617056335374616b65723a3a7374616b65546f6b656e3a206e6f6e60408201527f2d6578697374656e7420696e63656e7469766500000000000000000000000000606082015260800190565b60208082526056908201527f556e697377617056335374616b65723a3a756e7374616b65546f6b656e3a206f60408201527f6e6c79206f776e65722063616e20776974686472617720746f6b656e2062656660608201527f6f726520696e63656e7469766520656e642074696d6500000000000000000000608082015260a00190565b60208082526032908201527f556e697377617056335374616b65723a3a7374616b65546f6b656e3a20696e6360408201527f656e74697665206e6f7420737461727465640000000000000000000000000000606082015260800190565b60208082526041908201527f556e697377617056335374616b65723a3a7374616b65546f6b656e3a20746f6b60408201527f656e20706f6f6c206973206e6f742074686520696e63656e7469766520706f6f60608201527f6c00000000000000000000000000000000000000000000000000000000000000608082015260a00190565b6020808252603d908201527f556e697377617056335374616b65723a3a7769746864726177546f6b656e3a2060408201527f6f6e6c79206f776e65722063616e20776974686472617720746f6b656e000000606082015260800190565b6020808252604d908201527f556e697377617056335374616b65723a3a656e64496e63656e746976653a206360408201527f616e6e6f7420656e6420696e63656e74697665207768696c65206465706f736960608201527f747320617265207374616b656400000000000000000000000000000000000000608082015260a00190565b60208082526037908201527f556e697377617056335374616b65723a3a7374616b65546f6b656e3a206f6e6c60408201527f79206f776e65722063616e207374616b6520746f6b656e000000000000000000606082015260800190565b60208082526039908201527f556e697377617056335374616b65723a3a637265617465496e63656e7469766560408201527f3a20726577617264206d75737420626520706f73697469766500000000000000606082015260800190565b602080825260409082018190527f556e697377617056335374616b65723a3a637265617465496e63656e74697665908201527f3a2073746172742074696d6520746f6f2066617220696e746f20667574757265606082015260800190565b602080825260409082018190527f556e697377617056335374616b65723a3a637265617465496e63656e74697665908201527f3a20696e63656e74697665206475726174696f6e20697320746f6f206c6f6e67606082015260800190565b60208082526044908201527f556e697377617056335374616b65723a3a637265617465496e63656e7469766560408201527f3a2073746172742074696d65206d757374206265206265666f726520656e642060608201527f74696d6500000000000000000000000000000000000000000000000000000000608082015260a00190565b60208082526032908201527f556e697377617056335374616b65723a3a6f6e4552433732315265636569766560408201527f643a206e6f74206120756e697633206e66740000000000000000000000000000606082015260800190565b60208082526039908201527f556e697377617056335374616b65723a3a7769746864726177546f6b656e3a2060408201527f63616e6e6f7420776974686472617720746f207374616b657200000000000000606082015260800190565b815173ffffffffffffffffffffffffffffffffffffffff90811682526020808401518216908301526040808401519083015260608084015190830152608092830151169181019190915260a00190565b6fffffffffffffffffffffffffffffffff91909116815260200190565b73ffffffffffffffffffffffffffffffffffffffff9290921682526fffffffffffffffffffffffffffffffff16602082015260400190565b90815260200190565b91825273ffffffffffffffffffffffffffffffffffffffff16602082015260400190565b92835273ffffffffffffffffffffffffffffffffffffffff9190911660208301526bffffffffffffffffffffffff16604082015260600190565b938452602084019290925273ffffffffffffffffffffffffffffffffffffffff166040830152606082015260800190565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112613985578283fd5b83018035915067ffffffffffffffff82111561399f578283fd5b6020019150368190038213156139b457600080fd5b9250929050565b60405181810167ffffffffffffffff811182821017156139d757fe5b604052919050565b600067ffffffffffffffff8211156139f357fe5b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b60005b83811015613a3a578181015183820152602001613a22565b83811115613a49576000848401525b50505050565b73ffffffffffffffffffffffffffffffffffffffff81168114613a7157600080fd5b5056fea164736f6c6343000706000a";
const linkReferences$5 = {};
const deployedLinkReferences$5 = {};
const IUniswapV3Staker = {
  _format: _format$5,
  contractName: contractName$5,
  sourceName: sourceName$5,
  abi: abi$5,
  bytecode: bytecode$5,
  deployedBytecode: deployedBytecode$5,
  linkReferences: linkReferences$5,
  deployedLinkReferences: deployedLinkReferences$5
};
const _format$4 = "hh-sol-artifact-1";
const contractName$4 = "SwapRouter";
const sourceName$4 = "contracts/SwapRouter.sol";
const abi$4 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_factory",
        type: "address"
      },
      {
        internalType: "address",
        name: "_WETH9",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "WETH9",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes",
            name: "path",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountOutMinimum",
            type: "uint256"
          }
        ],
        internalType: "struct ISwapRouter.ExactInputParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactInput",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "address",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint24",
            name: "fee",
            type: "uint24"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountOutMinimum",
            type: "uint256"
          },
          {
            internalType: "uint160",
            name: "sqrtPriceLimitX96",
            type: "uint160"
          }
        ],
        internalType: "struct ISwapRouter.ExactInputSingleParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactInputSingle",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes",
            name: "path",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountOut",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountInMaximum",
            type: "uint256"
          }
        ],
        internalType: "struct ISwapRouter.ExactOutputParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactOutput",
    outputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "address",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint24",
            name: "fee",
            type: "uint24"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountOut",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountInMaximum",
            type: "uint256"
          },
          {
            internalType: "uint160",
            name: "sqrtPriceLimitX96",
            type: "uint160"
          }
        ],
        internalType: "struct ISwapRouter.ExactOutputSingleParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactOutputSingle",
    outputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "factory",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "refundETH",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "expiry",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermitAllowed",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "expiry",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermitAllowedIfNecessary",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermitIfNecessary",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "sweepToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "feeBips",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "feeRecipient",
        type: "address"
      }
    ],
    name: "sweepTokenWithFee",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "int256",
        name: "amount0Delta",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "amount1Delta",
        type: "int256"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "uniswapV3SwapCallback",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "unwrapWETH9",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "feeBips",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "feeRecipient",
        type: "address"
      }
    ],
    name: "unwrapWETH9WithFee",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];
const bytecode$4 = "0x60c06040526000196000553480156200001757600080fd5b506040516200302f3803806200302f8339810160408190526200003a9162000076565b6001600160601b0319606092831b8116608052911b1660a052620000ad565b80516001600160a01b03811681146200007157600080fd5b919050565b6000806040838503121562000089578182fd5b620000948362000059565b9150620000a46020840162000059565b90509250929050565b60805160601c60a05160601c612f26620001096000398061012f528061058352806106ad5280610747528061078752806108b15280611c435280611ca35280611d24525080610dc6528061140c5280611e265250612f266000f3fe6080604052600436106101125760003560e01c8063c04b8d59116100a5578063df2ab5bb11610074578063f28c049811610059578063f28c0498146102f5578063f3995c6714610308578063fa461e331461031b576101bd565b8063df2ab5bb146102cf578063e0e189a0146102e2576101bd565b8063c04b8d5914610281578063c2e3140a14610294578063c45a0155146102a7578063db3e2198146102bc576101bd565b80634aa4a4fc116100e15780634aa4a4fc146102195780639b2c0a371461023b578063a4a78f0c1461024e578063ac9650d814610261576101bd565b806312210e8a146101c2578063414bf389146101ca5780634659a494146101f357806349404b7c14610206576101bd565b366101bd573373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146101bb57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f4e6f742057455448390000000000000000000000000000000000000000000000604482015290519081900360640190fd5b005b600080fd5b6101bb61033b565b6101dd6101d83660046129f8565b61034d565b6040516101ea9190612df1565b60405180910390f35b6101bb610201366004612776565b6104bf565b6101bb610214366004612aff565b61057f565b34801561022557600080fd5b5061022e610745565b6040516101ea9190612c37565b6101bb610249366004612b2e565b610769565b6101bb61025c366004612776565b610981565b61027461026f3660046127d6565b610a56565b6040516101ea9190612caa565b6101dd61028f36600461294d565b610bb0565b6101bb6102a2366004612776565b610d0f565b3480156102b357600080fd5b5061022e610dc4565b6101dd6102ca3660046129f8565b610de8565b6101bb6102dd3660046126d7565b610f78565b6101bb6102f0366004612718565b611095565b6101dd610303366004612a14565b6111fb565b6101bb610316366004612776565b61132f565b34801561032757600080fd5b506101bb610336366004612868565b6113c7565b471561034b5761034b334761150e565b565b600081608001358061035d61165c565b11156103ca57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f5472616e73616374696f6e20746f6f206f6c6400000000000000000000000000604482015290519081900360640190fd5b61047060a08401356103e260808601606087016126b4565b6103f3610100870160e088016126b4565b604080518082019091528061040b60208a018a6126b4565b61041b60608b0160408c01612adc565b61042b60408c0160208d016126b4565b60405160200161043d93929190612bc1565b60405160208183030381529060405281526020013373ffffffffffffffffffffffffffffffffffffffff16815250611660565b91508260c001358210156104b9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104b090612d72565b60405180910390fd5b50919050565b604080517f8fcbaf0c00000000000000000000000000000000000000000000000000000000815233600482015230602482015260448101879052606481018690526001608482015260ff851660a482015260c4810184905260e48101839052905173ffffffffffffffffffffffffffffffffffffffff881691638fcbaf0c9161010480830192600092919082900301818387803b15801561055f57600080fd5b505af1158015610573573d6000803e3d6000fd5b50505050505050505050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561060857600080fd5b505afa15801561061c573d6000803e3d6000fd5b505050506040513d602081101561063257600080fd5b50519050828110156106a557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f496e73756666696369656e742057455448390000000000000000000000000000604482015290519081900360640190fd5b8015610740577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16632e1a7d4d826040518263ffffffff1660e01b815260040180828152602001915050600060405180830381600087803b15801561071e57600080fd5b505af1158015610732573d6000803e3d6000fd5b50505050610740828261150e565b505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b60008211801561077a575060648211155b61078357600080fd5b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561080c57600080fd5b505afa158015610820573d6000803e3d6000fd5b505050506040513d602081101561083657600080fd5b50519050848110156108a957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f496e73756666696369656e742057455448390000000000000000000000000000604482015290519081900360640190fd5b801561097a577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16632e1a7d4d826040518263ffffffff1660e01b815260040180828152602001915050600060405180830381600087803b15801561092257600080fd5b505af1158015610936573d6000803e3d6000fd5b50505050600061271061095285846117e690919063ffffffff16565b8161095957fe5b049050801561096c5761096c838261150e565b6109788582840361150e565b505b5050505050565b604080517fdd62ed3e00000000000000000000000000000000000000000000000000000000815233600482015230602482015290517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9173ffffffffffffffffffffffffffffffffffffffff89169163dd62ed3e91604480820192602092909190829003018186803b158015610a1657600080fd5b505afa158015610a2a573d6000803e3d6000fd5b505050506040513d6020811015610a4057600080fd5b50511015610978576109788686868686866104bf565b60608167ffffffffffffffff81118015610a6f57600080fd5b50604051908082528060200260200182016040528015610aa357816020015b6060815260200190600190039081610a8e5790505b50905060005b82811015610ba95760008030868685818110610ac157fe5b9050602002810190610ad39190612dfa565b604051610ae1929190612c27565b600060405180830381855af49150503d8060008114610b1c576040519150601f19603f3d011682016040523d82523d6000602084013e610b21565b606091505b509150915081610b8757604481511015610b3a57600080fd5b60048101905080806020019051810190610b5491906128e3565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104b09190612d28565b80848481518110610b9457fe5b60209081029190910101525050600101610aa9565b5092915050565b6000816040015180610bc061165c565b1115610c2d57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f5472616e73616374696f6e20746f6f206f6c6400000000000000000000000000604482015290519081900360640190fd5b335b6000610c3e8560000151611810565b9050610c97856060015182610c57578660200151610c59565b305b60006040518060400160405280610c738b6000015161181c565b81526020018773ffffffffffffffffffffffffffffffffffffffff16815250611660565b60608601528015610cb7578451309250610cb09061182b565b8552610cc4565b8460600151935050610cca565b50610c2f565b8360800151831015610d08576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104b090612d72565b5050919050565b604080517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523360048201523060248201529051869173ffffffffffffffffffffffffffffffffffffffff89169163dd62ed3e91604480820192602092909190829003018186803b158015610d8457600080fd5b505afa158015610d98573d6000803e3d6000fd5b505050506040513d6020811015610dae57600080fd5b505110156109785761097886868686868661132f565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000816080013580610df861165c565b1115610e6557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f5472616e73616374696f6e20746f6f206f6c6400000000000000000000000000604482015290519081900360640190fd5b610f0e60a0840135610e7d60808601606087016126b4565b610e8e610100870160e088016126b4565b6040518060400160405280886020016020810190610eac91906126b4565b610ebc60608b0160408c01612adc565b610ec960208c018c6126b4565b604051602001610edb93929190612bc1565b60405160208183030381529060405281526020013373ffffffffffffffffffffffffffffffffffffffff16815250611860565b91508260c00135821115610f4e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104b090612d3b565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600055919050565b60008373ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015610fe157600080fd5b505afa158015610ff5573d6000803e3d6000fd5b505050506040513d602081101561100b57600080fd5b505190508281101561107e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f496e73756666696369656e7420746f6b656e0000000000000000000000000000604482015290519081900360640190fd5b801561108f5761108f848383611a1c565b50505050565b6000821180156110a6575060648211155b6110af57600080fd5b60008573ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561111857600080fd5b505afa15801561112c573d6000803e3d6000fd5b505050506040513d602081101561114257600080fd5b50519050848110156111b557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f496e73756666696369656e7420746f6b656e0000000000000000000000000000604482015290519081900360640190fd5b80156109785760006127106111ca83866117e6565b816111d157fe5b04905080156111e5576111e5878483611a1c565b6111f28786838503611a1c565b50505050505050565b600081604001358061120b61165c565b111561127857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f5472616e73616374696f6e20746f6f206f6c6400000000000000000000000000604482015290519081900360640190fd5b6112eb606084013561129060408601602087016126b4565b60408051808201909152600090806112a88980612dfa565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050509082525033602090910152611860565b5060005491508260800135821115610f4e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104b090612d3b565b604080517fd505accf000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018790526064810186905260ff8516608482015260a4810184905260c48101839052905173ffffffffffffffffffffffffffffffffffffffff88169163d505accf9160e480830192600092919082900301818387803b15801561055f57600080fd5b60008413806113d65750600083135b6113df57600080fd5b60006113ed82840184612a4c565b905060008060006114018460000151611bf1565b9250925092506114337f0000000000000000000000000000000000000000000000000000000000000000848484611c22565b5060008060008a13611474578473ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1610896114a5565b8373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16108a5b9150915081156114c4576114bf8587602001513384611c41565b610573565b85516114cf90611810565b156114f45785516114df9061182b565b86526114ee8133600089611860565b50610573565b806000819055508394506105738587602001513384611c41565b6040805160008082526020820190925273ffffffffffffffffffffffffffffffffffffffff84169083906040518082805190602001908083835b6020831061158557805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09092019160209182019101611548565b6001836020036101000a03801982511681845116808217855250505050505090500191505060006040518083038185875af1925050503d80600081146115e7576040519150601f19603f3d011682016040523d82523d6000602084013e6115ec565b606091505b505090508061074057604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600360248201527f5354450000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b4290565b600073ffffffffffffffffffffffffffffffffffffffff8416611681573093505b60008060006116938560000151611bf1565b9194509250905073ffffffffffffffffffffffffffffffffffffffff808316908416106000806116c4868686611e1f565b73ffffffffffffffffffffffffffffffffffffffff1663128acb088b856116ea8f611e5d565b73ffffffffffffffffffffffffffffffffffffffff8e161561170c578d611732565b8761172b5773fffd8963efd1fc6a506488495d951d5263988d25611732565b6401000276a45b8d6040516020016117439190612da9565b6040516020818303038152906040526040518663ffffffff1660e01b8152600401611772959493929190612c58565b6040805180830381600087803b15801561178b57600080fd5b505af115801561179f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117c39190612845565b91509150826117d257816117d4565b805b6000039b9a5050505050505050505050565b6000821580611801575050818102818382816117fe57fe5b04145b61180a57600080fd5b92915050565b8051604211155b919050565b606061180a826000602b611e8f565b805160609061180a9083906017907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe901611e8f565b600073ffffffffffffffffffffffffffffffffffffffff8416611881573093505b60008060006118938560000151611bf1565b9194509250905073ffffffffffffffffffffffffffffffffffffffff808416908316106000806118c4858786611e1f565b73ffffffffffffffffffffffffffffffffffffffff1663128acb088b856118ea8f611e5d565b60000373ffffffffffffffffffffffffffffffffffffffff8e161561190f578d611935565b8761192e5773fffd8963efd1fc6a506488495d951d5263988d25611935565b6401000276a45b8d6040516020016119469190612da9565b6040516020818303038152906040526040518663ffffffff1660e01b8152600401611975959493929190612c58565b6040805180830381600087803b15801561198e57600080fd5b505af11580156119a2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119c69190612845565b915091506000836119db5781836000036119e1565b82826000035b909850905073ffffffffffffffffffffffffffffffffffffffff8a16611a0d578b8114611a0d57600080fd5b50505050505050949350505050565b6040805173ffffffffffffffffffffffffffffffffffffffff8481166024830152604480830185905283518084039091018152606490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb000000000000000000000000000000000000000000000000000000001781529251825160009485949389169392918291908083835b60208310611af157805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09092019160209182019101611ab4565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114611b53576040519150601f19603f3d011682016040523d82523d6000602084013e611b58565b606091505b5091509150818015611b86575080511580611b865750808060200190516020811015611b8357600080fd5b50515b61097a57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600260248201527f5354000000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b60008080611bff8482612076565b9250611c0c846014612176565b9050611c19846017612076565b91509193909250565b6000611c3885611c33868686612266565b6122e3565b95945050505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16148015611c9c5750804710155b15611de5577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b158015611d0957600080fd5b505af1158015611d1d573d6000803e3d6000fd5b50505050507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a9059cbb83836040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b158015611db357600080fd5b505af1158015611dc7573d6000803e3d6000fd5b505050506040513d6020811015611ddd57600080fd5b5061108f9050565b73ffffffffffffffffffffffffffffffffffffffff8316301415611e1357611e0e848383611a1c565b61108f565b61108f84848484612313565b6000611e557f0000000000000000000000000000000000000000000000000000000000000000611e50868686612266565b6124f0565b949350505050565b60007f80000000000000000000000000000000000000000000000000000000000000008210611e8b57600080fd5b5090565b60608182601f011015611f0357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b828284011015611f7457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b81830184511015611fe657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f736c6963655f6f75744f66426f756e6473000000000000000000000000000000604482015290519081900360640190fd5b606082158015612005576040519150600082526020820160405261206d565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561203e578051835260209283019201612026565b5050858452601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016604052505b50949350505050565b6000818260140110156120ea57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f746f416464726573735f6f766572666c6f770000000000000000000000000000604482015290519081900360640190fd5b816014018351101561215d57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f746f416464726573735f6f75744f66426f756e64730000000000000000000000604482015290519081900360640190fd5b5001602001516c01000000000000000000000000900490565b6000818260030110156121ea57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f746f55696e7432345f6f766572666c6f77000000000000000000000000000000604482015290519081900360640190fd5b816003018351101561225d57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f746f55696e7432345f6f75744f66426f756e6473000000000000000000000000604482015290519081900360640190fd5b50016003015190565b61226e612626565b8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1611156122a6579192915b506040805160608101825273ffffffffffffffffffffffffffffffffffffffff948516815292909316602083015262ffffff169181019190915290565b60006122ef83836124f0565b90503373ffffffffffffffffffffffffffffffffffffffff82161461180a57600080fd5b6040805173ffffffffffffffffffffffffffffffffffffffff85811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f23b872dd00000000000000000000000000000000000000000000000000000000178152925182516000948594938a169392918291908083835b602083106123f057805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920191602091820191016123b3565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114612452576040519150601f19603f3d011682016040523d82523d6000602084013e612457565b606091505b5091509150818015612485575080511580612485575080806020019051602081101561248257600080fd5b50515b61097857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600360248201527f5354460000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6000816020015173ffffffffffffffffffffffffffffffffffffffff16826000015173ffffffffffffffffffffffffffffffffffffffff161061253257600080fd5b508051602080830151604093840151845173ffffffffffffffffffffffffffffffffffffffff94851681850152939091168385015262ffffff166060808401919091528351808403820181526080840185528051908301207fff0000000000000000000000000000000000000000000000000000000000000060a085015294901b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000001660a183015260b58201939093527fe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b5460d5808301919091528251808303909101815260f5909101909152805191012090565b604080516060810182526000808252602082018190529181019190915290565b803561181781612ef4565b600082601f830112612661578081fd5b813561267461266f82612e88565b612e64565b818152846020838601011115612688578283fd5b816020850160208301379081016020019190915292915050565b600061010082840312156104b9578081fd5b6000602082840312156126c5578081fd5b81356126d081612ef4565b9392505050565b6000806000606084860312156126eb578182fd5b83356126f681612ef4565b925060208401359150604084013561270d81612ef4565b809150509250925092565b600080600080600060a0868803121561272f578081fd5b853561273a81612ef4565b945060208601359350604086013561275181612ef4565b925060608601359150608086013561276881612ef4565b809150509295509295909350565b60008060008060008060c0878903121561278e578081fd5b863561279981612ef4565b95506020870135945060408701359350606087013560ff811681146127bc578182fd5b9598949750929560808101359460a0909101359350915050565b600080602083850312156127e8578182fd5b823567ffffffffffffffff808211156127ff578384fd5b818501915085601f830112612812578384fd5b813581811115612820578485fd5b8660208083028501011115612833578485fd5b60209290920196919550909350505050565b60008060408385031215612857578182fd5b505080516020909101519092909150565b6000806000806060858703121561287d578182fd5b8435935060208501359250604085013567ffffffffffffffff808211156128a2578384fd5b818701915087601f8301126128b5578384fd5b8135818111156128c3578485fd5b8860208285010111156128d4578485fd5b95989497505060200194505050565b6000602082840312156128f4578081fd5b815167ffffffffffffffff81111561290a578182fd5b8201601f8101841361291a578182fd5b805161292861266f82612e88565b81815285602083850101111561293c578384fd5b611c38826020830160208601612ec8565b60006020828403121561295e578081fd5b813567ffffffffffffffff80821115612975578283fd5b9083019060a08286031215612988578283fd5b60405160a08101818110838211171561299d57fe5b6040528235828111156129ae578485fd5b6129ba87828601612651565b8252506129c960208401612646565b602082015260408301356040820152606083013560608201526080830135608082015280935050505092915050565b60006101008284031215612a0a578081fd5b6126d083836126a2565b600060208284031215612a25578081fd5b813567ffffffffffffffff811115612a3b578182fd5b820160a081850312156126d0578182fd5b600060208284031215612a5d578081fd5b813567ffffffffffffffff80821115612a74578283fd5b9083019060408286031215612a87578283fd5b604051604081018181108382111715612a9c57fe5b604052823582811115612aad578485fd5b612ab987828601612651565b82525060208301359250612acc83612ef4565b6020810192909252509392505050565b600060208284031215612aed578081fd5b813562ffffff811681146126d0578182fd5b60008060408385031215612b11578182fd5b823591506020830135612b2381612ef4565b809150509250929050565b60008060008060808587031215612b43578182fd5b843593506020850135612b5581612ef4565b9250604085013591506060850135612b6c81612ef4565b939692955090935050565b60008151808452612b8f816020860160208601612ec8565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b606093841b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000908116825260e89390931b7fffffff0000000000000000000000000000000000000000000000000000000000166014820152921b166017820152602b0190565b6000828483379101908152919050565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b600073ffffffffffffffffffffffffffffffffffffffff8088168352861515602084015285604084015280851660608401525060a06080830152612c9f60a0830184612b77565b979650505050505050565b6000602080830181845280855180835260408601915060408482028701019250838701855b82811015612d1b577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0888603018452612d09858351612b77565b94509285019290850190600101612ccf565b5092979650505050505050565b6000602082526126d06020830184612b77565b60208082526012908201527f546f6f206d756368207265717565737465640000000000000000000000000000604082015260600190565b60208082526013908201527f546f6f206c6974746c6520726563656976656400000000000000000000000000604082015260600190565b600060208252825160406020840152612dc56060840182612b77565b905073ffffffffffffffffffffffffffffffffffffffff60208501511660408401528091505092915050565b90815260200190565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112612e2e578283fd5b83018035915067ffffffffffffffff821115612e48578283fd5b602001915036819003821315612e5d57600080fd5b9250929050565b60405181810167ffffffffffffffff81118282101715612e8057fe5b604052919050565b600067ffffffffffffffff821115612e9c57fe5b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b60005b83811015612ee3578181015183820152602001612ecb565b8381111561108f5750506000910152565b73ffffffffffffffffffffffffffffffffffffffff81168114612f1657600080fd5b5056fea164736f6c6343000706000a";
const deployedBytecode$4 = "0x6080604052600436106101125760003560e01c8063c04b8d59116100a5578063df2ab5bb11610074578063f28c049811610059578063f28c0498146102f5578063f3995c6714610308578063fa461e331461031b576101bd565b8063df2ab5bb146102cf578063e0e189a0146102e2576101bd565b8063c04b8d5914610281578063c2e3140a14610294578063c45a0155146102a7578063db3e2198146102bc576101bd565b80634aa4a4fc116100e15780634aa4a4fc146102195780639b2c0a371461023b578063a4a78f0c1461024e578063ac9650d814610261576101bd565b806312210e8a146101c2578063414bf389146101ca5780634659a494146101f357806349404b7c14610206576101bd565b366101bd573373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146101bb57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f4e6f742057455448390000000000000000000000000000000000000000000000604482015290519081900360640190fd5b005b600080fd5b6101bb61033b565b6101dd6101d83660046129f8565b61034d565b6040516101ea9190612df1565b60405180910390f35b6101bb610201366004612776565b6104bf565b6101bb610214366004612aff565b61057f565b34801561022557600080fd5b5061022e610745565b6040516101ea9190612c37565b6101bb610249366004612b2e565b610769565b6101bb61025c366004612776565b610981565b61027461026f3660046127d6565b610a56565b6040516101ea9190612caa565b6101dd61028f36600461294d565b610bb0565b6101bb6102a2366004612776565b610d0f565b3480156102b357600080fd5b5061022e610dc4565b6101dd6102ca3660046129f8565b610de8565b6101bb6102dd3660046126d7565b610f78565b6101bb6102f0366004612718565b611095565b6101dd610303366004612a14565b6111fb565b6101bb610316366004612776565b61132f565b34801561032757600080fd5b506101bb610336366004612868565b6113c7565b471561034b5761034b334761150e565b565b600081608001358061035d61165c565b11156103ca57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f5472616e73616374696f6e20746f6f206f6c6400000000000000000000000000604482015290519081900360640190fd5b61047060a08401356103e260808601606087016126b4565b6103f3610100870160e088016126b4565b604080518082019091528061040b60208a018a6126b4565b61041b60608b0160408c01612adc565b61042b60408c0160208d016126b4565b60405160200161043d93929190612bc1565b60405160208183030381529060405281526020013373ffffffffffffffffffffffffffffffffffffffff16815250611660565b91508260c001358210156104b9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104b090612d72565b60405180910390fd5b50919050565b604080517f8fcbaf0c00000000000000000000000000000000000000000000000000000000815233600482015230602482015260448101879052606481018690526001608482015260ff851660a482015260c4810184905260e48101839052905173ffffffffffffffffffffffffffffffffffffffff881691638fcbaf0c9161010480830192600092919082900301818387803b15801561055f57600080fd5b505af1158015610573573d6000803e3d6000fd5b50505050505050505050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561060857600080fd5b505afa15801561061c573d6000803e3d6000fd5b505050506040513d602081101561063257600080fd5b50519050828110156106a557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f496e73756666696369656e742057455448390000000000000000000000000000604482015290519081900360640190fd5b8015610740577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16632e1a7d4d826040518263ffffffff1660e01b815260040180828152602001915050600060405180830381600087803b15801561071e57600080fd5b505af1158015610732573d6000803e3d6000fd5b50505050610740828261150e565b505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b60008211801561077a575060648211155b61078357600080fd5b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561080c57600080fd5b505afa158015610820573d6000803e3d6000fd5b505050506040513d602081101561083657600080fd5b50519050848110156108a957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f496e73756666696369656e742057455448390000000000000000000000000000604482015290519081900360640190fd5b801561097a577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16632e1a7d4d826040518263ffffffff1660e01b815260040180828152602001915050600060405180830381600087803b15801561092257600080fd5b505af1158015610936573d6000803e3d6000fd5b50505050600061271061095285846117e690919063ffffffff16565b8161095957fe5b049050801561096c5761096c838261150e565b6109788582840361150e565b505b5050505050565b604080517fdd62ed3e00000000000000000000000000000000000000000000000000000000815233600482015230602482015290517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9173ffffffffffffffffffffffffffffffffffffffff89169163dd62ed3e91604480820192602092909190829003018186803b158015610a1657600080fd5b505afa158015610a2a573d6000803e3d6000fd5b505050506040513d6020811015610a4057600080fd5b50511015610978576109788686868686866104bf565b60608167ffffffffffffffff81118015610a6f57600080fd5b50604051908082528060200260200182016040528015610aa357816020015b6060815260200190600190039081610a8e5790505b50905060005b82811015610ba95760008030868685818110610ac157fe5b9050602002810190610ad39190612dfa565b604051610ae1929190612c27565b600060405180830381855af49150503d8060008114610b1c576040519150601f19603f3d011682016040523d82523d6000602084013e610b21565b606091505b509150915081610b8757604481511015610b3a57600080fd5b60048101905080806020019051810190610b5491906128e3565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104b09190612d28565b80848481518110610b9457fe5b60209081029190910101525050600101610aa9565b5092915050565b6000816040015180610bc061165c565b1115610c2d57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f5472616e73616374696f6e20746f6f206f6c6400000000000000000000000000604482015290519081900360640190fd5b335b6000610c3e8560000151611810565b9050610c97856060015182610c57578660200151610c59565b305b60006040518060400160405280610c738b6000015161181c565b81526020018773ffffffffffffffffffffffffffffffffffffffff16815250611660565b60608601528015610cb7578451309250610cb09061182b565b8552610cc4565b8460600151935050610cca565b50610c2f565b8360800151831015610d08576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104b090612d72565b5050919050565b604080517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523360048201523060248201529051869173ffffffffffffffffffffffffffffffffffffffff89169163dd62ed3e91604480820192602092909190829003018186803b158015610d8457600080fd5b505afa158015610d98573d6000803e3d6000fd5b505050506040513d6020811015610dae57600080fd5b505110156109785761097886868686868661132f565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000816080013580610df861165c565b1115610e6557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f5472616e73616374696f6e20746f6f206f6c6400000000000000000000000000604482015290519081900360640190fd5b610f0e60a0840135610e7d60808601606087016126b4565b610e8e610100870160e088016126b4565b6040518060400160405280886020016020810190610eac91906126b4565b610ebc60608b0160408c01612adc565b610ec960208c018c6126b4565b604051602001610edb93929190612bc1565b60405160208183030381529060405281526020013373ffffffffffffffffffffffffffffffffffffffff16815250611860565b91508260c00135821115610f4e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104b090612d3b565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600055919050565b60008373ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015610fe157600080fd5b505afa158015610ff5573d6000803e3d6000fd5b505050506040513d602081101561100b57600080fd5b505190508281101561107e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f496e73756666696369656e7420746f6b656e0000000000000000000000000000604482015290519081900360640190fd5b801561108f5761108f848383611a1c565b50505050565b6000821180156110a6575060648211155b6110af57600080fd5b60008573ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561111857600080fd5b505afa15801561112c573d6000803e3d6000fd5b505050506040513d602081101561114257600080fd5b50519050848110156111b557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f496e73756666696369656e7420746f6b656e0000000000000000000000000000604482015290519081900360640190fd5b80156109785760006127106111ca83866117e6565b816111d157fe5b04905080156111e5576111e5878483611a1c565b6111f28786838503611a1c565b50505050505050565b600081604001358061120b61165c565b111561127857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f5472616e73616374696f6e20746f6f206f6c6400000000000000000000000000604482015290519081900360640190fd5b6112eb606084013561129060408601602087016126b4565b60408051808201909152600090806112a88980612dfa565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050509082525033602090910152611860565b5060005491508260800135821115610f4e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104b090612d3b565b604080517fd505accf000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018790526064810186905260ff8516608482015260a4810184905260c48101839052905173ffffffffffffffffffffffffffffffffffffffff88169163d505accf9160e480830192600092919082900301818387803b15801561055f57600080fd5b60008413806113d65750600083135b6113df57600080fd5b60006113ed82840184612a4c565b905060008060006114018460000151611bf1565b9250925092506114337f0000000000000000000000000000000000000000000000000000000000000000848484611c22565b5060008060008a13611474578473ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1610896114a5565b8373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16108a5b9150915081156114c4576114bf8587602001513384611c41565b610573565b85516114cf90611810565b156114f45785516114df9061182b565b86526114ee8133600089611860565b50610573565b806000819055508394506105738587602001513384611c41565b6040805160008082526020820190925273ffffffffffffffffffffffffffffffffffffffff84169083906040518082805190602001908083835b6020831061158557805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09092019160209182019101611548565b6001836020036101000a03801982511681845116808217855250505050505090500191505060006040518083038185875af1925050503d80600081146115e7576040519150601f19603f3d011682016040523d82523d6000602084013e6115ec565b606091505b505090508061074057604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600360248201527f5354450000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b4290565b600073ffffffffffffffffffffffffffffffffffffffff8416611681573093505b60008060006116938560000151611bf1565b9194509250905073ffffffffffffffffffffffffffffffffffffffff808316908416106000806116c4868686611e1f565b73ffffffffffffffffffffffffffffffffffffffff1663128acb088b856116ea8f611e5d565b73ffffffffffffffffffffffffffffffffffffffff8e161561170c578d611732565b8761172b5773fffd8963efd1fc6a506488495d951d5263988d25611732565b6401000276a45b8d6040516020016117439190612da9565b6040516020818303038152906040526040518663ffffffff1660e01b8152600401611772959493929190612c58565b6040805180830381600087803b15801561178b57600080fd5b505af115801561179f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117c39190612845565b91509150826117d257816117d4565b805b6000039b9a5050505050505050505050565b6000821580611801575050818102818382816117fe57fe5b04145b61180a57600080fd5b92915050565b8051604211155b919050565b606061180a826000602b611e8f565b805160609061180a9083906017907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe901611e8f565b600073ffffffffffffffffffffffffffffffffffffffff8416611881573093505b60008060006118938560000151611bf1565b9194509250905073ffffffffffffffffffffffffffffffffffffffff808416908316106000806118c4858786611e1f565b73ffffffffffffffffffffffffffffffffffffffff1663128acb088b856118ea8f611e5d565b60000373ffffffffffffffffffffffffffffffffffffffff8e161561190f578d611935565b8761192e5773fffd8963efd1fc6a506488495d951d5263988d25611935565b6401000276a45b8d6040516020016119469190612da9565b6040516020818303038152906040526040518663ffffffff1660e01b8152600401611975959493929190612c58565b6040805180830381600087803b15801561198e57600080fd5b505af11580156119a2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119c69190612845565b915091506000836119db5781836000036119e1565b82826000035b909850905073ffffffffffffffffffffffffffffffffffffffff8a16611a0d578b8114611a0d57600080fd5b50505050505050949350505050565b6040805173ffffffffffffffffffffffffffffffffffffffff8481166024830152604480830185905283518084039091018152606490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb000000000000000000000000000000000000000000000000000000001781529251825160009485949389169392918291908083835b60208310611af157805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09092019160209182019101611ab4565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114611b53576040519150601f19603f3d011682016040523d82523d6000602084013e611b58565b606091505b5091509150818015611b86575080511580611b865750808060200190516020811015611b8357600080fd5b50515b61097a57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600260248201527f5354000000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b60008080611bff8482612076565b9250611c0c846014612176565b9050611c19846017612076565b91509193909250565b6000611c3885611c33868686612266565b6122e3565b95945050505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16148015611c9c5750804710155b15611de5577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b158015611d0957600080fd5b505af1158015611d1d573d6000803e3d6000fd5b50505050507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a9059cbb83836040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b158015611db357600080fd5b505af1158015611dc7573d6000803e3d6000fd5b505050506040513d6020811015611ddd57600080fd5b5061108f9050565b73ffffffffffffffffffffffffffffffffffffffff8316301415611e1357611e0e848383611a1c565b61108f565b61108f84848484612313565b6000611e557f0000000000000000000000000000000000000000000000000000000000000000611e50868686612266565b6124f0565b949350505050565b60007f80000000000000000000000000000000000000000000000000000000000000008210611e8b57600080fd5b5090565b60608182601f011015611f0357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b828284011015611f7457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b81830184511015611fe657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f736c6963655f6f75744f66426f756e6473000000000000000000000000000000604482015290519081900360640190fd5b606082158015612005576040519150600082526020820160405261206d565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561203e578051835260209283019201612026565b5050858452601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016604052505b50949350505050565b6000818260140110156120ea57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f746f416464726573735f6f766572666c6f770000000000000000000000000000604482015290519081900360640190fd5b816014018351101561215d57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f746f416464726573735f6f75744f66426f756e64730000000000000000000000604482015290519081900360640190fd5b5001602001516c01000000000000000000000000900490565b6000818260030110156121ea57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f746f55696e7432345f6f766572666c6f77000000000000000000000000000000604482015290519081900360640190fd5b816003018351101561225d57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f746f55696e7432345f6f75744f66426f756e6473000000000000000000000000604482015290519081900360640190fd5b50016003015190565b61226e612626565b8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1611156122a6579192915b506040805160608101825273ffffffffffffffffffffffffffffffffffffffff948516815292909316602083015262ffffff169181019190915290565b60006122ef83836124f0565b90503373ffffffffffffffffffffffffffffffffffffffff82161461180a57600080fd5b6040805173ffffffffffffffffffffffffffffffffffffffff85811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f23b872dd00000000000000000000000000000000000000000000000000000000178152925182516000948594938a169392918291908083835b602083106123f057805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920191602091820191016123b3565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114612452576040519150601f19603f3d011682016040523d82523d6000602084013e612457565b606091505b5091509150818015612485575080511580612485575080806020019051602081101561248257600080fd5b50515b61097857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600360248201527f5354460000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6000816020015173ffffffffffffffffffffffffffffffffffffffff16826000015173ffffffffffffffffffffffffffffffffffffffff161061253257600080fd5b508051602080830151604093840151845173ffffffffffffffffffffffffffffffffffffffff94851681850152939091168385015262ffffff166060808401919091528351808403820181526080840185528051908301207fff0000000000000000000000000000000000000000000000000000000000000060a085015294901b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000001660a183015260b58201939093527fe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b5460d5808301919091528251808303909101815260f5909101909152805191012090565b604080516060810182526000808252602082018190529181019190915290565b803561181781612ef4565b600082601f830112612661578081fd5b813561267461266f82612e88565b612e64565b818152846020838601011115612688578283fd5b816020850160208301379081016020019190915292915050565b600061010082840312156104b9578081fd5b6000602082840312156126c5578081fd5b81356126d081612ef4565b9392505050565b6000806000606084860312156126eb578182fd5b83356126f681612ef4565b925060208401359150604084013561270d81612ef4565b809150509250925092565b600080600080600060a0868803121561272f578081fd5b853561273a81612ef4565b945060208601359350604086013561275181612ef4565b925060608601359150608086013561276881612ef4565b809150509295509295909350565b60008060008060008060c0878903121561278e578081fd5b863561279981612ef4565b95506020870135945060408701359350606087013560ff811681146127bc578182fd5b9598949750929560808101359460a0909101359350915050565b600080602083850312156127e8578182fd5b823567ffffffffffffffff808211156127ff578384fd5b818501915085601f830112612812578384fd5b813581811115612820578485fd5b8660208083028501011115612833578485fd5b60209290920196919550909350505050565b60008060408385031215612857578182fd5b505080516020909101519092909150565b6000806000806060858703121561287d578182fd5b8435935060208501359250604085013567ffffffffffffffff808211156128a2578384fd5b818701915087601f8301126128b5578384fd5b8135818111156128c3578485fd5b8860208285010111156128d4578485fd5b95989497505060200194505050565b6000602082840312156128f4578081fd5b815167ffffffffffffffff81111561290a578182fd5b8201601f8101841361291a578182fd5b805161292861266f82612e88565b81815285602083850101111561293c578384fd5b611c38826020830160208601612ec8565b60006020828403121561295e578081fd5b813567ffffffffffffffff80821115612975578283fd5b9083019060a08286031215612988578283fd5b60405160a08101818110838211171561299d57fe5b6040528235828111156129ae578485fd5b6129ba87828601612651565b8252506129c960208401612646565b602082015260408301356040820152606083013560608201526080830135608082015280935050505092915050565b60006101008284031215612a0a578081fd5b6126d083836126a2565b600060208284031215612a25578081fd5b813567ffffffffffffffff811115612a3b578182fd5b820160a081850312156126d0578182fd5b600060208284031215612a5d578081fd5b813567ffffffffffffffff80821115612a74578283fd5b9083019060408286031215612a87578283fd5b604051604081018181108382111715612a9c57fe5b604052823582811115612aad578485fd5b612ab987828601612651565b82525060208301359250612acc83612ef4565b6020810192909252509392505050565b600060208284031215612aed578081fd5b813562ffffff811681146126d0578182fd5b60008060408385031215612b11578182fd5b823591506020830135612b2381612ef4565b809150509250929050565b60008060008060808587031215612b43578182fd5b843593506020850135612b5581612ef4565b9250604085013591506060850135612b6c81612ef4565b939692955090935050565b60008151808452612b8f816020860160208601612ec8565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b606093841b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000908116825260e89390931b7fffffff0000000000000000000000000000000000000000000000000000000000166014820152921b166017820152602b0190565b6000828483379101908152919050565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b600073ffffffffffffffffffffffffffffffffffffffff8088168352861515602084015285604084015280851660608401525060a06080830152612c9f60a0830184612b77565b979650505050505050565b6000602080830181845280855180835260408601915060408482028701019250838701855b82811015612d1b577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0888603018452612d09858351612b77565b94509285019290850190600101612ccf565b5092979650505050505050565b6000602082526126d06020830184612b77565b60208082526012908201527f546f6f206d756368207265717565737465640000000000000000000000000000604082015260600190565b60208082526013908201527f546f6f206c6974746c6520726563656976656400000000000000000000000000604082015260600190565b600060208252825160406020840152612dc56060840182612b77565b905073ffffffffffffffffffffffffffffffffffffffff60208501511660408401528091505092915050565b90815260200190565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112612e2e578283fd5b83018035915067ffffffffffffffff821115612e48578283fd5b602001915036819003821315612e5d57600080fd5b9250929050565b60405181810167ffffffffffffffff81118282101715612e8057fe5b604052919050565b600067ffffffffffffffff821115612e9c57fe5b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b60005b83811015612ee3578181015183820152602001612ecb565b8381111561108f5750506000910152565b73ffffffffffffffffffffffffffffffffffffffff81168114612f1657600080fd5b5056fea164736f6c6343000706000a";
const linkReferences$4 = {};
const deployedLinkReferences$4 = {};
const ISwapRouter = {
  _format: _format$4,
  contractName: contractName$4,
  sourceName: sourceName$4,
  abi: abi$4,
  bytecode: bytecode$4,
  deployedBytecode: deployedBytecode$4,
  linkReferences: linkReferences$4,
  deployedLinkReferences: deployedLinkReferences$4
};
function asyncGeneratorStep(gen2, resolve, reject, _next, _throw, key2, arg) {
  try {
    var info = gen2[key2](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn2) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen2 = fn2.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen2, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen2, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _defineProperties$4(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$4(Constructor, staticProps);
  return Constructor;
}
function _extends$2() {
  _extends$2 = Object.assign || function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded2) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key2 = sourceKeys[i3];
    if (excluded2.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
function _unsupportedIterableToArray$2(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$2(o2, minLen);
  var n4 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n4 === "Object" && o2.constructor)
    n4 = o2.constructor.name;
  if (n4 === "Map" || n4 === "Set")
    return Array.from(o2);
  if (n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
    return _arrayLikeToArray$2(o2, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++)
    arr2[i3] = arr[i3];
  return arr2;
}
function _createForOfIteratorHelperLoose$2(o2, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray$2(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i3 = 0;
      return function() {
        if (i3 >= o2.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o2[i3++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it = o2[Symbol.iterator]();
  return it.next.bind(it);
}
function createCommonjsModule$1(fn2, module) {
  return module = { exports: {} }, fn2(module, module.exports), module.exports;
}
var runtime_1 = createCommonjsModule$1(function(module) {
  var runtime = function(exports) {
    var Op = Object.prototype;
    var hasOwn2 = Op.hasOwnProperty;
    var defineProperty = Object.defineProperty || function(obj, key2, desc) {
      obj[key2] = desc.value;
    };
    var undefined$1;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key2, value) {
      Object.defineProperty(obj, key2, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key2];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function(obj, key2, value) {
        return obj[key2] = value;
      };
    }
    function wrap2(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context) });
      return generator;
    }
    exports.wrap = wrap2;
    function tryCatch(fn2, obj, arg) {
      try {
        return { type: "normal", arg: fn2.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
      return this;
    });
    var getProto2 = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto2 && getProto2(getProto2(values2([])));
    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn2.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
    defineProperty(
      GeneratorFunctionPrototype,
      "constructor",
      { value: GeneratorFunction, configurable: true }
    );
    GeneratorFunction.displayName = define(
      GeneratorFunctionPrototype,
      toStringTagSymbol,
      "GeneratorFunction"
    );
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };
    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };
    exports.awrap = function(arg) {
      return { __await: arg };
    };
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value && typeof value === "object" && hasOwn2.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }
          return PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            return invoke("throw", error, resolve, reject);
          });
        }
      }
      var previousPromise;
      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
      }
      defineProperty(this, "_invoke", { value: enqueue });
    }
    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    });
    exports.AsyncIterator = AsyncIterator;
    exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0)
        PromiseImpl = Promise;
      var iter = new AsyncIterator(
        wrap2(innerFn, outerFn, self2, tryLocsList),
        PromiseImpl
      );
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    };
    function makeInvokeMethod(innerFn, self2, context) {
      var state2 = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state2 === GenStateExecuting) {
          throw new Error("Generator is already running");
        }
        if (state2 === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }
          return doneResult();
        }
        context.method = method;
        context.arg = arg;
        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state2 === GenStateSuspendedStart) {
              state2 = GenStateCompleted;
              throw context.arg;
            }
            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }
          state2 = GenStateExecuting;
          var record = tryCatch(innerFn, self2, context);
          if (record.type === "normal") {
            state2 = context.done ? GenStateCompleted : GenStateSuspendedYield;
            if (record.arg === ContinueSentinel) {
              continue;
            }
            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state2 = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var methodName = context.method;
      var method = delegate.iterator[methodName];
      if (method === undefined$1) {
        context.delegate = null;
        if (methodName === "throw" && delegate.iterator["return"]) {
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);
          if (context.method === "throw") {
            return ContinueSentinel;
          }
        }
        if (methodName !== "return") {
          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a '" + methodName + "' method"
          );
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method, delegate.iterator, context.arg);
      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }
      var info = record.arg;
      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }
      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        return info;
      }
      context.delegate = null;
      return ContinueSentinel;
    }
    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator");
    define(Gp, iteratorSymbol, function() {
      return this;
    });
    define(Gp, "toString", function() {
      return "[object Generator]";
    });
    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
      this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
    exports.keys = function(val) {
      var object = Object(val);
      var keys = [];
      for (var key2 in object) {
        keys.push(key2);
      }
      keys.reverse();
      return function next2() {
        while (keys.length) {
          var key22 = keys.pop();
          if (key22 in object) {
            next2.value = key22;
            next2.done = false;
            return next2;
          }
        }
        next2.done = true;
        return next2;
      };
    };
    function values2(iterable) {
      if (iterable != null) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }
        if (typeof iterable.next === "function") {
          return iterable;
        }
        if (!isNaN(iterable.length)) {
          var i3 = -1, next2 = function next22() {
            while (++i3 < iterable.length) {
              if (hasOwn2.call(iterable, i3)) {
                next22.value = iterable[i3];
                next22.done = false;
                return next22;
              }
            }
            next22.value = undefined$1;
            next22.done = true;
            return next22;
          };
          return next2.next = next2;
        }
      }
      throw new TypeError(typeof iterable + " is not iterable");
    }
    exports.values = values2;
    function doneResult() {
      return { value: undefined$1, done: true };
    }
    Context.prototype = {
      constructor: Context,
      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);
        if (!skipTempReset) {
          for (var name2 in this) {
            if (name2.charAt(0) === "t" && hasOwn2.call(this, name2) && !isNaN(+name2.slice(1))) {
              this[name2] = undefined$1;
            }
          }
        }
      },
      stop: function() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }
        return this.rval;
      },
      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }
        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;
          if (caught) {
            context.method = "next";
            context.arg = undefined$1;
          }
          return !!caught;
        }
        for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
          var entry = this.tryEntries[i3];
          var record = entry.completion;
          if (entry.tryLoc === "root") {
            return handle("end");
          }
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn2.call(entry, "catchLoc");
            var hasFinally = hasOwn2.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function(type, arg) {
        for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
          var entry = this.tryEntries[i3];
          if (entry.tryLoc <= this.prev && hasOwn2.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }
        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;
        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }
        return this.complete(record);
      },
      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }
        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
        return ContinueSentinel;
      },
      finish: function(finallyLoc) {
        for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
          var entry = this.tryEntries[i3];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function(tryLoc) {
        for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
          var entry = this.tryEntries[i3];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values2(iterable),
          resultName,
          nextLoc
        };
        if (this.method === "next") {
          this.arg = undefined$1;
        }
        return ContinueSentinel;
      }
    };
    return exports;
  }(
    // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
    module.exports
  );
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
});
var _TICK_SPACINGS;
var FACTORY_ADDRESS = "0x1F98431c8aD98523631AE4a59f267346ea31F984";
var ADDRESS_ZERO = "0x0000000000000000000000000000000000000000";
var POOL_INIT_CODE_HASH = "0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54";
var FeeAmount;
(function(FeeAmount2) {
  FeeAmount2[FeeAmount2["LOWEST"] = 100] = "LOWEST";
  FeeAmount2[FeeAmount2["LOW"] = 500] = "LOW";
  FeeAmount2[FeeAmount2["MEDIUM"] = 3e3] = "MEDIUM";
  FeeAmount2[FeeAmount2["HIGH"] = 1e4] = "HIGH";
})(FeeAmount || (FeeAmount = {}));
var TICK_SPACINGS = (_TICK_SPACINGS = {}, _TICK_SPACINGS[FeeAmount.LOWEST] = 1, _TICK_SPACINGS[FeeAmount.LOW] = 10, _TICK_SPACINGS[FeeAmount.MEDIUM] = 60, _TICK_SPACINGS[FeeAmount.HIGH] = 200, _TICK_SPACINGS);
var NEGATIVE_ONE = /* @__PURE__ */ JSBI.BigInt(-1);
var ZERO$4 = /* @__PURE__ */ JSBI.BigInt(0);
var ONE$4 = /* @__PURE__ */ JSBI.BigInt(1);
var Q96 = /* @__PURE__ */ JSBI.exponentiate(/* @__PURE__ */ JSBI.BigInt(2), /* @__PURE__ */ JSBI.BigInt(96));
var Q192 = /* @__PURE__ */ JSBI.exponentiate(Q96, /* @__PURE__ */ JSBI.BigInt(2));
function computePoolAddress(_ref) {
  var factoryAddress = _ref.factoryAddress, tokenA = _ref.tokenA, tokenB = _ref.tokenB, fee = _ref.fee, initCodeHashManualOverride = _ref.initCodeHashManualOverride;
  var _ref2 = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA], token0 = _ref2[0], token1 = _ref2[1];
  return getCreate2Address(factoryAddress, keccak256$1(["bytes"], [defaultAbiCoder.encode(["address", "address", "uint24"], [token0.address, token1.address, fee])]), initCodeHashManualOverride != null ? initCodeHashManualOverride : POOL_INIT_CODE_HASH);
}
var LiquidityMath = /* @__PURE__ */ function() {
  function LiquidityMath2() {
  }
  LiquidityMath2.addDelta = function addDelta(x2, y2) {
    if (JSBI.lessThan(y2, ZERO$4)) {
      return JSBI.subtract(x2, JSBI.multiply(y2, NEGATIVE_ONE));
    } else {
      return JSBI.add(x2, y2);
    }
  };
  return LiquidityMath2;
}();
var FullMath = /* @__PURE__ */ function() {
  function FullMath2() {
  }
  FullMath2.mulDivRoundingUp = function mulDivRoundingUp(a2, b3, denominator) {
    var product = JSBI.multiply(a2, b3);
    var result = JSBI.divide(product, denominator);
    if (JSBI.notEqual(JSBI.remainder(product, denominator), ZERO$4))
      result = JSBI.add(result, ONE$4);
    return result;
  };
  return FullMath2;
}();
var MaxUint160 = /* @__PURE__ */ JSBI.subtract(/* @__PURE__ */ JSBI.exponentiate(/* @__PURE__ */ JSBI.BigInt(2), /* @__PURE__ */ JSBI.BigInt(160)), ONE$4);
function multiplyIn256(x2, y2) {
  var product = JSBI.multiply(x2, y2);
  return JSBI.bitwiseAnd(product, MaxUint256$4);
}
function addIn256(x2, y2) {
  var sum2 = JSBI.add(x2, y2);
  return JSBI.bitwiseAnd(sum2, MaxUint256$4);
}
var SqrtPriceMath = /* @__PURE__ */ function() {
  function SqrtPriceMath2() {
  }
  SqrtPriceMath2.getAmount0Delta = function getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp) {
    if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
      var _ref = [sqrtRatioBX96, sqrtRatioAX96];
      sqrtRatioAX96 = _ref[0];
      sqrtRatioBX96 = _ref[1];
    }
    var numerator1 = JSBI.leftShift(liquidity, JSBI.BigInt(96));
    var numerator2 = JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96);
    return roundUp ? FullMath.mulDivRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), ONE$4, sqrtRatioAX96) : JSBI.divide(JSBI.divide(JSBI.multiply(numerator1, numerator2), sqrtRatioBX96), sqrtRatioAX96);
  };
  SqrtPriceMath2.getAmount1Delta = function getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp) {
    if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
      var _ref2 = [sqrtRatioBX96, sqrtRatioAX96];
      sqrtRatioAX96 = _ref2[0];
      sqrtRatioBX96 = _ref2[1];
    }
    return roundUp ? FullMath.mulDivRoundingUp(liquidity, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96), Q96) : JSBI.divide(JSBI.multiply(liquidity, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96)), Q96);
  };
  SqrtPriceMath2.getNextSqrtPriceFromInput = function getNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne) {
    !JSBI.greaterThan(sqrtPX96, ZERO$4) ? invariant$1(false) : void 0;
    !JSBI.greaterThan(liquidity, ZERO$4) ? invariant$1(false) : void 0;
    return zeroForOne ? this.getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true) : this.getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);
  };
  SqrtPriceMath2.getNextSqrtPriceFromOutput = function getNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne) {
    !JSBI.greaterThan(sqrtPX96, ZERO$4) ? invariant$1(false) : void 0;
    !JSBI.greaterThan(liquidity, ZERO$4) ? invariant$1(false) : void 0;
    return zeroForOne ? this.getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false) : this.getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);
  };
  SqrtPriceMath2.getNextSqrtPriceFromAmount0RoundingUp = function getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amount, add4) {
    if (JSBI.equal(amount, ZERO$4))
      return sqrtPX96;
    var numerator1 = JSBI.leftShift(liquidity, JSBI.BigInt(96));
    if (add4) {
      var product = multiplyIn256(amount, sqrtPX96);
      if (JSBI.equal(JSBI.divide(product, amount), sqrtPX96)) {
        var denominator = addIn256(numerator1, product);
        if (JSBI.greaterThanOrEqual(denominator, numerator1)) {
          return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator);
        }
      }
      return FullMath.mulDivRoundingUp(numerator1, ONE$4, JSBI.add(JSBI.divide(numerator1, sqrtPX96), amount));
    } else {
      var _product = multiplyIn256(amount, sqrtPX96);
      !JSBI.equal(JSBI.divide(_product, amount), sqrtPX96) ? invariant$1(false) : void 0;
      !JSBI.greaterThan(numerator1, _product) ? invariant$1(false) : void 0;
      var _denominator = JSBI.subtract(numerator1, _product);
      return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, _denominator);
    }
  };
  SqrtPriceMath2.getNextSqrtPriceFromAmount1RoundingDown = function getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amount, add4) {
    if (add4) {
      var quotient = JSBI.lessThanOrEqual(amount, MaxUint160) ? JSBI.divide(JSBI.leftShift(amount, JSBI.BigInt(96)), liquidity) : JSBI.divide(JSBI.multiply(amount, Q96), liquidity);
      return JSBI.add(sqrtPX96, quotient);
    } else {
      var _quotient = FullMath.mulDivRoundingUp(amount, Q96, liquidity);
      !JSBI.greaterThan(sqrtPX96, _quotient) ? invariant$1(false) : void 0;
      return JSBI.subtract(sqrtPX96, _quotient);
    }
  };
  return SqrtPriceMath2;
}();
var MAX_FEE = /* @__PURE__ */ JSBI.exponentiate(/* @__PURE__ */ JSBI.BigInt(10), /* @__PURE__ */ JSBI.BigInt(6));
var SwapMath = /* @__PURE__ */ function() {
  function SwapMath2() {
  }
  SwapMath2.computeSwapStep = function computeSwapStep(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, amountRemaining, feePips) {
    var returnValues = {};
    var zeroForOne = JSBI.greaterThanOrEqual(sqrtRatioCurrentX96, sqrtRatioTargetX96);
    var exactIn = JSBI.greaterThanOrEqual(amountRemaining, ZERO$4);
    if (exactIn) {
      var amountRemainingLessFee = JSBI.divide(JSBI.multiply(amountRemaining, JSBI.subtract(MAX_FEE, JSBI.BigInt(feePips))), MAX_FEE);
      returnValues.amountIn = zeroForOne ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true) : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);
      if (JSBI.greaterThanOrEqual(amountRemainingLessFee, returnValues.amountIn)) {
        returnValues.sqrtRatioNextX96 = sqrtRatioTargetX96;
      } else {
        returnValues.sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(sqrtRatioCurrentX96, liquidity, amountRemainingLessFee, zeroForOne);
      }
    } else {
      returnValues.amountOut = zeroForOne ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false) : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);
      if (JSBI.greaterThanOrEqual(JSBI.multiply(amountRemaining, NEGATIVE_ONE), returnValues.amountOut)) {
        returnValues.sqrtRatioNextX96 = sqrtRatioTargetX96;
      } else {
        returnValues.sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(sqrtRatioCurrentX96, liquidity, JSBI.multiply(amountRemaining, NEGATIVE_ONE), zeroForOne);
      }
    }
    var max = JSBI.equal(sqrtRatioTargetX96, returnValues.sqrtRatioNextX96);
    if (zeroForOne) {
      returnValues.amountIn = max && exactIn ? returnValues.amountIn : SqrtPriceMath.getAmount0Delta(returnValues.sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);
      returnValues.amountOut = max && !exactIn ? returnValues.amountOut : SqrtPriceMath.getAmount1Delta(returnValues.sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);
    } else {
      returnValues.amountIn = max && exactIn ? returnValues.amountIn : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, returnValues.sqrtRatioNextX96, liquidity, true);
      returnValues.amountOut = max && !exactIn ? returnValues.amountOut : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, returnValues.sqrtRatioNextX96, liquidity, false);
    }
    if (!exactIn && JSBI.greaterThan(returnValues.amountOut, JSBI.multiply(amountRemaining, NEGATIVE_ONE))) {
      returnValues.amountOut = JSBI.multiply(amountRemaining, NEGATIVE_ONE);
    }
    if (exactIn && JSBI.notEqual(returnValues.sqrtRatioNextX96, sqrtRatioTargetX96)) {
      returnValues.feeAmount = JSBI.subtract(amountRemaining, returnValues.amountIn);
    } else {
      returnValues.feeAmount = FullMath.mulDivRoundingUp(returnValues.amountIn, JSBI.BigInt(feePips), JSBI.subtract(MAX_FEE, JSBI.BigInt(feePips)));
    }
    return [returnValues.sqrtRatioNextX96, returnValues.amountIn, returnValues.amountOut, returnValues.feeAmount];
  };
  return SwapMath2;
}();
var TWO$2 = /* @__PURE__ */ JSBI.BigInt(2);
var POWERS_OF_2 = /* @__PURE__ */ [128, 64, 32, 16, 8, 4, 2, 1].map(function(pow) {
  return [pow, JSBI.exponentiate(TWO$2, JSBI.BigInt(pow))];
});
function mostSignificantBit(x2) {
  !JSBI.greaterThan(x2, ZERO$4) ? invariant$1(false) : void 0;
  !JSBI.lessThanOrEqual(x2, MaxUint256$4) ? invariant$1(false) : void 0;
  var msb = 0;
  for (var _iterator = _createForOfIteratorHelperLoose$2(POWERS_OF_2), _step; !(_step = _iterator()).done; ) {
    var _step$value = _step.value, power = _step$value[0], min = _step$value[1];
    if (JSBI.greaterThanOrEqual(x2, min)) {
      x2 = JSBI.signedRightShift(x2, JSBI.BigInt(power));
      msb += power;
    }
  }
  return msb;
}
function mulShift(val, mulBy) {
  return JSBI.signedRightShift(JSBI.multiply(val, JSBI.BigInt(mulBy)), JSBI.BigInt(128));
}
var Q32 = /* @__PURE__ */ JSBI.exponentiate(/* @__PURE__ */ JSBI.BigInt(2), /* @__PURE__ */ JSBI.BigInt(32));
var TickMath = /* @__PURE__ */ function() {
  function TickMath2() {
  }
  TickMath2.getSqrtRatioAtTick = function getSqrtRatioAtTick(tick) {
    !(tick >= TickMath2.MIN_TICK && tick <= TickMath2.MAX_TICK && Number.isInteger(tick)) ? invariant$1(false) : void 0;
    var absTick = tick < 0 ? tick * -1 : tick;
    var ratio = (absTick & 1) != 0 ? JSBI.BigInt("0xfffcb933bd6fad37aa2d162d1a594001") : JSBI.BigInt("0x100000000000000000000000000000000");
    if ((absTick & 2) != 0)
      ratio = mulShift(ratio, "0xfff97272373d413259a46990580e213a");
    if ((absTick & 4) != 0)
      ratio = mulShift(ratio, "0xfff2e50f5f656932ef12357cf3c7fdcc");
    if ((absTick & 8) != 0)
      ratio = mulShift(ratio, "0xffe5caca7e10e4e61c3624eaa0941cd0");
    if ((absTick & 16) != 0)
      ratio = mulShift(ratio, "0xffcb9843d60f6159c9db58835c926644");
    if ((absTick & 32) != 0)
      ratio = mulShift(ratio, "0xff973b41fa98c081472e6896dfb254c0");
    if ((absTick & 64) != 0)
      ratio = mulShift(ratio, "0xff2ea16466c96a3843ec78b326b52861");
    if ((absTick & 128) != 0)
      ratio = mulShift(ratio, "0xfe5dee046a99a2a811c461f1969c3053");
    if ((absTick & 256) != 0)
      ratio = mulShift(ratio, "0xfcbe86c7900a88aedcffc83b479aa3a4");
    if ((absTick & 512) != 0)
      ratio = mulShift(ratio, "0xf987a7253ac413176f2b074cf7815e54");
    if ((absTick & 1024) != 0)
      ratio = mulShift(ratio, "0xf3392b0822b70005940c7a398e4b70f3");
    if ((absTick & 2048) != 0)
      ratio = mulShift(ratio, "0xe7159475a2c29b7443b29c7fa6e889d9");
    if ((absTick & 4096) != 0)
      ratio = mulShift(ratio, "0xd097f3bdfd2022b8845ad8f792aa5825");
    if ((absTick & 8192) != 0)
      ratio = mulShift(ratio, "0xa9f746462d870fdf8a65dc1f90e061e5");
    if ((absTick & 16384) != 0)
      ratio = mulShift(ratio, "0x70d869a156d2a1b890bb3df62baf32f7");
    if ((absTick & 32768) != 0)
      ratio = mulShift(ratio, "0x31be135f97d08fd981231505542fcfa6");
    if ((absTick & 65536) != 0)
      ratio = mulShift(ratio, "0x9aa508b5b7a84e1c677de54f3e99bc9");
    if ((absTick & 131072) != 0)
      ratio = mulShift(ratio, "0x5d6af8dedb81196699c329225ee604");
    if ((absTick & 262144) != 0)
      ratio = mulShift(ratio, "0x2216e584f5fa1ea926041bedfe98");
    if ((absTick & 524288) != 0)
      ratio = mulShift(ratio, "0x48a170391f7dc42444e8fa2");
    if (tick > 0)
      ratio = JSBI.divide(MaxUint256$4, ratio);
    return JSBI.greaterThan(JSBI.remainder(ratio, Q32), ZERO$4) ? JSBI.add(JSBI.divide(ratio, Q32), ONE$4) : JSBI.divide(ratio, Q32);
  };
  TickMath2.getTickAtSqrtRatio = function getTickAtSqrtRatio(sqrtRatioX96) {
    !(JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath2.MIN_SQRT_RATIO) && JSBI.lessThan(sqrtRatioX96, TickMath2.MAX_SQRT_RATIO)) ? invariant$1(false) : void 0;
    var sqrtRatioX128 = JSBI.leftShift(sqrtRatioX96, JSBI.BigInt(32));
    var msb = mostSignificantBit(sqrtRatioX128);
    var r2;
    if (JSBI.greaterThanOrEqual(JSBI.BigInt(msb), JSBI.BigInt(128))) {
      r2 = JSBI.signedRightShift(sqrtRatioX128, JSBI.BigInt(msb - 127));
    } else {
      r2 = JSBI.leftShift(sqrtRatioX128, JSBI.BigInt(127 - msb));
    }
    var log_2 = JSBI.leftShift(JSBI.subtract(JSBI.BigInt(msb), JSBI.BigInt(128)), JSBI.BigInt(64));
    for (var i3 = 0; i3 < 14; i3++) {
      r2 = JSBI.signedRightShift(JSBI.multiply(r2, r2), JSBI.BigInt(127));
      var f3 = JSBI.signedRightShift(r2, JSBI.BigInt(128));
      log_2 = JSBI.bitwiseOr(log_2, JSBI.leftShift(f3, JSBI.BigInt(63 - i3)));
      r2 = JSBI.signedRightShift(r2, f3);
    }
    var log_sqrt10001 = JSBI.multiply(log_2, JSBI.BigInt("255738958999603826347141"));
    var tickLow = JSBI.toNumber(JSBI.signedRightShift(JSBI.subtract(log_sqrt10001, JSBI.BigInt("3402992956809132418596140100660247210")), JSBI.BigInt(128)));
    var tickHigh = JSBI.toNumber(JSBI.signedRightShift(JSBI.add(log_sqrt10001, JSBI.BigInt("291339464771989622907027621153398088495")), JSBI.BigInt(128)));
    return tickLow === tickHigh ? tickLow : JSBI.lessThanOrEqual(TickMath2.getSqrtRatioAtTick(tickHigh), sqrtRatioX96) ? tickHigh : tickLow;
  };
  return TickMath2;
}();
TickMath.MIN_TICK = -887272;
TickMath.MAX_TICK = -TickMath.MIN_TICK;
TickMath.MIN_SQRT_RATIO = /* @__PURE__ */ JSBI.BigInt("4295128739");
TickMath.MAX_SQRT_RATIO = /* @__PURE__ */ JSBI.BigInt("1461446703485210103287273052203988822378723970342");
var NoTickDataProvider = /* @__PURE__ */ function() {
  function NoTickDataProvider2() {
  }
  var _proto = NoTickDataProvider2.prototype;
  _proto.getTick = /* @__PURE__ */ function() {
    var _getTick = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ runtime_1.mark(function _callee(_tick) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              throw new Error(NoTickDataProvider2.ERROR_MESSAGE);
            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    function getTick(_x) {
      return _getTick.apply(this, arguments);
    }
    return getTick;
  }();
  _proto.nextInitializedTickWithinOneWord = /* @__PURE__ */ function() {
    var _nextInitializedTickWithinOneWord = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ runtime_1.mark(function _callee2(_tick, _lte, _tickSpacing) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              throw new Error(NoTickDataProvider2.ERROR_MESSAGE);
            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    function nextInitializedTickWithinOneWord(_x2, _x3, _x4) {
      return _nextInitializedTickWithinOneWord.apply(this, arguments);
    }
    return nextInitializedTickWithinOneWord;
  }();
  return NoTickDataProvider2;
}();
NoTickDataProvider.ERROR_MESSAGE = "No tick data provider was given";
function isSorted(list, comparator) {
  for (var i3 = 0; i3 < list.length - 1; i3++) {
    if (comparator(list[i3], list[i3 + 1]) > 0) {
      return false;
    }
  }
  return true;
}
function tickComparator(a2, b3) {
  return a2.index - b3.index;
}
var TickList = /* @__PURE__ */ function() {
  function TickList2() {
  }
  TickList2.validateList = function validateList(ticks, tickSpacing) {
    !(tickSpacing > 0) ? invariant$1(false) : void 0;
    !ticks.every(function(_ref) {
      var index2 = _ref.index;
      return index2 % tickSpacing === 0;
    }) ? invariant$1(false) : void 0;
    !JSBI.equal(ticks.reduce(function(accumulator, _ref2) {
      var liquidityNet = _ref2.liquidityNet;
      return JSBI.add(accumulator, liquidityNet);
    }, ZERO$4), ZERO$4) ? invariant$1(false) : void 0;
    !isSorted(ticks, tickComparator) ? invariant$1(false) : void 0;
  };
  TickList2.isBelowSmallest = function isBelowSmallest(ticks, tick) {
    !(ticks.length > 0) ? invariant$1(false) : void 0;
    return tick < ticks[0].index;
  };
  TickList2.isAtOrAboveLargest = function isAtOrAboveLargest(ticks, tick) {
    !(ticks.length > 0) ? invariant$1(false) : void 0;
    return tick >= ticks[ticks.length - 1].index;
  };
  TickList2.getTick = function getTick(ticks, index2) {
    var tick = ticks[this.binarySearch(ticks, index2)];
    !(tick.index === index2) ? invariant$1(false) : void 0;
    return tick;
  };
  TickList2.binarySearch = function binarySearch(ticks, tick) {
    !!this.isBelowSmallest(ticks, tick) ? invariant$1(false) : void 0;
    var l2 = 0;
    var r2 = ticks.length - 1;
    var i3;
    while (true) {
      i3 = Math.floor((l2 + r2) / 2);
      if (ticks[i3].index <= tick && (i3 === ticks.length - 1 || ticks[i3 + 1].index > tick)) {
        return i3;
      }
      if (ticks[i3].index < tick) {
        l2 = i3 + 1;
      } else {
        r2 = i3 - 1;
      }
    }
  };
  TickList2.nextInitializedTick = function nextInitializedTick(ticks, tick, lte) {
    if (lte) {
      !!TickList2.isBelowSmallest(ticks, tick) ? invariant$1(false) : void 0;
      if (TickList2.isAtOrAboveLargest(ticks, tick)) {
        return ticks[ticks.length - 1];
      }
      var index2 = this.binarySearch(ticks, tick);
      return ticks[index2];
    } else {
      !!this.isAtOrAboveLargest(ticks, tick) ? invariant$1(false) : void 0;
      if (this.isBelowSmallest(ticks, tick)) {
        return ticks[0];
      }
      var _index = this.binarySearch(ticks, tick);
      return ticks[_index + 1];
    }
  };
  TickList2.nextInitializedTickWithinOneWord = function nextInitializedTickWithinOneWord(ticks, tick, lte, tickSpacing) {
    var compressed = Math.floor(tick / tickSpacing);
    if (lte) {
      var wordPos = compressed >> 8;
      var minimum = (wordPos << 8) * tickSpacing;
      if (TickList2.isBelowSmallest(ticks, tick)) {
        return [minimum, false];
      }
      var index2 = TickList2.nextInitializedTick(ticks, tick, lte).index;
      var nextInitializedTick = Math.max(minimum, index2);
      return [nextInitializedTick, nextInitializedTick === index2];
    } else {
      var _wordPos = compressed + 1 >> 8;
      var maximum = ((_wordPos + 1 << 8) - 1) * tickSpacing;
      if (this.isAtOrAboveLargest(ticks, tick)) {
        return [maximum, false];
      }
      var _index2 = this.nextInitializedTick(ticks, tick, lte).index;
      var _nextInitializedTick = Math.min(maximum, _index2);
      return [_nextInitializedTick, _nextInitializedTick === _index2];
    }
  };
  return TickList2;
}();
function toHex$2(bigintIsh) {
  var bigInt = JSBI.BigInt(bigintIsh);
  var hex = bigInt.toString(16);
  if (hex.length % 2 !== 0) {
    hex = "0" + hex;
  }
  return "0x" + hex;
}
function encodeRouteToPath(route, exactOutput) {
  var firstInputToken = route.input.wrapped;
  var _route$pools$reduce = route.pools.reduce(function(_ref, pool, index2) {
    var inputToken = _ref.inputToken, path2 = _ref.path, types22 = _ref.types;
    var outputToken = pool.token0.equals(inputToken) ? pool.token1 : pool.token0;
    if (index2 === 0) {
      return {
        inputToken: outputToken,
        types: ["address", "uint24", "address"],
        path: [inputToken.address, pool.fee, outputToken.address]
      };
    } else {
      return {
        inputToken: outputToken,
        types: [].concat(types22, ["uint24", "address"]),
        path: [].concat(path2, [pool.fee, outputToken.address])
      };
    }
  }, {
    inputToken: firstInputToken,
    path: [],
    types: []
  }), path = _route$pools$reduce.path, types2 = _route$pools$reduce.types;
  return exactOutput ? pack(types2.reverse(), path.reverse()) : pack(types2, path);
}
function encodeSqrtRatioX96(amount1, amount0) {
  var numerator = JSBI.leftShift(JSBI.BigInt(amount1), JSBI.BigInt(192));
  var denominator = JSBI.BigInt(amount0);
  var ratioX192 = JSBI.divide(numerator, denominator);
  return sqrt$2(ratioX192);
}
function maxLiquidityForAmount0Imprecise(sqrtRatioAX96, sqrtRatioBX96, amount0) {
  if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
    var _ref = [sqrtRatioBX96, sqrtRatioAX96];
    sqrtRatioAX96 = _ref[0];
    sqrtRatioBX96 = _ref[1];
  }
  var intermediate = JSBI.divide(JSBI.multiply(sqrtRatioAX96, sqrtRatioBX96), Q96);
  return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount0), intermediate), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));
}
function maxLiquidityForAmount0Precise(sqrtRatioAX96, sqrtRatioBX96, amount0) {
  if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
    var _ref2 = [sqrtRatioBX96, sqrtRatioAX96];
    sqrtRatioAX96 = _ref2[0];
    sqrtRatioBX96 = _ref2[1];
  }
  var numerator = JSBI.multiply(JSBI.multiply(JSBI.BigInt(amount0), sqrtRatioAX96), sqrtRatioBX96);
  var denominator = JSBI.multiply(Q96, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));
  return JSBI.divide(numerator, denominator);
}
function maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1) {
  if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
    var _ref3 = [sqrtRatioBX96, sqrtRatioAX96];
    sqrtRatioAX96 = _ref3[0];
    sqrtRatioBX96 = _ref3[1];
  }
  return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount1), Q96), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));
}
function maxLiquidityForAmounts(sqrtRatioCurrentX96, sqrtRatioAX96, sqrtRatioBX96, amount0, amount1, useFullPrecision) {
  if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
    var _ref4 = [sqrtRatioBX96, sqrtRatioAX96];
    sqrtRatioAX96 = _ref4[0];
    sqrtRatioBX96 = _ref4[1];
  }
  var maxLiquidityForAmount0 = useFullPrecision ? maxLiquidityForAmount0Precise : maxLiquidityForAmount0Imprecise;
  if (JSBI.lessThanOrEqual(sqrtRatioCurrentX96, sqrtRatioAX96)) {
    return maxLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
  } else if (JSBI.lessThan(sqrtRatioCurrentX96, sqrtRatioBX96)) {
    var liquidity0 = maxLiquidityForAmount0(sqrtRatioCurrentX96, sqrtRatioBX96, amount0);
    var liquidity1 = maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioCurrentX96, amount1);
    return JSBI.lessThan(liquidity0, liquidity1) ? liquidity0 : liquidity1;
  } else {
    return maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
  }
}
function nearestUsableTick(tick, tickSpacing) {
  !(Number.isInteger(tick) && Number.isInteger(tickSpacing)) ? invariant$1(false) : void 0;
  !(tickSpacing > 0) ? invariant$1(false) : void 0;
  !(tick >= TickMath.MIN_TICK && tick <= TickMath.MAX_TICK) ? invariant$1(false) : void 0;
  var rounded = Math.round(tick / tickSpacing) * tickSpacing;
  if (rounded < TickMath.MIN_TICK)
    return rounded + tickSpacing;
  else if (rounded > TickMath.MAX_TICK)
    return rounded - tickSpacing;
  else
    return rounded;
}
var Q128 = /* @__PURE__ */ JSBI.exponentiate(/* @__PURE__ */ JSBI.BigInt(2), /* @__PURE__ */ JSBI.BigInt(128));
var PositionLibrary = /* @__PURE__ */ function() {
  function PositionLibrary2() {
  }
  PositionLibrary2.getTokensOwed = function getTokensOwed(feeGrowthInside0LastX128, feeGrowthInside1LastX128, liquidity, feeGrowthInside0X128, feeGrowthInside1X128) {
    var tokensOwed0 = JSBI.divide(JSBI.multiply(subIn256(feeGrowthInside0X128, feeGrowthInside0LastX128), liquidity), Q128);
    var tokensOwed1 = JSBI.divide(JSBI.multiply(subIn256(feeGrowthInside1X128, feeGrowthInside1LastX128), liquidity), Q128);
    return [tokensOwed0, tokensOwed1];
  };
  return PositionLibrary2;
}();
function tickToPrice(baseToken, quoteToken, tick) {
  var sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);
  var ratioX192 = JSBI.multiply(sqrtRatioX96, sqrtRatioX96);
  return baseToken.sortsBefore(quoteToken) ? new Price$2(baseToken, quoteToken, Q192, ratioX192) : new Price$2(baseToken, quoteToken, ratioX192, Q192);
}
function priceToClosestTick(price) {
  var sorted = price.baseCurrency.sortsBefore(price.quoteCurrency);
  var sqrtRatioX96 = sorted ? encodeSqrtRatioX96(price.numerator, price.denominator) : encodeSqrtRatioX96(price.denominator, price.numerator);
  var tick = TickMath.getTickAtSqrtRatio(sqrtRatioX96);
  var nextTickPrice = tickToPrice(price.baseCurrency, price.quoteCurrency, tick + 1);
  if (sorted) {
    if (!price.lessThan(nextTickPrice)) {
      tick++;
    }
  } else {
    if (!price.greaterThan(nextTickPrice)) {
      tick++;
    }
  }
  return tick;
}
var Q256 = /* @__PURE__ */ JSBI.exponentiate(/* @__PURE__ */ JSBI.BigInt(2), /* @__PURE__ */ JSBI.BigInt(256));
function subIn256(x2, y2) {
  var difference = JSBI.subtract(x2, y2);
  if (JSBI.lessThan(difference, ZERO$4)) {
    return JSBI.add(Q256, difference);
  } else {
    return difference;
  }
}
var TickLibrary = /* @__PURE__ */ function() {
  function TickLibrary2() {
  }
  TickLibrary2.getFeeGrowthInside = function getFeeGrowthInside(feeGrowthOutsideLower, feeGrowthOutsideUpper, tickLower, tickUpper, tickCurrent, feeGrowthGlobal0X128, feeGrowthGlobal1X128) {
    var feeGrowthBelow0X128;
    var feeGrowthBelow1X128;
    if (tickCurrent >= tickLower) {
      feeGrowthBelow0X128 = feeGrowthOutsideLower.feeGrowthOutside0X128;
      feeGrowthBelow1X128 = feeGrowthOutsideLower.feeGrowthOutside1X128;
    } else {
      feeGrowthBelow0X128 = subIn256(feeGrowthGlobal0X128, feeGrowthOutsideLower.feeGrowthOutside0X128);
      feeGrowthBelow1X128 = subIn256(feeGrowthGlobal1X128, feeGrowthOutsideLower.feeGrowthOutside1X128);
    }
    var feeGrowthAbove0X128;
    var feeGrowthAbove1X128;
    if (tickCurrent < tickUpper) {
      feeGrowthAbove0X128 = feeGrowthOutsideUpper.feeGrowthOutside0X128;
      feeGrowthAbove1X128 = feeGrowthOutsideUpper.feeGrowthOutside1X128;
    } else {
      feeGrowthAbove0X128 = subIn256(feeGrowthGlobal0X128, feeGrowthOutsideUpper.feeGrowthOutside0X128);
      feeGrowthAbove1X128 = subIn256(feeGrowthGlobal1X128, feeGrowthOutsideUpper.feeGrowthOutside1X128);
    }
    return [subIn256(subIn256(feeGrowthGlobal0X128, feeGrowthBelow0X128), feeGrowthAbove0X128), subIn256(subIn256(feeGrowthGlobal1X128, feeGrowthBelow1X128), feeGrowthAbove1X128)];
  };
  return TickLibrary2;
}();
var Tick = function Tick2(_ref) {
  var index2 = _ref.index, liquidityGross = _ref.liquidityGross, liquidityNet = _ref.liquidityNet;
  !(index2 >= TickMath.MIN_TICK && index2 <= TickMath.MAX_TICK) ? invariant$1(false) : void 0;
  this.index = index2;
  this.liquidityGross = JSBI.BigInt(liquidityGross);
  this.liquidityNet = JSBI.BigInt(liquidityNet);
};
var TickListDataProvider = /* @__PURE__ */ function() {
  function TickListDataProvider2(ticks, tickSpacing) {
    var ticksMapped = ticks.map(function(t2) {
      return t2 instanceof Tick ? t2 : new Tick(t2);
    });
    TickList.validateList(ticksMapped, tickSpacing);
    this.ticks = ticksMapped;
  }
  var _proto = TickListDataProvider2.prototype;
  _proto.getTick = /* @__PURE__ */ function() {
    var _getTick = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ runtime_1.mark(function _callee(tick) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", TickList.getTick(this.ticks, tick));
            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    function getTick(_x) {
      return _getTick.apply(this, arguments);
    }
    return getTick;
  }();
  _proto.nextInitializedTickWithinOneWord = /* @__PURE__ */ function() {
    var _nextInitializedTickWithinOneWord = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ runtime_1.mark(function _callee2(tick, lte, tickSpacing) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", TickList.nextInitializedTickWithinOneWord(this.ticks, tick, lte, tickSpacing));
            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
    function nextInitializedTickWithinOneWord(_x2, _x3, _x4) {
      return _nextInitializedTickWithinOneWord.apply(this, arguments);
    }
    return nextInitializedTickWithinOneWord;
  }();
  return TickListDataProvider2;
}();
var NO_TICK_DATA_PROVIDER_DEFAULT = /* @__PURE__ */ new NoTickDataProvider();
var Pool = /* @__PURE__ */ function() {
  function Pool2(tokenA, tokenB, fee, sqrtRatioX96, liquidity, tickCurrent, ticks) {
    if (ticks === void 0) {
      ticks = NO_TICK_DATA_PROVIDER_DEFAULT;
    }
    !(Number.isInteger(fee) && fee < 1e6) ? invariant$1(false) : void 0;
    var tickCurrentSqrtRatioX96 = TickMath.getSqrtRatioAtTick(tickCurrent);
    var nextTickSqrtRatioX96 = TickMath.getSqrtRatioAtTick(tickCurrent + 1);
    !(JSBI.greaterThanOrEqual(JSBI.BigInt(sqrtRatioX96), tickCurrentSqrtRatioX96) && JSBI.lessThanOrEqual(JSBI.BigInt(sqrtRatioX96), nextTickSqrtRatioX96)) ? invariant$1(false) : void 0;
    var _ref = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];
    this.token0 = _ref[0];
    this.token1 = _ref[1];
    this.fee = fee;
    this.sqrtRatioX96 = JSBI.BigInt(sqrtRatioX96);
    this.liquidity = JSBI.BigInt(liquidity);
    this.tickCurrent = tickCurrent;
    this.tickDataProvider = Array.isArray(ticks) ? new TickListDataProvider(ticks, TICK_SPACINGS[fee]) : ticks;
  }
  Pool2.getAddress = function getAddress2(tokenA, tokenB, fee, initCodeHashManualOverride, factoryAddressOverride) {
    return computePoolAddress({
      factoryAddress: factoryAddressOverride != null ? factoryAddressOverride : FACTORY_ADDRESS,
      fee,
      tokenA,
      tokenB,
      initCodeHashManualOverride
    });
  };
  var _proto = Pool2.prototype;
  _proto.involvesToken = function involvesToken(token2) {
    return token2.equals(this.token0) || token2.equals(this.token1);
  };
  _proto.priceOf = function priceOf(token2) {
    !this.involvesToken(token2) ? invariant$1(false) : void 0;
    return token2.equals(this.token0) ? this.token0Price : this.token1Price;
  };
  _proto.getOutputAmount = /* @__PURE__ */ function() {
    var _getOutputAmount = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ runtime_1.mark(function _callee(inputAmount, sqrtPriceLimitX96) {
      var zeroForOne, _yield$this$swap, outputAmount, sqrtRatioX96, liquidity, tickCurrent, outputToken;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              !this.involvesToken(inputAmount.currency) ? invariant$1(false) : void 0;
              zeroForOne = inputAmount.currency.equals(this.token0);
              _context.next = 4;
              return this.swap(zeroForOne, inputAmount.quotient, sqrtPriceLimitX96);
            case 4:
              _yield$this$swap = _context.sent;
              outputAmount = _yield$this$swap.amountCalculated;
              sqrtRatioX96 = _yield$this$swap.sqrtRatioX96;
              liquidity = _yield$this$swap.liquidity;
              tickCurrent = _yield$this$swap.tickCurrent;
              outputToken = zeroForOne ? this.token1 : this.token0;
              return _context.abrupt("return", [CurrencyAmount$3.fromRawAmount(outputToken, JSBI.multiply(outputAmount, NEGATIVE_ONE)), new Pool2(this.token0, this.token1, this.fee, sqrtRatioX96, liquidity, tickCurrent, this.tickDataProvider)]);
            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    function getOutputAmount(_x, _x2) {
      return _getOutputAmount.apply(this, arguments);
    }
    return getOutputAmount;
  }();
  _proto.getInputAmount = /* @__PURE__ */ function() {
    var _getInputAmount = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ runtime_1.mark(function _callee2(outputAmount, sqrtPriceLimitX96) {
      var zeroForOne, _yield$this$swap2, inputAmount, sqrtRatioX96, liquidity, tickCurrent, inputToken;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              !(outputAmount.currency.isToken && this.involvesToken(outputAmount.currency)) ? invariant$1(false) : void 0;
              zeroForOne = outputAmount.currency.equals(this.token1);
              _context2.next = 4;
              return this.swap(zeroForOne, JSBI.multiply(outputAmount.quotient, NEGATIVE_ONE), sqrtPriceLimitX96);
            case 4:
              _yield$this$swap2 = _context2.sent;
              inputAmount = _yield$this$swap2.amountCalculated;
              sqrtRatioX96 = _yield$this$swap2.sqrtRatioX96;
              liquidity = _yield$this$swap2.liquidity;
              tickCurrent = _yield$this$swap2.tickCurrent;
              inputToken = zeroForOne ? this.token0 : this.token1;
              return _context2.abrupt("return", [CurrencyAmount$3.fromRawAmount(inputToken, inputAmount), new Pool2(this.token0, this.token1, this.fee, sqrtRatioX96, liquidity, tickCurrent, this.tickDataProvider)]);
            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
    function getInputAmount(_x3, _x4) {
      return _getInputAmount.apply(this, arguments);
    }
    return getInputAmount;
  }();
  _proto.swap = /* @__PURE__ */ function() {
    var _swap = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ runtime_1.mark(function _callee3(zeroForOne, amountSpecified, sqrtPriceLimitX96) {
      var exactInput, state2, step, _yield$this$tickDataP, _SwapMath$computeSwap, liquidityNet;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!sqrtPriceLimitX96)
                sqrtPriceLimitX96 = zeroForOne ? JSBI.add(TickMath.MIN_SQRT_RATIO, ONE$4) : JSBI.subtract(TickMath.MAX_SQRT_RATIO, ONE$4);
              if (zeroForOne) {
                !JSBI.greaterThan(sqrtPriceLimitX96, TickMath.MIN_SQRT_RATIO) ? invariant$1(false) : void 0;
                !JSBI.lessThan(sqrtPriceLimitX96, this.sqrtRatioX96) ? invariant$1(false) : void 0;
              } else {
                !JSBI.lessThan(sqrtPriceLimitX96, TickMath.MAX_SQRT_RATIO) ? invariant$1(false) : void 0;
                !JSBI.greaterThan(sqrtPriceLimitX96, this.sqrtRatioX96) ? invariant$1(false) : void 0;
              }
              exactInput = JSBI.greaterThanOrEqual(amountSpecified, ZERO$4);
              state2 = {
                amountSpecifiedRemaining: amountSpecified,
                amountCalculated: ZERO$4,
                sqrtPriceX96: this.sqrtRatioX96,
                tick: this.tickCurrent,
                liquidity: this.liquidity
              };
            case 4:
              if (!(JSBI.notEqual(state2.amountSpecifiedRemaining, ZERO$4) && state2.sqrtPriceX96 != sqrtPriceLimitX96)) {
                _context3.next = 35;
                break;
              }
              step = {};
              step.sqrtPriceStartX96 = state2.sqrtPriceX96;
              _context3.next = 9;
              return this.tickDataProvider.nextInitializedTickWithinOneWord(state2.tick, zeroForOne, this.tickSpacing);
            case 9:
              _yield$this$tickDataP = _context3.sent;
              step.tickNext = _yield$this$tickDataP[0];
              step.initialized = _yield$this$tickDataP[1];
              if (step.tickNext < TickMath.MIN_TICK) {
                step.tickNext = TickMath.MIN_TICK;
              } else if (step.tickNext > TickMath.MAX_TICK) {
                step.tickNext = TickMath.MAX_TICK;
              }
              step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);
              _SwapMath$computeSwap = SwapMath.computeSwapStep(state2.sqrtPriceX96, (zeroForOne ? JSBI.lessThan(step.sqrtPriceNextX96, sqrtPriceLimitX96) : JSBI.greaterThan(step.sqrtPriceNextX96, sqrtPriceLimitX96)) ? sqrtPriceLimitX96 : step.sqrtPriceNextX96, state2.liquidity, state2.amountSpecifiedRemaining, this.fee);
              state2.sqrtPriceX96 = _SwapMath$computeSwap[0];
              step.amountIn = _SwapMath$computeSwap[1];
              step.amountOut = _SwapMath$computeSwap[2];
              step.feeAmount = _SwapMath$computeSwap[3];
              if (exactInput) {
                state2.amountSpecifiedRemaining = JSBI.subtract(state2.amountSpecifiedRemaining, JSBI.add(step.amountIn, step.feeAmount));
                state2.amountCalculated = JSBI.subtract(state2.amountCalculated, step.amountOut);
              } else {
                state2.amountSpecifiedRemaining = JSBI.add(state2.amountSpecifiedRemaining, step.amountOut);
                state2.amountCalculated = JSBI.add(state2.amountCalculated, JSBI.add(step.amountIn, step.feeAmount));
              }
              if (!JSBI.equal(state2.sqrtPriceX96, step.sqrtPriceNextX96)) {
                _context3.next = 32;
                break;
              }
              if (!step.initialized) {
                _context3.next = 29;
                break;
              }
              _context3.t0 = JSBI;
              _context3.next = 25;
              return this.tickDataProvider.getTick(step.tickNext);
            case 25:
              _context3.t1 = _context3.sent.liquidityNet;
              liquidityNet = _context3.t0.BigInt.call(_context3.t0, _context3.t1);
              if (zeroForOne)
                liquidityNet = JSBI.multiply(liquidityNet, NEGATIVE_ONE);
              state2.liquidity = LiquidityMath.addDelta(state2.liquidity, liquidityNet);
            case 29:
              state2.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
              _context3.next = 33;
              break;
            case 32:
              if (JSBI.notEqual(state2.sqrtPriceX96, step.sqrtPriceStartX96)) {
                state2.tick = TickMath.getTickAtSqrtRatio(state2.sqrtPriceX96);
              }
            case 33:
              _context3.next = 4;
              break;
            case 35:
              return _context3.abrupt("return", {
                amountCalculated: state2.amountCalculated,
                sqrtRatioX96: state2.sqrtPriceX96,
                liquidity: state2.liquidity,
                tickCurrent: state2.tick
              });
            case 36:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));
    function swap(_x5, _x6, _x7) {
      return _swap.apply(this, arguments);
    }
    return swap;
  }();
  _createClass$4(Pool2, [{
    key: "token0Price",
    get: function get2() {
      var _this$_token0Price;
      return (_this$_token0Price = this._token0Price) != null ? _this$_token0Price : this._token0Price = new Price$2(this.token0, this.token1, Q192, JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96));
    }
    /**
     * Returns the current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1
     */
  }, {
    key: "token1Price",
    get: function get2() {
      var _this$_token1Price;
      return (_this$_token1Price = this._token1Price) != null ? _this$_token1Price : this._token1Price = new Price$2(this.token1, this.token0, JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96), Q192);
    }
  }, {
    key: "chainId",
    get: function get2() {
      return this.token0.chainId;
    }
  }, {
    key: "tickSpacing",
    get: function get2() {
      return TICK_SPACINGS[this.fee];
    }
  }]);
  return Pool2;
}();
var Position$1 = /* @__PURE__ */ function() {
  function Position2(_ref) {
    var pool = _ref.pool, liquidity = _ref.liquidity, tickLower = _ref.tickLower, tickUpper = _ref.tickUpper;
    this._token0Amount = null;
    this._token1Amount = null;
    this._mintAmounts = null;
    !(tickLower < tickUpper) ? invariant$1(false) : void 0;
    !(tickLower >= TickMath.MIN_TICK && tickLower % pool.tickSpacing === 0) ? invariant$1(false) : void 0;
    !(tickUpper <= TickMath.MAX_TICK && tickUpper % pool.tickSpacing === 0) ? invariant$1(false) : void 0;
    this.pool = pool;
    this.tickLower = tickLower;
    this.tickUpper = tickUpper;
    this.liquidity = JSBI.BigInt(liquidity);
  }
  var _proto = Position2.prototype;
  _proto.ratiosAfterSlippage = function ratiosAfterSlippage(slippageTolerance) {
    var priceLower = this.pool.token0Price.asFraction.multiply(new Percent$2(1).subtract(slippageTolerance));
    var priceUpper = this.pool.token0Price.asFraction.multiply(slippageTolerance.add(1));
    var sqrtRatioX96Lower = encodeSqrtRatioX96(priceLower.numerator, priceLower.denominator);
    if (JSBI.lessThanOrEqual(sqrtRatioX96Lower, TickMath.MIN_SQRT_RATIO)) {
      sqrtRatioX96Lower = JSBI.add(TickMath.MIN_SQRT_RATIO, JSBI.BigInt(1));
    }
    var sqrtRatioX96Upper = encodeSqrtRatioX96(priceUpper.numerator, priceUpper.denominator);
    if (JSBI.greaterThanOrEqual(sqrtRatioX96Upper, TickMath.MAX_SQRT_RATIO)) {
      sqrtRatioX96Upper = JSBI.subtract(TickMath.MAX_SQRT_RATIO, JSBI.BigInt(1));
    }
    return {
      sqrtRatioX96Lower,
      sqrtRatioX96Upper
    };
  };
  _proto.mintAmountsWithSlippage = function mintAmountsWithSlippage(slippageTolerance) {
    var _this$ratiosAfterSlip = this.ratiosAfterSlippage(slippageTolerance), sqrtRatioX96Upper = _this$ratiosAfterSlip.sqrtRatioX96Upper, sqrtRatioX96Lower = _this$ratiosAfterSlip.sqrtRatioX96Lower;
    var poolLower = new Pool(
      this.pool.token0,
      this.pool.token1,
      this.pool.fee,
      sqrtRatioX96Lower,
      0,
      TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower)
    );
    var poolUpper = new Pool(
      this.pool.token0,
      this.pool.token1,
      this.pool.fee,
      sqrtRatioX96Upper,
      0,
      TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper)
    );
    var positionThatWillBeCreated = Position2.fromAmounts(_extends$2({
      pool: this.pool,
      tickLower: this.tickLower,
      tickUpper: this.tickUpper
    }, this.mintAmounts, {
      useFullPrecision: false
    }));
    var amount0 = new Position2({
      pool: poolUpper,
      liquidity: positionThatWillBeCreated.liquidity,
      tickLower: this.tickLower,
      tickUpper: this.tickUpper
    }).mintAmounts.amount0;
    var amount1 = new Position2({
      pool: poolLower,
      liquidity: positionThatWillBeCreated.liquidity,
      tickLower: this.tickLower,
      tickUpper: this.tickUpper
    }).mintAmounts.amount1;
    return {
      amount0,
      amount1
    };
  };
  _proto.burnAmountsWithSlippage = function burnAmountsWithSlippage(slippageTolerance) {
    var _this$ratiosAfterSlip2 = this.ratiosAfterSlippage(slippageTolerance), sqrtRatioX96Upper = _this$ratiosAfterSlip2.sqrtRatioX96Upper, sqrtRatioX96Lower = _this$ratiosAfterSlip2.sqrtRatioX96Lower;
    var poolLower = new Pool(
      this.pool.token0,
      this.pool.token1,
      this.pool.fee,
      sqrtRatioX96Lower,
      0,
      TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower)
    );
    var poolUpper = new Pool(
      this.pool.token0,
      this.pool.token1,
      this.pool.fee,
      sqrtRatioX96Upper,
      0,
      TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper)
    );
    var amount0 = new Position2({
      pool: poolUpper,
      liquidity: this.liquidity,
      tickLower: this.tickLower,
      tickUpper: this.tickUpper
    }).amount0;
    var amount1 = new Position2({
      pool: poolLower,
      liquidity: this.liquidity,
      tickLower: this.tickLower,
      tickUpper: this.tickUpper
    }).amount1;
    return {
      amount0: amount0.quotient,
      amount1: amount1.quotient
    };
  };
  Position2.fromAmounts = function fromAmounts(_ref2) {
    var pool = _ref2.pool, tickLower = _ref2.tickLower, tickUpper = _ref2.tickUpper, amount0 = _ref2.amount0, amount1 = _ref2.amount1, useFullPrecision = _ref2.useFullPrecision;
    var sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);
    var sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
    return new Position2({
      pool,
      tickLower,
      tickUpper,
      liquidity: maxLiquidityForAmounts(pool.sqrtRatioX96, sqrtRatioAX96, sqrtRatioBX96, amount0, amount1, useFullPrecision)
    });
  };
  Position2.fromAmount0 = function fromAmount0(_ref3) {
    var pool = _ref3.pool, tickLower = _ref3.tickLower, tickUpper = _ref3.tickUpper, amount0 = _ref3.amount0, useFullPrecision = _ref3.useFullPrecision;
    return Position2.fromAmounts({
      pool,
      tickLower,
      tickUpper,
      amount0,
      amount1: MaxUint256$4,
      useFullPrecision
    });
  };
  Position2.fromAmount1 = function fromAmount1(_ref4) {
    var pool = _ref4.pool, tickLower = _ref4.tickLower, tickUpper = _ref4.tickUpper, amount1 = _ref4.amount1;
    return Position2.fromAmounts({
      pool,
      tickLower,
      tickUpper,
      amount0: MaxUint256$4,
      amount1,
      useFullPrecision: true
    });
  };
  _createClass$4(Position2, [{
    key: "token0PriceLower",
    get: function get2() {
      return tickToPrice(this.pool.token0, this.pool.token1, this.tickLower);
    }
    /**
     * Returns the price of token0 at the upper tick
     */
  }, {
    key: "token0PriceUpper",
    get: function get2() {
      return tickToPrice(this.pool.token0, this.pool.token1, this.tickUpper);
    }
    /**
     * Returns the amount of token0 that this position's liquidity could be burned for at the current pool price
     */
  }, {
    key: "amount0",
    get: function get2() {
      if (this._token0Amount === null) {
        if (this.pool.tickCurrent < this.tickLower) {
          this._token0Amount = CurrencyAmount$3.fromRawAmount(this.pool.token0, SqrtPriceMath.getAmount0Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, false));
        } else if (this.pool.tickCurrent < this.tickUpper) {
          this._token0Amount = CurrencyAmount$3.fromRawAmount(this.pool.token0, SqrtPriceMath.getAmount0Delta(this.pool.sqrtRatioX96, TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, false));
        } else {
          this._token0Amount = CurrencyAmount$3.fromRawAmount(this.pool.token0, ZERO$4);
        }
      }
      return this._token0Amount;
    }
    /**
     * Returns the amount of token1 that this position's liquidity could be burned for at the current pool price
     */
  }, {
    key: "amount1",
    get: function get2() {
      if (this._token1Amount === null) {
        if (this.pool.tickCurrent < this.tickLower) {
          this._token1Amount = CurrencyAmount$3.fromRawAmount(this.pool.token1, ZERO$4);
        } else if (this.pool.tickCurrent < this.tickUpper) {
          this._token1Amount = CurrencyAmount$3.fromRawAmount(this.pool.token1, SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), this.pool.sqrtRatioX96, this.liquidity, false));
        } else {
          this._token1Amount = CurrencyAmount$3.fromRawAmount(this.pool.token1, SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, false));
        }
      }
      return this._token1Amount;
    }
  }, {
    key: "mintAmounts",
    get: function get2() {
      if (this._mintAmounts === null) {
        if (this.pool.tickCurrent < this.tickLower) {
          return {
            amount0: SqrtPriceMath.getAmount0Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, true),
            amount1: ZERO$4
          };
        } else if (this.pool.tickCurrent < this.tickUpper) {
          return {
            amount0: SqrtPriceMath.getAmount0Delta(this.pool.sqrtRatioX96, TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, true),
            amount1: SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), this.pool.sqrtRatioX96, this.liquidity, true)
          };
        } else {
          return {
            amount0: ZERO$4,
            amount1: SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, true)
          };
        }
      }
      return this._mintAmounts;
    }
  }]);
  return Position2;
}();
var Route$2 = /* @__PURE__ */ function() {
  function Route2(pools, input, output2) {
    this._midPrice = null;
    !(pools.length > 0) ? invariant$1(false) : void 0;
    var chainId2 = pools[0].chainId;
    var allOnSameChain = pools.every(function(pool2) {
      return pool2.chainId === chainId2;
    });
    !allOnSameChain ? invariant$1(false) : void 0;
    var wrappedInput = input.wrapped;
    !pools[0].involvesToken(wrappedInput) ? invariant$1(false) : void 0;
    !pools[pools.length - 1].involvesToken(output2.wrapped) ? invariant$1(false) : void 0;
    var tokenPath = [wrappedInput];
    for (var _iterator = _createForOfIteratorHelperLoose$2(pools.entries()), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, i3 = _step$value[0], pool = _step$value[1];
      var currentInputToken = tokenPath[i3];
      !(currentInputToken.equals(pool.token0) || currentInputToken.equals(pool.token1)) ? invariant$1(false) : void 0;
      var nextToken = currentInputToken.equals(pool.token0) ? pool.token1 : pool.token0;
      tokenPath.push(nextToken);
    }
    this.pools = pools;
    this.tokenPath = tokenPath;
    this.input = input;
    this.output = output2 != null ? output2 : tokenPath[tokenPath.length - 1];
  }
  _createClass$4(Route2, [{
    key: "chainId",
    get: function get2() {
      return this.pools[0].chainId;
    }
    /**
     * Returns the mid price of the route
     */
  }, {
    key: "midPrice",
    get: function get2() {
      if (this._midPrice !== null)
        return this._midPrice;
      var price = this.pools.slice(1).reduce(function(_ref, pool) {
        var nextInput = _ref.nextInput, price2 = _ref.price;
        return nextInput.equals(pool.token0) ? {
          nextInput: pool.token1,
          price: price2.multiply(pool.token0Price)
        } : {
          nextInput: pool.token0,
          price: price2.multiply(pool.token1Price)
        };
      }, this.pools[0].token0.equals(this.input.wrapped) ? {
        nextInput: this.pools[0].token1,
        price: this.pools[0].token0Price
      } : {
        nextInput: this.pools[0].token0,
        price: this.pools[0].token1Price
      }).price;
      return this._midPrice = new Price$2(this.input, this.output, price.denominator, price.numerator);
    }
  }]);
  return Route2;
}();
function tradeComparator$1(a2, b3) {
  !a2.inputAmount.currency.equals(b3.inputAmount.currency) ? invariant$1(false) : void 0;
  !a2.outputAmount.currency.equals(b3.outputAmount.currency) ? invariant$1(false) : void 0;
  if (a2.outputAmount.equalTo(b3.outputAmount)) {
    if (a2.inputAmount.equalTo(b3.inputAmount)) {
      var aHops = a2.swaps.reduce(function(total, cur) {
        return total + cur.route.tokenPath.length;
      }, 0);
      var bHops = b3.swaps.reduce(function(total, cur) {
        return total + cur.route.tokenPath.length;
      }, 0);
      return aHops - bHops;
    }
    if (a2.inputAmount.lessThan(b3.inputAmount)) {
      return -1;
    } else {
      return 1;
    }
  } else {
    if (a2.outputAmount.lessThan(b3.outputAmount)) {
      return 1;
    } else {
      return -1;
    }
  }
}
var Trade$1 = /* @__PURE__ */ function() {
  function Trade2(_ref) {
    var routes = _ref.routes, tradeType = _ref.tradeType;
    var inputCurrency = routes[0].inputAmount.currency;
    var outputCurrency = routes[0].outputAmount.currency;
    !routes.every(function(_ref2) {
      var route2 = _ref2.route;
      return inputCurrency.wrapped.equals(route2.input.wrapped);
    }) ? invariant$1(false) : void 0;
    !routes.every(function(_ref3) {
      var route2 = _ref3.route;
      return outputCurrency.wrapped.equals(route2.output.wrapped);
    }) ? invariant$1(false) : void 0;
    var numPools = routes.map(function(_ref4) {
      var route2 = _ref4.route;
      return route2.pools.length;
    }).reduce(function(total, cur) {
      return total + cur;
    }, 0);
    var poolAddressSet = /* @__PURE__ */ new Set();
    for (var _iterator = _createForOfIteratorHelperLoose$2(routes), _step; !(_step = _iterator()).done; ) {
      var route = _step.value.route;
      for (var _iterator2 = _createForOfIteratorHelperLoose$2(route.pools), _step2; !(_step2 = _iterator2()).done; ) {
        var pool = _step2.value;
        poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, pool.fee));
      }
    }
    !(numPools == poolAddressSet.size) ? invariant$1(false) : void 0;
    this.swaps = routes;
    this.tradeType = tradeType;
  }
  Trade2.exactIn = /* @__PURE__ */ function() {
    var _exactIn = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ runtime_1.mark(function _callee(route, amountIn) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", Trade2.fromRoute(route, amountIn, TradeType$2.EXACT_INPUT));
            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    function exactIn(_x, _x2) {
      return _exactIn.apply(this, arguments);
    }
    return exactIn;
  }();
  Trade2.exactOut = /* @__PURE__ */ function() {
    var _exactOut = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ runtime_1.mark(function _callee2(route, amountOut) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", Trade2.fromRoute(route, amountOut, TradeType$2.EXACT_OUTPUT));
            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    function exactOut(_x3, _x4) {
      return _exactOut.apply(this, arguments);
    }
    return exactOut;
  }();
  Trade2.fromRoute = /* @__PURE__ */ function() {
    var _fromRoute = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ runtime_1.mark(function _callee3(route, amount, tradeType) {
      var amounts, inputAmount, outputAmount, i3, pool, _yield$pool$getOutput, _outputAmount, _i, _pool, _yield$_pool$getInput, _inputAmount;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              amounts = new Array(route.tokenPath.length);
              if (!(tradeType === TradeType$2.EXACT_INPUT)) {
                _context3.next = 19;
                break;
              }
              !amount.currency.equals(route.input) ? invariant$1(false) : void 0;
              amounts[0] = amount.wrapped;
              i3 = 0;
            case 5:
              if (!(i3 < route.tokenPath.length - 1)) {
                _context3.next = 15;
                break;
              }
              pool = route.pools[i3];
              _context3.next = 9;
              return pool.getOutputAmount(amounts[i3]);
            case 9:
              _yield$pool$getOutput = _context3.sent;
              _outputAmount = _yield$pool$getOutput[0];
              amounts[i3 + 1] = _outputAmount;
            case 12:
              i3++;
              _context3.next = 5;
              break;
            case 15:
              inputAmount = CurrencyAmount$3.fromFractionalAmount(route.input, amount.numerator, amount.denominator);
              outputAmount = CurrencyAmount$3.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);
              _context3.next = 34;
              break;
            case 19:
              !amount.currency.equals(route.output) ? invariant$1(false) : void 0;
              amounts[amounts.length - 1] = amount.wrapped;
              _i = route.tokenPath.length - 1;
            case 22:
              if (!(_i > 0)) {
                _context3.next = 32;
                break;
              }
              _pool = route.pools[_i - 1];
              _context3.next = 26;
              return _pool.getInputAmount(amounts[_i]);
            case 26:
              _yield$_pool$getInput = _context3.sent;
              _inputAmount = _yield$_pool$getInput[0];
              amounts[_i - 1] = _inputAmount;
            case 29:
              _i--;
              _context3.next = 22;
              break;
            case 32:
              inputAmount = CurrencyAmount$3.fromFractionalAmount(route.input, amounts[0].numerator, amounts[0].denominator);
              outputAmount = CurrencyAmount$3.fromFractionalAmount(route.output, amount.numerator, amount.denominator);
            case 34:
              return _context3.abrupt("return", new Trade2({
                routes: [{
                  inputAmount,
                  outputAmount,
                  route
                }],
                tradeType
              }));
            case 35:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    function fromRoute(_x5, _x6, _x7) {
      return _fromRoute.apply(this, arguments);
    }
    return fromRoute;
  }();
  Trade2.fromRoutes = /* @__PURE__ */ function() {
    var _fromRoutes = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ runtime_1.mark(function _callee4(routes, tradeType) {
      var populatedRoutes, _iterator3, _step3, _step3$value, route, amount, amounts, inputAmount, outputAmount, i3, pool, _yield$pool$getOutput2, _outputAmount2, _i2, _pool2, _yield$_pool2$getInpu, _inputAmount2;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              populatedRoutes = [];
              _iterator3 = _createForOfIteratorHelperLoose$2(routes);
            case 2:
              if ((_step3 = _iterator3()).done) {
                _context4.next = 43;
                break;
              }
              _step3$value = _step3.value, route = _step3$value.route, amount = _step3$value.amount;
              amounts = new Array(route.tokenPath.length);
              inputAmount = void 0;
              outputAmount = void 0;
              if (!(tradeType === TradeType$2.EXACT_INPUT)) {
                _context4.next = 25;
                break;
              }
              !amount.currency.equals(route.input) ? invariant$1(false) : void 0;
              inputAmount = CurrencyAmount$3.fromFractionalAmount(route.input, amount.numerator, amount.denominator);
              amounts[0] = CurrencyAmount$3.fromFractionalAmount(route.input.wrapped, amount.numerator, amount.denominator);
              i3 = 0;
            case 12:
              if (!(i3 < route.tokenPath.length - 1)) {
                _context4.next = 22;
                break;
              }
              pool = route.pools[i3];
              _context4.next = 16;
              return pool.getOutputAmount(amounts[i3]);
            case 16:
              _yield$pool$getOutput2 = _context4.sent;
              _outputAmount2 = _yield$pool$getOutput2[0];
              amounts[i3 + 1] = _outputAmount2;
            case 19:
              i3++;
              _context4.next = 12;
              break;
            case 22:
              outputAmount = CurrencyAmount$3.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);
              _context4.next = 40;
              break;
            case 25:
              !amount.currency.equals(route.output) ? invariant$1(false) : void 0;
              outputAmount = CurrencyAmount$3.fromFractionalAmount(route.output, amount.numerator, amount.denominator);
              amounts[amounts.length - 1] = CurrencyAmount$3.fromFractionalAmount(route.output.wrapped, amount.numerator, amount.denominator);
              _i2 = route.tokenPath.length - 1;
            case 29:
              if (!(_i2 > 0)) {
                _context4.next = 39;
                break;
              }
              _pool2 = route.pools[_i2 - 1];
              _context4.next = 33;
              return _pool2.getInputAmount(amounts[_i2]);
            case 33:
              _yield$_pool2$getInpu = _context4.sent;
              _inputAmount2 = _yield$_pool2$getInpu[0];
              amounts[_i2 - 1] = _inputAmount2;
            case 36:
              _i2--;
              _context4.next = 29;
              break;
            case 39:
              inputAmount = CurrencyAmount$3.fromFractionalAmount(route.input, amounts[0].numerator, amounts[0].denominator);
            case 40:
              populatedRoutes.push({
                route,
                inputAmount,
                outputAmount
              });
            case 41:
              _context4.next = 2;
              break;
            case 43:
              return _context4.abrupt("return", new Trade2({
                routes: populatedRoutes,
                tradeType
              }));
            case 44:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    function fromRoutes(_x8, _x9) {
      return _fromRoutes.apply(this, arguments);
    }
    return fromRoutes;
  }();
  Trade2.createUncheckedTrade = function createUncheckedTrade(constructorArguments) {
    return new Trade2(_extends$2({}, constructorArguments, {
      routes: [{
        inputAmount: constructorArguments.inputAmount,
        outputAmount: constructorArguments.outputAmount,
        route: constructorArguments.route
      }]
    }));
  };
  Trade2.createUncheckedTradeWithMultipleRoutes = function createUncheckedTradeWithMultipleRoutes(constructorArguments) {
    return new Trade2(constructorArguments);
  };
  var _proto = Trade2.prototype;
  _proto.minimumAmountOut = function minimumAmountOut(slippageTolerance, amountOut) {
    if (amountOut === void 0) {
      amountOut = this.outputAmount;
    }
    !!slippageTolerance.lessThan(ZERO$4) ? invariant$1(false) : void 0;
    if (this.tradeType === TradeType$2.EXACT_OUTPUT) {
      return amountOut;
    } else {
      var slippageAdjustedAmountOut = new Fraction$2(ONE$4).add(slippageTolerance).invert().multiply(amountOut.quotient).quotient;
      return CurrencyAmount$3.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut);
    }
  };
  _proto.maximumAmountIn = function maximumAmountIn(slippageTolerance, amountIn) {
    if (amountIn === void 0) {
      amountIn = this.inputAmount;
    }
    !!slippageTolerance.lessThan(ZERO$4) ? invariant$1(false) : void 0;
    if (this.tradeType === TradeType$2.EXACT_INPUT) {
      return amountIn;
    } else {
      var slippageAdjustedAmountIn = new Fraction$2(ONE$4).add(slippageTolerance).multiply(amountIn.quotient).quotient;
      return CurrencyAmount$3.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn);
    }
  };
  _proto.worstExecutionPrice = function worstExecutionPrice(slippageTolerance) {
    return new Price$2(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);
  };
  Trade2.bestTradeExactIn = /* @__PURE__ */ function() {
    var _bestTradeExactIn = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ runtime_1.mark(function _callee5(pools, currencyAmountIn, currencyOut, _temp, currentPools, nextAmountIn, bestTrades) {
      var _ref5, _ref5$maxNumResults, maxNumResults, _ref5$maxHops, maxHops, amountIn, tokenOut, i3, pool, amountOut, _yield$pool$getOutput3, poolsExcludingThisPool;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _ref5 = _temp === void 0 ? {} : _temp, _ref5$maxNumResults = _ref5.maxNumResults, maxNumResults = _ref5$maxNumResults === void 0 ? 3 : _ref5$maxNumResults, _ref5$maxHops = _ref5.maxHops, maxHops = _ref5$maxHops === void 0 ? 3 : _ref5$maxHops;
              if (currentPools === void 0) {
                currentPools = [];
              }
              if (nextAmountIn === void 0) {
                nextAmountIn = currencyAmountIn;
              }
              if (bestTrades === void 0) {
                bestTrades = [];
              }
              !(pools.length > 0) ? invariant$1(false) : void 0;
              !(maxHops > 0) ? invariant$1(false) : void 0;
              !(currencyAmountIn === nextAmountIn || currentPools.length > 0) ? invariant$1(false) : void 0;
              amountIn = nextAmountIn.wrapped;
              tokenOut = currencyOut.wrapped;
              i3 = 0;
            case 10:
              if (!(i3 < pools.length)) {
                _context5.next = 46;
                break;
              }
              pool = pools[i3];
              if (!(!pool.token0.equals(amountIn.currency) && !pool.token1.equals(amountIn.currency))) {
                _context5.next = 14;
                break;
              }
              return _context5.abrupt("continue", 43);
            case 14:
              amountOut = void 0;
              _context5.prev = 15;
              _context5.next = 19;
              return pool.getOutputAmount(amountIn);
            case 19:
              _yield$pool$getOutput3 = _context5.sent;
              amountOut = _yield$pool$getOutput3[0];
              _context5.next = 28;
              break;
            case 23:
              _context5.prev = 23;
              _context5.t0 = _context5["catch"](15);
              if (!_context5.t0.isInsufficientInputAmountError) {
                _context5.next = 27;
                break;
              }
              return _context5.abrupt("continue", 43);
            case 27:
              throw _context5.t0;
            case 28:
              if (!(amountOut.currency.isToken && amountOut.currency.equals(tokenOut))) {
                _context5.next = 39;
                break;
              }
              _context5.t1 = sortedInsert$1;
              _context5.t2 = bestTrades;
              _context5.next = 33;
              return Trade2.fromRoute(new Route$2([].concat(currentPools, [pool]), currencyAmountIn.currency, currencyOut), currencyAmountIn, TradeType$2.EXACT_INPUT);
            case 33:
              _context5.t3 = _context5.sent;
              _context5.t4 = maxNumResults;
              _context5.t5 = tradeComparator$1;
              (0, _context5.t1)(_context5.t2, _context5.t3, _context5.t4, _context5.t5);
              _context5.next = 43;
              break;
            case 39:
              if (!(maxHops > 1 && pools.length > 1)) {
                _context5.next = 43;
                break;
              }
              poolsExcludingThisPool = pools.slice(0, i3).concat(pools.slice(i3 + 1, pools.length));
              _context5.next = 43;
              return Trade2.bestTradeExactIn(poolsExcludingThisPool, currencyAmountIn, currencyOut, {
                maxNumResults,
                maxHops: maxHops - 1
              }, [].concat(currentPools, [pool]), amountOut, bestTrades);
            case 43:
              i3++;
              _context5.next = 10;
              break;
            case 46:
              return _context5.abrupt("return", bestTrades);
            case 47:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, null, [[15, 23]]);
    }));
    function bestTradeExactIn(_x10, _x11, _x12, _x13, _x14, _x15, _x16) {
      return _bestTradeExactIn.apply(this, arguments);
    }
    return bestTradeExactIn;
  }();
  Trade2.bestTradeExactOut = /* @__PURE__ */ function() {
    var _bestTradeExactOut = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ runtime_1.mark(function _callee6(pools, currencyIn, currencyAmountOut, _temp2, currentPools, nextAmountOut, bestTrades) {
      var _ref6, _ref6$maxNumResults, maxNumResults, _ref6$maxHops, maxHops, amountOut, tokenIn, i3, pool, amountIn, _yield$pool$getInputA, poolsExcludingThisPool;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _ref6 = _temp2 === void 0 ? {} : _temp2, _ref6$maxNumResults = _ref6.maxNumResults, maxNumResults = _ref6$maxNumResults === void 0 ? 3 : _ref6$maxNumResults, _ref6$maxHops = _ref6.maxHops, maxHops = _ref6$maxHops === void 0 ? 3 : _ref6$maxHops;
              if (currentPools === void 0) {
                currentPools = [];
              }
              if (nextAmountOut === void 0) {
                nextAmountOut = currencyAmountOut;
              }
              if (bestTrades === void 0) {
                bestTrades = [];
              }
              !(pools.length > 0) ? invariant$1(false) : void 0;
              !(maxHops > 0) ? invariant$1(false) : void 0;
              !(currencyAmountOut === nextAmountOut || currentPools.length > 0) ? invariant$1(false) : void 0;
              amountOut = nextAmountOut.wrapped;
              tokenIn = currencyIn.wrapped;
              i3 = 0;
            case 10:
              if (!(i3 < pools.length)) {
                _context6.next = 46;
                break;
              }
              pool = pools[i3];
              if (!(!pool.token0.equals(amountOut.currency) && !pool.token1.equals(amountOut.currency))) {
                _context6.next = 14;
                break;
              }
              return _context6.abrupt("continue", 43);
            case 14:
              amountIn = void 0;
              _context6.prev = 15;
              _context6.next = 19;
              return pool.getInputAmount(amountOut);
            case 19:
              _yield$pool$getInputA = _context6.sent;
              amountIn = _yield$pool$getInputA[0];
              _context6.next = 28;
              break;
            case 23:
              _context6.prev = 23;
              _context6.t0 = _context6["catch"](15);
              if (!_context6.t0.isInsufficientReservesError) {
                _context6.next = 27;
                break;
              }
              return _context6.abrupt("continue", 43);
            case 27:
              throw _context6.t0;
            case 28:
              if (!amountIn.currency.equals(tokenIn)) {
                _context6.next = 39;
                break;
              }
              _context6.t1 = sortedInsert$1;
              _context6.t2 = bestTrades;
              _context6.next = 33;
              return Trade2.fromRoute(new Route$2([pool].concat(currentPools), currencyIn, currencyAmountOut.currency), currencyAmountOut, TradeType$2.EXACT_OUTPUT);
            case 33:
              _context6.t3 = _context6.sent;
              _context6.t4 = maxNumResults;
              _context6.t5 = tradeComparator$1;
              (0, _context6.t1)(_context6.t2, _context6.t3, _context6.t4, _context6.t5);
              _context6.next = 43;
              break;
            case 39:
              if (!(maxHops > 1 && pools.length > 1)) {
                _context6.next = 43;
                break;
              }
              poolsExcludingThisPool = pools.slice(0, i3).concat(pools.slice(i3 + 1, pools.length));
              _context6.next = 43;
              return Trade2.bestTradeExactOut(poolsExcludingThisPool, currencyIn, currencyAmountOut, {
                maxNumResults,
                maxHops: maxHops - 1
              }, [pool].concat(currentPools), amountIn, bestTrades);
            case 43:
              i3++;
              _context6.next = 10;
              break;
            case 46:
              return _context6.abrupt("return", bestTrades);
            case 47:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, null, [[15, 23]]);
    }));
    function bestTradeExactOut(_x17, _x18, _x19, _x20, _x21, _x22, _x23) {
      return _bestTradeExactOut.apply(this, arguments);
    }
    return bestTradeExactOut;
  }();
  _createClass$4(Trade2, [{
    key: "route",
    get: function get2() {
      !(this.swaps.length == 1) ? invariant$1(false) : void 0;
      return this.swaps[0].route;
    }
    /**
     * The input amount for the trade assuming no slippage.
     */
  }, {
    key: "inputAmount",
    get: function get2() {
      if (this._inputAmount) {
        return this._inputAmount;
      }
      var inputCurrency = this.swaps[0].inputAmount.currency;
      var totalInputFromRoutes = this.swaps.map(function(_ref7) {
        var inputAmount = _ref7.inputAmount;
        return inputAmount;
      }).reduce(function(total, cur) {
        return total.add(cur);
      }, CurrencyAmount$3.fromRawAmount(inputCurrency, 0));
      this._inputAmount = totalInputFromRoutes;
      return this._inputAmount;
    }
    /**
     * The output amount for the trade assuming no slippage.
     */
  }, {
    key: "outputAmount",
    get: function get2() {
      if (this._outputAmount) {
        return this._outputAmount;
      }
      var outputCurrency = this.swaps[0].outputAmount.currency;
      var totalOutputFromRoutes = this.swaps.map(function(_ref8) {
        var outputAmount = _ref8.outputAmount;
        return outputAmount;
      }).reduce(function(total, cur) {
        return total.add(cur);
      }, CurrencyAmount$3.fromRawAmount(outputCurrency, 0));
      this._outputAmount = totalOutputFromRoutes;
      return this._outputAmount;
    }
    /**
     * The price expressed in terms of output amount/input amount.
     */
  }, {
    key: "executionPrice",
    get: function get2() {
      var _this$_executionPrice;
      return (_this$_executionPrice = this._executionPrice) != null ? _this$_executionPrice : this._executionPrice = new Price$2(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);
    }
    /**
     * Returns the percent difference between the route's mid price and the price impact
     */
  }, {
    key: "priceImpact",
    get: function get2() {
      if (this._priceImpact) {
        return this._priceImpact;
      }
      var spotOutputAmount = CurrencyAmount$3.fromRawAmount(this.outputAmount.currency, 0);
      for (var _iterator4 = _createForOfIteratorHelperLoose$2(this.swaps), _step4; !(_step4 = _iterator4()).done; ) {
        var _step4$value = _step4.value, route = _step4$value.route, inputAmount = _step4$value.inputAmount;
        var midPrice = route.midPrice;
        spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount));
      }
      var priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount);
      this._priceImpact = new Percent$2(priceImpact.numerator, priceImpact.denominator);
      return this._priceImpact;
    }
  }]);
  return Trade2;
}();
var Multicall = /* @__PURE__ */ function() {
  function Multicall2() {
  }
  Multicall2.encodeMulticall = function encodeMulticall(calldatas) {
    if (!Array.isArray(calldatas)) {
      calldatas = [calldatas];
    }
    return calldatas.length === 1 ? calldatas[0] : Multicall2.INTERFACE.encodeFunctionData("multicall", [calldatas]);
  };
  return Multicall2;
}();
Multicall.INTERFACE = /* @__PURE__ */ new Interface(IMulticall.abi);
function isAllowedPermit(permitOptions) {
  return "nonce" in permitOptions;
}
var SelfPermit = /* @__PURE__ */ function() {
  function SelfPermit2() {
  }
  SelfPermit2.encodePermit = function encodePermit(token2, options) {
    return isAllowedPermit(options) ? SelfPermit2.INTERFACE.encodeFunctionData("selfPermitAllowed", [token2.address, toHex$2(options.nonce), toHex$2(options.expiry), options.v, options.r, options.s]) : SelfPermit2.INTERFACE.encodeFunctionData("selfPermit", [token2.address, toHex$2(options.amount), toHex$2(options.deadline), options.v, options.r, options.s]);
  };
  return SelfPermit2;
}();
SelfPermit.INTERFACE = /* @__PURE__ */ new Interface(ISelfPermit.abi);
var Payments = /* @__PURE__ */ function() {
  function Payments2() {
  }
  Payments2.encodeFeeBips = function encodeFeeBips(fee) {
    return toHex$2(fee.multiply(1e4).quotient);
  };
  Payments2.encodeUnwrapWETH9 = function encodeUnwrapWETH9(amountMinimum, recipient, feeOptions) {
    recipient = validateAndParseAddress$2(recipient);
    if (!!feeOptions) {
      var feeBips = this.encodeFeeBips(feeOptions.fee);
      var feeRecipient = validateAndParseAddress$2(feeOptions.recipient);
      return Payments2.INTERFACE.encodeFunctionData("unwrapWETH9WithFee", [toHex$2(amountMinimum), recipient, feeBips, feeRecipient]);
    } else {
      return Payments2.INTERFACE.encodeFunctionData("unwrapWETH9", [toHex$2(amountMinimum), recipient]);
    }
  };
  Payments2.encodeSweepToken = function encodeSweepToken(token2, amountMinimum, recipient, feeOptions) {
    recipient = validateAndParseAddress$2(recipient);
    if (!!feeOptions) {
      var feeBips = this.encodeFeeBips(feeOptions.fee);
      var feeRecipient = validateAndParseAddress$2(feeOptions.recipient);
      return Payments2.INTERFACE.encodeFunctionData("sweepTokenWithFee", [token2.address, toHex$2(amountMinimum), recipient, feeBips, feeRecipient]);
    } else {
      return Payments2.INTERFACE.encodeFunctionData("sweepToken", [token2.address, toHex$2(amountMinimum), recipient]);
    }
  };
  Payments2.encodeRefundETH = function encodeRefundETH() {
    return Payments2.INTERFACE.encodeFunctionData("refundETH");
  };
  return Payments2;
}();
Payments.INTERFACE = /* @__PURE__ */ new Interface(IPeripheryPaymentsWithFee.abi);
var MaxUint128 = /* @__PURE__ */ toHex$2(/* @__PURE__ */ JSBI.subtract(/* @__PURE__ */ JSBI.exponentiate(/* @__PURE__ */ JSBI.BigInt(2), /* @__PURE__ */ JSBI.BigInt(128)), /* @__PURE__ */ JSBI.BigInt(1)));
function isMint(options) {
  return Object.keys(options).some(function(k4) {
    return k4 === "recipient";
  });
}
var NonfungiblePositionManager = /* @__PURE__ */ function() {
  function NonfungiblePositionManager2() {
  }
  NonfungiblePositionManager2.encodeCreate = function encodeCreate(pool) {
    return NonfungiblePositionManager2.INTERFACE.encodeFunctionData("createAndInitializePoolIfNecessary", [pool.token0.address, pool.token1.address, pool.fee, toHex$2(pool.sqrtRatioX96)]);
  };
  NonfungiblePositionManager2.createCallParameters = function createCallParameters(pool) {
    return {
      calldata: this.encodeCreate(pool),
      value: toHex$2(0)
    };
  };
  NonfungiblePositionManager2.addCallParameters = function addCallParameters(position2, options) {
    !JSBI.greaterThan(position2.liquidity, ZERO$4) ? invariant$1(false) : void 0;
    var calldatas = [];
    var _position$mintAmounts = position2.mintAmounts, amount0Desired = _position$mintAmounts.amount0, amount1Desired = _position$mintAmounts.amount1;
    var minimumAmounts = position2.mintAmountsWithSlippage(options.slippageTolerance);
    var amount0Min = toHex$2(minimumAmounts.amount0);
    var amount1Min = toHex$2(minimumAmounts.amount1);
    var deadline = toHex$2(options.deadline);
    if (isMint(options) && options.createPool) {
      calldatas.push(this.encodeCreate(position2.pool));
    }
    if (options.token0Permit) {
      calldatas.push(SelfPermit.encodePermit(position2.pool.token0, options.token0Permit));
    }
    if (options.token1Permit) {
      calldatas.push(SelfPermit.encodePermit(position2.pool.token1, options.token1Permit));
    }
    if (isMint(options)) {
      var recipient = validateAndParseAddress$2(options.recipient);
      calldatas.push(NonfungiblePositionManager2.INTERFACE.encodeFunctionData("mint", [{
        token0: position2.pool.token0.address,
        token1: position2.pool.token1.address,
        fee: position2.pool.fee,
        tickLower: position2.tickLower,
        tickUpper: position2.tickUpper,
        amount0Desired: toHex$2(amount0Desired),
        amount1Desired: toHex$2(amount1Desired),
        amount0Min,
        amount1Min,
        recipient,
        deadline
      }]));
    } else {
      calldatas.push(NonfungiblePositionManager2.INTERFACE.encodeFunctionData("increaseLiquidity", [{
        tokenId: toHex$2(options.tokenId),
        amount0Desired: toHex$2(amount0Desired),
        amount1Desired: toHex$2(amount1Desired),
        amount0Min,
        amount1Min,
        deadline
      }]));
    }
    var value = toHex$2(0);
    if (options.useNative) {
      var wrapped = options.useNative.wrapped;
      !(position2.pool.token0.equals(wrapped) || position2.pool.token1.equals(wrapped)) ? invariant$1(false) : void 0;
      var wrappedValue = position2.pool.token0.equals(wrapped) ? amount0Desired : amount1Desired;
      if (JSBI.greaterThan(wrappedValue, ZERO$4)) {
        calldatas.push(Payments.encodeRefundETH());
      }
      value = toHex$2(wrappedValue);
    }
    return {
      calldata: Multicall.encodeMulticall(calldatas),
      value
    };
  };
  NonfungiblePositionManager2.encodeCollect = function encodeCollect(options) {
    var calldatas = [];
    var tokenId = toHex$2(options.tokenId);
    var involvesETH = options.expectedCurrencyOwed0.currency.isNative || options.expectedCurrencyOwed1.currency.isNative;
    var recipient = validateAndParseAddress$2(options.recipient);
    calldatas.push(NonfungiblePositionManager2.INTERFACE.encodeFunctionData("collect", [{
      tokenId,
      recipient: involvesETH ? ADDRESS_ZERO : recipient,
      amount0Max: MaxUint128,
      amount1Max: MaxUint128
    }]));
    if (involvesETH) {
      var ethAmount = options.expectedCurrencyOwed0.currency.isNative ? options.expectedCurrencyOwed0.quotient : options.expectedCurrencyOwed1.quotient;
      var token2 = options.expectedCurrencyOwed0.currency.isNative ? options.expectedCurrencyOwed1.currency : options.expectedCurrencyOwed0.currency;
      var tokenAmount = options.expectedCurrencyOwed0.currency.isNative ? options.expectedCurrencyOwed1.quotient : options.expectedCurrencyOwed0.quotient;
      calldatas.push(Payments.encodeUnwrapWETH9(ethAmount, recipient));
      calldatas.push(Payments.encodeSweepToken(token2, tokenAmount, recipient));
    }
    return calldatas;
  };
  NonfungiblePositionManager2.collectCallParameters = function collectCallParameters(options) {
    var calldatas = NonfungiblePositionManager2.encodeCollect(options);
    return {
      calldata: Multicall.encodeMulticall(calldatas),
      value: toHex$2(0)
    };
  };
  NonfungiblePositionManager2.removeCallParameters = function removeCallParameters(position2, options) {
    var calldatas = [];
    var deadline = toHex$2(options.deadline);
    var tokenId = toHex$2(options.tokenId);
    var partialPosition = new Position$1({
      pool: position2.pool,
      liquidity: options.liquidityPercentage.multiply(position2.liquidity).quotient,
      tickLower: position2.tickLower,
      tickUpper: position2.tickUpper
    });
    !JSBI.greaterThan(partialPosition.liquidity, ZERO$4) ? invariant$1(false) : void 0;
    var _partialPosition$burn = partialPosition.burnAmountsWithSlippage(options.slippageTolerance), amount0Min = _partialPosition$burn.amount0, amount1Min = _partialPosition$burn.amount1;
    if (options.permit) {
      calldatas.push(NonfungiblePositionManager2.INTERFACE.encodeFunctionData("permit", [validateAndParseAddress$2(options.permit.spender), tokenId, toHex$2(options.permit.deadline), options.permit.v, options.permit.r, options.permit.s]));
    }
    calldatas.push(NonfungiblePositionManager2.INTERFACE.encodeFunctionData("decreaseLiquidity", [{
      tokenId,
      liquidity: toHex$2(partialPosition.liquidity),
      amount0Min: toHex$2(amount0Min),
      amount1Min: toHex$2(amount1Min),
      deadline
    }]));
    var _options$collectOptio = options.collectOptions, expectedCurrencyOwed0 = _options$collectOptio.expectedCurrencyOwed0, expectedCurrencyOwed1 = _options$collectOptio.expectedCurrencyOwed1, rest = _objectWithoutPropertiesLoose(_options$collectOptio, ["expectedCurrencyOwed0", "expectedCurrencyOwed1"]);
    calldatas.push.apply(calldatas, NonfungiblePositionManager2.encodeCollect(_extends$2({
      tokenId: toHex$2(options.tokenId),
      // add the underlying value to the expected currency already owed
      expectedCurrencyOwed0: expectedCurrencyOwed0.add(CurrencyAmount$3.fromRawAmount(expectedCurrencyOwed0.currency, amount0Min)),
      expectedCurrencyOwed1: expectedCurrencyOwed1.add(CurrencyAmount$3.fromRawAmount(expectedCurrencyOwed1.currency, amount1Min))
    }, rest)));
    if (options.liquidityPercentage.equalTo(ONE$4)) {
      if (options.burnToken) {
        calldatas.push(NonfungiblePositionManager2.INTERFACE.encodeFunctionData("burn", [tokenId]));
      }
    } else {
      !(options.burnToken !== true) ? invariant$1(false) : void 0;
    }
    return {
      calldata: Multicall.encodeMulticall(calldatas),
      value: toHex$2(0)
    };
  };
  NonfungiblePositionManager2.safeTransferFromParameters = function safeTransferFromParameters(options) {
    var recipient = validateAndParseAddress$2(options.recipient);
    var sender = validateAndParseAddress$2(options.sender);
    var calldata;
    if (options.data) {
      calldata = NonfungiblePositionManager2.INTERFACE.encodeFunctionData("safeTransferFrom(address,address,uint256,bytes)", [sender, recipient, toHex$2(options.tokenId), options.data]);
    } else {
      calldata = NonfungiblePositionManager2.INTERFACE.encodeFunctionData("safeTransferFrom(address,address,uint256)", [sender, recipient, toHex$2(options.tokenId)]);
    }
    return {
      calldata,
      value: toHex$2(0)
    };
  };
  return NonfungiblePositionManager2;
}();
NonfungiblePositionManager.INTERFACE = /* @__PURE__ */ new Interface(INonfungiblePositionManager.abi);
var SwapQuoter = /* @__PURE__ */ function() {
  function SwapQuoter2() {
  }
  SwapQuoter2.quoteCallParameters = function quoteCallParameters(route, amount, tradeType, options) {
    if (options === void 0) {
      options = {};
    }
    var singleHop = route.pools.length === 1;
    var quoteAmount = toHex$2(amount.quotient);
    var calldata;
    var swapInterface = options.useQuoterV2 ? this.V2INTERFACE : this.V1INTERFACE;
    if (singleHop) {
      var _options$sqrtPriceLim, _options;
      var baseQuoteParams = {
        tokenIn: route.tokenPath[0].address,
        tokenOut: route.tokenPath[1].address,
        fee: route.pools[0].fee,
        sqrtPriceLimitX96: toHex$2((_options$sqrtPriceLim = (_options = options) == null ? void 0 : _options.sqrtPriceLimitX96) != null ? _options$sqrtPriceLim : 0)
      };
      var v2QuoteParams = _extends$2({}, baseQuoteParams, tradeType == TradeType$2.EXACT_INPUT ? {
        amountIn: quoteAmount
      } : {
        amount: quoteAmount
      });
      var v1QuoteParams = [baseQuoteParams.tokenIn, baseQuoteParams.tokenOut, baseQuoteParams.fee, quoteAmount, baseQuoteParams.sqrtPriceLimitX96];
      var tradeTypeFunctionName = tradeType === TradeType$2.EXACT_INPUT ? "quoteExactInputSingle" : "quoteExactOutputSingle";
      calldata = swapInterface.encodeFunctionData(tradeTypeFunctionName, options.useQuoterV2 ? [v2QuoteParams] : v1QuoteParams);
    } else {
      var _options2;
      !(((_options2 = options) == null ? void 0 : _options2.sqrtPriceLimitX96) === void 0) ? invariant$1(false) : void 0;
      var path = encodeRouteToPath(route, tradeType === TradeType$2.EXACT_OUTPUT);
      var _tradeTypeFunctionName = tradeType === TradeType$2.EXACT_INPUT ? "quoteExactInput" : "quoteExactOutput";
      calldata = swapInterface.encodeFunctionData(_tradeTypeFunctionName, [path, quoteAmount]);
    }
    return {
      calldata,
      value: toHex$2(0)
    };
  };
  return SwapQuoter2;
}();
SwapQuoter.V1INTERFACE = /* @__PURE__ */ new Interface(IQuoter.abi);
SwapQuoter.V2INTERFACE = /* @__PURE__ */ new Interface(IQuoterV2.abi);
var Staker = /* @__PURE__ */ function() {
  function Staker2() {
  }
  Staker2.encodeClaim = function encodeClaim(incentiveKey, options) {
    var _options$amount;
    var calldatas = [];
    calldatas.push(Staker2.INTERFACE.encodeFunctionData("unstakeToken", [this._encodeIncentiveKey(incentiveKey), toHex$2(options.tokenId)]));
    var recipient = validateAndParseAddress$2(options.recipient);
    var amount = (_options$amount = options.amount) != null ? _options$amount : 0;
    calldatas.push(Staker2.INTERFACE.encodeFunctionData("claimReward", [incentiveKey.rewardToken.address, recipient, toHex$2(amount)]));
    return calldatas;
  };
  Staker2.collectRewards = function collectRewards(incentiveKeys, options) {
    incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys];
    var calldatas = [];
    for (var i3 = 0; i3 < incentiveKeys.length; i3++) {
      var incentiveKey = incentiveKeys[i3];
      calldatas = calldatas.concat(this.encodeClaim(incentiveKey, options));
      calldatas.push(Staker2.INTERFACE.encodeFunctionData("stakeToken", [this._encodeIncentiveKey(incentiveKey), toHex$2(options.tokenId)]));
    }
    return {
      calldata: Multicall.encodeMulticall(calldatas),
      value: toHex$2(0)
    };
  };
  Staker2.withdrawToken = function withdrawToken(incentiveKeys, withdrawOptions) {
    var calldatas = [];
    incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys];
    var claimOptions = {
      tokenId: withdrawOptions.tokenId,
      recipient: withdrawOptions.recipient,
      amount: withdrawOptions.amount
    };
    for (var i3 = 0; i3 < incentiveKeys.length; i3++) {
      var incentiveKey = incentiveKeys[i3];
      calldatas = calldatas.concat(this.encodeClaim(incentiveKey, claimOptions));
    }
    var owner = validateAndParseAddress$2(withdrawOptions.owner);
    calldatas.push(Staker2.INTERFACE.encodeFunctionData("withdrawToken", [toHex$2(withdrawOptions.tokenId), owner, withdrawOptions.data ? withdrawOptions.data : toHex$2(0)]));
    return {
      calldata: Multicall.encodeMulticall(calldatas),
      value: toHex$2(0)
    };
  };
  Staker2.encodeDeposit = function encodeDeposit(incentiveKeys) {
    incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys];
    var data2;
    if (incentiveKeys.length > 1) {
      var keys = [];
      for (var i3 = 0; i3 < incentiveKeys.length; i3++) {
        var incentiveKey = incentiveKeys[i3];
        keys.push(this._encodeIncentiveKey(incentiveKey));
      }
      data2 = defaultAbiCoder.encode([Staker2.INCENTIVE_KEY_ABI + "[]"], [keys]);
    } else {
      data2 = defaultAbiCoder.encode([Staker2.INCENTIVE_KEY_ABI], [this._encodeIncentiveKey(incentiveKeys[0])]);
    }
    return data2;
  };
  Staker2._encodeIncentiveKey = function _encodeIncentiveKey(incentiveKey) {
    var _incentiveKey$pool = incentiveKey.pool, token0 = _incentiveKey$pool.token0, token1 = _incentiveKey$pool.token1, fee = _incentiveKey$pool.fee;
    var refundee = validateAndParseAddress$2(incentiveKey.refundee);
    return {
      rewardToken: incentiveKey.rewardToken.address,
      pool: Pool.getAddress(token0, token1, fee),
      startTime: toHex$2(incentiveKey.startTime),
      endTime: toHex$2(incentiveKey.endTime),
      refundee
    };
  };
  return Staker2;
}();
Staker.INTERFACE = /* @__PURE__ */ new Interface(IUniswapV3Staker.abi);
Staker.INCENTIVE_KEY_ABI = "tuple(address rewardToken, address pool, uint256 startTime, uint256 endTime, address refundee)";
var SwapRouter = /* @__PURE__ */ function() {
  function SwapRouter2() {
  }
  SwapRouter2.swapCallParameters = function swapCallParameters(trades, options) {
    if (!Array.isArray(trades)) {
      trades = [trades];
    }
    var sampleTrade = trades[0];
    var tokenIn = sampleTrade.inputAmount.currency.wrapped;
    var tokenOut = sampleTrade.outputAmount.currency.wrapped;
    !trades.every(function(trade2) {
      return trade2.inputAmount.currency.wrapped.equals(tokenIn);
    }) ? invariant$1(false) : void 0;
    !trades.every(function(trade2) {
      return trade2.outputAmount.currency.wrapped.equals(tokenOut);
    }) ? invariant$1(false) : void 0;
    var calldatas = [];
    var ZERO_IN = CurrencyAmount$3.fromRawAmount(trades[0].inputAmount.currency, 0);
    var ZERO_OUT = CurrencyAmount$3.fromRawAmount(trades[0].outputAmount.currency, 0);
    var totalAmountOut = trades.reduce(function(sum2, trade2) {
      return sum2.add(trade2.minimumAmountOut(options.slippageTolerance));
    }, ZERO_OUT);
    var mustRefund = sampleTrade.inputAmount.currency.isNative && sampleTrade.tradeType === TradeType$2.EXACT_OUTPUT;
    var inputIsNative = sampleTrade.inputAmount.currency.isNative;
    var outputIsNative = sampleTrade.outputAmount.currency.isNative;
    var routerMustCustody = outputIsNative || !!options.fee;
    var totalValue = inputIsNative ? trades.reduce(function(sum2, trade2) {
      return sum2.add(trade2.maximumAmountIn(options.slippageTolerance));
    }, ZERO_IN) : ZERO_IN;
    if (options.inputTokenPermit) {
      !sampleTrade.inputAmount.currency.isToken ? invariant$1(false) : void 0;
      calldatas.push(SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit));
    }
    var recipient = validateAndParseAddress$2(options.recipient);
    var deadline = toHex$2(options.deadline);
    for (var _iterator = _createForOfIteratorHelperLoose$2(trades), _step; !(_step = _iterator()).done; ) {
      var trade = _step.value;
      for (var _iterator2 = _createForOfIteratorHelperLoose$2(trade.swaps), _step2; !(_step2 = _iterator2()).done; ) {
        var _step2$value = _step2.value, route = _step2$value.route, inputAmount = _step2$value.inputAmount, outputAmount = _step2$value.outputAmount;
        var amountIn = toHex$2(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient);
        var amountOut = toHex$2(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient);
        var singleHop = route.pools.length === 1;
        if (singleHop) {
          if (trade.tradeType === TradeType$2.EXACT_INPUT) {
            var _options$sqrtPriceLim;
            var exactInputSingleParams = {
              tokenIn: route.tokenPath[0].address,
              tokenOut: route.tokenPath[1].address,
              fee: route.pools[0].fee,
              recipient: routerMustCustody ? ADDRESS_ZERO : recipient,
              deadline,
              amountIn,
              amountOutMinimum: amountOut,
              sqrtPriceLimitX96: toHex$2((_options$sqrtPriceLim = options.sqrtPriceLimitX96) != null ? _options$sqrtPriceLim : 0)
            };
            calldatas.push(SwapRouter2.INTERFACE.encodeFunctionData("exactInputSingle", [exactInputSingleParams]));
          } else {
            var _options$sqrtPriceLim2;
            var exactOutputSingleParams = {
              tokenIn: route.tokenPath[0].address,
              tokenOut: route.tokenPath[1].address,
              fee: route.pools[0].fee,
              recipient: routerMustCustody ? ADDRESS_ZERO : recipient,
              deadline,
              amountOut,
              amountInMaximum: amountIn,
              sqrtPriceLimitX96: toHex$2((_options$sqrtPriceLim2 = options.sqrtPriceLimitX96) != null ? _options$sqrtPriceLim2 : 0)
            };
            calldatas.push(SwapRouter2.INTERFACE.encodeFunctionData("exactOutputSingle", [exactOutputSingleParams]));
          }
        } else {
          !(options.sqrtPriceLimitX96 === void 0) ? invariant$1(false) : void 0;
          var path = encodeRouteToPath(route, trade.tradeType === TradeType$2.EXACT_OUTPUT);
          if (trade.tradeType === TradeType$2.EXACT_INPUT) {
            var exactInputParams = {
              path,
              recipient: routerMustCustody ? ADDRESS_ZERO : recipient,
              deadline,
              amountIn,
              amountOutMinimum: amountOut
            };
            calldatas.push(SwapRouter2.INTERFACE.encodeFunctionData("exactInput", [exactInputParams]));
          } else {
            var exactOutputParams = {
              path,
              recipient: routerMustCustody ? ADDRESS_ZERO : recipient,
              deadline,
              amountOut,
              amountInMaximum: amountIn
            };
            calldatas.push(SwapRouter2.INTERFACE.encodeFunctionData("exactOutput", [exactOutputParams]));
          }
        }
      }
    }
    if (routerMustCustody) {
      if (!!options.fee) {
        if (outputIsNative) {
          calldatas.push(Payments.encodeUnwrapWETH9(totalAmountOut.quotient, recipient, options.fee));
        } else {
          calldatas.push(Payments.encodeSweepToken(sampleTrade.outputAmount.currency.wrapped, totalAmountOut.quotient, recipient, options.fee));
        }
      } else {
        calldatas.push(Payments.encodeUnwrapWETH9(totalAmountOut.quotient, recipient));
      }
    }
    if (mustRefund) {
      calldatas.push(Payments.encodeRefundETH());
    }
    return {
      calldata: Multicall.encodeMulticall(calldatas),
      value: toHex$2(totalValue.quotient)
    };
  };
  return SwapRouter2;
}();
SwapRouter.INTERFACE = /* @__PURE__ */ new Interface(ISwapRouter.abi);
const v3Sdk_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ADDRESS_ZERO,
  FACTORY_ADDRESS,
  get FeeAmount() {
    return FeeAmount;
  },
  FullMath,
  LiquidityMath,
  Multicall,
  NoTickDataProvider,
  NonfungiblePositionManager,
  POOL_INIT_CODE_HASH,
  Payments,
  Pool,
  Position: Position$1,
  PositionLibrary,
  Route: Route$2,
  SelfPermit,
  SqrtPriceMath,
  Staker,
  SwapMath,
  SwapQuoter,
  SwapRouter,
  TICK_SPACINGS,
  Tick,
  TickLibrary,
  TickList,
  TickListDataProvider,
  TickMath,
  Trade: Trade$1,
  computePoolAddress,
  encodeRouteToPath,
  encodeSqrtRatioX96,
  isSorted,
  maxLiquidityForAmounts,
  mostSignificantBit,
  nearestUsableTick,
  priceToClosestTick,
  subIn256,
  tickToPrice,
  toHex: toHex$2,
  tradeComparator: tradeComparator$1
}, Symbol.toStringTag, { value: "Module" }));
var ChainId$2;
(function(ChainId2) {
  ChainId2[ChainId2["MAINNET"] = 1] = "MAINNET";
  ChainId2[ChainId2["ROPSTEN"] = 3] = "ROPSTEN";
  ChainId2[ChainId2["RINKEBY"] = 4] = "RINKEBY";
  ChainId2[ChainId2["GRLI"] = 5] = "GRLI";
  ChainId2[ChainId2["KOVAN"] = 42] = "KOVAN";
  ChainId2[ChainId2["OPTIMISM"] = 10] = "OPTIMISM";
  ChainId2[ChainId2["OPTIMISTIC_KOVAN"] = 69] = "OPTIMISTIC_KOVAN";
  ChainId2[ChainId2["ARBITRUM_ONE"] = 42161] = "ARBITRUM_ONE";
  ChainId2[ChainId2["ARBITRUM_RINKEBY"] = 421611] = "ARBITRUM_RINKEBY";
  ChainId2[ChainId2["POLYGON"] = 137] = "POLYGON";
  ChainId2[ChainId2["POLYGON_MUMBAI"] = 80001] = "POLYGON_MUMBAI";
  ChainId2[ChainId2["CELO"] = 42220] = "CELO";
  ChainId2[ChainId2["CELO_ALFAJORES"] = 44787] = "CELO_ALFAJORES";
  ChainId2[ChainId2["GNOSIS"] = 100] = "GNOSIS";
  ChainId2[ChainId2["MOONBEAM"] = 1284] = "MOONBEAM";
})(ChainId$2 || (ChainId$2 = {}));
[
  ChainId$2.MAINNET,
  ChainId$2.RINKEBY,
  ChainId$2.ROPSTEN,
  ChainId$2.KOVAN,
  ChainId$2.OPTIMISM,
  ChainId$2.OPTIMISTIC_KOVAN,
  ChainId$2.ARBITRUM_ONE,
  ChainId$2.ARBITRUM_RINKEBY,
  ChainId$2.POLYGON,
  ChainId$2.POLYGON_MUMBAI,
  ChainId$2.GRLI,
  ChainId$2.CELO_ALFAJORES,
  ChainId$2.CELO
  // Gnosis and Moonbeam don't yet have contracts deployed yet
];
const V2_SUPPORTED = [
  ChainId$2.MAINNET,
  ChainId$2.KOVAN,
  ChainId$2.GRLI,
  ChainId$2.RINKEBY,
  ChainId$2.ROPSTEN
];
const HAS_L1_FEE = [
  ChainId$2.OPTIMISM,
  ChainId$2.OPTIMISTIC_KOVAN,
  ChainId$2.ARBITRUM_ONE,
  ChainId$2.ARBITRUM_RINKEBY
];
const NETWORKS_WITH_SAME_UNISWAP_ADDRESSES = [
  ChainId$2.MAINNET,
  ChainId$2.ROPSTEN,
  ChainId$2.RINKEBY,
  ChainId$2.GRLI,
  ChainId$2.KOVAN,
  ChainId$2.OPTIMISM,
  ChainId$2.OPTIMISTIC_KOVAN,
  ChainId$2.ARBITRUM_ONE,
  ChainId$2.ARBITRUM_RINKEBY,
  ChainId$2.POLYGON,
  ChainId$2.POLYGON_MUMBAI
];
const ID_TO_CHAIN_ID = (id2) => {
  switch (id2) {
    case 1:
      return ChainId$2.MAINNET;
    case 3:
      return ChainId$2.ROPSTEN;
    case 4:
      return ChainId$2.RINKEBY;
    case 5:
      return ChainId$2.GRLI;
    case 42:
      return ChainId$2.KOVAN;
    case 10:
      return ChainId$2.OPTIMISM;
    case 69:
      return ChainId$2.OPTIMISTIC_KOVAN;
    case 42161:
      return ChainId$2.ARBITRUM_ONE;
    case 421611:
      return ChainId$2.ARBITRUM_RINKEBY;
    case 137:
      return ChainId$2.POLYGON;
    case 80001:
      return ChainId$2.POLYGON_MUMBAI;
    case 42220:
      return ChainId$2.CELO;
    case 44787:
      return ChainId$2.CELO_ALFAJORES;
    case 100:
      return ChainId$2.GNOSIS;
    case 1284:
      return ChainId$2.MOONBEAM;
    default:
      throw new Error(`Unknown chain id: ${id2}`);
  }
};
var ChainName;
(function(ChainName2) {
  ChainName2["MAINNET"] = "mainnet";
  ChainName2["ROPSTEN"] = "ropsten";
  ChainName2["RINKEBY"] = "rinkeby";
  ChainName2["GRLI"] = "goerli";
  ChainName2["KOVAN"] = "kovan";
  ChainName2["OPTIMISM"] = "optimism-mainnet";
  ChainName2["OPTIMISTIC_KOVAN"] = "optimism-kovan";
  ChainName2["ARBITRUM_ONE"] = "arbitrum-mainnet";
  ChainName2["ARBITRUM_RINKEBY"] = "arbitrum-rinkeby";
  ChainName2["POLYGON"] = "polygon-mainnet";
  ChainName2["POLYGON_MUMBAI"] = "polygon-mumbai";
  ChainName2["CELO"] = "celo-mainnet";
  ChainName2["CELO_ALFAJORES"] = "celo-alfajores";
  ChainName2["GNOSIS"] = "gnosis-mainnet";
  ChainName2["MOONBEAM"] = "moonbeam-mainnet";
})(ChainName || (ChainName = {}));
var NativeCurrencyName$2;
(function(NativeCurrencyName2) {
  NativeCurrencyName2["ETHER"] = "ETH";
  NativeCurrencyName2["MATIC"] = "MATIC";
  NativeCurrencyName2["CELO"] = "CELO";
  NativeCurrencyName2["GNOSIS"] = "XDAI";
  NativeCurrencyName2["MOONBEAM"] = "GLMR";
})(NativeCurrencyName$2 || (NativeCurrencyName$2 = {}));
({
  [ChainId$2.MAINNET]: [
    "ETH",
    "ETHER",
    "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
  ],
  [ChainId$2.RINKEBY]: [
    "ETH",
    "ETHER",
    "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
  ],
  [ChainId$2.GRLI]: [
    "ETH",
    "ETHER",
    "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
  ],
  [ChainId$2.KOVAN]: [
    "ETH",
    "ETHER",
    "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
  ],
  [ChainId$2.ROPSTEN]: [
    "ETH",
    "ETHER",
    "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
  ],
  [ChainId$2.OPTIMISM]: [
    "ETH",
    "ETHER",
    "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
  ],
  [ChainId$2.OPTIMISTIC_KOVAN]: [
    "ETH",
    "ETHER",
    "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
  ],
  [ChainId$2.ARBITRUM_ONE]: [
    "ETH",
    "ETHER",
    "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
  ],
  [ChainId$2.ARBITRUM_RINKEBY]: [
    "ETH",
    "ETHER",
    "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
  ],
  [ChainId$2.POLYGON]: ["MATIC", "0x0000000000000000000000000000000000001010"],
  [ChainId$2.POLYGON_MUMBAI]: [
    "MATIC",
    "0x0000000000000000000000000000000000001010"
  ],
  [ChainId$2.CELO]: ["CELO"],
  [ChainId$2.CELO_ALFAJORES]: ["CELO"],
  [ChainId$2.GNOSIS]: ["XDAI"],
  [ChainId$2.MOONBEAM]: ["GLMR"]
});
({
  [ChainId$2.MAINNET]: NativeCurrencyName$2.ETHER,
  [ChainId$2.ROPSTEN]: NativeCurrencyName$2.ETHER,
  [ChainId$2.RINKEBY]: NativeCurrencyName$2.ETHER,
  [ChainId$2.GRLI]: NativeCurrencyName$2.ETHER,
  [ChainId$2.KOVAN]: NativeCurrencyName$2.ETHER,
  [ChainId$2.OPTIMISM]: NativeCurrencyName$2.ETHER,
  [ChainId$2.OPTIMISTIC_KOVAN]: NativeCurrencyName$2.ETHER,
  [ChainId$2.ARBITRUM_ONE]: NativeCurrencyName$2.ETHER,
  [ChainId$2.ARBITRUM_RINKEBY]: NativeCurrencyName$2.ETHER,
  [ChainId$2.POLYGON]: NativeCurrencyName$2.MATIC,
  [ChainId$2.POLYGON_MUMBAI]: NativeCurrencyName$2.MATIC,
  [ChainId$2.CELO]: NativeCurrencyName$2.CELO,
  [ChainId$2.CELO_ALFAJORES]: NativeCurrencyName$2.CELO,
  [ChainId$2.GNOSIS]: NativeCurrencyName$2.GNOSIS,
  [ChainId$2.MOONBEAM]: NativeCurrencyName$2.MOONBEAM
});
const ID_TO_NETWORK_NAME = (id2) => {
  switch (id2) {
    case 1:
      return ChainName.MAINNET;
    case 3:
      return ChainName.ROPSTEN;
    case 4:
      return ChainName.RINKEBY;
    case 5:
      return ChainName.GRLI;
    case 42:
      return ChainName.KOVAN;
    case 10:
      return ChainName.OPTIMISM;
    case 69:
      return ChainName.OPTIMISTIC_KOVAN;
    case 42161:
      return ChainName.ARBITRUM_ONE;
    case 421611:
      return ChainName.ARBITRUM_RINKEBY;
    case 137:
      return ChainName.POLYGON;
    case 80001:
      return ChainName.POLYGON_MUMBAI;
    case 42220:
      return ChainName.CELO;
    case 44787:
      return ChainName.CELO_ALFAJORES;
    case 100:
      return ChainName.GNOSIS;
    case 1284:
      return ChainName.MOONBEAM;
    default:
      throw new Error(`Unknown chain id: ${id2}`);
  }
};
Object.values(ChainId$2).map((c2) => c2.toString());
const WRAPPED_NATIVE_CURRENCY = {
  [ChainId$2.MAINNET]: new Token$4(1, "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.ROPSTEN]: new Token$4(3, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.RINKEBY]: new Token$4(4, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.GRLI]: new Token$4(5, "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.KOVAN]: new Token$4(42, "0xd0A1E359811322d97991E03f863a0C30C2cF029C", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.OPTIMISM]: new Token$4(ChainId$2.OPTIMISM, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.OPTIMISTIC_KOVAN]: new Token$4(ChainId$2.OPTIMISTIC_KOVAN, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.ARBITRUM_ONE]: new Token$4(ChainId$2.ARBITRUM_ONE, "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.ARBITRUM_RINKEBY]: new Token$4(ChainId$2.ARBITRUM_RINKEBY, "0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.POLYGON]: new Token$4(ChainId$2.POLYGON, "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270", 18, "WMATIC", "Wrapped MATIC"),
  [ChainId$2.POLYGON_MUMBAI]: new Token$4(ChainId$2.POLYGON_MUMBAI, "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889", 18, "WMATIC", "Wrapped MATIC"),
  // The Celo native currency 'CELO' implements the erc-20 token standard
  [ChainId$2.CELO]: new Token$4(ChainId$2.CELO, "0x471EcE3750Da237f93B8E339c536989b8978a438", 18, "CELO", "Celo native asset"),
  [ChainId$2.CELO_ALFAJORES]: new Token$4(ChainId$2.CELO_ALFAJORES, "0xF194afDf50B03e69Bd7D057c1Aa9e10c9954E4C9", 18, "CELO", "Celo native asset"),
  [ChainId$2.GNOSIS]: new Token$4(ChainId$2.GNOSIS, "0xe91d153e0b41518a2ce8dd3d7944fa863463a97d", 18, "WXDAI", "Wrapped XDAI on Gnosis"),
  [ChainId$2.MOONBEAM]: new Token$4(ChainId$2.MOONBEAM, "0xAcc15dC74880C9944775448304B263D191c6077F", 18, "WGLMR", "Wrapped GLMR")
};
const CELO_V3_CORE_FACTORY_ADDRESSES = "0xAfE208a311B21f13EF87E33A90049fC17A7acDEc";
const CELO_QUOTER_ADDRESSES = "0x82825d0554fA07f7FC52Ab63c961F330fdEFa8E8";
const CELO_MULTICALL_ADDRESS = "0x633987602DE5C4F337e3DbF265303A1080324204";
const V3_CORE_FACTORY_ADDRESSES$1 = {
  ...constructSameAddressMap$2(FACTORY_ADDRESS),
  [ChainId$2.CELO]: CELO_V3_CORE_FACTORY_ADDRESSES,
  [ChainId$2.CELO_ALFAJORES]: CELO_V3_CORE_FACTORY_ADDRESSES
  // TODO: Gnosis + Moonbeam contracts to be deployed
};
const QUOTER_V2_ADDRESSES = {
  ...constructSameAddressMap$2("0x61fFE014bA17989E743c5F6cB21bF9697530B21e"),
  [ChainId$2.CELO]: CELO_QUOTER_ADDRESSES,
  [ChainId$2.CELO_ALFAJORES]: CELO_QUOTER_ADDRESSES
  // TODO: Gnosis + Moonbeam contracts to be deployed
};
const MIXED_ROUTE_QUOTER_V1_ADDRESSES$1 = {
  [ChainId$2.MAINNET]: "0x84E44095eeBfEC7793Cd7d5b57B7e401D7f1cA2E",
  [ChainId$2.RINKEBY]: "0x84E44095eeBfEC7793Cd7d5b57B7e401D7f1cA2E",
  [ChainId$2.ROPSTEN]: "0x84E44095eeBfEC7793Cd7d5b57B7e401D7f1cA2E",
  [ChainId$2.GRLI]: "0xBa60b6e6fF25488308789E6e0A65D838be34194e"
};
const UNISWAP_MULTICALL_ADDRESSES = {
  ...constructSameAddressMap$2("0x1F98415757620B543A52E61c46B32eB19261F984"),
  [ChainId$2.CELO]: CELO_MULTICALL_ADDRESS,
  [ChainId$2.CELO_ALFAJORES]: CELO_MULTICALL_ADDRESS
  // TODO: Gnosis + Moonbeam contracts to be deployed
};
const OVM_GASPRICE_ADDRESS = "0x420000000000000000000000000000000000000F";
const ARB_GASINFO_ADDRESS = "0x000000000000000000000000000000000000006C";
const SWAP_ROUTER_ADDRESS = "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45";
function constructSameAddressMap$2(address, additionalNetworks = []) {
  return NETWORKS_WITH_SAME_UNISWAP_ADDRESSES.concat(additionalNetworks).reduce((memo, chainId2) => {
    memo[chainId2] = address;
    return memo;
  }, {});
}
({
  [ChainId$2.MAINNET]: new Token$4(ChainId$2.MAINNET, "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.ROPSTEN]: new Token$4(ChainId$2.ROPSTEN, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.RINKEBY]: new Token$4(ChainId$2.RINKEBY, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.GRLI]: new Token$4(ChainId$2.GRLI, "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.KOVAN]: new Token$4(ChainId$2.KOVAN, "0xd0A1E359811322d97991E03f863a0C30C2cF029C", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.OPTIMISM]: new Token$4(ChainId$2.OPTIMISM, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.OPTIMISTIC_KOVAN]: new Token$4(ChainId$2.OPTIMISTIC_KOVAN, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.ARBITRUM_ONE]: new Token$4(ChainId$2.ARBITRUM_ONE, "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1", 18, "WETH", "Wrapped Ether"),
  [ChainId$2.ARBITRUM_RINKEBY]: new Token$4(ChainId$2.ARBITRUM_RINKEBY, "0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681", 18, "WETH", "Wrapped Ether")
});
const version$b = "units/5.7.0";
const logger$b = new Logger(version$b);
const names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function formatUnits$1(value, unitName) {
  if (typeof unitName === "string") {
    const index2 = names.indexOf(unitName);
    if (index2 !== -1) {
      unitName = 3 * index2;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger$b.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index2 = names.indexOf(unitName);
    if (index2 !== -1) {
      unitName = 3 * index2;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
let CurrencyAmount$2 = class CurrencyAmount extends CurrencyAmount$4 {
};
function parseFeeAmount(feeAmountStr) {
  switch (feeAmountStr) {
    case "10000":
      return FeeAmount.HIGH;
    case "3000":
      return FeeAmount.MEDIUM;
    case "500":
      return FeeAmount.LOW;
    case "100":
      return FeeAmount.LOWEST;
    default:
      throw new Error(`Fee amount ${feeAmountStr} not supported.`);
  }
}
function unparseFeeAmount(feeAmount) {
  switch (feeAmount) {
    case FeeAmount.HIGH:
      return "10000";
    case FeeAmount.MEDIUM:
      return "3000";
    case FeeAmount.LOW:
      return "500";
    case FeeAmount.LOWEST:
      return "100";
    default:
      throw new Error(`Fee amount ${feeAmount} not supported.`);
  }
}
var dist$1 = { exports: {} };
var routerSdk_cjs_production_min = {};
function _defineProperties$3(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  return Constructor;
}
function _extends$1() {
  _extends$1 = Object.assign || function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _inheritsLoose$3(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var ChainId$1;
(function(ChainId2) {
  ChainId2[ChainId2["MAINNET"] = 1] = "MAINNET";
  ChainId2[ChainId2["GOERLI"] = 5] = "GOERLI";
  ChainId2[ChainId2["SEPOLIA"] = 11155111] = "SEPOLIA";
  ChainId2[ChainId2["OPTIMISM"] = 10] = "OPTIMISM";
  ChainId2[ChainId2["OPTIMISM_GOERLI"] = 420] = "OPTIMISM_GOERLI";
  ChainId2[ChainId2["OPTIMISM_SEPOLIA"] = 11155420] = "OPTIMISM_SEPOLIA";
  ChainId2[ChainId2["ARBITRUM_ONE"] = 42161] = "ARBITRUM_ONE";
  ChainId2[ChainId2["ARBITRUM_GOERLI"] = 421613] = "ARBITRUM_GOERLI";
  ChainId2[ChainId2["POLYGON"] = 137] = "POLYGON";
  ChainId2[ChainId2["POLYGON_MUMBAI"] = 80001] = "POLYGON_MUMBAI";
  ChainId2[ChainId2["CELO"] = 42220] = "CELO";
  ChainId2[ChainId2["CELO_ALFAJORES"] = 44787] = "CELO_ALFAJORES";
  ChainId2[ChainId2["GNOSIS"] = 100] = "GNOSIS";
  ChainId2[ChainId2["MOONBEAM"] = 1284] = "MOONBEAM";
  ChainId2[ChainId2["BNB"] = 56] = "BNB";
  ChainId2[ChainId2["AVALANCHE"] = 43114] = "AVALANCHE";
  ChainId2[ChainId2["BASE_GOERLI"] = 84531] = "BASE_GOERLI";
  ChainId2[ChainId2["BASE"] = 8453] = "BASE";
})(ChainId$1 || (ChainId$1 = {}));
var SUPPORTED_CHAINS = [ChainId$1.MAINNET, ChainId$1.OPTIMISM, ChainId$1.OPTIMISM_GOERLI, ChainId$1.OPTIMISM_SEPOLIA, ChainId$1.ARBITRUM_ONE, ChainId$1.ARBITRUM_GOERLI, ChainId$1.POLYGON, ChainId$1.POLYGON_MUMBAI, ChainId$1.GOERLI, ChainId$1.SEPOLIA, ChainId$1.CELO_ALFAJORES, ChainId$1.CELO, ChainId$1.BNB, ChainId$1.AVALANCHE, ChainId$1.BASE, ChainId$1.BASE_GOERLI];
var NativeCurrencyName$1;
(function(NativeCurrencyName2) {
  NativeCurrencyName2["ETHER"] = "ETH";
  NativeCurrencyName2["MATIC"] = "MATIC";
  NativeCurrencyName2["CELO"] = "CELO";
  NativeCurrencyName2["GNOSIS"] = "XDAI";
  NativeCurrencyName2["MOONBEAM"] = "GLMR";
  NativeCurrencyName2["BNB"] = "BNB";
  NativeCurrencyName2["AVAX"] = "AVAX";
})(NativeCurrencyName$1 || (NativeCurrencyName$1 = {}));
var _CHAIN_TO_ADDRESSES_M$1, _GOVERNANCE_ALPHA_V1_$1, _GOVERNANCE_BRAVO_ADD$1, _MERKLE_DISTRIBUTOR_A$1, _ARGENT_WALLET_DETECT$1, _SOCKS_CONTROLLER_ADD$1;
var DEFAULT_NETWORKS$1 = [ChainId$1.MAINNET, ChainId$1.GOERLI, ChainId$1.SEPOLIA];
function constructSameAddressMap$1(address, additionalNetworks) {
  if (additionalNetworks === void 0) {
    additionalNetworks = [];
  }
  return DEFAULT_NETWORKS$1.concat(additionalNetworks).reduce(function(memo, chainId2) {
    memo[chainId2] = address;
    return memo;
  }, {});
}
var UNI_ADDRESSES = /* @__PURE__ */ constructSameAddressMap$1("0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984", [ChainId$1.OPTIMISM, ChainId$1.ARBITRUM_ONE, ChainId$1.POLYGON, ChainId$1.POLYGON_MUMBAI, ChainId$1.SEPOLIA]);
var UNISWAP_NFT_AIRDROP_CLAIM_ADDRESS = "0x8B799381ac40b838BBA4131ffB26197C432AFe78";
var V2_FACTORY_ADDRESS$1 = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f";
var V2_FACTORY_ADDRESSES = /* @__PURE__ */ constructSameAddressMap$1(V2_FACTORY_ADDRESS$1, [ChainId$1.POLYGON, ChainId$1.OPTIMISM, ChainId$1.CELO, ChainId$1.ARBITRUM_ONE, ChainId$1.BNB, ChainId$1.AVALANCHE, ChainId$1.BASE]);
var V2_ROUTER_ADDRESS = "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D";
var V2_ROUTER_ADDRESSES = /* @__PURE__ */ constructSameAddressMap$1(V2_ROUTER_ADDRESS);
var DEFAULT_ADDRESSES$1 = {
  v3CoreFactoryAddress: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
  multicallAddress: "0x1F98415757620B543A52E61c46B32eB19261F984",
  quoterAddress: "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6",
  v3MigratorAddress: "0xA5644E29708357803b5A882D272c41cC0dF92B34",
  nonfungiblePositionManagerAddress: "0xC36442b4a4522E871399CD717aBDD847Ab11FE88"
};
var MAINNET_ADDRESSES$1 = /* @__PURE__ */ _extends$1({}, DEFAULT_ADDRESSES$1, {
  v1MixedRouteQuoterAddress: "0x84E44095eeBfEC7793Cd7d5b57B7e401D7f1cA2E"
});
var GOERLI_ADDRESSES$1 = /* @__PURE__ */ _extends$1({}, DEFAULT_ADDRESSES$1, {
  v1MixedRouteQuoterAddress: "0xBa60b6e6fF25488308789E6e0A65D838be34194e"
});
var OPTIMISM_ADDRESSES$1 = DEFAULT_ADDRESSES$1;
var ARBITRUM_ONE_ADDRESSES$1 = /* @__PURE__ */ _extends$1({}, DEFAULT_ADDRESSES$1, {
  multicallAddress: "0xadF885960B47eA2CD9B55E6DAc6B42b7Cb2806dB",
  tickLensAddress: "0xbfd8137f7d1516D3ea5cA83523914859ec47F573"
});
var POLYGON_ADDRESSES$1 = DEFAULT_ADDRESSES$1;
var CELO_ADDRESSES$1 = {
  v3CoreFactoryAddress: "0xAfE208a311B21f13EF87E33A90049fC17A7acDEc",
  multicallAddress: "0x633987602DE5C4F337e3DbF265303A1080324204",
  quoterAddress: "0x82825d0554fA07f7FC52Ab63c961F330fdEFa8E8",
  v3MigratorAddress: "0x3cFd4d48EDfDCC53D3f173F596f621064614C582",
  nonfungiblePositionManagerAddress: "0x3d79EdAaBC0EaB6F08ED885C05Fc0B014290D95A",
  tickLensAddress: "0x5f115D9113F88e0a0Db1b5033D90D4a9690AcD3D"
};
var BNB_ADDRESSES$1 = {
  v3CoreFactoryAddress: "0xdB1d10011AD0Ff90774D0C6Bb92e5C5c8b4461F7",
  multicallAddress: "0x963Df249eD09c358A4819E39d9Cd5736c3087184",
  quoterAddress: "0x78D78E420Da98ad378D7799bE8f4AF69033EB077",
  v3MigratorAddress: "0x32681814957e0C13117ddc0c2aba232b5c9e760f",
  nonfungiblePositionManagerAddress: "0x7b8A01B39D58278b5DE7e48c8449c9f4F5170613",
  tickLensAddress: "0xD9270014D396281579760619CCf4c3af0501A47C",
  swapRouter02Address: "0xB971eF87ede563556b2ED4b1C0b0019111Dd85d2"
};
var OPTIMISM_GOERLI_ADDRESSES$1 = {
  v3CoreFactoryAddress: "0xB656dA17129e7EB733A557f4EBc57B76CFbB5d10",
  multicallAddress: "0x07F2D8a2a02251B62af965f22fC4744A5f96BCCd",
  quoterAddress: "0x9569CbA925c8ca2248772A9A4976A516743A246F",
  v3MigratorAddress: "0xf6c55fBe84B1C8c3283533c53F51bC32F5C7Aba8",
  nonfungiblePositionManagerAddress: "0x39Ca85Af2F383190cBf7d7c41ED9202D27426EF6",
  tickLensAddress: "0xe6140Bd164b63E8BfCfc40D5dF952f83e171758e"
};
var OPTIMISM_SEPOLIA_ADDRESSES$1 = {
  v3CoreFactoryAddress: "0x8CE191193D15ea94e11d327b4c7ad8bbE520f6aF",
  multicallAddress: "0x80e4e06841bb76AA9735E0448cB8d003C0EF009a",
  quoterAddress: "0x0FBEa6cf957d95ee9313490050F6A0DA68039404",
  v3MigratorAddress: "0xE7EcbAAaA54D007A00dbb6c1d2f150066D69dA07",
  nonfungiblePositionManagerAddress: "0xdA75cEf1C93078e8b736FCA5D5a30adb97C8957d",
  tickLensAddress: "0xCb7f54747F58F8944973cea5b8f4ac2209BadDC5"
};
var ARBITRUM_GOERLI_ADDRESSES$1 = {
  v3CoreFactoryAddress: "0x4893376342d5D7b3e31d4184c08b265e5aB2A3f6",
  multicallAddress: "0x8260CB40247290317a4c062F3542622367F206Ee",
  quoterAddress: "0x1dd92b83591781D0C6d98d07391eea4b9a6008FA",
  v3MigratorAddress: "0xA815919D2584Ac3F76ea9CB62E6Fd40a43BCe0C3",
  nonfungiblePositionManagerAddress: "0x622e4726a167799826d1E1D150b076A7725f5D81",
  tickLensAddress: "0xb52429333da969a0C79a60930a4Bf0020E5D1DE8"
};
var SEPOLIA_ADDRESSES$1 = {
  v3CoreFactoryAddress: "0x0227628f3F023bb0B980b67D528571c95c6DaC1c",
  multicallAddress: "0xD7F33bCdb21b359c8ee6F0251d30E94832baAd07",
  quoterAddress: "0xEd1f6473345F45b75F8179591dd5bA1888cf2FB3",
  v3MigratorAddress: "0x729004182cF005CEC8Bd85df140094b6aCbe8b15",
  nonfungiblePositionManagerAddress: "0x1238536071E1c677A632429e3655c799b22cDA52",
  tickLensAddress: "0xd7f33bcdb21b359c8ee6f0251d30e94832baad07"
};
var AVALANCHE_ADDRESSES$1 = {
  v3CoreFactoryAddress: "0x740b1c1de25031C31FF4fC9A62f554A55cdC1baD",
  multicallAddress: "0x0139141Cd4Ee88dF3Cdb65881D411bAE271Ef0C2",
  quoterAddress: "0xbe0F5544EC67e9B3b2D979aaA43f18Fd87E6257F",
  v3MigratorAddress: "0x44f5f1f5E452ea8d29C890E8F6e893fC0f1f0f97",
  nonfungiblePositionManagerAddress: "0x655C406EBFa14EE2006250925e54ec43AD184f8B",
  tickLensAddress: "0xEB9fFC8bf81b4fFd11fb6A63a6B0f098c6e21950",
  swapRouter02Address: "0xbb00FF08d01D300023C629E8fFfFcb65A5a578cE"
};
var BASE_ADDRESSES$1 = {
  v3CoreFactoryAddress: "0x33128a8fC17869897dcE68Ed026d694621f6FDfD",
  multicallAddress: "0x091e99cb1C49331a94dD62755D168E941AbD0693",
  quoterAddress: "0x3d4e44Eb1374240CE5F1B871ab261CD16335B76a",
  v3MigratorAddress: "0x23cF10b1ee3AdfCA73B0eF17C07F7577e7ACd2d7",
  nonfungiblePositionManagerAddress: "0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1",
  tickLensAddress: "0x0CdeE061c75D43c82520eD998C23ac2991c9ac6d",
  swapRouter02Address: "0x2626664c2603336E57B271c5C0b26F421741e481"
};
var BASE_GOERLI_ADDRESSES$1 = {
  v3CoreFactoryAddress: "0x9323c1d6D800ed51Bd7C6B216cfBec678B7d0BC2",
  multicallAddress: "0xB206027a9E0E13F05eBEFa5D2402Bab3eA716439",
  quoterAddress: "0xedf539058e28E5937dAef3f69cEd0b25fbE66Ae9",
  v3MigratorAddress: "0x3efe5d02a04b7351D671Db7008ec6eBA9AD9e3aE",
  nonfungiblePositionManagerAddress: "0x3c61369ef0D1D2AFa70d8feC2F31C5D6Ce134F30",
  tickLensAddress: "0x1acB873Ee909D0c98adB18e4474943249F931b92",
  swapRouter02Address: "0x8357227D4eDc78991Db6FDB9bD6ADE250536dE1d"
};
var CHAIN_TO_ADDRESSES_MAP = (_CHAIN_TO_ADDRESSES_M$1 = {}, _CHAIN_TO_ADDRESSES_M$1[ChainId$1.MAINNET] = MAINNET_ADDRESSES$1, _CHAIN_TO_ADDRESSES_M$1[ChainId$1.OPTIMISM] = OPTIMISM_ADDRESSES$1, _CHAIN_TO_ADDRESSES_M$1[ChainId$1.ARBITRUM_ONE] = ARBITRUM_ONE_ADDRESSES$1, _CHAIN_TO_ADDRESSES_M$1[ChainId$1.POLYGON] = POLYGON_ADDRESSES$1, _CHAIN_TO_ADDRESSES_M$1[ChainId$1.POLYGON_MUMBAI] = POLYGON_ADDRESSES$1, _CHAIN_TO_ADDRESSES_M$1[ChainId$1.GOERLI] = GOERLI_ADDRESSES$1, _CHAIN_TO_ADDRESSES_M$1[ChainId$1.CELO] = CELO_ADDRESSES$1, _CHAIN_TO_ADDRESSES_M$1[ChainId$1.CELO_ALFAJORES] = CELO_ADDRESSES$1, _CHAIN_TO_ADDRESSES_M$1[ChainId$1.BNB] = BNB_ADDRESSES$1, _CHAIN_TO_ADDRESSES_M$1[ChainId$1.OPTIMISM_GOERLI] = OPTIMISM_GOERLI_ADDRESSES$1, _CHAIN_TO_ADDRESSES_M$1[ChainId$1.OPTIMISM_SEPOLIA] = OPTIMISM_SEPOLIA_ADDRESSES$1, _CHAIN_TO_ADDRESSES_M$1[ChainId$1.ARBITRUM_GOERLI] = ARBITRUM_GOERLI_ADDRESSES$1, _CHAIN_TO_ADDRESSES_M$1[ChainId$1.SEPOLIA] = SEPOLIA_ADDRESSES$1, _CHAIN_TO_ADDRESSES_M$1[ChainId$1.AVALANCHE] = AVALANCHE_ADDRESSES$1, _CHAIN_TO_ADDRESSES_M$1[ChainId$1.BASE] = BASE_ADDRESSES$1, _CHAIN_TO_ADDRESSES_M$1[ChainId$1.BASE_GOERLI] = BASE_GOERLI_ADDRESSES$1, _CHAIN_TO_ADDRESSES_M$1);
var V3_CORE_FACTORY_ADDRESSES = /* @__PURE__ */ _extends$1({}, /* @__PURE__ */ SUPPORTED_CHAINS.reduce(function(memo, chainId2) {
  memo[chainId2] = CHAIN_TO_ADDRESSES_MAP[chainId2].v3CoreFactoryAddress;
  return memo;
}, {}));
var V3_MIGRATOR_ADDRESSES = /* @__PURE__ */ _extends$1({}, /* @__PURE__ */ SUPPORTED_CHAINS.reduce(function(memo, chainId2) {
  var v3MigratorAddress = CHAIN_TO_ADDRESSES_MAP[chainId2].v3MigratorAddress;
  if (v3MigratorAddress) {
    memo[chainId2] = v3MigratorAddress;
  }
  return memo;
}, {}));
var MULTICALL_ADDRESSES = /* @__PURE__ */ _extends$1({}, /* @__PURE__ */ SUPPORTED_CHAINS.reduce(function(memo, chainId2) {
  memo[chainId2] = CHAIN_TO_ADDRESSES_MAP[chainId2].multicallAddress;
  return memo;
}, {}));
var GOVERNANCE_ALPHA_V0_ADDRESSES = /* @__PURE__ */ constructSameAddressMap$1("0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F");
var GOVERNANCE_ALPHA_V1_ADDRESSES = (_GOVERNANCE_ALPHA_V1_$1 = {}, _GOVERNANCE_ALPHA_V1_$1[ChainId$1.MAINNET] = "0xC4e172459f1E7939D522503B81AFAaC1014CE6F6", _GOVERNANCE_ALPHA_V1_$1);
var GOVERNANCE_BRAVO_ADDRESSES = (_GOVERNANCE_BRAVO_ADD$1 = {}, _GOVERNANCE_BRAVO_ADD$1[ChainId$1.MAINNET] = "0x408ED6354d4973f66138C91495F2f2FCbd8724C3", _GOVERNANCE_BRAVO_ADD$1);
var TIMELOCK_ADDRESSES = /* @__PURE__ */ constructSameAddressMap$1("0x1a9C8182C09F50C8318d769245beA52c32BE35BC");
var MERKLE_DISTRIBUTOR_ADDRESS = (_MERKLE_DISTRIBUTOR_A$1 = {}, _MERKLE_DISTRIBUTOR_A$1[ChainId$1.MAINNET] = "0x090D4613473dEE047c3f2706764f49E0821D256e", _MERKLE_DISTRIBUTOR_A$1);
var ARGENT_WALLET_DETECTOR_ADDRESS = (_ARGENT_WALLET_DETECT$1 = {}, _ARGENT_WALLET_DETECT$1[ChainId$1.MAINNET] = "0xeca4B0bDBf7c55E9b7925919d03CbF8Dc82537E8", _ARGENT_WALLET_DETECT$1);
var QUOTER_ADDRESSES = /* @__PURE__ */ _extends$1({}, /* @__PURE__ */ SUPPORTED_CHAINS.reduce(function(memo, chainId2) {
  memo[chainId2] = CHAIN_TO_ADDRESSES_MAP[chainId2].quoterAddress;
  return memo;
}, {}));
var NONFUNGIBLE_POSITION_MANAGER_ADDRESSES = /* @__PURE__ */ _extends$1({}, /* @__PURE__ */ SUPPORTED_CHAINS.reduce(function(memo, chainId2) {
  var nonfungiblePositionManagerAddress = CHAIN_TO_ADDRESSES_MAP[chainId2].nonfungiblePositionManagerAddress;
  if (nonfungiblePositionManagerAddress) {
    memo[chainId2] = nonfungiblePositionManagerAddress;
  }
  return memo;
}, {}));
var ENS_REGISTRAR_ADDRESSES = /* @__PURE__ */ _extends$1({}, /* @__PURE__ */ constructSameAddressMap$1("0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"));
var SOCKS_CONTROLLER_ADDRESSES = (_SOCKS_CONTROLLER_ADD$1 = {}, _SOCKS_CONTROLLER_ADD$1[ChainId$1.MAINNET] = "0x65770b5283117639760beA3F867b69b3697a91dd", _SOCKS_CONTROLLER_ADD$1);
var TICK_LENS_ADDRESSES = /* @__PURE__ */ _extends$1({}, /* @__PURE__ */ SUPPORTED_CHAINS.reduce(function(memo, chainId2) {
  var tickLensAddress = CHAIN_TO_ADDRESSES_MAP[chainId2].tickLensAddress;
  if (tickLensAddress) {
    memo[chainId2] = tickLensAddress;
  }
  return memo;
}, {}));
var MIXED_ROUTE_QUOTER_V1_ADDRESSES = /* @__PURE__ */ SUPPORTED_CHAINS.reduce(function(memo, chainId2) {
  var v1MixedRouteQuoterAddress = CHAIN_TO_ADDRESSES_MAP[chainId2].v1MixedRouteQuoterAddress;
  if (v1MixedRouteQuoterAddress) {
    memo[chainId2] = v1MixedRouteQuoterAddress;
  }
  return memo;
}, {});
var SWAP_ROUTER_02_ADDRESSES = function SWAP_ROUTER_02_ADDRESSES2(chainId2) {
  if (chainId2 == ChainId$1.BNB) {
    return CHAIN_TO_ADDRESSES_MAP[chainId2].swapRouter02Address;
  }
  return "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45";
};
var TradeType$1;
(function(TradeType2) {
  TradeType2[TradeType2["EXACT_INPUT"] = 0] = "EXACT_INPUT";
  TradeType2[TradeType2["EXACT_OUTPUT"] = 1] = "EXACT_OUTPUT";
})(TradeType$1 || (TradeType$1 = {}));
var Rounding$1;
(function(Rounding2) {
  Rounding2[Rounding2["ROUND_DOWN"] = 0] = "ROUND_DOWN";
  Rounding2[Rounding2["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
  Rounding2[Rounding2["ROUND_UP"] = 2] = "ROUND_UP";
})(Rounding$1 || (Rounding$1 = {}));
var MaxUint256$1 = /* @__PURE__ */ JSBI.BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var _toSignificantRoundin$1, _toFixedRounding$1;
var Decimal$1 = /* @__PURE__ */ toFormat(_Decimal);
var Big$2 = /* @__PURE__ */ toFormat(Big$5);
var toSignificantRounding$1 = (_toSignificantRoundin$1 = {}, _toSignificantRoundin$1[Rounding$1.ROUND_DOWN] = Decimal$1.ROUND_DOWN, _toSignificantRoundin$1[Rounding$1.ROUND_HALF_UP] = Decimal$1.ROUND_HALF_UP, _toSignificantRoundin$1[Rounding$1.ROUND_UP] = Decimal$1.ROUND_UP, _toSignificantRoundin$1);
var toFixedRounding$1 = (_toFixedRounding$1 = {}, _toFixedRounding$1[Rounding$1.ROUND_DOWN] = 0, _toFixedRounding$1[Rounding$1.ROUND_HALF_UP] = 1, _toFixedRounding$1[Rounding$1.ROUND_UP] = 3, _toFixedRounding$1);
var Fraction$1 = /* @__PURE__ */ function() {
  function Fraction2(numerator, denominator) {
    if (denominator === void 0) {
      denominator = JSBI.BigInt(1);
    }
    this.numerator = JSBI.BigInt(numerator);
    this.denominator = JSBI.BigInt(denominator);
  }
  Fraction2.tryParseFraction = function tryParseFraction(fractionish) {
    if (fractionish instanceof JSBI || typeof fractionish === "number" || typeof fractionish === "string")
      return new Fraction2(fractionish);
    if ("numerator" in fractionish && "denominator" in fractionish)
      return fractionish;
    throw new Error("Could not parse fraction");
  };
  var _proto = Fraction2.prototype;
  _proto.invert = function invert() {
    return new Fraction2(this.denominator, this.numerator);
  };
  _proto.add = function add4(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    if (JSBI.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction2(JSBI.add(this.numerator, otherParsed.numerator), this.denominator);
    }
    return new Fraction2(JSBI.add(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.subtract = function subtract2(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    if (JSBI.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction2(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator);
    }
    return new Fraction2(JSBI.subtract(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.lessThan = function lessThan(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return JSBI.lessThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.equalTo = function equalTo(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return JSBI.equal(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.greaterThan = function greaterThan(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return JSBI.greaterThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.multiply = function multiply(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return new Fraction2(JSBI.multiply(this.numerator, otherParsed.numerator), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.divide = function divide2(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return new Fraction2(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(this.denominator, otherParsed.numerator));
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    if (rounding === void 0) {
      rounding = Rounding$1.ROUND_HALF_UP;
    }
    !Number.isInteger(significantDigits) ? invariant$1(false) : void 0;
    !(significantDigits > 0) ? invariant$1(false) : void 0;
    Decimal$1.set({
      precision: significantDigits + 1,
      rounding: toSignificantRounding$1[rounding]
    });
    var quotient = new Decimal$1(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
    return quotient.toFormat(quotient.decimalPlaces(), format);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    if (rounding === void 0) {
      rounding = Rounding$1.ROUND_HALF_UP;
    }
    !Number.isInteger(decimalPlaces) ? invariant$1(false) : void 0;
    !(decimalPlaces >= 0) ? invariant$1(false) : void 0;
    Big$2.DP = decimalPlaces;
    Big$2.RM = toFixedRounding$1[rounding];
    return new Big$2(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
  };
  _createClass$3(Fraction2, [{
    key: "quotient",
    get: function get2() {
      return JSBI.divide(this.numerator, this.denominator);
    }
    // remainder after floor division
  }, {
    key: "remainder",
    get: function get2() {
      return new Fraction2(JSBI.remainder(this.numerator, this.denominator), this.denominator);
    }
  }, {
    key: "asFraction",
    get: function get2() {
      return new Fraction2(this.numerator, this.denominator);
    }
  }]);
  return Fraction2;
}();
var Big$1$1 = /* @__PURE__ */ toFormat(Big$5);
var CurrencyAmount$1 = /* @__PURE__ */ function(_Fraction) {
  _inheritsLoose$3(CurrencyAmount22, _Fraction);
  function CurrencyAmount22(currency, numerator, denominator) {
    var _this;
    _this = _Fraction.call(this, numerator, denominator) || this;
    !JSBI.lessThanOrEqual(_this.quotient, MaxUint256$1) ? invariant$1(false) : void 0;
    _this.currency = currency;
    _this.decimalScale = JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(currency.decimals));
    return _this;
  }
  CurrencyAmount22.fromRawAmount = function fromRawAmount(currency, rawAmount) {
    return new CurrencyAmount22(currency, rawAmount);
  };
  CurrencyAmount22.fromFractionalAmount = function fromFractionalAmount(currency, numerator, denominator) {
    return new CurrencyAmount22(currency, numerator, denominator);
  };
  var _proto = CurrencyAmount22.prototype;
  _proto.add = function add4(other) {
    !this.currency.equals(other.currency) ? invariant$1(false) : void 0;
    var added = _Fraction.prototype.add.call(this, other);
    return CurrencyAmount22.fromFractionalAmount(this.currency, added.numerator, added.denominator);
  };
  _proto.subtract = function subtract2(other) {
    !this.currency.equals(other.currency) ? invariant$1(false) : void 0;
    var subtracted = _Fraction.prototype.subtract.call(this, other);
    return CurrencyAmount22.fromFractionalAmount(this.currency, subtracted.numerator, subtracted.denominator);
  };
  _proto.multiply = function multiply(other) {
    var multiplied = _Fraction.prototype.multiply.call(this, other);
    return CurrencyAmount22.fromFractionalAmount(this.currency, multiplied.numerator, multiplied.denominator);
  };
  _proto.divide = function divide2(other) {
    var divided = _Fraction.prototype.divide.call(this, other);
    return CurrencyAmount22.fromFractionalAmount(this.currency, divided.numerator, divided.denominator);
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 6;
    }
    if (rounding === void 0) {
      rounding = Rounding$1.ROUND_DOWN;
    }
    return _Fraction.prototype.divide.call(this, this.decimalScale).toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = this.currency.decimals;
    }
    if (rounding === void 0) {
      rounding = Rounding$1.ROUND_DOWN;
    }
    !(decimalPlaces <= this.currency.decimals) ? invariant$1(false) : void 0;
    return _Fraction.prototype.divide.call(this, this.decimalScale).toFixed(decimalPlaces, format, rounding);
  };
  _proto.toExact = function toExact(format) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    Big$1$1.DP = this.currency.decimals;
    return new Big$1$1(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(format);
  };
  _createClass$3(CurrencyAmount22, [{
    key: "wrapped",
    get: function get2() {
      if (this.currency.isToken)
        return this;
      return CurrencyAmount22.fromFractionalAmount(this.currency.wrapped, this.numerator, this.denominator);
    }
  }]);
  return CurrencyAmount22;
}(Fraction$1);
var ONE_HUNDRED$1 = /* @__PURE__ */ new Fraction$1(/* @__PURE__ */ JSBI.BigInt(100));
function toPercent$1(fraction) {
  return new Percent$1(fraction.numerator, fraction.denominator);
}
var Percent$1 = /* @__PURE__ */ function(_Fraction) {
  _inheritsLoose$3(Percent2, _Fraction);
  function Percent2() {
    var _this;
    _this = _Fraction.apply(this, arguments) || this;
    _this.isPercent = true;
    return _this;
  }
  var _proto = Percent2.prototype;
  _proto.add = function add4(other) {
    return toPercent$1(_Fraction.prototype.add.call(this, other));
  };
  _proto.subtract = function subtract2(other) {
    return toPercent$1(_Fraction.prototype.subtract.call(this, other));
  };
  _proto.multiply = function multiply(other) {
    return toPercent$1(_Fraction.prototype.multiply.call(this, other));
  };
  _proto.divide = function divide2(other) {
    return toPercent$1(_Fraction.prototype.divide.call(this, other));
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 5;
    }
    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED$1).toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = 2;
    }
    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED$1).toFixed(decimalPlaces, format, rounding);
  };
  return Percent2;
}(Fraction$1);
var Price$1 = /* @__PURE__ */ function(_Fraction) {
  _inheritsLoose$3(Price2, _Fraction);
  function Price2() {
    var _this;
    var baseCurrency, quoteCurrency, denominator, numerator;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 4) {
      baseCurrency = args[0];
      quoteCurrency = args[1];
      denominator = args[2];
      numerator = args[3];
    } else {
      var result = args[0].quoteAmount.divide(args[0].baseAmount);
      var _ref = [args[0].baseAmount.currency, args[0].quoteAmount.currency, result.denominator, result.numerator];
      baseCurrency = _ref[0];
      quoteCurrency = _ref[1];
      denominator = _ref[2];
      numerator = _ref[3];
    }
    _this = _Fraction.call(this, numerator, denominator) || this;
    _this.baseCurrency = baseCurrency;
    _this.quoteCurrency = quoteCurrency;
    _this.scalar = new Fraction$1(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(baseCurrency.decimals)), JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(quoteCurrency.decimals)));
    return _this;
  }
  var _proto = Price2.prototype;
  _proto.invert = function invert() {
    return new Price2(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);
  };
  _proto.multiply = function multiply(other) {
    !this.quoteCurrency.equals(other.baseCurrency) ? invariant$1(false) : void 0;
    var fraction = _Fraction.prototype.multiply.call(this, other);
    return new Price2(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);
  };
  _proto.quote = function quote(currencyAmount) {
    !currencyAmount.currency.equals(this.baseCurrency) ? invariant$1(false) : void 0;
    var result = _Fraction.prototype.multiply.call(this, currencyAmount);
    return CurrencyAmount$1.fromFractionalAmount(this.quoteCurrency, result.numerator, result.denominator);
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 6;
    }
    return this.adjustedForDecimals.toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = 4;
    }
    return this.adjustedForDecimals.toFixed(decimalPlaces, format, rounding);
  };
  _createClass$3(Price2, [{
    key: "adjustedForDecimals",
    get: function get2() {
      return _Fraction.prototype.multiply.call(this, this.scalar);
    }
  }]);
  return Price2;
}(Fraction$1);
var BaseCurrency$1 = (
  /**
   * Constructs an instance of the base class `BaseCurrency`.
   * @param chainId the chain ID on which this currency resides
   * @param decimals decimals of the currency
   * @param symbol symbol of the currency
   * @param name of the currency
   */
  function BaseCurrency23(chainId2, decimals, symbol, name2) {
    !Number.isSafeInteger(chainId2) ? invariant$1(false) : void 0;
    !(decimals >= 0 && decimals < 255 && Number.isInteger(decimals)) ? invariant$1(false) : void 0;
    this.chainId = chainId2;
    this.decimals = decimals;
    this.symbol = symbol;
    this.name = name2;
  }
);
var NativeCurrency = /* @__PURE__ */ function(_BaseCurrency) {
  _inheritsLoose$3(NativeCurrency2, _BaseCurrency);
  function NativeCurrency2() {
    var _this;
    _this = _BaseCurrency.apply(this, arguments) || this;
    _this.isNative = true;
    _this.isToken = false;
    return _this;
  }
  return NativeCurrency2;
}(BaseCurrency$1);
function validateAndParseAddress$1(address) {
  try {
    return getAddress$1(address);
  } catch (error) {
    throw new Error(address + " is not a valid address.");
  }
}
var startsWith0xLen42HexRegex$1 = /^0x[0-9a-fA-F]{40}$/;
function checkValidAddress$1(address) {
  if (startsWith0xLen42HexRegex$1.test(address)) {
    return address;
  }
  throw new Error(address + " is not a valid address.");
}
var Token$2 = /* @__PURE__ */ function(_BaseCurrency) {
  _inheritsLoose$3(Token2, _BaseCurrency);
  function Token2(chainId2, address, decimals, symbol, name2, bypassChecksum, buyFeeBps, sellFeeBps) {
    var _this;
    _this = _BaseCurrency.call(this, chainId2, decimals, symbol, name2) || this;
    _this.isNative = false;
    _this.isToken = true;
    if (bypassChecksum) {
      _this.address = checkValidAddress$1(address);
    } else {
      _this.address = validateAndParseAddress$1(address);
    }
    if (buyFeeBps) {
      !buyFeeBps.gte(BigNumber.from(0)) ? invariant$1(false) : void 0;
    }
    if (sellFeeBps) {
      !sellFeeBps.gte(BigNumber.from(0)) ? invariant$1(false) : void 0;
    }
    _this.buyFeeBps = buyFeeBps;
    _this.sellFeeBps = sellFeeBps;
    return _this;
  }
  var _proto = Token2.prototype;
  _proto.equals = function equals(other) {
    return other.isToken && this.chainId === other.chainId && this.address.toLowerCase() === other.address.toLowerCase();
  };
  _proto.sortsBefore = function sortsBefore(other) {
    !(this.chainId === other.chainId) ? invariant$1(false) : void 0;
    !(this.address.toLowerCase() !== other.address.toLowerCase()) ? invariant$1(false) : void 0;
    return this.address.toLowerCase() < other.address.toLowerCase();
  };
  _createClass$3(Token2, [{
    key: "wrapped",
    get: function get2() {
      return this;
    }
  }]);
  return Token2;
}(BaseCurrency$1);
var _WETH$1;
var WETH9 = (_WETH$1 = {}, _WETH$1[1] = /* @__PURE__ */ new Token$2(1, "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", 18, "WETH", "Wrapped Ether"), _WETH$1[3] = /* @__PURE__ */ new Token$2(3, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"), _WETH$1[4] = /* @__PURE__ */ new Token$2(4, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"), _WETH$1[5] = /* @__PURE__ */ new Token$2(5, "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6", 18, "WETH", "Wrapped Ether"), _WETH$1[42] = /* @__PURE__ */ new Token$2(42, "0xd0A1E359811322d97991E03f863a0C30C2cF029C", 18, "WETH", "Wrapped Ether"), _WETH$1[10] = /* @__PURE__ */ new Token$2(10, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH$1[69] = /* @__PURE__ */ new Token$2(69, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH$1[11155420] = /* @__PURE__ */ new Token$2(11155420, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH$1[42161] = /* @__PURE__ */ new Token$2(42161, "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1", 18, "WETH", "Wrapped Ether"), _WETH$1[421611] = /* @__PURE__ */ new Token$2(421611, "0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681", 18, "WETH", "Wrapped Ether"), _WETH$1[8453] = /* @__PURE__ */ new Token$2(8453, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH$1[56] = /* @__PURE__ */ new Token$2(56, "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", 18, "WBNB", "Wrapped BNB"), _WETH$1[137] = /* @__PURE__ */ new Token$2(137, "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270", 18, "WMATIC", "Wrapped MATIC"), _WETH$1[43114] = /* @__PURE__ */ new Token$2(43114, "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7", 18, "WAVAX", "Wrapped AVAX"), _WETH$1);
var Ether = /* @__PURE__ */ function(_NativeCurrency) {
  _inheritsLoose$3(Ether2, _NativeCurrency);
  function Ether2(chainId2) {
    return _NativeCurrency.call(this, chainId2, 18, "ETH", "Ether") || this;
  }
  Ether2.onChain = function onChain(chainId2) {
    var _this$_etherCache$cha;
    return (_this$_etherCache$cha = this._etherCache[chainId2]) != null ? _this$_etherCache$cha : this._etherCache[chainId2] = new Ether2(chainId2);
  };
  var _proto = Ether2.prototype;
  _proto.equals = function equals(other) {
    return other.isNative && other.chainId === this.chainId;
  };
  _createClass$3(Ether2, [{
    key: "wrapped",
    get: function get2() {
      var weth9 = WETH9[this.chainId];
      !!!weth9 ? invariant$1(false) : void 0;
      return weth9;
    }
  }]);
  return Ether2;
}(NativeCurrency);
Ether._etherCache = {};
function computePriceImpact(midPrice, inputAmount, outputAmount) {
  var quotedOutputAmount = midPrice.quote(inputAmount);
  var priceImpact = quotedOutputAmount.subtract(outputAmount).divide(quotedOutputAmount);
  return new Percent$1(priceImpact.numerator, priceImpact.denominator);
}
function sortedInsert(items, add4, maxSize, comparator) {
  !(maxSize > 0) ? invariant$1(false) : void 0;
  !(items.length <= maxSize) ? invariant$1(false) : void 0;
  if (items.length === 0) {
    items.push(add4);
    return null;
  } else {
    var isFull = items.length === maxSize;
    if (isFull && comparator(items[items.length - 1], add4) <= 0) {
      return add4;
    }
    var lo = 0, hi2 = items.length;
    while (lo < hi2) {
      var mid = lo + hi2 >>> 1;
      if (comparator(items[mid], add4) <= 0) {
        lo = mid + 1;
      } else {
        hi2 = mid;
      }
    }
    items.splice(lo, 0, add4);
    return isFull ? items.pop() : null;
  }
}
var MAX_SAFE_INTEGER$1 = /* @__PURE__ */ JSBI.BigInt(Number.MAX_SAFE_INTEGER);
var ZERO$3 = /* @__PURE__ */ JSBI.BigInt(0);
var ONE$3 = /* @__PURE__ */ JSBI.BigInt(1);
var TWO$1 = /* @__PURE__ */ JSBI.BigInt(2);
function sqrt$1(value) {
  !JSBI.greaterThanOrEqual(value, ZERO$3) ? invariant$1(false) : void 0;
  if (JSBI.lessThan(value, MAX_SAFE_INTEGER$1)) {
    return JSBI.BigInt(Math.floor(Math.sqrt(JSBI.toNumber(value))));
  }
  var z2;
  var x2;
  z2 = value;
  x2 = JSBI.add(JSBI.divide(value, TWO$1), ONE$3);
  while (JSBI.lessThan(x2, z2)) {
    z2 = x2;
    x2 = JSBI.divide(JSBI.add(JSBI.divide(value, x2), x2), TWO$1);
  }
  return z2;
}
const sdkCore_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ARGENT_WALLET_DETECTOR_ADDRESS,
  CHAIN_TO_ADDRESSES_MAP,
  get ChainId() {
    return ChainId$1;
  },
  CurrencyAmount: CurrencyAmount$1,
  ENS_REGISTRAR_ADDRESSES,
  Ether,
  Fraction: Fraction$1,
  GOVERNANCE_ALPHA_V0_ADDRESSES,
  GOVERNANCE_ALPHA_V1_ADDRESSES,
  GOVERNANCE_BRAVO_ADDRESSES,
  MERKLE_DISTRIBUTOR_ADDRESS,
  MIXED_ROUTE_QUOTER_V1_ADDRESSES,
  MULTICALL_ADDRESSES,
  MaxUint256: MaxUint256$1,
  NONFUNGIBLE_POSITION_MANAGER_ADDRESSES,
  NativeCurrency,
  get NativeCurrencyName() {
    return NativeCurrencyName$1;
  },
  Percent: Percent$1,
  Price: Price$1,
  QUOTER_ADDRESSES,
  get Rounding() {
    return Rounding$1;
  },
  SOCKS_CONTROLLER_ADDRESSES,
  SUPPORTED_CHAINS,
  SWAP_ROUTER_02_ADDRESSES,
  TICK_LENS_ADDRESSES,
  TIMELOCK_ADDRESSES,
  Token: Token$2,
  get TradeType() {
    return TradeType$1;
  },
  UNISWAP_NFT_AIRDROP_CLAIM_ADDRESS,
  UNI_ADDRESSES,
  V2_FACTORY_ADDRESS: V2_FACTORY_ADDRESS$1,
  V2_FACTORY_ADDRESSES,
  V2_ROUTER_ADDRESS,
  V2_ROUTER_ADDRESSES,
  V3_CORE_FACTORY_ADDRESSES,
  V3_MIGRATOR_ADDRESSES,
  WETH9,
  computePriceImpact,
  sortedInsert,
  sqrt: sqrt$1,
  validateAndParseAddress: validateAndParseAddress$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(sdkCore_esm);
var jsbiUmd = { exports: {} };
(function(module, exports) {
  (function(i3, _2) {
    _2(exports);
  })(commonjsGlobal, function(i3) {
    var _2 = Math.clz32, t2 = Math.abs, e2 = Math.max, g2 = Math.floor;
    class o2 extends Array {
      constructor(i4, _3) {
        if (super(i4), this.sign = _3, i4 > o2.__kMaxLength)
          throw new RangeError("Maximum BigInt size exceeded");
      }
      static BigInt(i4) {
        var _3 = Number.isFinite;
        if ("number" == typeof i4) {
          if (0 === i4)
            return o2.__zero();
          if (o2.__isOneDigitInt(i4))
            return 0 > i4 ? o2.__oneDigit(-i4, true) : o2.__oneDigit(i4, false);
          if (!_3(i4) || g2(i4) !== i4)
            throw new RangeError("The number " + i4 + " cannot be converted to BigInt because it is not an integer");
          return o2.__fromDouble(i4);
        }
        if ("string" == typeof i4) {
          const _4 = o2.__fromString(i4);
          if (null === _4)
            throw new SyntaxError("Cannot convert " + i4 + " to a BigInt");
          return _4;
        }
        if ("boolean" == typeof i4)
          return true === i4 ? o2.__oneDigit(1, false) : o2.__zero();
        if ("object" == typeof i4) {
          if (i4.constructor === o2)
            return i4;
          const _4 = o2.__toPrimitive(i4);
          return o2.BigInt(_4);
        }
        throw new TypeError("Cannot convert " + i4 + " to a BigInt");
      }
      toDebugString() {
        const i4 = ["BigInt["];
        for (const _3 of this)
          i4.push((_3 ? (_3 >>> 0).toString(16) : _3) + ", ");
        return i4.push("]"), i4.join("");
      }
      toString(i4 = 10) {
        if (2 > i4 || 36 < i4)
          throw new RangeError("toString() radix argument must be between 2 and 36");
        return 0 === this.length ? "0" : 0 == (i4 & i4 - 1) ? o2.__toStringBasePowerOfTwo(this, i4) : o2.__toStringGeneric(this, i4, false);
      }
      static toNumber(i4) {
        const _3 = i4.length;
        if (0 === _3)
          return 0;
        if (1 === _3) {
          const _4 = i4.__unsignedDigit(0);
          return i4.sign ? -_4 : _4;
        }
        const t3 = i4.__digit(_3 - 1), e3 = o2.__clz30(t3), n4 = 30 * _3 - e3;
        if (1024 < n4)
          return i4.sign ? -Infinity : 1 / 0;
        let g3 = n4 - 1, s4 = t3, l2 = _3 - 1;
        const r2 = e3 + 3;
        let a2 = 32 === r2 ? 0 : s4 << r2;
        a2 >>>= 12;
        const u2 = r2 - 12;
        let d2 = 12 <= r2 ? 0 : s4 << 20 + r2, h4 = 20 + r2;
        for (0 < u2 && 0 < l2 && (l2--, s4 = i4.__digit(l2), a2 |= s4 >>> 30 - u2, d2 = s4 << u2 + 2, h4 = u2 + 2); 0 < h4 && 0 < l2; )
          l2--, s4 = i4.__digit(l2), d2 |= 30 <= h4 ? s4 << h4 - 30 : s4 >>> 30 - h4, h4 -= 30;
        const m2 = o2.__decideRounding(i4, h4, l2, s4);
        if ((1 === m2 || 0 === m2 && 1 == (1 & d2)) && (d2 = d2 + 1 >>> 0, 0 === d2 && (a2++, 0 != a2 >>> 20 && (a2 = 0, g3++, 1023 < g3))))
          return i4.sign ? -Infinity : 1 / 0;
        const b3 = i4.sign ? -2147483648 : 0;
        return g3 = g3 + 1023 << 20, o2.__kBitConversionInts[1] = b3 | g3 | a2, o2.__kBitConversionInts[0] = d2, o2.__kBitConversionDouble[0];
      }
      static unaryMinus(i4) {
        if (0 === i4.length)
          return i4;
        const _3 = i4.__copy();
        return _3.sign = !i4.sign, _3;
      }
      static bitwiseNot(i4) {
        return i4.sign ? o2.__absoluteSubOne(i4).__trim() : o2.__absoluteAddOne(i4, true);
      }
      static exponentiate(i4, _3) {
        if (_3.sign)
          throw new RangeError("Exponent must be positive");
        if (0 === _3.length)
          return o2.__oneDigit(1, false);
        if (0 === i4.length)
          return i4;
        if (1 === i4.length && 1 === i4.__digit(0))
          return i4.sign && 0 == (1 & _3.__digit(0)) ? o2.unaryMinus(i4) : i4;
        if (1 < _3.length)
          throw new RangeError("BigInt too big");
        let t3 = _3.__unsignedDigit(0);
        if (1 === t3)
          return i4;
        if (t3 >= o2.__kMaxLengthBits)
          throw new RangeError("BigInt too big");
        if (1 === i4.length && 2 === i4.__digit(0)) {
          const _4 = 1 + (0 | t3 / 30), e4 = i4.sign && 0 != (1 & t3), n5 = new o2(_4, e4);
          n5.__initializeDigits();
          const g3 = 1 << t3 % 30;
          return n5.__setDigit(_4 - 1, g3), n5;
        }
        let e3 = null, n4 = i4;
        for (0 != (1 & t3) && (e3 = i4), t3 >>= 1; 0 !== t3; t3 >>= 1)
          n4 = o2.multiply(n4, n4), 0 != (1 & t3) && (null === e3 ? e3 = n4 : e3 = o2.multiply(e3, n4));
        return e3;
      }
      static multiply(_3, t3) {
        if (0 === _3.length)
          return _3;
        if (0 === t3.length)
          return t3;
        let i4 = _3.length + t3.length;
        30 <= _3.__clzmsd() + t3.__clzmsd() && i4--;
        const e3 = new o2(i4, _3.sign !== t3.sign);
        e3.__initializeDigits();
        for (let n4 = 0; n4 < _3.length; n4++)
          o2.__multiplyAccumulate(t3, _3.__digit(n4), e3, n4);
        return e3.__trim();
      }
      static divide(i4, _3) {
        if (0 === _3.length)
          throw new RangeError("Division by zero");
        if (0 > o2.__absoluteCompare(i4, _3))
          return o2.__zero();
        const t3 = i4.sign !== _3.sign, e3 = _3.__unsignedDigit(0);
        let n4;
        if (1 === _3.length && 32767 >= e3) {
          if (1 === e3)
            return t3 === i4.sign ? i4 : o2.unaryMinus(i4);
          n4 = o2.__absoluteDivSmall(i4, e3, null);
        } else
          n4 = o2.__absoluteDivLarge(i4, _3, true, false);
        return n4.sign = t3, n4.__trim();
      }
      static remainder(i4, _3) {
        if (0 === _3.length)
          throw new RangeError("Division by zero");
        if (0 > o2.__absoluteCompare(i4, _3))
          return i4;
        const t3 = _3.__unsignedDigit(0);
        if (1 === _3.length && 32767 >= t3) {
          if (1 === t3)
            return o2.__zero();
          const _4 = o2.__absoluteModSmall(i4, t3);
          return 0 === _4 ? o2.__zero() : o2.__oneDigit(_4, i4.sign);
        }
        const e3 = o2.__absoluteDivLarge(i4, _3, false, true);
        return e3.sign = i4.sign, e3.__trim();
      }
      static add(i4, _3) {
        const t3 = i4.sign;
        return t3 === _3.sign ? o2.__absoluteAdd(i4, _3, t3) : 0 <= o2.__absoluteCompare(i4, _3) ? o2.__absoluteSub(i4, _3, t3) : o2.__absoluteSub(_3, i4, !t3);
      }
      static subtract(i4, _3) {
        const t3 = i4.sign;
        return t3 === _3.sign ? 0 <= o2.__absoluteCompare(i4, _3) ? o2.__absoluteSub(i4, _3, t3) : o2.__absoluteSub(_3, i4, !t3) : o2.__absoluteAdd(i4, _3, t3);
      }
      static leftShift(i4, _3) {
        return 0 === _3.length || 0 === i4.length ? i4 : _3.sign ? o2.__rightShiftByAbsolute(i4, _3) : o2.__leftShiftByAbsolute(i4, _3);
      }
      static signedRightShift(i4, _3) {
        return 0 === _3.length || 0 === i4.length ? i4 : _3.sign ? o2.__leftShiftByAbsolute(i4, _3) : o2.__rightShiftByAbsolute(i4, _3);
      }
      static unsignedRightShift() {
        throw new TypeError("BigInts have no unsigned right shift; use >> instead");
      }
      static lessThan(i4, _3) {
        return 0 > o2.__compareToBigInt(i4, _3);
      }
      static lessThanOrEqual(i4, _3) {
        return 0 >= o2.__compareToBigInt(i4, _3);
      }
      static greaterThan(i4, _3) {
        return 0 < o2.__compareToBigInt(i4, _3);
      }
      static greaterThanOrEqual(i4, _3) {
        return 0 <= o2.__compareToBigInt(i4, _3);
      }
      static equal(_3, t3) {
        if (_3.sign !== t3.sign)
          return false;
        if (_3.length !== t3.length)
          return false;
        for (let e3 = 0; e3 < _3.length; e3++)
          if (_3.__digit(e3) !== t3.__digit(e3))
            return false;
        return true;
      }
      static notEqual(i4, _3) {
        return !o2.equal(i4, _3);
      }
      static bitwiseAnd(i4, _3) {
        if (!i4.sign && !_3.sign)
          return o2.__absoluteAnd(i4, _3).__trim();
        if (i4.sign && _3.sign) {
          const t3 = e2(i4.length, _3.length) + 1;
          let n4 = o2.__absoluteSubOne(i4, t3);
          const g3 = o2.__absoluteSubOne(_3);
          return n4 = o2.__absoluteOr(n4, g3, n4), o2.__absoluteAddOne(n4, true, n4).__trim();
        }
        return i4.sign && ([i4, _3] = [_3, i4]), o2.__absoluteAndNot(i4, o2.__absoluteSubOne(_3)).__trim();
      }
      static bitwiseXor(i4, _3) {
        if (!i4.sign && !_3.sign)
          return o2.__absoluteXor(i4, _3).__trim();
        if (i4.sign && _3.sign) {
          const t4 = e2(i4.length, _3.length), n5 = o2.__absoluteSubOne(i4, t4), g3 = o2.__absoluteSubOne(_3);
          return o2.__absoluteXor(n5, g3, n5).__trim();
        }
        const t3 = e2(i4.length, _3.length) + 1;
        i4.sign && ([i4, _3] = [_3, i4]);
        let n4 = o2.__absoluteSubOne(_3, t3);
        return n4 = o2.__absoluteXor(n4, i4, n4), o2.__absoluteAddOne(n4, true, n4).__trim();
      }
      static bitwiseOr(i4, _3) {
        const t3 = e2(i4.length, _3.length);
        if (!i4.sign && !_3.sign)
          return o2.__absoluteOr(i4, _3).__trim();
        if (i4.sign && _3.sign) {
          let e3 = o2.__absoluteSubOne(i4, t3);
          const n5 = o2.__absoluteSubOne(_3);
          return e3 = o2.__absoluteAnd(e3, n5, e3), o2.__absoluteAddOne(e3, true, e3).__trim();
        }
        i4.sign && ([i4, _3] = [_3, i4]);
        let n4 = o2.__absoluteSubOne(_3, t3);
        return n4 = o2.__absoluteAndNot(n4, i4, n4), o2.__absoluteAddOne(n4, true, n4).__trim();
      }
      static asIntN(_3, t3) {
        if (0 === t3.length)
          return t3;
        if (_3 = g2(_3), 0 > _3)
          throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (0 === _3)
          return o2.__zero();
        if (_3 >= o2.__kMaxLengthBits)
          return t3;
        const e3 = 0 | (_3 + 29) / 30;
        if (t3.length < e3)
          return t3;
        const s4 = t3.__unsignedDigit(e3 - 1), l2 = 1 << (_3 - 1) % 30;
        if (t3.length === e3 && s4 < l2)
          return t3;
        if (!((s4 & l2) === l2))
          return o2.__truncateToNBits(_3, t3);
        if (!t3.sign)
          return o2.__truncateAndSubFromPowerOfTwo(_3, t3, true);
        if (0 == (s4 & l2 - 1)) {
          for (let n4 = e3 - 2; 0 <= n4; n4--)
            if (0 !== t3.__digit(n4))
              return o2.__truncateAndSubFromPowerOfTwo(_3, t3, false);
          return t3.length === e3 && s4 === l2 ? t3 : o2.__truncateToNBits(_3, t3);
        }
        return o2.__truncateAndSubFromPowerOfTwo(_3, t3, false);
      }
      static asUintN(i4, _3) {
        if (0 === _3.length)
          return _3;
        if (i4 = g2(i4), 0 > i4)
          throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (0 === i4)
          return o2.__zero();
        if (_3.sign) {
          if (i4 > o2.__kMaxLengthBits)
            throw new RangeError("BigInt too big");
          return o2.__truncateAndSubFromPowerOfTwo(i4, _3, false);
        }
        if (i4 >= o2.__kMaxLengthBits)
          return _3;
        const t3 = 0 | (i4 + 29) / 30;
        if (_3.length < t3)
          return _3;
        const e3 = i4 % 30;
        if (_3.length == t3) {
          if (0 === e3)
            return _3;
          const i5 = _3.__digit(t3 - 1);
          if (0 == i5 >>> e3)
            return _3;
        }
        return o2.__truncateToNBits(i4, _3);
      }
      static ADD(i4, _3) {
        if (i4 = o2.__toPrimitive(i4), _3 = o2.__toPrimitive(_3), "string" == typeof i4)
          return "string" != typeof _3 && (_3 = _3.toString()), i4 + _3;
        if ("string" == typeof _3)
          return i4.toString() + _3;
        if (i4 = o2.__toNumeric(i4), _3 = o2.__toNumeric(_3), o2.__isBigInt(i4) && o2.__isBigInt(_3))
          return o2.add(i4, _3);
        if ("number" == typeof i4 && "number" == typeof _3)
          return i4 + _3;
        throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
      }
      static LT(i4, _3) {
        return o2.__compare(i4, _3, 0);
      }
      static LE(i4, _3) {
        return o2.__compare(i4, _3, 1);
      }
      static GT(i4, _3) {
        return o2.__compare(i4, _3, 2);
      }
      static GE(i4, _3) {
        return o2.__compare(i4, _3, 3);
      }
      static EQ(i4, _3) {
        for (; ; ) {
          if (o2.__isBigInt(i4))
            return o2.__isBigInt(_3) ? o2.equal(i4, _3) : o2.EQ(_3, i4);
          if ("number" == typeof i4) {
            if (o2.__isBigInt(_3))
              return o2.__equalToNumber(_3, i4);
            if ("object" != typeof _3)
              return i4 == _3;
            _3 = o2.__toPrimitive(_3);
          } else if ("string" == typeof i4) {
            if (o2.__isBigInt(_3))
              return i4 = o2.__fromString(i4), null !== i4 && o2.equal(i4, _3);
            if ("object" != typeof _3)
              return i4 == _3;
            _3 = o2.__toPrimitive(_3);
          } else if ("boolean" == typeof i4) {
            if (o2.__isBigInt(_3))
              return o2.__equalToNumber(_3, +i4);
            if ("object" != typeof _3)
              return i4 == _3;
            _3 = o2.__toPrimitive(_3);
          } else if ("symbol" == typeof i4) {
            if (o2.__isBigInt(_3))
              return false;
            if ("object" != typeof _3)
              return i4 == _3;
            _3 = o2.__toPrimitive(_3);
          } else if ("object" == typeof i4) {
            if ("object" == typeof _3 && _3.constructor !== o2)
              return i4 == _3;
            i4 = o2.__toPrimitive(i4);
          } else
            return i4 == _3;
        }
      }
      static NE(i4, _3) {
        return !o2.EQ(i4, _3);
      }
      static __zero() {
        return new o2(0, false);
      }
      static __oneDigit(i4, _3) {
        const t3 = new o2(1, _3);
        return t3.__setDigit(0, i4), t3;
      }
      __copy() {
        const _3 = new o2(this.length, this.sign);
        for (let t3 = 0; t3 < this.length; t3++)
          _3[t3] = this[t3];
        return _3;
      }
      __trim() {
        let i4 = this.length, _3 = this[i4 - 1];
        for (; 0 === _3; )
          i4--, _3 = this[i4 - 1], this.pop();
        return 0 === i4 && (this.sign = false), this;
      }
      __initializeDigits() {
        for (let _3 = 0; _3 < this.length; _3++)
          this[_3] = 0;
      }
      static __decideRounding(i4, _3, t3, e3) {
        if (0 < _3)
          return -1;
        let n4;
        if (0 > _3)
          n4 = -_3 - 1;
        else {
          if (0 === t3)
            return -1;
          t3--, e3 = i4.__digit(t3), n4 = 29;
        }
        let g3 = 1 << n4;
        if (0 == (e3 & g3))
          return -1;
        if (g3 -= 1, 0 != (e3 & g3))
          return 1;
        for (; 0 < t3; )
          if (t3--, 0 !== i4.__digit(t3))
            return 1;
        return 0;
      }
      static __fromDouble(i4) {
        o2.__kBitConversionDouble[0] = i4;
        const _3 = 2047 & o2.__kBitConversionInts[1] >>> 20, t3 = _3 - 1023, e3 = (0 | t3 / 30) + 1, n4 = new o2(e3, 0 > i4);
        let g3 = 1048575 & o2.__kBitConversionInts[1] | 1048576, s4 = o2.__kBitConversionInts[0];
        const l2 = 20, r2 = t3 % 30;
        let a2, u2 = 0;
        if (r2 < 20) {
          const i5 = l2 - r2;
          u2 = i5 + 32, a2 = g3 >>> i5, g3 = g3 << 32 - i5 | s4 >>> i5, s4 <<= 32 - i5;
        } else if (r2 === 20)
          u2 = 32, a2 = g3, g3 = s4, s4 = 0;
        else {
          const i5 = r2 - l2;
          u2 = 32 - i5, a2 = g3 << i5 | s4 >>> 32 - i5, g3 = s4 << i5, s4 = 0;
        }
        n4.__setDigit(e3 - 1, a2);
        for (let _4 = e3 - 2; 0 <= _4; _4--)
          0 < u2 ? (u2 -= 30, a2 = g3 >>> 2, g3 = g3 << 30 | s4 >>> 2, s4 <<= 30) : a2 = 0, n4.__setDigit(_4, a2);
        return n4.__trim();
      }
      static __isWhitespace(i4) {
        return !!(13 >= i4 && 9 <= i4) || (159 >= i4 ? 32 == i4 : 131071 >= i4 ? 160 == i4 || 5760 == i4 : 196607 >= i4 ? (i4 &= 131071, 10 >= i4 || 40 == i4 || 41 == i4 || 47 == i4 || 95 == i4 || 4096 == i4) : 65279 == i4);
      }
      static __fromString(i4, _3 = 0) {
        let t3 = 0;
        const e3 = i4.length;
        let n4 = 0;
        if (n4 === e3)
          return o2.__zero();
        let g3 = i4.charCodeAt(n4);
        for (; o2.__isWhitespace(g3); ) {
          if (++n4 === e3)
            return o2.__zero();
          g3 = i4.charCodeAt(n4);
        }
        if (43 === g3) {
          if (++n4 === e3)
            return null;
          g3 = i4.charCodeAt(n4), t3 = 1;
        } else if (45 === g3) {
          if (++n4 === e3)
            return null;
          g3 = i4.charCodeAt(n4), t3 = -1;
        }
        if (0 === _3) {
          if (_3 = 10, 48 === g3) {
            if (++n4 === e3)
              return o2.__zero();
            if (g3 = i4.charCodeAt(n4), 88 === g3 || 120 === g3) {
              if (_3 = 16, ++n4 === e3)
                return null;
              g3 = i4.charCodeAt(n4);
            } else if (79 === g3 || 111 === g3) {
              if (_3 = 8, ++n4 === e3)
                return null;
              g3 = i4.charCodeAt(n4);
            } else if (66 === g3 || 98 === g3) {
              if (_3 = 2, ++n4 === e3)
                return null;
              g3 = i4.charCodeAt(n4);
            }
          }
        } else if (16 === _3 && 48 === g3) {
          if (++n4 === e3)
            return o2.__zero();
          if (g3 = i4.charCodeAt(n4), 88 === g3 || 120 === g3) {
            if (++n4 === e3)
              return null;
            g3 = i4.charCodeAt(n4);
          }
        }
        if (0 != t3 && 10 !== _3)
          return null;
        for (; 48 === g3; ) {
          if (++n4 === e3)
            return o2.__zero();
          g3 = i4.charCodeAt(n4);
        }
        const s4 = e3 - n4;
        let l2 = o2.__kMaxBitsPerChar[_3], r2 = o2.__kBitsPerCharTableMultiplier - 1;
        if (s4 > 1073741824 / l2)
          return null;
        const a2 = l2 * s4 + r2 >>> o2.__kBitsPerCharTableShift, u2 = new o2(0 | (a2 + 29) / 30, false), h4 = 10 > _3 ? _3 : 10, b3 = 10 < _3 ? _3 - 10 : 0;
        if (0 == (_3 & _3 - 1)) {
          l2 >>= o2.__kBitsPerCharTableShift;
          const _4 = [], t4 = [];
          let s5 = false;
          do {
            let o3 = 0, r3 = 0;
            for (; ; ) {
              let _5;
              if (g3 - 48 >>> 0 < h4)
                _5 = g3 - 48;
              else if ((32 | g3) - 97 >>> 0 < b3)
                _5 = (32 | g3) - 87;
              else {
                s5 = true;
                break;
              }
              if (r3 += l2, o3 = o3 << l2 | _5, ++n4 === e3) {
                s5 = true;
                break;
              }
              if (g3 = i4.charCodeAt(n4), 30 < r3 + l2)
                break;
            }
            _4.push(o3), t4.push(r3);
          } while (!s5);
          o2.__fillFromParts(u2, _4, t4);
        } else {
          u2.__initializeDigits();
          let t4 = false, s5 = 0;
          do {
            let a3 = 0, D2 = 1;
            for (; ; ) {
              let o3;
              if (g3 - 48 >>> 0 < h4)
                o3 = g3 - 48;
              else if ((32 | g3) - 97 >>> 0 < b3)
                o3 = (32 | g3) - 87;
              else {
                t4 = true;
                break;
              }
              const l3 = D2 * _3;
              if (1073741823 < l3)
                break;
              if (D2 = l3, a3 = a3 * _3 + o3, s5++, ++n4 === e3) {
                t4 = true;
                break;
              }
              g3 = i4.charCodeAt(n4);
            }
            r2 = 30 * o2.__kBitsPerCharTableMultiplier - 1;
            const c2 = 0 | (l2 * s5 + r2 >>> o2.__kBitsPerCharTableShift) / 30;
            u2.__inplaceMultiplyAdd(D2, a3, c2);
          } while (!t4);
        }
        if (n4 !== e3) {
          if (!o2.__isWhitespace(g3))
            return null;
          for (n4++; n4 < e3; n4++)
            if (g3 = i4.charCodeAt(n4), !o2.__isWhitespace(g3))
              return null;
        }
        return u2.sign = -1 == t3, u2.__trim();
      }
      static __fillFromParts(_3, t3, e3) {
        let n4 = 0, g3 = 0, o3 = 0;
        for (let s4 = t3.length - 1; 0 <= s4; s4--) {
          const i4 = t3[s4], l2 = e3[s4];
          g3 |= i4 << o3, o3 += l2, 30 === o3 ? (_3.__setDigit(n4++, g3), o3 = 0, g3 = 0) : 30 < o3 && (_3.__setDigit(n4++, 1073741823 & g3), o3 -= 30, g3 = i4 >>> l2 - o3);
        }
        if (0 !== g3) {
          if (n4 >= _3.length)
            throw new Error("implementation bug");
          _3.__setDigit(n4++, g3);
        }
        for (; n4 < _3.length; n4++)
          _3.__setDigit(n4, 0);
      }
      static __toStringBasePowerOfTwo(_3, i4) {
        const t3 = _3.length;
        let e3 = i4 - 1;
        e3 = (85 & e3 >>> 1) + (85 & e3), e3 = (51 & e3 >>> 2) + (51 & e3), e3 = (15 & e3 >>> 4) + (15 & e3);
        const n4 = e3, g3 = i4 - 1, s4 = _3.__digit(t3 - 1), l2 = o2.__clz30(s4);
        let r2 = 0 | (30 * t3 - l2 + n4 - 1) / n4;
        if (_3.sign && r2++, 268435456 < r2)
          throw new Error("string too long");
        const a2 = Array(r2);
        let u2 = r2 - 1, d2 = 0, h4 = 0;
        for (let e4 = 0; e4 < t3 - 1; e4++) {
          const i5 = _3.__digit(e4), t4 = (d2 | i5 << h4) & g3;
          a2[u2--] = o2.__kConversionChars[t4];
          const s5 = n4 - h4;
          for (d2 = i5 >>> s5, h4 = 30 - s5; h4 >= n4; )
            a2[u2--] = o2.__kConversionChars[d2 & g3], d2 >>>= n4, h4 -= n4;
        }
        const m2 = (d2 | s4 << h4) & g3;
        for (a2[u2--] = o2.__kConversionChars[m2], d2 = s4 >>> n4 - h4; 0 !== d2; )
          a2[u2--] = o2.__kConversionChars[d2 & g3], d2 >>>= n4;
        if (_3.sign && (a2[u2--] = "-"), -1 != u2)
          throw new Error("implementation bug");
        return a2.join("");
      }
      static __toStringGeneric(_3, i4, t3) {
        const e3 = _3.length;
        if (0 === e3)
          return "";
        if (1 === e3) {
          let e4 = _3.__unsignedDigit(0).toString(i4);
          return false === t3 && _3.sign && (e4 = "-" + e4), e4;
        }
        const n4 = 30 * e3 - o2.__clz30(_3.__digit(e3 - 1)), g3 = o2.__kMaxBitsPerChar[i4], s4 = g3 - 1;
        let l2 = n4 * o2.__kBitsPerCharTableMultiplier;
        l2 += s4 - 1, l2 = 0 | l2 / s4;
        const r2 = l2 + 1 >> 1, a2 = o2.exponentiate(o2.__oneDigit(i4, false), o2.__oneDigit(r2, false));
        let u2, d2;
        const h4 = a2.__unsignedDigit(0);
        if (1 === a2.length && 32767 >= h4) {
          u2 = new o2(_3.length, false), u2.__initializeDigits();
          let t4 = 0;
          for (let e4 = 2 * _3.length - 1; 0 <= e4; e4--) {
            const i5 = t4 << 15 | _3.__halfDigit(e4);
            u2.__setHalfDigit(e4, 0 | i5 / h4), t4 = 0 | i5 % h4;
          }
          d2 = t4.toString(i4);
        } else {
          const t4 = o2.__absoluteDivLarge(_3, a2, true, true);
          u2 = t4.quotient;
          const e4 = t4.remainder.__trim();
          d2 = o2.__toStringGeneric(e4, i4, true);
        }
        u2.__trim();
        let m2 = o2.__toStringGeneric(u2, i4, true);
        for (; d2.length < r2; )
          d2 = "0" + d2;
        return false === t3 && _3.sign && (m2 = "-" + m2), m2 + d2;
      }
      static __unequalSign(i4) {
        return i4 ? -1 : 1;
      }
      static __absoluteGreater(i4) {
        return i4 ? -1 : 1;
      }
      static __absoluteLess(i4) {
        return i4 ? 1 : -1;
      }
      static __compareToBigInt(i4, _3) {
        const t3 = i4.sign;
        if (t3 !== _3.sign)
          return o2.__unequalSign(t3);
        const e3 = o2.__absoluteCompare(i4, _3);
        return 0 < e3 ? o2.__absoluteGreater(t3) : 0 > e3 ? o2.__absoluteLess(t3) : 0;
      }
      static __compareToNumber(i4, _3) {
        if (o2.__isOneDigitInt(_3)) {
          const e3 = i4.sign, n4 = 0 > _3;
          if (e3 !== n4)
            return o2.__unequalSign(e3);
          if (0 === i4.length) {
            if (n4)
              throw new Error("implementation bug");
            return 0 === _3 ? 0 : -1;
          }
          if (1 < i4.length)
            return o2.__absoluteGreater(e3);
          const g3 = t2(_3), s4 = i4.__unsignedDigit(0);
          return s4 > g3 ? o2.__absoluteGreater(e3) : s4 < g3 ? o2.__absoluteLess(e3) : 0;
        }
        return o2.__compareToDouble(i4, _3);
      }
      static __compareToDouble(i4, _3) {
        if (_3 !== _3)
          return _3;
        if (_3 === 1 / 0)
          return -1;
        if (_3 === -Infinity)
          return 1;
        const t3 = i4.sign;
        if (t3 !== 0 > _3)
          return o2.__unequalSign(t3);
        if (0 === _3)
          throw new Error("implementation bug: should be handled elsewhere");
        if (0 === i4.length)
          return -1;
        o2.__kBitConversionDouble[0] = _3;
        const e3 = 2047 & o2.__kBitConversionInts[1] >>> 20;
        if (2047 == e3)
          throw new Error("implementation bug: handled elsewhere");
        const n4 = e3 - 1023;
        if (0 > n4)
          return o2.__absoluteGreater(t3);
        const g3 = i4.length;
        let s4 = i4.__digit(g3 - 1);
        const l2 = o2.__clz30(s4), r2 = 30 * g3 - l2, a2 = n4 + 1;
        if (r2 < a2)
          return o2.__absoluteLess(t3);
        if (r2 > a2)
          return o2.__absoluteGreater(t3);
        let u2 = 1048576 | 1048575 & o2.__kBitConversionInts[1], d2 = o2.__kBitConversionInts[0];
        const h4 = 20, m2 = 29 - l2;
        if (m2 !== (0 | (r2 - 1) % 30))
          throw new Error("implementation bug");
        let b3, D2 = 0;
        if (20 > m2) {
          const i5 = h4 - m2;
          D2 = i5 + 32, b3 = u2 >>> i5, u2 = u2 << 32 - i5 | d2 >>> i5, d2 <<= 32 - i5;
        } else if (20 === m2)
          D2 = 32, b3 = u2, u2 = d2;
        else {
          const i5 = m2 - h4;
          D2 = 32 - i5, b3 = u2 << i5 | d2 >>> 32 - i5, u2 = d2 << i5;
        }
        if (s4 >>>= 0, b3 >>>= 0, s4 > b3)
          return o2.__absoluteGreater(t3);
        if (s4 < b3)
          return o2.__absoluteLess(t3);
        for (let e4 = g3 - 2; 0 <= e4; e4--) {
          0 < D2 ? (D2 -= 30, b3 = u2 >>> 2, u2 = u2 << 30 | d2 >>> 2, d2 <<= 30) : b3 = 0;
          const _4 = i4.__unsignedDigit(e4);
          if (_4 > b3)
            return o2.__absoluteGreater(t3);
          if (_4 < b3)
            return o2.__absoluteLess(t3);
        }
        if (0 !== u2 || 0 !== d2) {
          if (0 === D2)
            throw new Error("implementation bug");
          return o2.__absoluteLess(t3);
        }
        return 0;
      }
      static __equalToNumber(i4, _3) {
        return o2.__isOneDigitInt(_3) ? 0 === _3 ? 0 === i4.length : 1 === i4.length && i4.sign === 0 > _3 && i4.__unsignedDigit(0) === t2(_3) : 0 === o2.__compareToDouble(i4, _3);
      }
      static __comparisonResultToBool(i4, _3) {
        return 0 === _3 ? 0 > i4 : 1 === _3 ? 0 >= i4 : 2 === _3 ? 0 < i4 : 3 === _3 ? 0 <= i4 : void 0;
      }
      static __compare(i4, _3, t3) {
        if (i4 = o2.__toPrimitive(i4), _3 = o2.__toPrimitive(_3), "string" == typeof i4 && "string" == typeof _3)
          switch (t3) {
            case 0:
              return i4 < _3;
            case 1:
              return i4 <= _3;
            case 2:
              return i4 > _3;
            case 3:
              return i4 >= _3;
          }
        if (o2.__isBigInt(i4) && "string" == typeof _3)
          return _3 = o2.__fromString(_3), null !== _3 && o2.__comparisonResultToBool(o2.__compareToBigInt(i4, _3), t3);
        if ("string" == typeof i4 && o2.__isBigInt(_3))
          return i4 = o2.__fromString(i4), null !== i4 && o2.__comparisonResultToBool(o2.__compareToBigInt(i4, _3), t3);
        if (i4 = o2.__toNumeric(i4), _3 = o2.__toNumeric(_3), o2.__isBigInt(i4)) {
          if (o2.__isBigInt(_3))
            return o2.__comparisonResultToBool(o2.__compareToBigInt(i4, _3), t3);
          if ("number" != typeof _3)
            throw new Error("implementation bug");
          return o2.__comparisonResultToBool(o2.__compareToNumber(i4, _3), t3);
        }
        if ("number" != typeof i4)
          throw new Error("implementation bug");
        if (o2.__isBigInt(_3))
          return o2.__comparisonResultToBool(o2.__compareToNumber(_3, i4), 2 ^ t3);
        if ("number" != typeof _3)
          throw new Error("implementation bug");
        return 0 === t3 ? i4 < _3 : 1 === t3 ? i4 <= _3 : 2 === t3 ? i4 > _3 : 3 === t3 ? i4 >= _3 : void 0;
      }
      __clzmsd() {
        return o2.__clz30(this.__digit(this.length - 1));
      }
      static __absoluteAdd(_3, t3, e3) {
        if (_3.length < t3.length)
          return o2.__absoluteAdd(t3, _3, e3);
        if (0 === _3.length)
          return _3;
        if (0 === t3.length)
          return _3.sign === e3 ? _3 : o2.unaryMinus(_3);
        let n4 = _3.length;
        (0 === _3.__clzmsd() || t3.length === _3.length && 0 === t3.__clzmsd()) && n4++;
        const g3 = new o2(n4, e3);
        let s4 = 0, l2 = 0;
        for (; l2 < t3.length; l2++) {
          const i4 = _3.__digit(l2) + t3.__digit(l2) + s4;
          s4 = i4 >>> 30, g3.__setDigit(l2, 1073741823 & i4);
        }
        for (; l2 < _3.length; l2++) {
          const i4 = _3.__digit(l2) + s4;
          s4 = i4 >>> 30, g3.__setDigit(l2, 1073741823 & i4);
        }
        return l2 < g3.length && g3.__setDigit(l2, s4), g3.__trim();
      }
      static __absoluteSub(_3, t3, e3) {
        if (0 === _3.length)
          return _3;
        if (0 === t3.length)
          return _3.sign === e3 ? _3 : o2.unaryMinus(_3);
        const n4 = new o2(_3.length, e3);
        let g3 = 0, s4 = 0;
        for (; s4 < t3.length; s4++) {
          const i4 = _3.__digit(s4) - t3.__digit(s4) - g3;
          g3 = 1 & i4 >>> 30, n4.__setDigit(s4, 1073741823 & i4);
        }
        for (; s4 < _3.length; s4++) {
          const i4 = _3.__digit(s4) - g3;
          g3 = 1 & i4 >>> 30, n4.__setDigit(s4, 1073741823 & i4);
        }
        return n4.__trim();
      }
      static __absoluteAddOne(_3, i4, t3 = null) {
        const e3 = _3.length;
        null === t3 ? t3 = new o2(e3, i4) : t3.sign = i4;
        let n4 = 1;
        for (let g3 = 0; g3 < e3; g3++) {
          const i5 = _3.__digit(g3) + n4;
          n4 = i5 >>> 30, t3.__setDigit(g3, 1073741823 & i5);
        }
        return 0 != n4 && t3.__setDigitGrow(e3, 1), t3;
      }
      static __absoluteSubOne(_3, t3) {
        const e3 = _3.length;
        t3 = t3 || e3;
        const n4 = new o2(t3, false);
        let g3 = 1;
        for (let o3 = 0; o3 < e3; o3++) {
          const i4 = _3.__digit(o3) - g3;
          g3 = 1 & i4 >>> 30, n4.__setDigit(o3, 1073741823 & i4);
        }
        if (0 != g3)
          throw new Error("implementation bug");
        for (let g4 = e3; g4 < t3; g4++)
          n4.__setDigit(g4, 0);
        return n4;
      }
      static __absoluteAnd(_3, t3, e3 = null) {
        let n4 = _3.length, g3 = t3.length, s4 = g3;
        if (n4 < g3) {
          s4 = n4;
          const i4 = _3, e4 = n4;
          _3 = t3, n4 = g3, t3 = i4, g3 = e4;
        }
        let l2 = s4;
        null === e3 ? e3 = new o2(l2, false) : l2 = e3.length;
        let r2 = 0;
        for (; r2 < s4; r2++)
          e3.__setDigit(r2, _3.__digit(r2) & t3.__digit(r2));
        for (; r2 < l2; r2++)
          e3.__setDigit(r2, 0);
        return e3;
      }
      static __absoluteAndNot(_3, t3, e3 = null) {
        const n4 = _3.length, g3 = t3.length;
        let s4 = g3;
        n4 < g3 && (s4 = n4);
        let l2 = n4;
        null === e3 ? e3 = new o2(l2, false) : l2 = e3.length;
        let r2 = 0;
        for (; r2 < s4; r2++)
          e3.__setDigit(r2, _3.__digit(r2) & ~t3.__digit(r2));
        for (; r2 < n4; r2++)
          e3.__setDigit(r2, _3.__digit(r2));
        for (; r2 < l2; r2++)
          e3.__setDigit(r2, 0);
        return e3;
      }
      static __absoluteOr(_3, t3, e3 = null) {
        let n4 = _3.length, g3 = t3.length, s4 = g3;
        if (n4 < g3) {
          s4 = n4;
          const i4 = _3, e4 = n4;
          _3 = t3, n4 = g3, t3 = i4, g3 = e4;
        }
        let l2 = n4;
        null === e3 ? e3 = new o2(l2, false) : l2 = e3.length;
        let r2 = 0;
        for (; r2 < s4; r2++)
          e3.__setDigit(r2, _3.__digit(r2) | t3.__digit(r2));
        for (; r2 < n4; r2++)
          e3.__setDigit(r2, _3.__digit(r2));
        for (; r2 < l2; r2++)
          e3.__setDigit(r2, 0);
        return e3;
      }
      static __absoluteXor(_3, t3, e3 = null) {
        let n4 = _3.length, g3 = t3.length, s4 = g3;
        if (n4 < g3) {
          s4 = n4;
          const i4 = _3, e4 = n4;
          _3 = t3, n4 = g3, t3 = i4, g3 = e4;
        }
        let l2 = n4;
        null === e3 ? e3 = new o2(l2, false) : l2 = e3.length;
        let r2 = 0;
        for (; r2 < s4; r2++)
          e3.__setDigit(r2, _3.__digit(r2) ^ t3.__digit(r2));
        for (; r2 < n4; r2++)
          e3.__setDigit(r2, _3.__digit(r2));
        for (; r2 < l2; r2++)
          e3.__setDigit(r2, 0);
        return e3;
      }
      static __absoluteCompare(_3, t3) {
        const e3 = _3.length - t3.length;
        if (0 != e3)
          return e3;
        let n4 = _3.length - 1;
        for (; 0 <= n4 && _3.__digit(n4) === t3.__digit(n4); )
          n4--;
        return 0 > n4 ? 0 : _3.__unsignedDigit(n4) > t3.__unsignedDigit(n4) ? 1 : -1;
      }
      static __multiplyAccumulate(_3, t3, e3, n4) {
        if (0 === t3)
          return;
        const g3 = 32767 & t3, s4 = t3 >>> 15;
        let l2 = 0, r2 = 0;
        for (let a2, u2 = 0; u2 < _3.length; u2++, n4++) {
          a2 = e3.__digit(n4);
          const i4 = _3.__digit(u2), t4 = 32767 & i4, d2 = i4 >>> 15, h4 = o2.__imul(t4, g3), m2 = o2.__imul(t4, s4), b3 = o2.__imul(d2, g3), D2 = o2.__imul(d2, s4);
          a2 += r2 + h4 + l2, l2 = a2 >>> 30, a2 &= 1073741823, a2 += ((32767 & m2) << 15) + ((32767 & b3) << 15), l2 += a2 >>> 30, r2 = D2 + (m2 >>> 15) + (b3 >>> 15), e3.__setDigit(n4, 1073741823 & a2);
        }
        for (; 0 != l2 || 0 !== r2; n4++) {
          let i4 = e3.__digit(n4);
          i4 += l2 + r2, r2 = 0, l2 = i4 >>> 30, e3.__setDigit(n4, 1073741823 & i4);
        }
      }
      static __internalMultiplyAdd(_3, t3, e3, g3, s4) {
        let l2 = e3, a2 = 0;
        for (let n4 = 0; n4 < g3; n4++) {
          const i4 = _3.__digit(n4), e4 = o2.__imul(32767 & i4, t3), g4 = o2.__imul(i4 >>> 15, t3), u2 = e4 + ((32767 & g4) << 15) + a2 + l2;
          l2 = u2 >>> 30, a2 = g4 >>> 15, s4.__setDigit(n4, 1073741823 & u2);
        }
        if (s4.length > g3)
          for (s4.__setDigit(g3++, l2 + a2); g3 < s4.length; )
            s4.__setDigit(g3++, 0);
        else if (0 !== l2 + a2)
          throw new Error("implementation bug");
      }
      __inplaceMultiplyAdd(i4, _3, t3) {
        t3 > this.length && (t3 = this.length);
        const e3 = 32767 & i4, n4 = i4 >>> 15;
        let g3 = 0, s4 = _3;
        for (let l2 = 0; l2 < t3; l2++) {
          const i5 = this.__digit(l2), _4 = 32767 & i5, t4 = i5 >>> 15, r2 = o2.__imul(_4, e3), a2 = o2.__imul(_4, n4), u2 = o2.__imul(t4, e3), d2 = o2.__imul(t4, n4);
          let h4 = s4 + r2 + g3;
          g3 = h4 >>> 30, h4 &= 1073741823, h4 += ((32767 & a2) << 15) + ((32767 & u2) << 15), g3 += h4 >>> 30, s4 = d2 + (a2 >>> 15) + (u2 >>> 15), this.__setDigit(l2, 1073741823 & h4);
        }
        if (0 != g3 || 0 !== s4)
          throw new Error("implementation bug");
      }
      static __absoluteDivSmall(_3, t3, e3 = null) {
        null === e3 && (e3 = new o2(_3.length, false));
        let n4 = 0;
        for (let g3, o3 = 2 * _3.length - 1; 0 <= o3; o3 -= 2) {
          g3 = (n4 << 15 | _3.__halfDigit(o3)) >>> 0;
          const i4 = 0 | g3 / t3;
          n4 = 0 | g3 % t3, g3 = (n4 << 15 | _3.__halfDigit(o3 - 1)) >>> 0;
          const s4 = 0 | g3 / t3;
          n4 = 0 | g3 % t3, e3.__setDigit(o3 >>> 1, i4 << 15 | s4);
        }
        return e3;
      }
      static __absoluteModSmall(_3, t3) {
        let e3 = 0;
        for (let n4 = 2 * _3.length - 1; 0 <= n4; n4--) {
          const i4 = (e3 << 15 | _3.__halfDigit(n4)) >>> 0;
          e3 = 0 | i4 % t3;
        }
        return e3;
      }
      static __absoluteDivLarge(i4, _3, t3, e3) {
        const g3 = _3.__halfDigitLength(), n4 = _3.length, s4 = i4.__halfDigitLength() - g3;
        let l2 = null;
        t3 && (l2 = new o2(s4 + 2 >>> 1, false), l2.__initializeDigits());
        const r2 = new o2(g3 + 2 >>> 1, false);
        r2.__initializeDigits();
        const a2 = o2.__clz15(_3.__halfDigit(g3 - 1));
        0 < a2 && (_3 = o2.__specialLeftShift(_3, a2, 0));
        const d2 = o2.__specialLeftShift(i4, a2, 1), u2 = _3.__halfDigit(g3 - 1);
        let h4 = 0;
        for (let a3, m2 = s4; 0 <= m2; m2--) {
          a3 = 32767;
          const i5 = d2.__halfDigit(m2 + g3);
          if (i5 !== u2) {
            const t4 = (i5 << 15 | d2.__halfDigit(m2 + g3 - 1)) >>> 0;
            a3 = 0 | t4 / u2;
            let e5 = 0 | t4 % u2;
            const n5 = _3.__halfDigit(g3 - 2), s5 = d2.__halfDigit(m2 + g3 - 2);
            for (; o2.__imul(a3, n5) >>> 0 > (e5 << 16 | s5) >>> 0 && (a3--, e5 += u2, !(32767 < e5)); )
              ;
          }
          o2.__internalMultiplyAdd(_3, a3, 0, n4, r2);
          let e4 = d2.__inplaceSub(r2, m2, g3 + 1);
          0 !== e4 && (e4 = d2.__inplaceAdd(_3, m2, g3), d2.__setHalfDigit(m2 + g3, 32767 & d2.__halfDigit(m2 + g3) + e4), a3--), t3 && (1 & m2 ? h4 = a3 << 15 : l2.__setDigit(m2 >>> 1, h4 | a3));
        }
        if (e3)
          return d2.__inplaceRightShift(a2), t3 ? { quotient: l2, remainder: d2 } : d2;
        if (t3)
          return l2;
        throw new Error("unreachable");
      }
      static __clz15(i4) {
        return o2.__clz30(i4) - 15;
      }
      __inplaceAdd(_3, t3, e3) {
        let n4 = 0;
        for (let g3 = 0; g3 < e3; g3++) {
          const i4 = this.__halfDigit(t3 + g3) + _3.__halfDigit(g3) + n4;
          n4 = i4 >>> 15, this.__setHalfDigit(t3 + g3, 32767 & i4);
        }
        return n4;
      }
      __inplaceSub(_3, t3, e3) {
        let n4 = 0;
        if (1 & t3) {
          t3 >>= 1;
          let g3 = this.__digit(t3), o3 = 32767 & g3, s4 = 0;
          for (; s4 < e3 - 1 >>> 1; s4++) {
            const i5 = _3.__digit(s4), e4 = (g3 >>> 15) - (32767 & i5) - n4;
            n4 = 1 & e4 >>> 15, this.__setDigit(t3 + s4, (32767 & e4) << 15 | 32767 & o3), g3 = this.__digit(t3 + s4 + 1), o3 = (32767 & g3) - (i5 >>> 15) - n4, n4 = 1 & o3 >>> 15;
          }
          const i4 = _3.__digit(s4), l2 = (g3 >>> 15) - (32767 & i4) - n4;
          n4 = 1 & l2 >>> 15, this.__setDigit(t3 + s4, (32767 & l2) << 15 | 32767 & o3);
          if (t3 + s4 + 1 >= this.length)
            throw new RangeError("out of bounds");
          0 == (1 & e3) && (g3 = this.__digit(t3 + s4 + 1), o3 = (32767 & g3) - (i4 >>> 15) - n4, n4 = 1 & o3 >>> 15, this.__setDigit(t3 + _3.length, 1073709056 & g3 | 32767 & o3));
        } else {
          t3 >>= 1;
          let g3 = 0;
          for (; g3 < _3.length - 1; g3++) {
            const i5 = this.__digit(t3 + g3), e4 = _3.__digit(g3), o4 = (32767 & i5) - (32767 & e4) - n4;
            n4 = 1 & o4 >>> 15;
            const s5 = (i5 >>> 15) - (e4 >>> 15) - n4;
            n4 = 1 & s5 >>> 15, this.__setDigit(t3 + g3, (32767 & s5) << 15 | 32767 & o4);
          }
          const i4 = this.__digit(t3 + g3), o3 = _3.__digit(g3), s4 = (32767 & i4) - (32767 & o3) - n4;
          n4 = 1 & s4 >>> 15;
          let l2 = 0;
          0 == (1 & e3) && (l2 = (i4 >>> 15) - (o3 >>> 15) - n4, n4 = 1 & l2 >>> 15), this.__setDigit(t3 + g3, (32767 & l2) << 15 | 32767 & s4);
        }
        return n4;
      }
      __inplaceRightShift(_3) {
        if (0 === _3)
          return;
        let t3 = this.__digit(0) >>> _3;
        const e3 = this.length - 1;
        for (let n4 = 0; n4 < e3; n4++) {
          const i4 = this.__digit(n4 + 1);
          this.__setDigit(n4, 1073741823 & i4 << 30 - _3 | t3), t3 = i4 >>> _3;
        }
        this.__setDigit(e3, t3);
      }
      static __specialLeftShift(_3, t3, e3) {
        const g3 = _3.length, n4 = new o2(g3 + e3, false);
        if (0 === t3) {
          for (let t4 = 0; t4 < g3; t4++)
            n4.__setDigit(t4, _3.__digit(t4));
          return 0 < e3 && n4.__setDigit(g3, 0), n4;
        }
        let s4 = 0;
        for (let o3 = 0; o3 < g3; o3++) {
          const i4 = _3.__digit(o3);
          n4.__setDigit(o3, 1073741823 & i4 << t3 | s4), s4 = i4 >>> 30 - t3;
        }
        return 0 < e3 && n4.__setDigit(g3, s4), n4;
      }
      static __leftShiftByAbsolute(_3, i4) {
        const t3 = o2.__toShiftAmount(i4);
        if (0 > t3)
          throw new RangeError("BigInt too big");
        const e3 = 0 | t3 / 30, n4 = t3 % 30, g3 = _3.length, s4 = 0 !== n4 && 0 != _3.__digit(g3 - 1) >>> 30 - n4, l2 = g3 + e3 + (s4 ? 1 : 0), r2 = new o2(l2, _3.sign);
        if (0 === n4) {
          let t4 = 0;
          for (; t4 < e3; t4++)
            r2.__setDigit(t4, 0);
          for (; t4 < l2; t4++)
            r2.__setDigit(t4, _3.__digit(t4 - e3));
        } else {
          let t4 = 0;
          for (let _4 = 0; _4 < e3; _4++)
            r2.__setDigit(_4, 0);
          for (let o3 = 0; o3 < g3; o3++) {
            const i5 = _3.__digit(o3);
            r2.__setDigit(o3 + e3, 1073741823 & i5 << n4 | t4), t4 = i5 >>> 30 - n4;
          }
          if (s4)
            r2.__setDigit(g3 + e3, t4);
          else if (0 !== t4)
            throw new Error("implementation bug");
        }
        return r2.__trim();
      }
      static __rightShiftByAbsolute(_3, i4) {
        const t3 = _3.length, e3 = _3.sign, n4 = o2.__toShiftAmount(i4);
        if (0 > n4)
          return o2.__rightShiftByMaximum(e3);
        const g3 = 0 | n4 / 30, s4 = n4 % 30;
        let l2 = t3 - g3;
        if (0 >= l2)
          return o2.__rightShiftByMaximum(e3);
        let r2 = false;
        if (e3) {
          if (0 != (_3.__digit(g3) & (1 << s4) - 1))
            r2 = true;
          else
            for (let t4 = 0; t4 < g3; t4++)
              if (0 !== _3.__digit(t4)) {
                r2 = true;
                break;
              }
        }
        if (r2 && 0 === s4) {
          const i5 = _3.__digit(t3 - 1);
          0 == ~i5 && l2++;
        }
        let a2 = new o2(l2, e3);
        if (0 === s4) {
          a2.__setDigit(l2 - 1, 0);
          for (let e4 = g3; e4 < t3; e4++)
            a2.__setDigit(e4 - g3, _3.__digit(e4));
        } else {
          let e4 = _3.__digit(g3) >>> s4;
          const n5 = t3 - g3 - 1;
          for (let t4 = 0; t4 < n5; t4++) {
            const i5 = _3.__digit(t4 + g3 + 1);
            a2.__setDigit(t4, 1073741823 & i5 << 30 - s4 | e4), e4 = i5 >>> s4;
          }
          a2.__setDigit(n5, e4);
        }
        return r2 && (a2 = o2.__absoluteAddOne(a2, true, a2)), a2.__trim();
      }
      static __rightShiftByMaximum(i4) {
        return i4 ? o2.__oneDigit(1, true) : o2.__zero();
      }
      static __toShiftAmount(i4) {
        if (1 < i4.length)
          return -1;
        const _3 = i4.__unsignedDigit(0);
        return _3 > o2.__kMaxLengthBits ? -1 : _3;
      }
      static __toPrimitive(i4, _3 = "default") {
        if ("object" != typeof i4)
          return i4;
        if (i4.constructor === o2)
          return i4;
        const t3 = i4[Symbol.toPrimitive];
        if (t3) {
          const i5 = t3(_3);
          if ("object" != typeof i5)
            return i5;
          throw new TypeError("Cannot convert object to primitive value");
        }
        const e3 = i4.valueOf;
        if (e3) {
          const _4 = e3.call(i4);
          if ("object" != typeof _4)
            return _4;
        }
        const n4 = i4.toString;
        if (n4) {
          const _4 = n4.call(i4);
          if ("object" != typeof _4)
            return _4;
        }
        throw new TypeError("Cannot convert object to primitive value");
      }
      static __toNumeric(i4) {
        return o2.__isBigInt(i4) ? i4 : +i4;
      }
      static __isBigInt(i4) {
        return "object" == typeof i4 && null !== i4 && i4.constructor === o2;
      }
      static __truncateToNBits(i4, _3) {
        const t3 = 0 | (i4 + 29) / 30, e3 = new o2(t3, _3.sign), n4 = t3 - 1;
        for (let t4 = 0; t4 < n4; t4++)
          e3.__setDigit(t4, _3.__digit(t4));
        let g3 = _3.__digit(n4);
        if (0 != i4 % 30) {
          const _4 = 32 - i4 % 30;
          g3 = g3 << _4 >>> _4;
        }
        return e3.__setDigit(n4, g3), e3.__trim();
      }
      static __truncateAndSubFromPowerOfTwo(_3, t3, e3) {
        var n4 = Math.min;
        const g3 = 0 | (_3 + 29) / 30, s4 = new o2(g3, e3);
        let l2 = 0;
        const r2 = g3 - 1;
        let a2 = 0;
        for (const i4 = n4(r2, t3.length); l2 < i4; l2++) {
          const i5 = 0 - t3.__digit(l2) - a2;
          a2 = 1 & i5 >>> 30, s4.__setDigit(l2, 1073741823 & i5);
        }
        for (; l2 < r2; l2++)
          s4.__setDigit(l2, 0 | 1073741823 & -a2);
        let u2 = r2 < t3.length ? t3.__digit(r2) : 0;
        const d2 = _3 % 30;
        let h4;
        if (0 == d2)
          h4 = 0 - u2 - a2, h4 &= 1073741823;
        else {
          const i4 = 32 - d2;
          u2 = u2 << i4 >>> i4;
          const _4 = 1 << 32 - i4;
          h4 = _4 - u2 - a2, h4 &= _4 - 1;
        }
        return s4.__setDigit(r2, h4), s4.__trim();
      }
      __digit(_3) {
        return this[_3];
      }
      __unsignedDigit(_3) {
        return this[_3] >>> 0;
      }
      __setDigit(_3, i4) {
        this[_3] = 0 | i4;
      }
      __setDigitGrow(_3, i4) {
        this[_3] = 0 | i4;
      }
      __halfDigitLength() {
        const i4 = this.length;
        return 32767 >= this.__unsignedDigit(i4 - 1) ? 2 * i4 - 1 : 2 * i4;
      }
      __halfDigit(_3) {
        return 32767 & this[_3 >>> 1] >>> 15 * (1 & _3);
      }
      __setHalfDigit(_3, i4) {
        const t3 = _3 >>> 1, e3 = this.__digit(t3), n4 = 1 & _3 ? 32767 & e3 | i4 << 15 : 1073709056 & e3 | 32767 & i4;
        this.__setDigit(t3, n4);
      }
      static __digitPow(i4, _3) {
        let t3 = 1;
        for (; 0 < _3; )
          1 & _3 && (t3 *= i4), _3 >>>= 1, i4 *= i4;
        return t3;
      }
      static __isOneDigitInt(i4) {
        return (1073741823 & i4) === i4;
      }
    }
    o2.__kMaxLength = 33554432, o2.__kMaxLengthBits = o2.__kMaxLength << 5, o2.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], o2.__kBitsPerCharTableShift = 5, o2.__kBitsPerCharTableMultiplier = 1 << o2.__kBitsPerCharTableShift, o2.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], o2.__kBitConversionBuffer = new ArrayBuffer(8), o2.__kBitConversionDouble = new Float64Array(o2.__kBitConversionBuffer), o2.__kBitConversionInts = new Int32Array(o2.__kBitConversionBuffer), o2.__clz30 = _2 ? function(i4) {
      return _2(i4) - 2;
    } : function(i4) {
      return 0 === i4 ? 30 : 0 | 29 - (0 | Math.log(i4 >>> 0) / Math.LN2);
    }, o2.__imul = Math.imul || function(i4, _3) {
      return 0 | i4 * _3;
    }, i3.default = o2, Object.defineProperty(i3, "__esModule", { value: true });
  });
})(jsbiUmd, jsbiUmd.exports);
var jsbiUmdExports = jsbiUmd.exports;
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$1);
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(tinyInvariant);
const _format$3 = "hh-sol-artifact-1";
const contractName$3 = "IApproveAndCall";
const sourceName$3 = "contracts/interfaces/IApproveAndCall.sol";
const abi$3 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "approveMax",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "approveMaxMinusOne",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "approveZeroThenMax",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "approveZeroThenMaxMinusOne",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "callPositionManager",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "getApprovalType",
    outputs: [
      {
        internalType: "enum IApproveAndCall.ApprovalType",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "token0",
            type: "address"
          },
          {
            internalType: "address",
            name: "token1",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount0Min",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount1Min",
            type: "uint256"
          }
        ],
        internalType: "struct IApproveAndCall.IncreaseLiquidityParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "increaseLiquidity",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "token0",
            type: "address"
          },
          {
            internalType: "address",
            name: "token1",
            type: "address"
          },
          {
            internalType: "uint24",
            name: "fee",
            type: "uint24"
          },
          {
            internalType: "int24",
            name: "tickLower",
            type: "int24"
          },
          {
            internalType: "int24",
            name: "tickUpper",
            type: "int24"
          },
          {
            internalType: "uint256",
            name: "amount0Min",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount1Min",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        internalType: "struct IApproveAndCall.MintParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "mint",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "function"
  }
];
const bytecode$3 = "0x";
const deployedBytecode$3 = "0x";
const linkReferences$3 = {};
const deployedLinkReferences$3 = {};
const require$$4 = {
  _format: _format$3,
  contractName: contractName$3,
  sourceName: sourceName$3,
  abi: abi$3,
  bytecode: bytecode$3,
  deployedBytecode: deployedBytecode$3,
  linkReferences: linkReferences$3,
  deployedLinkReferences: deployedLinkReferences$3
};
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(v3Sdk_esm);
const _format$2 = "hh-sol-artifact-1";
const contractName$2 = "IMulticallExtended";
const sourceName$2 = "contracts/interfaces/IMulticallExtended.sol";
const abi$2 = [
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "previousBlockhash",
        type: "bytes32"
      },
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  }
];
const bytecode$2 = "0x";
const deployedBytecode$2 = "0x";
const linkReferences$2 = {};
const deployedLinkReferences$2 = {};
const require$$6 = {
  _format: _format$2,
  contractName: contractName$2,
  sourceName: sourceName$2,
  abi: abi$2,
  bytecode: bytecode$2,
  deployedBytecode: deployedBytecode$2,
  linkReferences: linkReferences$2,
  deployedLinkReferences: deployedLinkReferences$2
};
const _format$1 = "hh-sol-artifact-1";
const contractName$1 = "IPeripheryPaymentsWithFeeExtended";
const sourceName$1 = "contracts/interfaces/IPeripheryPaymentsWithFeeExtended.sol";
const abi$1 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "pull",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "refundETH",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "sweepToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      }
    ],
    name: "sweepToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "feeBips",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "feeRecipient",
        type: "address"
      }
    ],
    name: "sweepTokenWithFee",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "feeBips",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "feeRecipient",
        type: "address"
      }
    ],
    name: "sweepTokenWithFee",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "unwrapWETH9",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      }
    ],
    name: "unwrapWETH9",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "feeBips",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "feeRecipient",
        type: "address"
      }
    ],
    name: "unwrapWETH9WithFee",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "feeBips",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "feeRecipient",
        type: "address"
      }
    ],
    name: "unwrapWETH9WithFee",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "wrapETH",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
];
const bytecode$1 = "0x";
const deployedBytecode$1 = "0x";
const linkReferences$1 = {};
const deployedLinkReferences$1 = {};
const require$$7 = {
  _format: _format$1,
  contractName: contractName$1,
  sourceName: sourceName$1,
  abi: abi$1,
  bytecode: bytecode$1,
  deployedBytecode: deployedBytecode$1,
  linkReferences: linkReferences$1,
  deployedLinkReferences: deployedLinkReferences$1
};
const _format = "hh-sol-artifact-1";
const contractName = "ISwapRouter02";
const sourceName = "contracts/interfaces/ISwapRouter02.sol";
const abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "approveMax",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "approveMaxMinusOne",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "approveZeroThenMax",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "approveZeroThenMaxMinusOne",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "callPositionManager",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes",
            name: "path",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountOutMinimum",
            type: "uint256"
          }
        ],
        internalType: "struct IV3SwapRouter.ExactInputParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactInput",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "address",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint24",
            name: "fee",
            type: "uint24"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountOutMinimum",
            type: "uint256"
          },
          {
            internalType: "uint160",
            name: "sqrtPriceLimitX96",
            type: "uint160"
          }
        ],
        internalType: "struct IV3SwapRouter.ExactInputSingleParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactInputSingle",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes",
            name: "path",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amountOut",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountInMaximum",
            type: "uint256"
          }
        ],
        internalType: "struct IV3SwapRouter.ExactOutputParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactOutput",
    outputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "address",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint24",
            name: "fee",
            type: "uint24"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amountOut",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountInMaximum",
            type: "uint256"
          },
          {
            internalType: "uint160",
            name: "sqrtPriceLimitX96",
            type: "uint160"
          }
        ],
        internalType: "struct IV3SwapRouter.ExactOutputSingleParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactOutputSingle",
    outputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "getApprovalType",
    outputs: [
      {
        internalType: "enum IApproveAndCall.ApprovalType",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "token0",
            type: "address"
          },
          {
            internalType: "address",
            name: "token1",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount0Min",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount1Min",
            type: "uint256"
          }
        ],
        internalType: "struct IApproveAndCall.IncreaseLiquidityParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "increaseLiquidity",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "token0",
            type: "address"
          },
          {
            internalType: "address",
            name: "token1",
            type: "address"
          },
          {
            internalType: "uint24",
            name: "fee",
            type: "uint24"
          },
          {
            internalType: "int24",
            name: "tickLower",
            type: "int24"
          },
          {
            internalType: "int24",
            name: "tickUpper",
            type: "int24"
          },
          {
            internalType: "uint256",
            name: "amount0Min",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount1Min",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        internalType: "struct IApproveAndCall.MintParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "mint",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "previousBlockhash",
        type: "bytes32"
      },
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "expiry",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermitAllowed",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "expiry",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermitAllowedIfNecessary",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermitIfNecessary",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amountOutMin",
        type: "uint256"
      },
      {
        internalType: "address[]",
        name: "path",
        type: "address[]"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "swapExactTokensForTokens",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amountInMax",
        type: "uint256"
      },
      {
        internalType: "address[]",
        name: "path",
        type: "address[]"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "swapTokensForExactTokens",
    outputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "int256",
        name: "amount0Delta",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "amount1Delta",
        type: "int256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "uniswapV3SwapCallback",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const bytecode = "0x";
const deployedBytecode = "0x";
const linkReferences = {};
const deployedLinkReferences = {};
const require$$8 = {
  _format,
  contractName,
  sourceName,
  abi,
  bytecode,
  deployedBytecode,
  linkReferences,
  deployedLinkReferences
};
var FACTORY_ADDRESS_MAP$1 = {
  // Mainnet
  1: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f",
  // Ropsten
  3: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f",
  // Goerli
  5: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f",
  // Optimism
  10: "0x0c3c1c532F1e39EdF36BE9Fe0bE1410313E074Bf",
  // Arbitrum
  42161: "0xf1D7CC64Fb4452F05c498126312eBE29f30Fbcf9",
  // Avalanche
  43114: "0x9e5A52f57b3038F1B8EeE45F28b3C1967e22799C",
  // Base
  8453: "0x8909dc15e40173ff4699343b6eb8132c65e18ec6",
  // BNB
  56: "0x8909Dc15e40173Ff4699343b6eB8132c65e18eC6",
  // Polygon
  137: "0x9e5A52f57b3038F1B8EeE45F28b3C1967e22799C",
  // Celo
  42220: "0x79a530c8e2fA8748B7B40dd3629C0520c2cCf03f"
};
var INIT_CODE_HASH$1 = "0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f";
var MINIMUM_LIQUIDITY$1 = /* @__PURE__ */ JSBI.BigInt(1e3);
var ZERO$2 = /* @__PURE__ */ JSBI.BigInt(0);
var ONE$2 = /* @__PURE__ */ JSBI.BigInt(1);
var FIVE$1 = /* @__PURE__ */ JSBI.BigInt(5);
var _997$1 = /* @__PURE__ */ JSBI.BigInt(997);
var _1000$1 = /* @__PURE__ */ JSBI.BigInt(1e3);
var BASIS_POINTS$1 = /* @__PURE__ */ JSBI.BigInt(1e4);
var ZERO_PERCENT$1 = /* @__PURE__ */ new Percent$1(ZERO$2);
var ONE_HUNDRED_PERCENT$1 = /* @__PURE__ */ new Percent$1(ONE$2);
function _defineProperties$2(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  return Constructor;
}
function _inheritsLoose$2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _getPrototypeOf$1(o2) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf$1(o2);
}
function _setPrototypeOf$1(o2, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf$1(o2, p2);
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _construct$1(Parent, args, Class) {
  if (_isNativeReflectConstruct$1()) {
    _construct$1 = Reflect.construct;
  } else {
    _construct$1 = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$1(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct$1.apply(null, arguments);
}
function _isNativeFunction$1(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper$1(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper$1 = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction$1(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct$1(Class2, arguments, _getPrototypeOf$1(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf$1(Wrapper, Class2);
  };
  return _wrapNativeSuper$1(Class);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _unsupportedIterableToArray$1(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$1(o2, minLen);
  var n4 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n4 === "Object" && o2.constructor)
    n4 = o2.constructor.name;
  if (n4 === "Map" || n4 === "Set")
    return Array.from(o2);
  if (n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
    return _arrayLikeToArray$1(o2, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++)
    arr2[i3] = arr[i3];
  return arr2;
}
function _createForOfIteratorHelperLoose$1(o2, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray$1(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i3 = 0;
      return function() {
        if (i3 >= o2.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o2[i3++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it = o2[Symbol.iterator]();
  return it.next.bind(it);
}
var CAN_SET_PROTOTYPE$1 = "setPrototypeOf" in Object;
var InsufficientReservesError$1 = /* @__PURE__ */ function(_Error) {
  _inheritsLoose$2(InsufficientReservesError2, _Error);
  function InsufficientReservesError2() {
    var _this;
    _this = _Error.call(this) || this;
    _this.isInsufficientReservesError = true;
    _this.name = _this.constructor.name;
    if (CAN_SET_PROTOTYPE$1)
      Object.setPrototypeOf(_assertThisInitialized$1(_this), (this instanceof InsufficientReservesError2 ? this.constructor : void 0).prototype);
    return _this;
  }
  return InsufficientReservesError2;
}(/* @__PURE__ */ _wrapNativeSuper$1(Error));
var InsufficientInputAmountError$1 = /* @__PURE__ */ function(_Error2) {
  _inheritsLoose$2(InsufficientInputAmountError2, _Error2);
  function InsufficientInputAmountError2() {
    var _this2;
    _this2 = _Error2.call(this) || this;
    _this2.isInsufficientInputAmountError = true;
    _this2.name = _this2.constructor.name;
    if (CAN_SET_PROTOTYPE$1)
      Object.setPrototypeOf(_assertThisInitialized$1(_this2), (this instanceof InsufficientInputAmountError2 ? this.constructor : void 0).prototype);
    return _this2;
  }
  return InsufficientInputAmountError2;
}(/* @__PURE__ */ _wrapNativeSuper$1(Error));
var computePairAddress$1 = function computePairAddress2(_ref) {
  var factoryAddress = _ref.factoryAddress, tokenA = _ref.tokenA, tokenB = _ref.tokenB;
  var _ref2 = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA], token0 = _ref2[0], token1 = _ref2[1];
  return getCreate2Address(factoryAddress, keccak256$1(["bytes"], [pack(["address", "address"], [token0.address, token1.address])]), INIT_CODE_HASH$1);
};
var Pair$1 = /* @__PURE__ */ function() {
  function Pair2(currencyAmountA, tokenAmountB) {
    var tokenAmounts = currencyAmountA.currency.sortsBefore(tokenAmountB.currency) ? [currencyAmountA, tokenAmountB] : [tokenAmountB, currencyAmountA];
    this.liquidityToken = new Token$2(tokenAmounts[0].currency.chainId, Pair2.getAddress(tokenAmounts[0].currency, tokenAmounts[1].currency), 18, "UNI-V2", "Uniswap V2");
    this.tokenAmounts = tokenAmounts;
  }
  Pair2.getAddress = function getAddress2(tokenA, tokenB) {
    return computePairAddress$1({
      factoryAddress: FACTORY_ADDRESS_MAP$1[tokenA.chainId],
      tokenA,
      tokenB
    });
  };
  var _proto = Pair2.prototype;
  _proto.involvesToken = function involvesToken(token2) {
    return token2.equals(this.token0) || token2.equals(this.token1);
  };
  _proto.priceOf = function priceOf(token2) {
    !this.involvesToken(token2) ? invariant$1(false) : void 0;
    return token2.equals(this.token0) ? this.token0Price : this.token1Price;
  };
  _proto.reserveOf = function reserveOf(token2) {
    !this.involvesToken(token2) ? invariant$1(false) : void 0;
    return token2.equals(this.token0) ? this.reserve0 : this.reserve1;
  };
  _proto.getOutputAmount = function getOutputAmount(inputAmount, calculateFotFees) {
    if (calculateFotFees === void 0) {
      calculateFotFees = true;
    }
    !this.involvesToken(inputAmount.currency) ? invariant$1(false) : void 0;
    if (JSBI.equal(this.reserve0.quotient, ZERO$2) || JSBI.equal(this.reserve1.quotient, ZERO$2)) {
      throw new InsufficientReservesError$1();
    }
    var inputReserve = this.reserveOf(inputAmount.currency);
    var outputReserve = this.reserveOf(inputAmount.currency.equals(this.token0) ? this.token1 : this.token0);
    var percentAfterSellFees = calculateFotFees ? this.derivePercentAfterSellFees(inputAmount) : ZERO_PERCENT$1;
    var inputAmountAfterTax = percentAfterSellFees.greaterThan(ZERO_PERCENT$1) ? CurrencyAmount$1.fromRawAmount(
      inputAmount.currency,
      percentAfterSellFees.multiply(inputAmount).quotient
      // fraction.quotient will round down by itself, which is desired
    ) : inputAmount;
    var inputAmountWithFeeAndAfterTax = JSBI.multiply(inputAmountAfterTax.quotient, _997$1);
    var numerator = JSBI.multiply(inputAmountWithFeeAndAfterTax, outputReserve.quotient);
    var denominator = JSBI.add(JSBI.multiply(inputReserve.quotient, _1000$1), inputAmountWithFeeAndAfterTax);
    var outputAmount = CurrencyAmount$1.fromRawAmount(
      inputAmount.currency.equals(this.token0) ? this.token1 : this.token0,
      JSBI.divide(numerator, denominator)
      // JSBI.divide will round down by itself, which is desired
    );
    if (JSBI.equal(outputAmount.quotient, ZERO$2)) {
      throw new InsufficientInputAmountError$1();
    }
    var percentAfterBuyFees = calculateFotFees ? this.derivePercentAfterBuyFees(outputAmount) : ZERO_PERCENT$1;
    var outputAmountAfterTax = percentAfterBuyFees.greaterThan(ZERO_PERCENT$1) ? CurrencyAmount$1.fromRawAmount(
      outputAmount.currency,
      outputAmount.multiply(percentAfterBuyFees).quotient
      // fraction.quotient will round down by itself, which is desired
    ) : outputAmount;
    if (JSBI.equal(outputAmountAfterTax.quotient, ZERO$2)) {
      throw new InsufficientInputAmountError$1();
    }
    return [outputAmountAfterTax, new Pair2(inputReserve.add(inputAmountAfterTax), outputReserve.subtract(outputAmountAfterTax))];
  };
  _proto.getInputAmount = function getInputAmount(outputAmount, calculateFotFees) {
    if (calculateFotFees === void 0) {
      calculateFotFees = true;
    }
    !this.involvesToken(outputAmount.currency) ? invariant$1(false) : void 0;
    var percentAfterBuyFees = calculateFotFees ? this.derivePercentAfterBuyFees(outputAmount) : ZERO_PERCENT$1;
    var outputAmountBeforeTax = percentAfterBuyFees.greaterThan(ZERO_PERCENT$1) ? CurrencyAmount$1.fromRawAmount(
      outputAmount.currency,
      JSBI.add(outputAmount.divide(percentAfterBuyFees).quotient, ONE$2)
      // add 1 for rounding up
    ) : outputAmount;
    if (JSBI.equal(this.reserve0.quotient, ZERO$2) || JSBI.equal(this.reserve1.quotient, ZERO$2) || JSBI.greaterThanOrEqual(outputAmount.quotient, this.reserveOf(outputAmount.currency).quotient) || JSBI.greaterThanOrEqual(outputAmountBeforeTax.quotient, this.reserveOf(outputAmount.currency).quotient)) {
      throw new InsufficientReservesError$1();
    }
    var outputReserve = this.reserveOf(outputAmount.currency);
    var inputReserve = this.reserveOf(outputAmount.currency.equals(this.token0) ? this.token1 : this.token0);
    var numerator = JSBI.multiply(JSBI.multiply(inputReserve.quotient, outputAmountBeforeTax.quotient), _1000$1);
    var denominator = JSBI.multiply(JSBI.subtract(outputReserve.quotient, outputAmountBeforeTax.quotient), _997$1);
    var inputAmount = CurrencyAmount$1.fromRawAmount(
      outputAmount.currency.equals(this.token0) ? this.token1 : this.token0,
      JSBI.add(JSBI.divide(numerator, denominator), ONE$2)
      // add 1 here is part of the formula, no rounding needed here, since there will not be decimal at this point
    );
    var percentAfterSellFees = calculateFotFees ? this.derivePercentAfterSellFees(inputAmount) : ZERO_PERCENT$1;
    var inputAmountBeforeTax = percentAfterSellFees.greaterThan(ZERO_PERCENT$1) ? CurrencyAmount$1.fromRawAmount(
      inputAmount.currency,
      JSBI.add(inputAmount.divide(percentAfterSellFees).quotient, ONE$2)
      // add 1 for rounding up
    ) : inputAmount;
    return [inputAmountBeforeTax, new Pair2(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];
  };
  _proto.getLiquidityMinted = function getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB) {
    !totalSupply.currency.equals(this.liquidityToken) ? invariant$1(false) : void 0;
    var tokenAmounts = tokenAmountA.currency.sortsBefore(tokenAmountB.currency) ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];
    !(tokenAmounts[0].currency.equals(this.token0) && tokenAmounts[1].currency.equals(this.token1)) ? invariant$1(false) : void 0;
    var liquidity;
    if (JSBI.equal(totalSupply.quotient, ZERO$2)) {
      liquidity = JSBI.subtract(sqrt$1(JSBI.multiply(tokenAmounts[0].quotient, tokenAmounts[1].quotient)), MINIMUM_LIQUIDITY$1);
    } else {
      var amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].quotient, totalSupply.quotient), this.reserve0.quotient);
      var amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].quotient, totalSupply.quotient), this.reserve1.quotient);
      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1;
    }
    if (!JSBI.greaterThan(liquidity, ZERO$2)) {
      throw new InsufficientInputAmountError$1();
    }
    return CurrencyAmount$1.fromRawAmount(this.liquidityToken, liquidity);
  };
  _proto.getLiquidityValue = function getLiquidityValue(token2, totalSupply, liquidity, feeOn, kLast) {
    if (feeOn === void 0) {
      feeOn = false;
    }
    !this.involvesToken(token2) ? invariant$1(false) : void 0;
    !totalSupply.currency.equals(this.liquidityToken) ? invariant$1(false) : void 0;
    !liquidity.currency.equals(this.liquidityToken) ? invariant$1(false) : void 0;
    !JSBI.lessThanOrEqual(liquidity.quotient, totalSupply.quotient) ? invariant$1(false) : void 0;
    var totalSupplyAdjusted;
    if (!feeOn) {
      totalSupplyAdjusted = totalSupply;
    } else {
      !!!kLast ? invariant$1(false) : void 0;
      var kLastParsed = JSBI.BigInt(kLast);
      if (!JSBI.equal(kLastParsed, ZERO$2)) {
        var rootK = sqrt$1(JSBI.multiply(this.reserve0.quotient, this.reserve1.quotient));
        var rootKLast = sqrt$1(kLastParsed);
        if (JSBI.greaterThan(rootK, rootKLast)) {
          var numerator = JSBI.multiply(totalSupply.quotient, JSBI.subtract(rootK, rootKLast));
          var denominator = JSBI.add(JSBI.multiply(rootK, FIVE$1), rootKLast);
          var feeLiquidity = JSBI.divide(numerator, denominator);
          totalSupplyAdjusted = totalSupply.add(CurrencyAmount$1.fromRawAmount(this.liquidityToken, feeLiquidity));
        } else {
          totalSupplyAdjusted = totalSupply;
        }
      } else {
        totalSupplyAdjusted = totalSupply;
      }
    }
    return CurrencyAmount$1.fromRawAmount(token2, JSBI.divide(JSBI.multiply(liquidity.quotient, this.reserveOf(token2).quotient), totalSupplyAdjusted.quotient));
  };
  _proto.derivePercentAfterSellFees = function derivePercentAfterSellFees(inputAmount) {
    var sellFeeBips = this.token0.wrapped.equals(inputAmount.wrapped.currency) ? this.token0.wrapped.sellFeeBps : this.token1.wrapped.sellFeeBps;
    if (sellFeeBips != null && sellFeeBips.gt(BigNumber.from(0))) {
      return ONE_HUNDRED_PERCENT$1.subtract(new Percent$1(JSBI.BigInt(sellFeeBips)).divide(BASIS_POINTS$1));
    } else {
      return ZERO_PERCENT$1;
    }
  };
  _proto.derivePercentAfterBuyFees = function derivePercentAfterBuyFees(outputAmount) {
    var buyFeeBps = this.token0.wrapped.equals(outputAmount.wrapped.currency) ? this.token0.wrapped.buyFeeBps : this.token1.wrapped.buyFeeBps;
    if (buyFeeBps != null && buyFeeBps.gt(BigNumber.from(0))) {
      return ONE_HUNDRED_PERCENT$1.subtract(new Percent$1(JSBI.BigInt(buyFeeBps)).divide(BASIS_POINTS$1));
    } else {
      return ZERO_PERCENT$1;
    }
  };
  _createClass$2(Pair2, [{
    key: "token0Price",
    get: function get2() {
      var result = this.tokenAmounts[1].divide(this.tokenAmounts[0]);
      return new Price$1(this.token0, this.token1, result.denominator, result.numerator);
    }
    /**
     * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1
     */
  }, {
    key: "token1Price",
    get: function get2() {
      var result = this.tokenAmounts[0].divide(this.tokenAmounts[1]);
      return new Price$1(this.token1, this.token0, result.denominator, result.numerator);
    }
  }, {
    key: "chainId",
    get: function get2() {
      return this.token0.chainId;
    }
  }, {
    key: "token0",
    get: function get2() {
      return this.tokenAmounts[0].currency;
    }
  }, {
    key: "token1",
    get: function get2() {
      return this.tokenAmounts[1].currency;
    }
  }, {
    key: "reserve0",
    get: function get2() {
      return this.tokenAmounts[0];
    }
  }, {
    key: "reserve1",
    get: function get2() {
      return this.tokenAmounts[1];
    }
  }]);
  return Pair2;
}();
var Route$1 = /* @__PURE__ */ function() {
  function Route2(pairs, input, output2) {
    this._midPrice = null;
    !(pairs.length > 0) ? invariant$1(false) : void 0;
    var chainId2 = pairs[0].chainId;
    !pairs.every(function(pair2) {
      return pair2.chainId === chainId2;
    }) ? invariant$1(false) : void 0;
    var wrappedInput = input.wrapped;
    !pairs[0].involvesToken(wrappedInput) ? invariant$1(false) : void 0;
    !(typeof output2 === "undefined" || pairs[pairs.length - 1].involvesToken(output2.wrapped)) ? invariant$1(false) : void 0;
    var path = [wrappedInput];
    for (var _iterator = _createForOfIteratorHelperLoose$1(pairs.entries()), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, i3 = _step$value[0], pair = _step$value[1];
      var currentInput = path[i3];
      !(currentInput.equals(pair.token0) || currentInput.equals(pair.token1)) ? invariant$1(false) : void 0;
      var _output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0;
      path.push(_output);
    }
    this.pairs = pairs;
    this.path = path;
    this.input = input;
    this.output = output2;
  }
  _createClass$2(Route2, [{
    key: "midPrice",
    get: function get2() {
      if (this._midPrice !== null)
        return this._midPrice;
      var prices = [];
      for (var _iterator2 = _createForOfIteratorHelperLoose$1(this.pairs.entries()), _step2; !(_step2 = _iterator2()).done; ) {
        var _step2$value = _step2.value, i3 = _step2$value[0], pair = _step2$value[1];
        prices.push(this.path[i3].equals(pair.token0) ? new Price$1(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.quotient, pair.reserve1.quotient) : new Price$1(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.quotient, pair.reserve0.quotient));
      }
      var reduced = prices.slice(1).reduce(function(accumulator, currentValue) {
        return accumulator.multiply(currentValue);
      }, prices[0]);
      return this._midPrice = new Price$1(this.input, this.output, reduced.denominator, reduced.numerator);
    }
  }, {
    key: "chainId",
    get: function get2() {
      return this.pairs[0].chainId;
    }
  }]);
  return Route2;
}();
function inputOutputComparator(a2, b3) {
  !a2.inputAmount.currency.equals(b3.inputAmount.currency) ? invariant$1(false) : void 0;
  !a2.outputAmount.currency.equals(b3.outputAmount.currency) ? invariant$1(false) : void 0;
  if (a2.outputAmount.equalTo(b3.outputAmount)) {
    if (a2.inputAmount.equalTo(b3.inputAmount)) {
      return 0;
    }
    if (a2.inputAmount.lessThan(b3.inputAmount)) {
      return -1;
    } else {
      return 1;
    }
  } else {
    if (a2.outputAmount.lessThan(b3.outputAmount)) {
      return 1;
    } else {
      return -1;
    }
  }
}
function tradeComparator(a2, b3) {
  var ioComp = inputOutputComparator(a2, b3);
  if (ioComp !== 0) {
    return ioComp;
  }
  if (a2.priceImpact.lessThan(b3.priceImpact)) {
    return -1;
  } else if (a2.priceImpact.greaterThan(b3.priceImpact)) {
    return 1;
  }
  return a2.route.path.length - b3.route.path.length;
}
var Trade = /* @__PURE__ */ function() {
  function Trade2(route, amount, tradeType) {
    this.route = route;
    this.tradeType = tradeType;
    var tokenAmounts = new Array(route.path.length);
    if (tradeType === TradeType$1.EXACT_INPUT) {
      !amount.currency.equals(route.input) ? invariant$1(false) : void 0;
      tokenAmounts[0] = amount.wrapped;
      for (var i3 = 0; i3 < route.path.length - 1; i3++) {
        var pair = route.pairs[i3];
        var _pair$getOutputAmount = pair.getOutputAmount(tokenAmounts[i3]), outputAmount = _pair$getOutputAmount[0];
        tokenAmounts[i3 + 1] = outputAmount;
      }
      this.inputAmount = CurrencyAmount$1.fromFractionalAmount(route.input, amount.numerator, amount.denominator);
      this.outputAmount = CurrencyAmount$1.fromFractionalAmount(route.output, tokenAmounts[tokenAmounts.length - 1].numerator, tokenAmounts[tokenAmounts.length - 1].denominator);
    } else {
      !amount.currency.equals(route.output) ? invariant$1(false) : void 0;
      tokenAmounts[tokenAmounts.length - 1] = amount.wrapped;
      for (var _i = route.path.length - 1; _i > 0; _i--) {
        var _pair = route.pairs[_i - 1];
        var _pair$getInputAmount = _pair.getInputAmount(tokenAmounts[_i]), inputAmount = _pair$getInputAmount[0];
        tokenAmounts[_i - 1] = inputAmount;
      }
      this.inputAmount = CurrencyAmount$1.fromFractionalAmount(route.input, tokenAmounts[0].numerator, tokenAmounts[0].denominator);
      this.outputAmount = CurrencyAmount$1.fromFractionalAmount(route.output, amount.numerator, amount.denominator);
    }
    this.executionPrice = new Price$1(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);
    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount);
  }
  Trade2.exactIn = function exactIn(route, amountIn) {
    return new Trade2(route, amountIn, TradeType$1.EXACT_INPUT);
  };
  Trade2.exactOut = function exactOut(route, amountOut) {
    return new Trade2(route, amountOut, TradeType$1.EXACT_OUTPUT);
  };
  var _proto = Trade2.prototype;
  _proto.minimumAmountOut = function minimumAmountOut(slippageTolerance) {
    !!slippageTolerance.lessThan(ZERO$2) ? invariant$1(false) : void 0;
    if (this.tradeType === TradeType$1.EXACT_OUTPUT) {
      return this.outputAmount;
    } else {
      var slippageAdjustedAmountOut = new Fraction$1(ONE$2).add(slippageTolerance).invert().multiply(this.outputAmount.quotient).quotient;
      return CurrencyAmount$1.fromRawAmount(this.outputAmount.currency, slippageAdjustedAmountOut);
    }
  };
  _proto.maximumAmountIn = function maximumAmountIn(slippageTolerance) {
    !!slippageTolerance.lessThan(ZERO$2) ? invariant$1(false) : void 0;
    if (this.tradeType === TradeType$1.EXACT_INPUT) {
      return this.inputAmount;
    } else {
      var slippageAdjustedAmountIn = new Fraction$1(ONE$2).add(slippageTolerance).multiply(this.inputAmount.quotient).quotient;
      return CurrencyAmount$1.fromRawAmount(this.inputAmount.currency, slippageAdjustedAmountIn);
    }
  };
  Trade2.bestTradeExactIn = function bestTradeExactIn(pairs, currencyAmountIn, currencyOut, _temp, currentPairs, nextAmountIn, bestTrades) {
    var _ref = _temp === void 0 ? {} : _temp, _ref$maxNumResults = _ref.maxNumResults, maxNumResults = _ref$maxNumResults === void 0 ? 3 : _ref$maxNumResults, _ref$maxHops = _ref.maxHops, maxHops = _ref$maxHops === void 0 ? 3 : _ref$maxHops;
    if (currentPairs === void 0) {
      currentPairs = [];
    }
    if (nextAmountIn === void 0) {
      nextAmountIn = currencyAmountIn;
    }
    if (bestTrades === void 0) {
      bestTrades = [];
    }
    !(pairs.length > 0) ? invariant$1(false) : void 0;
    !(maxHops > 0) ? invariant$1(false) : void 0;
    !(currencyAmountIn === nextAmountIn || currentPairs.length > 0) ? invariant$1(false) : void 0;
    var amountIn = nextAmountIn.wrapped;
    var tokenOut = currencyOut.wrapped;
    for (var i3 = 0; i3 < pairs.length; i3++) {
      var pair = pairs[i3];
      if (!pair.token0.equals(amountIn.currency) && !pair.token1.equals(amountIn.currency))
        continue;
      if (pair.reserve0.equalTo(ZERO$2) || pair.reserve1.equalTo(ZERO$2))
        continue;
      var amountOut = void 0;
      try {
        ;
        var _pair$getOutputAmount2 = pair.getOutputAmount(amountIn);
        amountOut = _pair$getOutputAmount2[0];
      } catch (error) {
        if (error.isInsufficientInputAmountError) {
          continue;
        }
        throw error;
      }
      if (amountOut.currency.equals(tokenOut)) {
        sortedInsert(bestTrades, new Trade2(new Route$1([].concat(currentPairs, [pair]), currencyAmountIn.currency, currencyOut), currencyAmountIn, TradeType$1.EXACT_INPUT), maxNumResults, tradeComparator);
      } else if (maxHops > 1 && pairs.length > 1) {
        var pairsExcludingThisPair = pairs.slice(0, i3).concat(pairs.slice(i3 + 1, pairs.length));
        Trade2.bestTradeExactIn(pairsExcludingThisPair, currencyAmountIn, currencyOut, {
          maxNumResults,
          maxHops: maxHops - 1
        }, [].concat(currentPairs, [pair]), amountOut, bestTrades);
      }
    }
    return bestTrades;
  };
  _proto.worstExecutionPrice = function worstExecutionPrice(slippageTolerance) {
    return new Price$1(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);
  };
  Trade2.bestTradeExactOut = function bestTradeExactOut(pairs, currencyIn, currencyAmountOut, _temp2, currentPairs, nextAmountOut, bestTrades) {
    var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$maxNumResults = _ref2.maxNumResults, maxNumResults = _ref2$maxNumResults === void 0 ? 3 : _ref2$maxNumResults, _ref2$maxHops = _ref2.maxHops, maxHops = _ref2$maxHops === void 0 ? 3 : _ref2$maxHops;
    if (currentPairs === void 0) {
      currentPairs = [];
    }
    if (nextAmountOut === void 0) {
      nextAmountOut = currencyAmountOut;
    }
    if (bestTrades === void 0) {
      bestTrades = [];
    }
    !(pairs.length > 0) ? invariant$1(false) : void 0;
    !(maxHops > 0) ? invariant$1(false) : void 0;
    !(currencyAmountOut === nextAmountOut || currentPairs.length > 0) ? invariant$1(false) : void 0;
    var amountOut = nextAmountOut.wrapped;
    var tokenIn = currencyIn.wrapped;
    for (var i3 = 0; i3 < pairs.length; i3++) {
      var pair = pairs[i3];
      if (!pair.token0.equals(amountOut.currency) && !pair.token1.equals(amountOut.currency))
        continue;
      if (pair.reserve0.equalTo(ZERO$2) || pair.reserve1.equalTo(ZERO$2))
        continue;
      var amountIn = void 0;
      try {
        ;
        var _pair$getInputAmount2 = pair.getInputAmount(amountOut);
        amountIn = _pair$getInputAmount2[0];
      } catch (error) {
        if (error.isInsufficientReservesError) {
          continue;
        }
        throw error;
      }
      if (amountIn.currency.equals(tokenIn)) {
        sortedInsert(bestTrades, new Trade2(new Route$1([pair].concat(currentPairs), currencyIn, currencyAmountOut.currency), currencyAmountOut, TradeType$1.EXACT_OUTPUT), maxNumResults, tradeComparator);
      } else if (maxHops > 1 && pairs.length > 1) {
        var pairsExcludingThisPair = pairs.slice(0, i3).concat(pairs.slice(i3 + 1, pairs.length));
        Trade2.bestTradeExactOut(pairsExcludingThisPair, currencyIn, currencyAmountOut, {
          maxNumResults,
          maxHops: maxHops - 1
        }, [pair].concat(currentPairs), amountIn, bestTrades);
      }
    }
    return bestTrades;
  };
  return Trade2;
}();
function toHex$1(currencyAmount) {
  return "0x" + currencyAmount.quotient.toString(16);
}
var ZERO_HEX = "0x0";
var Router = /* @__PURE__ */ function() {
  function Router2() {
  }
  Router2.swapCallParameters = function swapCallParameters(trade, options) {
    var etherIn = trade.inputAmount.currency.isNative;
    var etherOut = trade.outputAmount.currency.isNative;
    !!(etherIn && etherOut) ? invariant$1(false) : void 0;
    !(!("ttl" in options) || options.ttl > 0) ? invariant$1(false) : void 0;
    var to = validateAndParseAddress$1(options.recipient);
    var amountIn = toHex$1(trade.maximumAmountIn(options.allowedSlippage));
    var amountOut = toHex$1(trade.minimumAmountOut(options.allowedSlippage));
    var path = trade.route.path.map(function(token2) {
      return token2.address;
    });
    var deadline = "ttl" in options ? "0x" + (Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3) + options.ttl).toString(16) : "0x" + options.deadline.toString(16);
    var useFeeOnTransfer = Boolean(options.feeOnTransfer);
    var methodName;
    var args;
    var value;
    switch (trade.tradeType) {
      case TradeType$1.EXACT_INPUT:
        if (etherIn) {
          methodName = useFeeOnTransfer ? "swapExactETHForTokensSupportingFeeOnTransferTokens" : "swapExactETHForTokens";
          args = [amountOut, path, to, deadline];
          value = amountIn;
        } else if (etherOut) {
          methodName = useFeeOnTransfer ? "swapExactTokensForETHSupportingFeeOnTransferTokens" : "swapExactTokensForETH";
          args = [amountIn, amountOut, path, to, deadline];
          value = ZERO_HEX;
        } else {
          methodName = useFeeOnTransfer ? "swapExactTokensForTokensSupportingFeeOnTransferTokens" : "swapExactTokensForTokens";
          args = [amountIn, amountOut, path, to, deadline];
          value = ZERO_HEX;
        }
        break;
      case TradeType$1.EXACT_OUTPUT:
        !!useFeeOnTransfer ? invariant$1(false) : void 0;
        if (etherIn) {
          methodName = "swapETHForExactTokens";
          args = [amountOut, path, to, deadline];
          value = amountIn;
        } else if (etherOut) {
          methodName = "swapTokensForExactETH";
          args = [amountOut, amountIn, path, to, deadline];
          value = ZERO_HEX;
        } else {
          methodName = "swapTokensForExactTokens";
          args = [amountOut, amountIn, path, to, deadline];
          value = ZERO_HEX;
        }
        break;
    }
    return {
      methodName,
      args,
      value
    };
  };
  return Router2;
}();
const v2Sdk_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FACTORY_ADDRESS_MAP: FACTORY_ADDRESS_MAP$1,
  INIT_CODE_HASH: INIT_CODE_HASH$1,
  InsufficientInputAmountError: InsufficientInputAmountError$1,
  InsufficientReservesError: InsufficientReservesError$1,
  MINIMUM_LIQUIDITY: MINIMUM_LIQUIDITY$1,
  Pair: Pair$1,
  Route: Route$1,
  Router,
  Trade,
  computePairAddress: computePairAddress$1,
  inputOutputComparator,
  tradeComparator
}, Symbol.toStringTag, { value: "Module" }));
const require$$9 = /* @__PURE__ */ getAugmentedNamespace(v2Sdk_esm);
const require$$11 = /* @__PURE__ */ getAugmentedNamespace(lib_esm);
(function(exports) {
  function t2(t3) {
    return t3 && "object" == typeof t3 && "default" in t3 ? t3.default : t3;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var e2, n4 = require$$0$2, r2 = t2(jsbiUmdExports), o2 = require$$0$1, u2 = t2(require$$3), i3 = require$$4, a2 = require$$5, c2 = require$$6, s4 = require$$7, p2 = require$$8, d2 = require$$9, l2 = require$$11, m2 = "0x0000000000000000000000000000000000000001", f3 = "0x0000000000000000000000000000000000000002", h4 = r2.BigInt(0), v2 = r2.BigInt(1), A2 = new n4.Percent(h4), y2 = new n4.Percent(100, 100);
  function T2(t3) {
    return Object.keys(t3).some(function(t4) {
      return "recipient" === t4;
    });
  }
  (e2 = exports.ApprovalTypes || (exports.ApprovalTypes = {}))[e2.NOT_REQUIRED = 0] = "NOT_REQUIRED", e2[e2.MAX = 1] = "MAX", e2[e2.MAX_MINUS_ONE = 2] = "MAX_MINUS_ONE", e2[e2.ZERO_THEN_MAX = 3] = "ZERO_THEN_MAX", e2[e2.ZERO_THEN_MAX_MINUS_ONE = 4] = "ZERO_THEN_MAX_MINUS_ONE";
  var w2 = function() {
    function t3() {
    }
    return t3.encodeApproveMax = function(e3) {
      return t3.INTERFACE.encodeFunctionData("approveMax", [e3.address]);
    }, t3.encodeApproveMaxMinusOne = function(e3) {
      return t3.INTERFACE.encodeFunctionData("approveMaxMinusOne", [e3.address]);
    }, t3.encodeApproveZeroThenMax = function(e3) {
      return t3.INTERFACE.encodeFunctionData("approveZeroThenMax", [e3.address]);
    }, t3.encodeApproveZeroThenMaxMinusOne = function(e3) {
      return t3.INTERFACE.encodeFunctionData("approveZeroThenMaxMinusOne", [e3.address]);
    }, t3.encodeCallPositionManager = function(e3) {
      if (e3.length > 0 || u2(false), 1 == e3.length)
        return t3.INTERFACE.encodeFunctionData("callPositionManager", e3);
      var n5 = a2.NonfungiblePositionManager.INTERFACE.encodeFunctionData("multicall", [e3]);
      return t3.INTERFACE.encodeFunctionData("callPositionManager", [n5]);
    }, t3.encodeAddLiquidity = function(e3, n5, o3, u3) {
      var i4 = e3.mintAmountsWithSlippage(u3), c3 = i4.amount0, s5 = i4.amount1;
      return r2.lessThan(n5.amount0.quotient, c3) && (c3 = n5.amount0.quotient), r2.lessThan(n5.amount1.quotient, s5) && (s5 = n5.amount1.quotient), T2(o3) ? t3.INTERFACE.encodeFunctionData("mint", [{ token0: e3.pool.token0.address, token1: e3.pool.token1.address, fee: e3.pool.fee, tickLower: e3.tickLower, tickUpper: e3.tickUpper, amount0Min: a2.toHex(c3), amount1Min: a2.toHex(s5), recipient: o3.recipient }]) : t3.INTERFACE.encodeFunctionData("increaseLiquidity", [{ token0: e3.pool.token0.address, token1: e3.pool.token1.address, amount0Min: a2.toHex(c3), amount1Min: a2.toHex(s5), tokenId: a2.toHex(o3.tokenId) }]);
    }, t3.encodeApprove = function(e3, n5) {
      switch (n5) {
        case exports.ApprovalTypes.MAX:
          return t3.encodeApproveMax(e3.wrapped);
        case exports.ApprovalTypes.MAX_MINUS_ONE:
          return t3.encodeApproveMaxMinusOne(e3.wrapped);
        case exports.ApprovalTypes.ZERO_THEN_MAX:
          return t3.encodeApproveZeroThenMax(e3.wrapped);
        case exports.ApprovalTypes.ZERO_THEN_MAX_MINUS_ONE:
          return t3.encodeApproveZeroThenMaxMinusOne(e3.wrapped);
        default:
          throw "Error: invalid ApprovalType";
      }
    }, t3;
  }();
  w2.INTERFACE = new o2.Interface(i3.abi);
  var x2 = function() {
    function t3() {
    }
    return t3.encodeMulticall = function(e3, n5) {
      if (void 0 === n5)
        return a2.Multicall.encodeMulticall(e3);
      if (Array.isArray(e3) || (e3 = [e3]), "string" == typeof n5 && n5.startsWith("0x")) {
        var r3 = function(t4) {
          if (!t4.match(/^0x[0-9a-fA-F]{64}$/))
            throw new Error(t4 + " is not valid bytes32.");
          return t4.toLowerCase();
        }(n5);
        return t3.INTERFACE.encodeFunctionData("multicall(bytes32,bytes[])", [r3, e3]);
      }
      var o3 = a2.toHex(n5);
      return t3.INTERFACE.encodeFunctionData("multicall(uint256,bytes[])", [o3, e3]);
    }, t3;
  }();
  function E2(t3) {
    return a2.toHex(t3.multiply(1e4).quotient);
  }
  x2.INTERFACE = new o2.Interface(c2.abi);
  var g2 = function() {
    function t3() {
    }
    return t3.encodeUnwrapWETH9 = function(e3, r3, o3) {
      if ("string" == typeof r3)
        return a2.Payments.encodeUnwrapWETH9(e3, r3, o3);
      if (o3) {
        var u3 = E2(o3.fee), i4 = n4.validateAndParseAddress(o3.recipient);
        return t3.INTERFACE.encodeFunctionData("unwrapWETH9WithFee(uint256,uint256,address)", [a2.toHex(e3), u3, i4]);
      }
      return t3.INTERFACE.encodeFunctionData("unwrapWETH9(uint256)", [a2.toHex(e3)]);
    }, t3.encodeSweepToken = function(e3, r3, o3, u3) {
      if ("string" == typeof o3)
        return a2.Payments.encodeSweepToken(e3, r3, o3, u3);
      if (u3) {
        var i4 = E2(u3.fee), c3 = n4.validateAndParseAddress(u3.recipient);
        return t3.INTERFACE.encodeFunctionData("sweepTokenWithFee(address,uint256,uint256,address)", [e3.address, a2.toHex(r3), i4, c3]);
      }
      return t3.INTERFACE.encodeFunctionData("sweepToken(address,uint256)", [e3.address, a2.toHex(r3)]);
    }, t3.encodePull = function(e3, n5) {
      return t3.INTERFACE.encodeFunctionData("pull", [e3.address, a2.toHex(n5)]);
    }, t3.encodeWrapETH = function(e3) {
      return t3.INTERFACE.encodeFunctionData("wrapETH", [a2.toHex(e3)]);
    }, t3;
  }();
  function k4(t3, e3, n5, r3, o3, u3, i4) {
    try {
      var a3 = t3[u3](i4), c3 = a3.value;
    } catch (t4) {
      return void n5(t4);
    }
    a3.done ? e3(c3) : Promise.resolve(c3).then(r3, o3);
  }
  function I3(t3) {
    return function() {
      var e3 = this, n5 = arguments;
      return new Promise(function(r3, o3) {
        var u3 = t3.apply(e3, n5);
        function i4(t4) {
          k4(u3, r3, o3, i4, a3, "next", t4);
        }
        function a3(t4) {
          k4(u3, r3, o3, i4, a3, "throw", t4);
        }
        i4(void 0);
      });
    };
  }
  function P2(t3, e3) {
    for (var n5 = 0; n5 < e3.length; n5++) {
      var r3 = e3[n5];
      r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t3, r3.key, r3);
    }
  }
  function R3(t3, e3, n5) {
    return e3 && P2(t3.prototype, e3), n5 && P2(t3, n5), t3;
  }
  function b3() {
    return (b3 = Object.assign || function(t3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var n5 = arguments[e3];
        for (var r3 in n5)
          Object.prototype.hasOwnProperty.call(n5, r3) && (t3[r3] = n5[r3]);
      }
      return t3;
    }).apply(this, arguments);
  }
  function _2(t3, e3) {
    t3.prototype = Object.create(e3.prototype), t3.prototype.constructor = t3, (Object.setPrototypeOf || function(t4, e4) {
      return t4.__proto__ = e4, t4;
    })(t3, e3);
  }
  function N2(t3, e3) {
    (null == e3 || e3 > t3.length) && (e3 = t3.length);
    for (var n5 = 0, r3 = new Array(e3); n5 < e3; n5++)
      r3[n5] = t3[n5];
    return r3;
  }
  function O2(t3, e3) {
    var n5 = "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
    if (n5)
      return (n5 = n5.call(t3)).next.bind(n5);
    if (Array.isArray(t3) || (n5 = function(t4, e4) {
      if (t4) {
        if ("string" == typeof t4)
          return N2(t4, void 0);
        var n6 = Object.prototype.toString.call(t4).slice(8, -1);
        return "Object" === n6 && t4.constructor && (n6 = t4.constructor.name), "Map" === n6 || "Set" === n6 ? Array.from(t4) : "Arguments" === n6 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n6) ? N2(t4, void 0) : void 0;
      }
    }(t3)) || e3 && t3 && "number" == typeof t3.length) {
      n5 && (t3 = n5);
      var r3 = 0;
      return function() {
        return r3 >= t3.length ? { done: true } : { done: false, value: t3[r3++] };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  g2.INTERFACE = new o2.Interface(s4.abi);
  var F2, q2 = (function(t3) {
    var e3 = function(t4) {
      var e4 = Object.prototype, n5 = e4.hasOwnProperty, r3 = "function" == typeof Symbol ? Symbol : {}, o3 = r3.iterator || "@@iterator", u3 = r3.asyncIterator || "@@asyncIterator", i4 = r3.toStringTag || "@@toStringTag";
      function a3(t5, e5, n6) {
        return Object.defineProperty(t5, e5, { value: n6, enumerable: true, configurable: true, writable: true }), t5[e5];
      }
      try {
        a3({}, "");
      } catch (t5) {
        a3 = function(t6, e5, n6) {
          return t6[e5] = n6;
        };
      }
      function c3(t5, e5, n6, r4) {
        var o4 = Object.create((e5 && e5.prototype instanceof d3 ? e5 : d3).prototype), u4 = new g3(r4 || []);
        return o4._invoke = /* @__PURE__ */ function(t6, e6, n7) {
          var r5 = "suspendedStart";
          return function(o5, u5) {
            if ("executing" === r5)
              throw new Error("Generator is already running");
            if ("completed" === r5) {
              if ("throw" === o5)
                throw u5;
              return { value: void 0, done: true };
            }
            for (n7.method = o5, n7.arg = u5; ; ) {
              var i5 = n7.delegate;
              if (i5) {
                var a4 = w3(i5, n7);
                if (a4) {
                  if (a4 === p3)
                    continue;
                  return a4;
                }
              }
              if ("next" === n7.method)
                n7.sent = n7._sent = n7.arg;
              else if ("throw" === n7.method) {
                if ("suspendedStart" === r5)
                  throw r5 = "completed", n7.arg;
                n7.dispatchException(n7.arg);
              } else
                "return" === n7.method && n7.abrupt("return", n7.arg);
              r5 = "executing";
              var c4 = s5(t6, e6, n7);
              if ("normal" === c4.type) {
                if (r5 = n7.done ? "completed" : "suspendedYield", c4.arg === p3)
                  continue;
                return { value: c4.arg, done: n7.done };
              }
              "throw" === c4.type && (r5 = "completed", n7.method = "throw", n7.arg = c4.arg);
            }
          };
        }(t5, n6, u4), o4;
      }
      function s5(t5, e5, n6) {
        try {
          return { type: "normal", arg: t5.call(e5, n6) };
        } catch (t6) {
          return { type: "throw", arg: t6 };
        }
      }
      t4.wrap = c3;
      var p3 = {};
      function d3() {
      }
      function l3() {
      }
      function m3() {
      }
      var f4 = {};
      a3(f4, o3, function() {
        return this;
      });
      var h5 = Object.getPrototypeOf, v3 = h5 && h5(h5(k5([])));
      v3 && v3 !== e4 && n5.call(v3, o3) && (f4 = v3);
      var A3 = m3.prototype = d3.prototype = Object.create(f4);
      function y3(t5) {
        ["next", "throw", "return"].forEach(function(e5) {
          a3(t5, e5, function(t6) {
            return this._invoke(e5, t6);
          });
        });
      }
      function T3(t5, e5) {
        var r4;
        this._invoke = function(o4, u4) {
          function i5() {
            return new e5(function(r5, i6) {
              !function r6(o5, u5, i7, a4) {
                var c4 = s5(t5[o5], t5, u5);
                if ("throw" !== c4.type) {
                  var p4 = c4.arg, d4 = p4.value;
                  return d4 && "object" == typeof d4 && n5.call(d4, "__await") ? e5.resolve(d4.__await).then(function(t6) {
                    r6("next", t6, i7, a4);
                  }, function(t6) {
                    r6("throw", t6, i7, a4);
                  }) : e5.resolve(d4).then(function(t6) {
                    p4.value = t6, i7(p4);
                  }, function(t6) {
                    return r6("throw", t6, i7, a4);
                  });
                }
                a4(c4.arg);
              }(o4, u4, r5, i6);
            });
          }
          return r4 = r4 ? r4.then(i5, i5) : i5();
        };
      }
      function w3(t5, e5) {
        var n6 = t5.iterator[e5.method];
        if (void 0 === n6) {
          if (e5.delegate = null, "throw" === e5.method) {
            if (t5.iterator.return && (e5.method = "return", e5.arg = void 0, w3(t5, e5), "throw" === e5.method))
              return p3;
            e5.method = "throw", e5.arg = new TypeError("The iterator does not provide a 'throw' method");
          }
          return p3;
        }
        var r4 = s5(n6, t5.iterator, e5.arg);
        if ("throw" === r4.type)
          return e5.method = "throw", e5.arg = r4.arg, e5.delegate = null, p3;
        var o4 = r4.arg;
        return o4 ? o4.done ? (e5[t5.resultName] = o4.value, e5.next = t5.nextLoc, "return" !== e5.method && (e5.method = "next", e5.arg = void 0), e5.delegate = null, p3) : o4 : (e5.method = "throw", e5.arg = new TypeError("iterator result is not an object"), e5.delegate = null, p3);
      }
      function x3(t5) {
        var e5 = { tryLoc: t5[0] };
        1 in t5 && (e5.catchLoc = t5[1]), 2 in t5 && (e5.finallyLoc = t5[2], e5.afterLoc = t5[3]), this.tryEntries.push(e5);
      }
      function E3(t5) {
        var e5 = t5.completion || {};
        e5.type = "normal", delete e5.arg, t5.completion = e5;
      }
      function g3(t5) {
        this.tryEntries = [{ tryLoc: "root" }], t5.forEach(x3, this), this.reset(true);
      }
      function k5(t5) {
        if (t5) {
          var e5 = t5[o3];
          if (e5)
            return e5.call(t5);
          if ("function" == typeof t5.next)
            return t5;
          if (!isNaN(t5.length)) {
            var r4 = -1, u4 = function e6() {
              for (; ++r4 < t5.length; )
                if (n5.call(t5, r4))
                  return e6.value = t5[r4], e6.done = false, e6;
              return e6.value = void 0, e6.done = true, e6;
            };
            return u4.next = u4;
          }
        }
        return { next: I4 };
      }
      function I4() {
        return { value: void 0, done: true };
      }
      return l3.prototype = m3, a3(A3, "constructor", m3), a3(m3, "constructor", l3), l3.displayName = a3(m3, i4, "GeneratorFunction"), t4.isGeneratorFunction = function(t5) {
        var e5 = "function" == typeof t5 && t5.constructor;
        return !!e5 && (e5 === l3 || "GeneratorFunction" === (e5.displayName || e5.name));
      }, t4.mark = function(t5) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t5, m3) : (t5.__proto__ = m3, a3(t5, i4, "GeneratorFunction")), t5.prototype = Object.create(A3), t5;
      }, t4.awrap = function(t5) {
        return { __await: t5 };
      }, y3(T3.prototype), a3(T3.prototype, u3, function() {
        return this;
      }), t4.AsyncIterator = T3, t4.async = function(e5, n6, r4, o4, u4) {
        void 0 === u4 && (u4 = Promise);
        var i5 = new T3(c3(e5, n6, r4, o4), u4);
        return t4.isGeneratorFunction(n6) ? i5 : i5.next().then(function(t5) {
          return t5.done ? t5.value : i5.next();
        });
      }, y3(A3), a3(A3, i4, "Generator"), a3(A3, o3, function() {
        return this;
      }), a3(A3, "toString", function() {
        return "[object Generator]";
      }), t4.keys = function(t5) {
        var e5 = [];
        for (var n6 in t5)
          e5.push(n6);
        return e5.reverse(), function n7() {
          for (; e5.length; ) {
            var r4 = e5.pop();
            if (r4 in t5)
              return n7.value = r4, n7.done = false, n7;
          }
          return n7.done = true, n7;
        };
      }, t4.values = k5, g3.prototype = { constructor: g3, reset: function(t5) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(E3), !t5)
          for (var e5 in this)
            "t" === e5.charAt(0) && n5.call(this, e5) && !isNaN(+e5.slice(1)) && (this[e5] = void 0);
      }, stop: function() {
        this.done = true;
        var t5 = this.tryEntries[0].completion;
        if ("throw" === t5.type)
          throw t5.arg;
        return this.rval;
      }, dispatchException: function(t5) {
        if (this.done)
          throw t5;
        var e5 = this;
        function r4(n6, r5) {
          return i5.type = "throw", i5.arg = t5, e5.next = n6, r5 && (e5.method = "next", e5.arg = void 0), !!r5;
        }
        for (var o4 = this.tryEntries.length - 1; o4 >= 0; --o4) {
          var u4 = this.tryEntries[o4], i5 = u4.completion;
          if ("root" === u4.tryLoc)
            return r4("end");
          if (u4.tryLoc <= this.prev) {
            var a4 = n5.call(u4, "catchLoc"), c4 = n5.call(u4, "finallyLoc");
            if (a4 && c4) {
              if (this.prev < u4.catchLoc)
                return r4(u4.catchLoc, true);
              if (this.prev < u4.finallyLoc)
                return r4(u4.finallyLoc);
            } else if (a4) {
              if (this.prev < u4.catchLoc)
                return r4(u4.catchLoc, true);
            } else {
              if (!c4)
                throw new Error("try statement without catch or finally");
              if (this.prev < u4.finallyLoc)
                return r4(u4.finallyLoc);
            }
          }
        }
      }, abrupt: function(t5, e5) {
        for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
          var o4 = this.tryEntries[r4];
          if (o4.tryLoc <= this.prev && n5.call(o4, "finallyLoc") && this.prev < o4.finallyLoc) {
            var u4 = o4;
            break;
          }
        }
        u4 && ("break" === t5 || "continue" === t5) && u4.tryLoc <= e5 && e5 <= u4.finallyLoc && (u4 = null);
        var i5 = u4 ? u4.completion : {};
        return i5.type = t5, i5.arg = e5, u4 ? (this.method = "next", this.next = u4.finallyLoc, p3) : this.complete(i5);
      }, complete: function(t5, e5) {
        if ("throw" === t5.type)
          throw t5.arg;
        return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && e5 && (this.next = e5), p3;
      }, finish: function(t5) {
        for (var e5 = this.tryEntries.length - 1; e5 >= 0; --e5) {
          var n6 = this.tryEntries[e5];
          if (n6.finallyLoc === t5)
            return this.complete(n6.completion, n6.afterLoc), E3(n6), p3;
        }
      }, catch: function(t5) {
        for (var e5 = this.tryEntries.length - 1; e5 >= 0; --e5) {
          var n6 = this.tryEntries[e5];
          if (n6.tryLoc === t5) {
            var r4 = n6.completion;
            if ("throw" === r4.type) {
              var o4 = r4.arg;
              E3(n6);
            }
            return o4;
          }
        }
        throw new Error("illegal catch attempt");
      }, delegateYield: function(t5, e5, n6) {
        return this.delegate = { iterator: k5(t5), resultName: e5, nextLoc: n6 }, "next" === this.method && (this.arg = void 0), p3;
      } }, t4;
    }(t3.exports);
    try {
      regeneratorRuntime = e3;
    } catch (t4) {
      "object" == typeof globalThis ? globalThis.regeneratorRuntime = e3 : Function("r", "regeneratorRuntime = r")(e3);
    }
  }(F2 = { exports: {} }), F2.exports), C2 = function() {
    function t3(t4, e3, n5) {
      this._midPrice = null, t4.length > 0 || u2(false);
      var r3 = t4[0].chainId;
      t4.every(function(t5) {
        return t5.chainId === r3;
      }) || u2(false);
      var o3 = e3.wrapped;
      t4[0].involvesToken(o3) || u2(false), t4[t4.length - 1].involvesToken(n5.wrapped) || u2(false);
      for (var i4, a3 = [o3], c3 = O2(t4.entries()); !(i4 = c3()).done; ) {
        var s5 = i4.value, p3 = s5[1], d3 = a3[s5[0]];
        d3.equals(p3.token0) || d3.equals(p3.token1) || u2(false);
        var l3 = d3.equals(p3.token0) ? p3.token1 : p3.token0;
        a3.push(l3);
      }
      this.pools = t4, this.path = a3, this.input = e3, this.output = null != n5 ? n5 : a3[a3.length - 1];
    }
    return R3(t3, [{ key: "chainId", get: function() {
      return this.pools[0].chainId;
    } }, { key: "midPrice", get: function() {
      if (null !== this._midPrice)
        return this._midPrice;
      var t4 = this.pools.slice(1).reduce(function(t5, e3) {
        var n5 = t5.price;
        return t5.nextInput.equals(e3.token0) ? { nextInput: e3.token1, price: n5.multiply(e3.token0Price) } : { nextInput: e3.token0, price: n5.multiply(e3.token1Price) };
      }, this.pools[0].token0.equals(this.input.wrapped) ? { nextInput: this.pools[0].token1, price: this.pools[0].token0Price } : { nextInput: this.pools[0].token0, price: this.pools[0].token1Price }).price;
      return this._midPrice = new n4.Price(this.input, this.output, t4.denominator, t4.numerator);
    } }]), t3;
  }();
  function M3(t3, e3) {
    return t3.inputAmount.currency.equals(e3.inputAmount.currency) || u2(false), t3.outputAmount.currency.equals(e3.outputAmount.currency) || u2(false), t3.outputAmount.equalTo(e3.outputAmount) ? t3.inputAmount.equalTo(e3.inputAmount) ? t3.swaps.reduce(function(t4, e4) {
      return t4 + e4.route.path.length;
    }, 0) - e3.swaps.reduce(function(t4, e4) {
      return t4 + e4.route.path.length;
    }, 0) : t3.inputAmount.lessThan(e3.inputAmount) ? -1 : 1 : t3.outputAmount.lessThan(e3.outputAmount) ? 1 : -1;
  }
  var S4, H4 = function() {
    function t3(t4) {
      var e4 = t4.routes, r3 = t4.tradeType, o3 = e4[0].inputAmount.currency, i4 = e4[0].outputAmount.currency;
      e4.every(function(t5) {
        return o3.wrapped.equals(t5.route.input.wrapped);
      }) || u2(false), e4.every(function(t5) {
        return i4.wrapped.equals(t5.route.output.wrapped);
      }) || u2(false);
      for (var c3, s5 = e4.map(function(t5) {
        return t5.route.pools.length;
      }).reduce(function(t5, e5) {
        return t5 + e5;
      }, 0), p3 = /* @__PURE__ */ new Set(), l3 = O2(e4); !(c3 = l3()).done; )
        for (var m3, f4 = O2(c3.value.route.pools); !(m3 = f4()).done; ) {
          var h5 = m3.value;
          p3.add(h5 instanceof a2.Pool ? a2.Pool.getAddress(h5.token0, h5.token1, h5.fee) : d2.Pair.getAddress(h5.token0, h5.token1));
        }
      s5 != p3.size && u2(false), r3 !== n4.TradeType.EXACT_INPUT && u2(false), this.swaps = e4, this.tradeType = r3;
    }
    t3.fromRoute = function() {
      var e4 = I3(q2.mark(function e5(r3, o3, i4) {
        var a3, c3, s5, p3, d3;
        return q2.wrap(function(e6) {
          for (; ; )
            switch (e6.prev = e6.next) {
              case 0:
                a3 = new Array(r3.path.length), i4 !== n4.TradeType.EXACT_INPUT && u2(false), o3.currency.equals(r3.input) || u2(false), a3[0] = o3.wrapped, p3 = 0;
              case 5:
                if (!(p3 < r3.path.length - 1)) {
                  e6.next = 15;
                  break;
                }
                return d3 = r3.pools[p3], e6.next = 9, d3.getOutputAmount(a3[p3]);
              case 9:
                a3[p3 + 1] = e6.sent[0];
              case 12:
                p3++, e6.next = 5;
                break;
              case 15:
                return c3 = n4.CurrencyAmount.fromFractionalAmount(r3.input, o3.numerator, o3.denominator), s5 = n4.CurrencyAmount.fromFractionalAmount(r3.output, a3[a3.length - 1].numerator, a3[a3.length - 1].denominator), e6.abrupt("return", new t3({ routes: [{ inputAmount: c3, outputAmount: s5, route: r3 }], tradeType: i4 }));
              case 18:
              case "end":
                return e6.stop();
            }
        }, e5);
      }));
      return function(t4, n5, r3) {
        return e4.apply(this, arguments);
      };
    }(), t3.fromRoutes = function() {
      var e4 = I3(q2.mark(function e5(r3, o3) {
        var i4, a3, c3, s5, p3, d3, l3, m3, f4, h5, v3;
        return q2.wrap(function(e6) {
          for (; ; )
            switch (e6.prev = e6.next) {
              case 0:
                i4 = [], o3 !== n4.TradeType.EXACT_INPUT && u2(false), a3 = O2(r3);
              case 3:
                if ((c3 = a3()).done) {
                  e6.next = 26;
                  break;
                }
                p3 = (s5 = c3.value).route, d3 = s5.amount, l3 = new Array(p3.path.length), m3 = void 0, f4 = void 0, d3.currency.equals(p3.input) || u2(false), m3 = n4.CurrencyAmount.fromFractionalAmount(p3.input, d3.numerator, d3.denominator), l3[0] = n4.CurrencyAmount.fromFractionalAmount(p3.input.wrapped, d3.numerator, d3.denominator), h5 = 0;
              case 12:
                if (!(h5 < p3.path.length - 1)) {
                  e6.next = 22;
                  break;
                }
                return v3 = p3.pools[h5], e6.next = 16, v3.getOutputAmount(l3[h5]);
              case 16:
                l3[h5 + 1] = e6.sent[0];
              case 19:
                h5++, e6.next = 12;
                break;
              case 22:
                f4 = n4.CurrencyAmount.fromFractionalAmount(p3.output, l3[l3.length - 1].numerator, l3[l3.length - 1].denominator), i4.push({ route: p3, inputAmount: m3, outputAmount: f4 });
              case 24:
                e6.next = 3;
                break;
              case 26:
                return e6.abrupt("return", new t3({ routes: i4, tradeType: o3 }));
              case 27:
              case "end":
                return e6.stop();
            }
        }, e5);
      }));
      return function(t4, n5) {
        return e4.apply(this, arguments);
      };
    }(), t3.createUncheckedTrade = function(e4) {
      return new t3(b3({}, e4, { routes: [{ inputAmount: e4.inputAmount, outputAmount: e4.outputAmount, route: e4.route }] }));
    }, t3.createUncheckedTradeWithMultipleRoutes = function(e4) {
      return new t3(e4);
    };
    var e3 = t3.prototype;
    return e3.minimumAmountOut = function(t4, e4) {
      void 0 === e4 && (e4 = this.outputAmount), t4.lessThan(h4) && u2(false);
      var r3 = new n4.Fraction(v2).add(t4).invert().multiply(e4.quotient).quotient;
      return n4.CurrencyAmount.fromRawAmount(e4.currency, r3);
    }, e3.maximumAmountIn = function(t4, e4) {
      return void 0 === e4 && (e4 = this.inputAmount), t4.lessThan(h4) && u2(false), e4;
    }, e3.worstExecutionPrice = function(t4) {
      return new n4.Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(t4).quotient, this.minimumAmountOut(t4).quotient);
    }, t3.bestTradeExactIn = function() {
      var e4 = I3(q2.mark(function e5(r3, o3, i4, a3, c3, s5, p3) {
        var l3, m3, f4, v3, A3, y3, T3, w3, x3, E3, g3;
        return q2.wrap(function(e6) {
          for (; ; )
            switch (e6.prev = e6.next) {
              case 0:
                f4 = void 0 === (m3 = (l3 = void 0 === a3 ? {} : a3).maxNumResults) ? 3 : m3, A3 = void 0 === (v3 = l3.maxHops) ? 3 : v3, void 0 === c3 && (c3 = []), void 0 === s5 && (s5 = o3), void 0 === p3 && (p3 = []), r3.length > 0 || u2(false), A3 > 0 || u2(false), o3 === s5 || c3.length > 0 || u2(false), y3 = s5.wrapped, T3 = i4.wrapped, w3 = 0;
              case 10:
                if (!(w3 < r3.length)) {
                  e6.next = 49;
                  break;
                }
                if ((x3 = r3[w3]).token0.equals(y3.currency) || x3.token1.equals(y3.currency)) {
                  e6.next = 14;
                  break;
                }
                return e6.abrupt("continue", 46);
              case 14:
                if (!(x3 instanceof d2.Pair)) {
                  e6.next = 17;
                  break;
                }
                if (!x3.reserve0.equalTo(h4) && !x3.reserve1.equalTo(h4)) {
                  e6.next = 17;
                  break;
                }
                return e6.abrupt("continue", 46);
              case 17:
                return E3 = void 0, e6.prev = 18, e6.next = 22, x3.getOutputAmount(y3);
              case 22:
                E3 = e6.sent[0], e6.next = 31;
                break;
              case 26:
                if (e6.prev = 26, e6.t0 = e6.catch(18), !e6.t0.isInsufficientInputAmountError) {
                  e6.next = 30;
                  break;
                }
                return e6.abrupt("continue", 46);
              case 30:
                throw e6.t0;
              case 31:
                if (!E3.currency.isToken || !E3.currency.equals(T3)) {
                  e6.next = 42;
                  break;
                }
                return e6.t1 = n4.sortedInsert, e6.t2 = p3, e6.next = 36, t3.fromRoute(new C2([].concat(c3, [x3]), o3.currency, i4), o3, n4.TradeType.EXACT_INPUT);
              case 36:
                e6.t3 = e6.sent, e6.t4 = f4, e6.t5 = M3, (0, e6.t1)(e6.t2, e6.t3, e6.t4, e6.t5), e6.next = 46;
                break;
              case 42:
                if (!(A3 > 1 && r3.length > 1)) {
                  e6.next = 46;
                  break;
                }
                return g3 = r3.slice(0, w3).concat(r3.slice(w3 + 1, r3.length)), e6.next = 46, t3.bestTradeExactIn(g3, o3, i4, { maxNumResults: f4, maxHops: A3 - 1 }, [].concat(c3, [x3]), E3, p3);
              case 46:
                w3++, e6.next = 10;
                break;
              case 49:
                return e6.abrupt("return", p3);
              case 50:
              case "end":
                return e6.stop();
            }
        }, e5, null, [[18, 26]]);
      }));
      return function(t4, n5, r3, o3, u3, i4, a3) {
        return e4.apply(this, arguments);
      };
    }(), R3(t3, [{ key: "route", get: function() {
      return 1 != this.swaps.length && u2(false), this.swaps[0].route;
    } }, { key: "inputAmount", get: function() {
      if (this._inputAmount)
        return this._inputAmount;
      var t4 = this.swaps[0].inputAmount.currency, e4 = this.swaps.map(function(t5) {
        return t5.inputAmount;
      }).reduce(function(t5, e5) {
        return t5.add(e5);
      }, n4.CurrencyAmount.fromRawAmount(t4, 0));
      return this._inputAmount = e4, this._inputAmount;
    } }, { key: "outputAmount", get: function() {
      if (this._outputAmount)
        return this._outputAmount;
      var t4 = this.swaps[0].outputAmount.currency, e4 = this.swaps.map(function(t5) {
        return t5.outputAmount;
      }).reduce(function(t5, e5) {
        return t5.add(e5);
      }, n4.CurrencyAmount.fromRawAmount(t4, 0));
      return this._outputAmount = e4, this._outputAmount;
    } }, { key: "executionPrice", get: function() {
      var t4;
      return null != (t4 = this._executionPrice) ? t4 : this._executionPrice = new n4.Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);
    } }, { key: "priceImpact", get: function() {
      if (this._priceImpact)
        return this._priceImpact;
      for (var t4, e4 = n4.CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0), r3 = O2(this.swaps); !(t4 = r3()).done; ) {
        var o3 = t4.value;
        e4 = e4.add(o3.route.midPrice.quote(o3.inputAmount));
      }
      var u3 = e4.subtract(this.outputAmount).divide(e4);
      return this._priceImpact = new n4.Percent(u3.numerator, u3.denominator), this._priceImpact;
    } }]), t3;
  }();
  (S4 = exports.Protocol || (exports.Protocol = {})).V2 = "V2", S4.V3 = "V3", S4.MIXED = "MIXED";
  var U2 = function(t3) {
    function e3(e4) {
      var n5;
      return (n5 = t3.call(this, e4.pairs, e4.input, e4.output) || this).protocol = exports.Protocol.V2, n5.pools = n5.pairs, n5;
    }
    return _2(e3, t3), e3;
  }(d2.Route), D2 = function(t3) {
    function e3(e4) {
      var n5;
      return (n5 = t3.call(this, e4.pools, e4.input, e4.output) || this).protocol = exports.Protocol.V3, n5.path = e4.tokenPath, n5;
    }
    return _2(e3, t3), e3;
  }(a2.Route), L4 = function(t3) {
    function e3(e4) {
      var n5;
      return (n5 = t3.call(this, e4.pools, e4.input, e4.output) || this).protocol = exports.Protocol.MIXED, n5;
    }
    return _2(e3, t3), e3;
  }(C2), X2 = function() {
    function t3(t4) {
      var e4 = t4.v2Routes, n5 = t4.v3Routes, r3 = t4.tradeType, o3 = t4.mixedRoutes;
      this.swaps = [], this.routes = [];
      for (var i4, c3 = O2(e4); !(i4 = c3()).done; ) {
        var s5 = i4.value, p3 = s5.inputAmount, l3 = s5.outputAmount, m3 = new U2(s5.routev2);
        this.routes.push(m3), this.swaps.push({ route: m3, inputAmount: p3, outputAmount: l3 });
      }
      for (var f4, h5 = O2(n5); !(f4 = h5()).done; ) {
        var v3 = f4.value, A3 = v3.inputAmount, y3 = v3.outputAmount, T3 = new D2(v3.routev3);
        this.routes.push(T3), this.swaps.push({ route: T3, inputAmount: A3, outputAmount: y3 });
      }
      if (o3)
        for (var w3, x3 = O2(o3); !(w3 = x3()).done; ) {
          var E3 = w3.value, g3 = E3.inputAmount, k5 = E3.outputAmount, I4 = new L4(E3.mixedRoute);
          this.routes.push(I4), this.swaps.push({ route: I4, inputAmount: g3, outputAmount: k5 });
        }
      if (0 === this.swaps.length)
        throw new Error("No routes provided when calling Trade constructor");
      this.tradeType = r3;
      var P3 = this.swaps[0].inputAmount.currency, R4 = this.swaps[0].outputAmount.currency;
      this.swaps.every(function(t5) {
        return P3.wrapped.equals(t5.route.input.wrapped);
      }) || u2(false), this.swaps.every(function(t5) {
        return R4.wrapped.equals(t5.route.output.wrapped);
      }) || u2(false);
      for (var b4, _3 = this.swaps.map(function(t5) {
        return t5.route.pools.length;
      }).reduce(function(t5, e5) {
        return t5 + e5;
      }, 0), N3 = /* @__PURE__ */ new Set(), F3 = O2(this.swaps); !(b4 = F3()).done; )
        for (var q3, C3 = O2(b4.value.route.pools); !(q3 = C3()).done; ) {
          var M4 = q3.value;
          if (M4 instanceof a2.Pool)
            N3.add(a2.Pool.getAddress(M4.token0, M4.token1, M4.fee));
          else {
            if (!(M4 instanceof d2.Pair))
              throw new Error("Unexpected pool type in route when constructing trade object");
            N3.add(d2.Pair.getAddress(M4.token0, M4.token1));
          }
        }
      _3 != N3.size && u2(false);
    }
    var e3 = t3.prototype;
    return e3.minimumAmountOut = function(t4, e4) {
      if (void 0 === e4 && (e4 = this.outputAmount), t4.lessThan(h4) && u2(false), this.tradeType === n4.TradeType.EXACT_OUTPUT)
        return e4;
      var r3 = new n4.Fraction(v2).add(t4).invert().multiply(e4.quotient).quotient;
      return n4.CurrencyAmount.fromRawAmount(e4.currency, r3);
    }, e3.maximumAmountIn = function(t4, e4) {
      if (void 0 === e4 && (e4 = this.inputAmount), t4.lessThan(h4) && u2(false), this.tradeType === n4.TradeType.EXACT_INPUT)
        return e4;
      var r3 = new n4.Fraction(v2).add(t4).multiply(e4.quotient).quotient;
      return n4.CurrencyAmount.fromRawAmount(e4.currency, r3);
    }, e3.worstExecutionPrice = function(t4) {
      return new n4.Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(t4).quotient, this.minimumAmountOut(t4).quotient);
    }, t3.fromRoutes = function() {
      var e4 = I3(q2.mark(function e5(n5, r3, o3, u3) {
        var i4, c3, s5, p3, l3, m3, f4, h5, v3, A3, y3, T3, w3, x3, E3, g3, k5, I4, P3, R4;
        return q2.wrap(function(e6) {
          for (; ; )
            switch (e6.prev = e6.next) {
              case 0:
                for (i4 = [], c3 = [], s5 = [], p3 = O2(n5); !(l3 = p3()).done; )
                  h5 = new d2.Trade(f4 = (m3 = l3.value).routev2, m3.amount, o3), i4.push({ routev2: f4, inputAmount: h5.inputAmount, outputAmount: h5.outputAmount });
                v3 = O2(r3);
              case 5:
                if ((A3 = v3()).done) {
                  e6.next = 14;
                  break;
                }
                return T3 = (y3 = A3.value).routev3, w3 = y3.amount, e6.next = 9, a2.Trade.fromRoute(T3, w3, o3);
              case 9:
                c3.push({ routev3: T3, inputAmount: (x3 = e6.sent).inputAmount, outputAmount: x3.outputAmount });
              case 12:
                e6.next = 5;
                break;
              case 14:
                if (!u3) {
                  e6.next = 25;
                  break;
                }
                E3 = O2(u3);
              case 16:
                if ((g3 = E3()).done) {
                  e6.next = 25;
                  break;
                }
                return I4 = (k5 = g3.value).mixedRoute, P3 = k5.amount, e6.next = 20, H4.fromRoute(I4, P3, o3);
              case 20:
                s5.push({ mixedRoute: I4, inputAmount: (R4 = e6.sent).inputAmount, outputAmount: R4.outputAmount });
              case 23:
                e6.next = 16;
                break;
              case 25:
                return e6.abrupt("return", new t3({ v2Routes: i4, v3Routes: c3, mixedRoutes: s5, tradeType: o3 }));
              case 26:
              case "end":
                return e6.stop();
            }
        }, e5);
      }));
      return function(t4, n5, r3, o3) {
        return e4.apply(this, arguments);
      };
    }(), t3.fromRoute = function() {
      var e4 = I3(q2.mark(function e5(n5, r3, o3) {
        var u3, i4, c3, s5, p3, l3;
        return q2.wrap(function(e6) {
          for (; ; )
            switch (e6.prev = e6.next) {
              case 0:
                if (u3 = [], i4 = [], c3 = [], !(n5 instanceof d2.Route)) {
                  e6.next = 9;
                  break;
                }
                s5 = new d2.Trade(n5, r3, o3), u3 = [{ routev2: n5, inputAmount: s5.inputAmount, outputAmount: s5.outputAmount }], e6.next = 26;
                break;
              case 9:
                if (!(n5 instanceof a2.Route)) {
                  e6.next = 17;
                  break;
                }
                return e6.next = 12, a2.Trade.fromRoute(n5, r3, o3);
              case 12:
                i4 = [{ routev3: n5, inputAmount: (p3 = e6.sent).inputAmount, outputAmount: p3.outputAmount }], e6.next = 26;
                break;
              case 17:
                if (!(n5 instanceof C2)) {
                  e6.next = 25;
                  break;
                }
                return e6.next = 20, H4.fromRoute(n5, r3, o3);
              case 20:
                c3 = [{ mixedRoute: n5, inputAmount: (l3 = e6.sent).inputAmount, outputAmount: l3.outputAmount }], e6.next = 26;
                break;
              case 25:
                throw new Error("Invalid route type");
              case 26:
                return e6.abrupt("return", new t3({ v2Routes: u3, v3Routes: i4, mixedRoutes: c3, tradeType: o3 }));
              case 27:
              case "end":
                return e6.stop();
            }
        }, e5);
      }));
      return function(t4, n5, r3) {
        return e4.apply(this, arguments);
      };
    }(), R3(t3, [{ key: "inputAmount", get: function() {
      if (this._inputAmount)
        return this._inputAmount;
      var t4 = this.swaps[0].inputAmount.currency, e4 = this.swaps.map(function(t5) {
        return t5.inputAmount;
      }).reduce(function(t5, e5) {
        return t5.add(e5);
      }, n4.CurrencyAmount.fromRawAmount(t4, 0));
      return this._inputAmount = e4, this._inputAmount;
    } }, { key: "outputAmount", get: function() {
      if (this._outputAmount)
        return this._outputAmount;
      var t4 = this.swaps[0].outputAmount.currency, e4 = this.swaps.map(function(t5) {
        return t5.outputAmount;
      }).reduce(function(t5, e5) {
        return t5.add(e5);
      }, n4.CurrencyAmount.fromRawAmount(t4, 0));
      return this._outputAmount = e4, this._outputAmount;
    } }, { key: "executionPrice", get: function() {
      var t4;
      return null != (t4 = this._executionPrice) ? t4 : this._executionPrice = new n4.Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);
    } }, { key: "inputTax", get: function() {
      var t4 = this.inputAmount.currency;
      return t4.isNative || !t4.wrapped.sellFeeBps ? A2 : new n4.Percent(t4.wrapped.sellFeeBps.toNumber(), 1e4);
    } }, { key: "outputTax", get: function() {
      var t4 = this.outputAmount.currency;
      return t4.isNative || !t4.wrapped.buyFeeBps ? A2 : new n4.Percent(t4.wrapped.buyFeeBps.toNumber(), 1e4);
    } }, { key: "priceImpact", get: function() {
      if (this._priceImpact)
        return this._priceImpact;
      if (this.outputTax.equalTo(y2))
        return A2;
      for (var t4, e4 = n4.CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0), r3 = O2(this.swaps); !(t4 = r3()).done; ) {
        var o3 = t4.value, u3 = o3.route.midPrice, i4 = o3.inputAmount.multiply(new n4.Fraction(v2).subtract(this.inputTax));
        e4 = e4.add(u3.quote(i4));
      }
      if (e4.equalTo(h4))
        return A2;
      var a3 = this.outputAmount.divide(new n4.Fraction(v2).subtract(this.outputTax)), c3 = e4.subtract(a3).divide(e4);
      return this._priceImpact = new n4.Percent(c3.numerator, c3.denominator), this._priceImpact;
    } }]), t3;
  }();
  function j2(t3) {
    var e3 = t3.pools.reduce(function(t4, e4, n5) {
      var r3 = t4.inputToken, o3 = t4.path, u3 = t4.types, i4 = e4.token0.equals(r3) ? e4.token1 : e4.token0;
      return 0 === n5 ? { inputToken: i4, types: ["address", "uint24", "address"], path: [r3.address, e4 instanceof a2.Pool ? e4.fee : 8388608, i4.address] } : { inputToken: i4, types: [].concat(u3, ["uint24", "address"]), path: [].concat(o3, [e4 instanceof a2.Pool ? e4.fee : 8388608, i4.address]) };
    }, { inputToken: t3.input.wrapped, path: [], types: [] });
    return l2.pack(e3.types, e3.path);
  }
  var W2 = function(t3) {
    for (var e3 = [], n5 = 0, r3 = 0; r3 < t3.pools.length; )
      (t3.pools[n5] instanceof a2.Pool && t3.pools[r3] instanceof d2.Pair || t3.pools[n5] instanceof d2.Pair && t3.pools[r3] instanceof a2.Pool) && (e3.push(t3.pools.slice(n5, r3)), n5 = r3), ++r3 === t3.pools.length && e3.push(t3.pools.slice(n5, r3));
    return e3;
  }, V4 = function(t3, e3) {
    return t3.reduce(function(t4, e4) {
      var n5 = t4.inputToken;
      if (!e4.involvesToken(n5))
        throw new Error("PATH");
      return { inputToken: e4.token0.equals(n5) ? e4.token1 : e4.token0 };
    }, { inputToken: e3 }).inputToken;
  }, Z2 = r2.BigInt(0), B2 = new n4.Percent(r2.BigInt(50), r2.BigInt(100)), G2 = function() {
    function t3() {
    }
    return t3.encodeV2Swap = function(e3, r3, o3, u3) {
      var i4 = a2.toHex(e3.maximumAmountIn(r3.slippageTolerance).quotient), c3 = a2.toHex(e3.minimumAmountOut(r3.slippageTolerance).quotient), s5 = e3.route.path.map(function(t4) {
        return t4.address;
      }), p3 = o3 ? f3 : void 0 === r3.recipient ? m2 : n4.validateAndParseAddress(r3.recipient);
      return e3.tradeType === n4.TradeType.EXACT_INPUT ? t3.INTERFACE.encodeFunctionData("swapExactTokensForTokens", [i4, u3 ? 0 : c3, s5, p3]) : t3.INTERFACE.encodeFunctionData("swapTokensForExactTokens", [c3, i4, s5, p3]);
    }, t3.encodeV3Swap = function(e3, r3, o3, u3) {
      for (var i4, c3 = [], s5 = O2(e3.swaps); !(i4 = s5()).done; ) {
        var p3 = i4.value, d3 = p3.route, l3 = p3.outputAmount, h5 = a2.toHex(e3.maximumAmountIn(r3.slippageTolerance, p3.inputAmount).quotient), v3 = a2.toHex(e3.minimumAmountOut(r3.slippageTolerance, l3).quotient), A3 = 1 === d3.pools.length, y3 = o3 ? f3 : void 0 === r3.recipient ? m2 : n4.validateAndParseAddress(r3.recipient);
        if (A3)
          c3.push(e3.tradeType === n4.TradeType.EXACT_INPUT ? t3.INTERFACE.encodeFunctionData("exactInputSingle", [{ tokenIn: d3.tokenPath[0].address, tokenOut: d3.tokenPath[1].address, fee: d3.pools[0].fee, recipient: y3, amountIn: h5, amountOutMinimum: u3 ? 0 : v3, sqrtPriceLimitX96: 0 }]) : t3.INTERFACE.encodeFunctionData("exactOutputSingle", [{ tokenIn: d3.tokenPath[0].address, tokenOut: d3.tokenPath[1].address, fee: d3.pools[0].fee, recipient: y3, amountOut: v3, amountInMaximum: h5, sqrtPriceLimitX96: 0 }]));
        else {
          var T3 = a2.encodeRouteToPath(d3, e3.tradeType === n4.TradeType.EXACT_OUTPUT);
          c3.push(e3.tradeType === n4.TradeType.EXACT_INPUT ? t3.INTERFACE.encodeFunctionData("exactInput", [{ path: T3, recipient: y3, amountIn: h5, amountOutMinimum: u3 ? 0 : v3 }]) : t3.INTERFACE.encodeFunctionData("exactOutput", [{ path: T3, recipient: y3, amountOut: v3, amountInMaximum: h5 }]));
        }
      }
      return c3;
    }, t3.encodeMixedRouteSwap = function(e3, r3, o3, i4) {
      var c3 = [];
      e3.tradeType !== n4.TradeType.EXACT_INPUT && u2(false);
      for (var s5, p3 = O2(e3.swaps); !(s5 = p3()).done; ) {
        var d3 = s5.value, l3 = d3.route, h5 = d3.outputAmount, v3 = a2.toHex(e3.maximumAmountIn(r3.slippageTolerance, d3.inputAmount).quotient), A3 = a2.toHex(e3.minimumAmountOut(r3.slippageTolerance, h5).quotient), y3 = 1 === l3.pools.length, T3 = o3 ? f3 : void 0 === r3.recipient ? m2 : n4.validateAndParseAddress(r3.recipient), w3 = function(t4) {
          return t4.pools.every(function(t5) {
            return t5 instanceof a2.Pool;
          });
        };
        if (y3)
          if (w3(l3))
            c3.push(t3.INTERFACE.encodeFunctionData("exactInputSingle", [{ tokenIn: l3.path[0].address, tokenOut: l3.path[1].address, fee: l3.pools[0].fee, recipient: T3, amountIn: v3, amountOutMinimum: i4 ? 0 : A3, sqrtPriceLimitX96: 0 }]));
          else {
            var x3 = l3.path.map(function(t4) {
              return t4.address;
            });
            c3.push(t3.INTERFACE.encodeFunctionData("swapExactTokensForTokens", [v3, i4 ? 0 : A3, x3, T3]));
          }
        else
          !function() {
            for (var e4 = W2(l3), n5 = function(t4) {
              return t4 === e4.length - 1;
            }, r4 = void 0, o4 = l3.input.wrapped, u3 = 0; u3 < e4.length; u3++) {
              var i5 = e4[u3];
              r4 = V4(i5, o4);
              var a3 = new C2([].concat(i5), i5[0].token0.equals(o4) ? i5[0].token0 : i5[0].token1, r4), s6 = new L4(a3);
              if (o4 = r4, w3(s6)) {
                var p4 = { path: j2(s6), recipient: n5(u3) ? T3 : f3, amountIn: 0 == u3 ? v3 : 0, amountOutMinimum: n5(u3) ? A3 : 0 };
                c3.push(t3.INTERFACE.encodeFunctionData("exactInput", [p4]));
              } else {
                var d4 = [0 == u3 ? v3 : 0, n5(u3) ? A3 : 0, s6.path.map(function(t4) {
                  return t4.address;
                }), n5(u3) ? T3 : f3];
                c3.push(t3.INTERFACE.encodeFunctionData("swapExactTokensForTokens", d4));
              }
            }
          }();
      }
      return c3;
    }, t3.encodeSwaps = function(e3, r3, o3) {
      if (e3 instanceof X2) {
        e3.swaps.every(function(t4) {
          return t4.route.protocol == exports.Protocol.V3 || t4.route.protocol == exports.Protocol.V2 || t4.route.protocol == exports.Protocol.MIXED;
        }) || u2(false);
        for (var i4, c3 = [], s5 = O2(e3.swaps); !(i4 = s5()).done; ) {
          var p3 = i4.value, l3 = p3.route, m3 = p3.inputAmount, f4 = p3.outputAmount;
          if (l3.protocol == exports.Protocol.V2)
            c3.push(new d2.Trade(l3, e3.tradeType == n4.TradeType.EXACT_INPUT ? m3 : f4, e3.tradeType));
          else if (l3.protocol == exports.Protocol.V3)
            c3.push(a2.Trade.createUncheckedTrade({ route: l3, inputAmount: m3, outputAmount: f4, tradeType: e3.tradeType }));
          else {
            if (l3.protocol != exports.Protocol.MIXED)
              throw new Error("UNSUPPORTED_TRADE_PROTOCOL");
            c3.push(H4.createUncheckedTrade({ route: l3, inputAmount: m3, outputAmount: f4, tradeType: e3.tradeType }));
          }
        }
        e3 = c3;
      }
      Array.isArray(e3) || (e3 = [e3]);
      var h5 = e3.reduce(function(t4, e4) {
        return t4 + (e4 instanceof a2.Trade || e4 instanceof H4 ? e4.swaps.length : 1);
      }, 0), v3 = e3[0];
      e3.every(function(t4) {
        return t4.inputAmount.currency.equals(v3.inputAmount.currency);
      }) || u2(false), e3.every(function(t4) {
        return t4.outputAmount.currency.equals(v3.outputAmount.currency);
      }) || u2(false), e3.every(function(t4) {
        return t4.tradeType === v3.tradeType;
      }) || u2(false);
      var A3 = [], y3 = v3.inputAmount.currency.isNative, T3 = v3.outputAmount.currency.isNative, w3 = v3.tradeType === n4.TradeType.EXACT_INPUT && h5 > 2, x3 = T3 || !!r3.fee || !!o3 || w3;
      r3.inputTokenPermit && (v3.inputAmount.currency.isToken || u2(false), A3.push(a2.SelfPermit.encodePermit(v3.inputAmount.currency, r3.inputTokenPermit)));
      for (var E3, g3 = O2(e3); !(E3 = g3()).done; ) {
        var k5 = E3.value;
        if (k5 instanceof d2.Trade)
          A3.push(t3.encodeV2Swap(k5, r3, x3, w3));
        else if (k5 instanceof a2.Trade)
          for (var I4, P3 = O2(t3.encodeV3Swap(k5, r3, x3, w3)); !(I4 = P3()).done; )
            A3.push(I4.value);
        else {
          if (!(k5 instanceof H4))
            throw new Error("Unsupported trade object");
          for (var R4, b4 = O2(t3.encodeMixedRouteSwap(k5, r3, x3, w3)); !(R4 = b4()).done; )
            A3.push(R4.value);
        }
      }
      var _3 = n4.CurrencyAmount.fromRawAmount(v3.inputAmount.currency, 0), N3 = n4.CurrencyAmount.fromRawAmount(v3.outputAmount.currency, 0), F3 = e3.reduce(function(t4, e4) {
        return t4.add(e4.minimumAmountOut(r3.slippageTolerance));
      }, N3), q3 = e3.reduce(function(t4, e4) {
        return t4.add(e4.outputAmount);
      }, N3), C3 = e3.reduce(function(t4, e4) {
        return t4.add(e4.maximumAmountIn(r3.slippageTolerance));
      }, _3);
      return { calldatas: A3, sampleTrade: v3, routerMustCustody: x3, inputIsNative: y3, outputIsNative: T3, totalAmountIn: C3, minimumAmountOut: F3, quoteAmountOut: q3 };
    }, t3.swapCallParameters = function(e3, r3) {
      var o3 = t3.encodeSwaps(e3, r3), u3 = o3.calldatas, i4 = o3.sampleTrade, c3 = o3.inputIsNative, s5 = o3.totalAmountIn, p3 = o3.minimumAmountOut;
      return o3.routerMustCustody && u3.push(o3.outputIsNative ? g2.encodeUnwrapWETH9(p3.quotient, r3.recipient, r3.fee) : g2.encodeSweepToken(i4.outputAmount.currency.wrapped, p3.quotient, r3.recipient, r3.fee)), c3 && (i4.tradeType === n4.TradeType.EXACT_OUTPUT || t3.riskOfPartialFill(e3)) && u3.push(a2.Payments.encodeRefundETH()), { calldata: x2.encodeMulticall(u3, r3.deadlineOrPreviousBlockhash), value: a2.toHex(c3 ? s5.quotient : Z2) };
    }, t3.swapAndAddCallParameters = function(e3, r3, o3, i4, c3, s5) {
      var p3 = t3.encodeSwaps(e3, r3, true), d3 = p3.calldatas, l3 = p3.inputIsNative, m3 = p3.outputIsNative, f4 = p3.sampleTrade, h5 = p3.totalAmountIn, v3 = p3.quoteAmountOut, A3 = p3.minimumAmountOut;
      r3.outputTokenPermit && (v3.currency.isToken || u2(false), d3.push(a2.SelfPermit.encodePermit(v3.currency, r3.outputTokenPermit)));
      var y3 = f4.route.chainId, T3 = o3.pool.token0.wrapped.address === h5.currency.wrapped.address, E3 = t3.getPositionAmounts(o3, T3), k5 = E3.positionAmountIn, I4 = E3.positionAmountOut, P3 = l3 ? n4.WETH9[y3] : k5.currency.wrapped, R4 = m3 ? n4.WETH9[y3] : I4.currency.wrapped, b4 = I4.subtract(v3.wrapped);
      b4.greaterThan(n4.CurrencyAmount.fromRawAmount(I4.currency, 0)) && d3.push(m3 ? g2.encodeWrapETH(b4.quotient) : g2.encodePull(R4, b4.quotient)), d3.push(l3 ? g2.encodeWrapETH(k5.quotient) : g2.encodePull(P3, k5.quotient)), c3 !== exports.ApprovalTypes.NOT_REQUIRED && d3.push(w2.encodeApprove(P3, c3)), s5 !== exports.ApprovalTypes.NOT_REQUIRED && d3.push(w2.encodeApprove(R4, s5));
      var _3, N3 = a2.Position.fromAmounts({ pool: o3.pool, tickLower: o3.tickLower, tickUpper: o3.tickUpper, amount0: T3 ? o3.amount0.quotient.toString() : A3.quotient.toString(), amount1: T3 ? A3.quotient.toString() : o3.amount1.quotient.toString(), useFullPrecision: false });
      return d3.push(w2.encodeAddLiquidity(o3, N3, i4, r3.slippageTolerance)), d3.push(l3 ? g2.encodeUnwrapWETH9(Z2) : g2.encodeSweepToken(P3, Z2)), d3.push(m3 ? g2.encodeUnwrapWETH9(Z2) : g2.encodeSweepToken(R4, Z2)), _3 = l3 ? h5.wrapped.add(k5.wrapped).quotient : m3 ? b4.quotient : Z2, { calldata: x2.encodeMulticall(d3, r3.deadlineOrPreviousBlockhash), value: _3.toString() };
    }, t3.riskOfPartialFill = function(e3) {
      return Array.isArray(e3) ? e3.some(function(e4) {
        return t3.v3TradeWithHighPriceImpact(e4);
      }) : t3.v3TradeWithHighPriceImpact(e3);
    }, t3.v3TradeWithHighPriceImpact = function(t4) {
      return !(t4 instanceof d2.Trade) && t4.priceImpact.greaterThan(B2);
    }, t3.getPositionAmounts = function(t4, e3) {
      var r3 = t4.mintAmounts, o3 = r3.amount1, u3 = n4.CurrencyAmount.fromRawAmount(t4.pool.token0, r3.amount0), i4 = n4.CurrencyAmount.fromRawAmount(t4.pool.token1, o3), a3 = e3 ? [u3, i4] : [i4, u3];
      return { positionAmountIn: a3[0], positionAmountOut: a3[1] };
    }, t3;
  }();
  G2.INTERFACE = new o2.Interface(p2.abi), exports.ADDRESS_THIS = f3, exports.ApproveAndCall = w2, exports.MSG_SENDER = m2, exports.MixedRoute = L4, exports.MixedRouteSDK = C2, exports.MixedRouteTrade = H4, exports.MulticallExtended = x2, exports.ONE = v2, exports.ONE_HUNDRED_PERCENT = y2, exports.PaymentsExtended = g2, exports.RouteV2 = U2, exports.RouteV3 = D2, exports.SwapRouter = G2, exports.Trade = X2, exports.V2_FEE_PATH_PLACEHOLDER = 8388608, exports.ZERO = h4, exports.ZERO_PERCENT = A2, exports.encodeMixedRouteToPath = j2, exports.getOutputOfPools = V4, exports.isMint = T2, exports.partitionMixedRouteByProtocol = W2, exports.tradeComparator = M3;
})(routerSdk_cjs_production_min);
{
  dist$1.exports = routerSdk_cjs_production_min;
}
var distExports = dist$1.exports;
function _defineProperties$1(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  return Constructor;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var ChainId;
(function(ChainId2) {
  ChainId2[ChainId2["MAINNET"] = 1] = "MAINNET";
  ChainId2[ChainId2["GOERLI"] = 5] = "GOERLI";
  ChainId2[ChainId2["SEPOLIA"] = 11155111] = "SEPOLIA";
  ChainId2[ChainId2["OPTIMISM"] = 10] = "OPTIMISM";
  ChainId2[ChainId2["OPTIMISM_GOERLI"] = 420] = "OPTIMISM_GOERLI";
  ChainId2[ChainId2["OPTIMISM_SEPOLIA"] = 11155420] = "OPTIMISM_SEPOLIA";
  ChainId2[ChainId2["ARBITRUM_ONE"] = 42161] = "ARBITRUM_ONE";
  ChainId2[ChainId2["ARBITRUM_GOERLI"] = 421613] = "ARBITRUM_GOERLI";
  ChainId2[ChainId2["POLYGON"] = 137] = "POLYGON";
  ChainId2[ChainId2["POLYGON_MUMBAI"] = 80001] = "POLYGON_MUMBAI";
  ChainId2[ChainId2["CELO"] = 42220] = "CELO";
  ChainId2[ChainId2["CELO_ALFAJORES"] = 44787] = "CELO_ALFAJORES";
  ChainId2[ChainId2["GNOSIS"] = 100] = "GNOSIS";
  ChainId2[ChainId2["MOONBEAM"] = 1284] = "MOONBEAM";
  ChainId2[ChainId2["BNB"] = 56] = "BNB";
  ChainId2[ChainId2["AVALANCHE"] = 43114] = "AVALANCHE";
  ChainId2[ChainId2["BASE_GOERLI"] = 84531] = "BASE_GOERLI";
  ChainId2[ChainId2["BASE"] = 8453] = "BASE";
})(ChainId || (ChainId = {}));
[ChainId.MAINNET, ChainId.OPTIMISM, ChainId.OPTIMISM_GOERLI, ChainId.OPTIMISM_SEPOLIA, ChainId.ARBITRUM_ONE, ChainId.ARBITRUM_GOERLI, ChainId.POLYGON, ChainId.POLYGON_MUMBAI, ChainId.GOERLI, ChainId.SEPOLIA, ChainId.CELO_ALFAJORES, ChainId.CELO, ChainId.BNB, ChainId.AVALANCHE, ChainId.BASE, ChainId.BASE_GOERLI];
var NativeCurrencyName;
(function(NativeCurrencyName2) {
  NativeCurrencyName2["ETHER"] = "ETH";
  NativeCurrencyName2["MATIC"] = "MATIC";
  NativeCurrencyName2["CELO"] = "CELO";
  NativeCurrencyName2["GNOSIS"] = "XDAI";
  NativeCurrencyName2["MOONBEAM"] = "GLMR";
  NativeCurrencyName2["BNB"] = "BNB";
  NativeCurrencyName2["AVAX"] = "AVAX";
})(NativeCurrencyName || (NativeCurrencyName = {}));
var _CHAIN_TO_ADDRESSES_M, _GOVERNANCE_ALPHA_V1_, _GOVERNANCE_BRAVO_ADD, _MERKLE_DISTRIBUTOR_A, _ARGENT_WALLET_DETECT, _SOCKS_CONTROLLER_ADD;
var DEFAULT_NETWORKS = [ChainId.MAINNET, ChainId.GOERLI, ChainId.SEPOLIA];
function constructSameAddressMap(address, additionalNetworks) {
  if (additionalNetworks === void 0) {
    additionalNetworks = [];
  }
  return DEFAULT_NETWORKS.concat(additionalNetworks).reduce(function(memo, chainId2) {
    memo[chainId2] = address;
    return memo;
  }, {});
}
/* @__PURE__ */ constructSameAddressMap("0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984", [ChainId.OPTIMISM, ChainId.ARBITRUM_ONE, ChainId.POLYGON, ChainId.POLYGON_MUMBAI, ChainId.SEPOLIA]);
var V2_FACTORY_ADDRESS = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f";
/* @__PURE__ */ constructSameAddressMap(V2_FACTORY_ADDRESS, [ChainId.POLYGON, ChainId.OPTIMISM, ChainId.CELO, ChainId.ARBITRUM_ONE, ChainId.BNB, ChainId.AVALANCHE, ChainId.BASE]);
var DEFAULT_ADDRESSES = {
  v3CoreFactoryAddress: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
  multicallAddress: "0x1F98415757620B543A52E61c46B32eB19261F984",
  quoterAddress: "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6",
  v3MigratorAddress: "0xA5644E29708357803b5A882D272c41cC0dF92B34",
  nonfungiblePositionManagerAddress: "0xC36442b4a4522E871399CD717aBDD847Ab11FE88"
};
var MAINNET_ADDRESSES = /* @__PURE__ */ _extends({}, DEFAULT_ADDRESSES, {
  v1MixedRouteQuoterAddress: "0x84E44095eeBfEC7793Cd7d5b57B7e401D7f1cA2E"
});
var GOERLI_ADDRESSES = /* @__PURE__ */ _extends({}, DEFAULT_ADDRESSES, {
  v1MixedRouteQuoterAddress: "0xBa60b6e6fF25488308789E6e0A65D838be34194e"
});
var OPTIMISM_ADDRESSES = DEFAULT_ADDRESSES;
var ARBITRUM_ONE_ADDRESSES = /* @__PURE__ */ _extends({}, DEFAULT_ADDRESSES, {
  multicallAddress: "0xadF885960B47eA2CD9B55E6DAc6B42b7Cb2806dB",
  tickLensAddress: "0xbfd8137f7d1516D3ea5cA83523914859ec47F573"
});
var POLYGON_ADDRESSES = DEFAULT_ADDRESSES;
var CELO_ADDRESSES = {
  v3CoreFactoryAddress: "0xAfE208a311B21f13EF87E33A90049fC17A7acDEc",
  multicallAddress: "0x633987602DE5C4F337e3DbF265303A1080324204",
  quoterAddress: "0x82825d0554fA07f7FC52Ab63c961F330fdEFa8E8",
  v3MigratorAddress: "0x3cFd4d48EDfDCC53D3f173F596f621064614C582",
  nonfungiblePositionManagerAddress: "0x3d79EdAaBC0EaB6F08ED885C05Fc0B014290D95A",
  tickLensAddress: "0x5f115D9113F88e0a0Db1b5033D90D4a9690AcD3D"
};
var BNB_ADDRESSES = {
  v3CoreFactoryAddress: "0xdB1d10011AD0Ff90774D0C6Bb92e5C5c8b4461F7",
  multicallAddress: "0x963Df249eD09c358A4819E39d9Cd5736c3087184",
  quoterAddress: "0x78D78E420Da98ad378D7799bE8f4AF69033EB077",
  v3MigratorAddress: "0x32681814957e0C13117ddc0c2aba232b5c9e760f",
  nonfungiblePositionManagerAddress: "0x7b8A01B39D58278b5DE7e48c8449c9f4F5170613",
  tickLensAddress: "0xD9270014D396281579760619CCf4c3af0501A47C",
  swapRouter02Address: "0xB971eF87ede563556b2ED4b1C0b0019111Dd85d2"
};
var OPTIMISM_GOERLI_ADDRESSES = {
  v3CoreFactoryAddress: "0xB656dA17129e7EB733A557f4EBc57B76CFbB5d10",
  multicallAddress: "0x07F2D8a2a02251B62af965f22fC4744A5f96BCCd",
  quoterAddress: "0x9569CbA925c8ca2248772A9A4976A516743A246F",
  v3MigratorAddress: "0xf6c55fBe84B1C8c3283533c53F51bC32F5C7Aba8",
  nonfungiblePositionManagerAddress: "0x39Ca85Af2F383190cBf7d7c41ED9202D27426EF6",
  tickLensAddress: "0xe6140Bd164b63E8BfCfc40D5dF952f83e171758e"
};
var OPTIMISM_SEPOLIA_ADDRESSES = {
  v3CoreFactoryAddress: "0x8CE191193D15ea94e11d327b4c7ad8bbE520f6aF",
  multicallAddress: "0x80e4e06841bb76AA9735E0448cB8d003C0EF009a",
  quoterAddress: "0x0FBEa6cf957d95ee9313490050F6A0DA68039404",
  v3MigratorAddress: "0xE7EcbAAaA54D007A00dbb6c1d2f150066D69dA07",
  nonfungiblePositionManagerAddress: "0xdA75cEf1C93078e8b736FCA5D5a30adb97C8957d",
  tickLensAddress: "0xCb7f54747F58F8944973cea5b8f4ac2209BadDC5"
};
var ARBITRUM_GOERLI_ADDRESSES = {
  v3CoreFactoryAddress: "0x4893376342d5D7b3e31d4184c08b265e5aB2A3f6",
  multicallAddress: "0x8260CB40247290317a4c062F3542622367F206Ee",
  quoterAddress: "0x1dd92b83591781D0C6d98d07391eea4b9a6008FA",
  v3MigratorAddress: "0xA815919D2584Ac3F76ea9CB62E6Fd40a43BCe0C3",
  nonfungiblePositionManagerAddress: "0x622e4726a167799826d1E1D150b076A7725f5D81",
  tickLensAddress: "0xb52429333da969a0C79a60930a4Bf0020E5D1DE8"
};
var SEPOLIA_ADDRESSES = {
  v3CoreFactoryAddress: "0x0227628f3F023bb0B980b67D528571c95c6DaC1c",
  multicallAddress: "0xD7F33bCdb21b359c8ee6F0251d30E94832baAd07",
  quoterAddress: "0xEd1f6473345F45b75F8179591dd5bA1888cf2FB3",
  v3MigratorAddress: "0x729004182cF005CEC8Bd85df140094b6aCbe8b15",
  nonfungiblePositionManagerAddress: "0x1238536071E1c677A632429e3655c799b22cDA52",
  tickLensAddress: "0xd7f33bcdb21b359c8ee6f0251d30e94832baad07"
};
var AVALANCHE_ADDRESSES = {
  v3CoreFactoryAddress: "0x740b1c1de25031C31FF4fC9A62f554A55cdC1baD",
  multicallAddress: "0x0139141Cd4Ee88dF3Cdb65881D411bAE271Ef0C2",
  quoterAddress: "0xbe0F5544EC67e9B3b2D979aaA43f18Fd87E6257F",
  v3MigratorAddress: "0x44f5f1f5E452ea8d29C890E8F6e893fC0f1f0f97",
  nonfungiblePositionManagerAddress: "0x655C406EBFa14EE2006250925e54ec43AD184f8B",
  tickLensAddress: "0xEB9fFC8bf81b4fFd11fb6A63a6B0f098c6e21950",
  swapRouter02Address: "0xbb00FF08d01D300023C629E8fFfFcb65A5a578cE"
};
var BASE_ADDRESSES = {
  v3CoreFactoryAddress: "0x33128a8fC17869897dcE68Ed026d694621f6FDfD",
  multicallAddress: "0x091e99cb1C49331a94dD62755D168E941AbD0693",
  quoterAddress: "0x3d4e44Eb1374240CE5F1B871ab261CD16335B76a",
  v3MigratorAddress: "0x23cF10b1ee3AdfCA73B0eF17C07F7577e7ACd2d7",
  nonfungiblePositionManagerAddress: "0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1",
  tickLensAddress: "0x0CdeE061c75D43c82520eD998C23ac2991c9ac6d",
  swapRouter02Address: "0x2626664c2603336E57B271c5C0b26F421741e481"
};
var BASE_GOERLI_ADDRESSES = {
  v3CoreFactoryAddress: "0x9323c1d6D800ed51Bd7C6B216cfBec678B7d0BC2",
  multicallAddress: "0xB206027a9E0E13F05eBEFa5D2402Bab3eA716439",
  quoterAddress: "0xedf539058e28E5937dAef3f69cEd0b25fbE66Ae9",
  v3MigratorAddress: "0x3efe5d02a04b7351D671Db7008ec6eBA9AD9e3aE",
  nonfungiblePositionManagerAddress: "0x3c61369ef0D1D2AFa70d8feC2F31C5D6Ce134F30",
  tickLensAddress: "0x1acB873Ee909D0c98adB18e4474943249F931b92",
  swapRouter02Address: "0x8357227D4eDc78991Db6FDB9bD6ADE250536dE1d"
};
_CHAIN_TO_ADDRESSES_M = {}, _CHAIN_TO_ADDRESSES_M[ChainId.MAINNET] = MAINNET_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.OPTIMISM] = OPTIMISM_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ARBITRUM_ONE] = ARBITRUM_ONE_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.POLYGON] = POLYGON_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.POLYGON_MUMBAI] = POLYGON_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.GOERLI] = GOERLI_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.CELO] = CELO_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.CELO_ALFAJORES] = CELO_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.BNB] = BNB_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.OPTIMISM_GOERLI] = OPTIMISM_GOERLI_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.OPTIMISM_SEPOLIA] = OPTIMISM_SEPOLIA_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ARBITRUM_GOERLI] = ARBITRUM_GOERLI_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.SEPOLIA] = SEPOLIA_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.AVALANCHE] = AVALANCHE_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.BASE] = BASE_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.BASE_GOERLI] = BASE_GOERLI_ADDRESSES, _CHAIN_TO_ADDRESSES_M;
_GOVERNANCE_ALPHA_V1_ = {}, _GOVERNANCE_ALPHA_V1_[ChainId.MAINNET] = "0xC4e172459f1E7939D522503B81AFAaC1014CE6F6", _GOVERNANCE_ALPHA_V1_;
_GOVERNANCE_BRAVO_ADD = {}, _GOVERNANCE_BRAVO_ADD[ChainId.MAINNET] = "0x408ED6354d4973f66138C91495F2f2FCbd8724C3", _GOVERNANCE_BRAVO_ADD;
_MERKLE_DISTRIBUTOR_A = {}, _MERKLE_DISTRIBUTOR_A[ChainId.MAINNET] = "0x090D4613473dEE047c3f2706764f49E0821D256e", _MERKLE_DISTRIBUTOR_A;
_ARGENT_WALLET_DETECT = {}, _ARGENT_WALLET_DETECT[ChainId.MAINNET] = "0xeca4B0bDBf7c55E9b7925919d03CbF8Dc82537E8", _ARGENT_WALLET_DETECT;
_SOCKS_CONTROLLER_ADD = {}, _SOCKS_CONTROLLER_ADD[ChainId.MAINNET] = "0x65770b5283117639760beA3F867b69b3697a91dd", _SOCKS_CONTROLLER_ADD;
var TradeType;
(function(TradeType2) {
  TradeType2[TradeType2["EXACT_INPUT"] = 0] = "EXACT_INPUT";
  TradeType2[TradeType2["EXACT_OUTPUT"] = 1] = "EXACT_OUTPUT";
})(TradeType || (TradeType = {}));
var Rounding;
(function(Rounding2) {
  Rounding2[Rounding2["ROUND_DOWN"] = 0] = "ROUND_DOWN";
  Rounding2[Rounding2["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
  Rounding2[Rounding2["ROUND_UP"] = 2] = "ROUND_UP";
})(Rounding || (Rounding = {}));
var MaxUint256 = /* @__PURE__ */ JSBI.BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var _toSignificantRoundin, _toFixedRounding;
var Decimal = /* @__PURE__ */ toFormat(_Decimal);
var Big = /* @__PURE__ */ toFormat(Big$5);
var toSignificantRounding = (_toSignificantRoundin = {}, _toSignificantRoundin[Rounding.ROUND_DOWN] = Decimal.ROUND_DOWN, _toSignificantRoundin[Rounding.ROUND_HALF_UP] = Decimal.ROUND_HALF_UP, _toSignificantRoundin[Rounding.ROUND_UP] = Decimal.ROUND_UP, _toSignificantRoundin);
var toFixedRounding = (_toFixedRounding = {}, _toFixedRounding[Rounding.ROUND_DOWN] = 0, _toFixedRounding[Rounding.ROUND_HALF_UP] = 1, _toFixedRounding[Rounding.ROUND_UP] = 3, _toFixedRounding);
var Fraction = /* @__PURE__ */ function() {
  function Fraction2(numerator, denominator) {
    if (denominator === void 0) {
      denominator = JSBI.BigInt(1);
    }
    this.numerator = JSBI.BigInt(numerator);
    this.denominator = JSBI.BigInt(denominator);
  }
  Fraction2.tryParseFraction = function tryParseFraction(fractionish) {
    if (fractionish instanceof JSBI || typeof fractionish === "number" || typeof fractionish === "string")
      return new Fraction2(fractionish);
    if ("numerator" in fractionish && "denominator" in fractionish)
      return fractionish;
    throw new Error("Could not parse fraction");
  };
  var _proto = Fraction2.prototype;
  _proto.invert = function invert() {
    return new Fraction2(this.denominator, this.numerator);
  };
  _proto.add = function add4(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    if (JSBI.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction2(JSBI.add(this.numerator, otherParsed.numerator), this.denominator);
    }
    return new Fraction2(JSBI.add(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.subtract = function subtract2(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    if (JSBI.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction2(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator);
    }
    return new Fraction2(JSBI.subtract(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.lessThan = function lessThan(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return JSBI.lessThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.equalTo = function equalTo(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return JSBI.equal(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.greaterThan = function greaterThan(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return JSBI.greaterThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.multiply = function multiply(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return new Fraction2(JSBI.multiply(this.numerator, otherParsed.numerator), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.divide = function divide2(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return new Fraction2(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(this.denominator, otherParsed.numerator));
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_HALF_UP;
    }
    !Number.isInteger(significantDigits) ? invariant$1(false) : void 0;
    !(significantDigits > 0) ? invariant$1(false) : void 0;
    Decimal.set({
      precision: significantDigits + 1,
      rounding: toSignificantRounding[rounding]
    });
    var quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
    return quotient.toFormat(quotient.decimalPlaces(), format);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_HALF_UP;
    }
    !Number.isInteger(decimalPlaces) ? invariant$1(false) : void 0;
    !(decimalPlaces >= 0) ? invariant$1(false) : void 0;
    Big.DP = decimalPlaces;
    Big.RM = toFixedRounding[rounding];
    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
  };
  _createClass$1(Fraction2, [{
    key: "quotient",
    get: function get2() {
      return JSBI.divide(this.numerator, this.denominator);
    }
    // remainder after floor division
  }, {
    key: "remainder",
    get: function get2() {
      return new Fraction2(JSBI.remainder(this.numerator, this.denominator), this.denominator);
    }
  }, {
    key: "asFraction",
    get: function get2() {
      return new Fraction2(this.numerator, this.denominator);
    }
  }]);
  return Fraction2;
}();
var Big$1 = /* @__PURE__ */ toFormat(Big$5);
var CurrencyAmount2 = /* @__PURE__ */ function(_Fraction) {
  _inheritsLoose$1(CurrencyAmount22, _Fraction);
  function CurrencyAmount22(currency, numerator, denominator) {
    var _this;
    _this = _Fraction.call(this, numerator, denominator) || this;
    !JSBI.lessThanOrEqual(_this.quotient, MaxUint256) ? invariant$1(false) : void 0;
    _this.currency = currency;
    _this.decimalScale = JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(currency.decimals));
    return _this;
  }
  CurrencyAmount22.fromRawAmount = function fromRawAmount(currency, rawAmount) {
    return new CurrencyAmount22(currency, rawAmount);
  };
  CurrencyAmount22.fromFractionalAmount = function fromFractionalAmount(currency, numerator, denominator) {
    return new CurrencyAmount22(currency, numerator, denominator);
  };
  var _proto = CurrencyAmount22.prototype;
  _proto.add = function add4(other) {
    !this.currency.equals(other.currency) ? invariant$1(false) : void 0;
    var added = _Fraction.prototype.add.call(this, other);
    return CurrencyAmount22.fromFractionalAmount(this.currency, added.numerator, added.denominator);
  };
  _proto.subtract = function subtract2(other) {
    !this.currency.equals(other.currency) ? invariant$1(false) : void 0;
    var subtracted = _Fraction.prototype.subtract.call(this, other);
    return CurrencyAmount22.fromFractionalAmount(this.currency, subtracted.numerator, subtracted.denominator);
  };
  _proto.multiply = function multiply(other) {
    var multiplied = _Fraction.prototype.multiply.call(this, other);
    return CurrencyAmount22.fromFractionalAmount(this.currency, multiplied.numerator, multiplied.denominator);
  };
  _proto.divide = function divide2(other) {
    var divided = _Fraction.prototype.divide.call(this, other);
    return CurrencyAmount22.fromFractionalAmount(this.currency, divided.numerator, divided.denominator);
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 6;
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_DOWN;
    }
    return _Fraction.prototype.divide.call(this, this.decimalScale).toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = this.currency.decimals;
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_DOWN;
    }
    !(decimalPlaces <= this.currency.decimals) ? invariant$1(false) : void 0;
    return _Fraction.prototype.divide.call(this, this.decimalScale).toFixed(decimalPlaces, format, rounding);
  };
  _proto.toExact = function toExact(format) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    Big$1.DP = this.currency.decimals;
    return new Big$1(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(format);
  };
  _createClass$1(CurrencyAmount22, [{
    key: "wrapped",
    get: function get2() {
      if (this.currency.isToken)
        return this;
      return CurrencyAmount22.fromFractionalAmount(this.currency.wrapped, this.numerator, this.denominator);
    }
  }]);
  return CurrencyAmount22;
}(Fraction);
var ONE_HUNDRED = /* @__PURE__ */ new Fraction(/* @__PURE__ */ JSBI.BigInt(100));
function toPercent(fraction) {
  return new Percent(fraction.numerator, fraction.denominator);
}
var Percent = /* @__PURE__ */ function(_Fraction) {
  _inheritsLoose$1(Percent2, _Fraction);
  function Percent2() {
    var _this;
    _this = _Fraction.apply(this, arguments) || this;
    _this.isPercent = true;
    return _this;
  }
  var _proto = Percent2.prototype;
  _proto.add = function add4(other) {
    return toPercent(_Fraction.prototype.add.call(this, other));
  };
  _proto.subtract = function subtract2(other) {
    return toPercent(_Fraction.prototype.subtract.call(this, other));
  };
  _proto.multiply = function multiply(other) {
    return toPercent(_Fraction.prototype.multiply.call(this, other));
  };
  _proto.divide = function divide2(other) {
    return toPercent(_Fraction.prototype.divide.call(this, other));
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 5;
    }
    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = 2;
    }
    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toFixed(decimalPlaces, format, rounding);
  };
  return Percent2;
}(Fraction);
var Price = /* @__PURE__ */ function(_Fraction) {
  _inheritsLoose$1(Price2, _Fraction);
  function Price2() {
    var _this;
    var baseCurrency, quoteCurrency, denominator, numerator;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 4) {
      baseCurrency = args[0];
      quoteCurrency = args[1];
      denominator = args[2];
      numerator = args[3];
    } else {
      var result = args[0].quoteAmount.divide(args[0].baseAmount);
      var _ref = [args[0].baseAmount.currency, args[0].quoteAmount.currency, result.denominator, result.numerator];
      baseCurrency = _ref[0];
      quoteCurrency = _ref[1];
      denominator = _ref[2];
      numerator = _ref[3];
    }
    _this = _Fraction.call(this, numerator, denominator) || this;
    _this.baseCurrency = baseCurrency;
    _this.quoteCurrency = quoteCurrency;
    _this.scalar = new Fraction(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(baseCurrency.decimals)), JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(quoteCurrency.decimals)));
    return _this;
  }
  var _proto = Price2.prototype;
  _proto.invert = function invert() {
    return new Price2(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);
  };
  _proto.multiply = function multiply(other) {
    !this.quoteCurrency.equals(other.baseCurrency) ? invariant$1(false) : void 0;
    var fraction = _Fraction.prototype.multiply.call(this, other);
    return new Price2(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);
  };
  _proto.quote = function quote(currencyAmount) {
    !currencyAmount.currency.equals(this.baseCurrency) ? invariant$1(false) : void 0;
    var result = _Fraction.prototype.multiply.call(this, currencyAmount);
    return CurrencyAmount2.fromFractionalAmount(this.quoteCurrency, result.numerator, result.denominator);
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 6;
    }
    return this.adjustedForDecimals.toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = 4;
    }
    return this.adjustedForDecimals.toFixed(decimalPlaces, format, rounding);
  };
  _createClass$1(Price2, [{
    key: "adjustedForDecimals",
    get: function get2() {
      return _Fraction.prototype.multiply.call(this, this.scalar);
    }
  }]);
  return Price2;
}(Fraction);
var BaseCurrency = (
  /**
   * Constructs an instance of the base class `BaseCurrency`.
   * @param chainId the chain ID on which this currency resides
   * @param decimals decimals of the currency
   * @param symbol symbol of the currency
   * @param name of the currency
   */
  function BaseCurrency24(chainId2, decimals, symbol, name2) {
    !Number.isSafeInteger(chainId2) ? invariant$1(false) : void 0;
    !(decimals >= 0 && decimals < 255 && Number.isInteger(decimals)) ? invariant$1(false) : void 0;
    this.chainId = chainId2;
    this.decimals = decimals;
    this.symbol = symbol;
    this.name = name2;
  }
);
function validateAndParseAddress(address) {
  try {
    return getAddress$1(address);
  } catch (error) {
    throw new Error(address + " is not a valid address.");
  }
}
var startsWith0xLen42HexRegex = /^0x[0-9a-fA-F]{40}$/;
function checkValidAddress(address) {
  if (startsWith0xLen42HexRegex.test(address)) {
    return address;
  }
  throw new Error(address + " is not a valid address.");
}
var Token$1 = /* @__PURE__ */ function(_BaseCurrency) {
  _inheritsLoose$1(Token2, _BaseCurrency);
  function Token2(chainId2, address, decimals, symbol, name2, bypassChecksum, buyFeeBps, sellFeeBps) {
    var _this;
    _this = _BaseCurrency.call(this, chainId2, decimals, symbol, name2) || this;
    _this.isNative = false;
    _this.isToken = true;
    if (bypassChecksum) {
      _this.address = checkValidAddress(address);
    } else {
      _this.address = validateAndParseAddress(address);
    }
    if (buyFeeBps) {
      !buyFeeBps.gte(BigNumber.from(0)) ? invariant$1(false) : void 0;
    }
    if (sellFeeBps) {
      !sellFeeBps.gte(BigNumber.from(0)) ? invariant$1(false) : void 0;
    }
    _this.buyFeeBps = buyFeeBps;
    _this.sellFeeBps = sellFeeBps;
    return _this;
  }
  var _proto = Token2.prototype;
  _proto.equals = function equals(other) {
    return other.isToken && this.chainId === other.chainId && this.address.toLowerCase() === other.address.toLowerCase();
  };
  _proto.sortsBefore = function sortsBefore(other) {
    !(this.chainId === other.chainId) ? invariant$1(false) : void 0;
    !(this.address.toLowerCase() !== other.address.toLowerCase()) ? invariant$1(false) : void 0;
    return this.address.toLowerCase() < other.address.toLowerCase();
  };
  _createClass$1(Token2, [{
    key: "wrapped",
    get: function get2() {
      return this;
    }
  }]);
  return Token2;
}(BaseCurrency);
var _WETH;
_WETH = {}, _WETH[1] = /* @__PURE__ */ new Token$1(1, "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", 18, "WETH", "Wrapped Ether"), _WETH[3] = /* @__PURE__ */ new Token$1(3, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"), _WETH[4] = /* @__PURE__ */ new Token$1(4, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"), _WETH[5] = /* @__PURE__ */ new Token$1(5, "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6", 18, "WETH", "Wrapped Ether"), _WETH[42] = /* @__PURE__ */ new Token$1(42, "0xd0A1E359811322d97991E03f863a0C30C2cF029C", 18, "WETH", "Wrapped Ether"), _WETH[10] = /* @__PURE__ */ new Token$1(10, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH[69] = /* @__PURE__ */ new Token$1(69, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH[11155420] = /* @__PURE__ */ new Token$1(11155420, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH[42161] = /* @__PURE__ */ new Token$1(42161, "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1", 18, "WETH", "Wrapped Ether"), _WETH[421611] = /* @__PURE__ */ new Token$1(421611, "0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681", 18, "WETH", "Wrapped Ether"), _WETH[8453] = /* @__PURE__ */ new Token$1(8453, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH[56] = /* @__PURE__ */ new Token$1(56, "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", 18, "WBNB", "Wrapped BNB"), _WETH[137] = /* @__PURE__ */ new Token$1(137, "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270", 18, "WMATIC", "Wrapped MATIC"), _WETH[43114] = /* @__PURE__ */ new Token$1(43114, "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7", 18, "WAVAX", "Wrapped AVAX"), _WETH;
var MAX_SAFE_INTEGER = /* @__PURE__ */ JSBI.BigInt(Number.MAX_SAFE_INTEGER);
var ZERO$1 = /* @__PURE__ */ JSBI.BigInt(0);
var ONE$1 = /* @__PURE__ */ JSBI.BigInt(1);
var TWO = /* @__PURE__ */ JSBI.BigInt(2);
function sqrt(value) {
  !JSBI.greaterThanOrEqual(value, ZERO$1) ? invariant$1(false) : void 0;
  if (JSBI.lessThan(value, MAX_SAFE_INTEGER)) {
    return JSBI.BigInt(Math.floor(Math.sqrt(JSBI.toNumber(value))));
  }
  var z2;
  var x2;
  z2 = value;
  x2 = JSBI.add(JSBI.divide(value, TWO), ONE$1);
  while (JSBI.lessThan(x2, z2)) {
    z2 = x2;
    x2 = JSBI.divide(JSBI.add(JSBI.divide(value, x2), x2), TWO);
  }
  return z2;
}
var FACTORY_ADDRESS_MAP = {
  // Mainnet
  1: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f",
  // Ropsten
  3: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f",
  // Goerli
  5: "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f",
  // Optimism
  10: "0x0c3c1c532F1e39EdF36BE9Fe0bE1410313E074Bf",
  // Arbitrum
  42161: "0xf1D7CC64Fb4452F05c498126312eBE29f30Fbcf9",
  // Avalanche
  43114: "0x9e5A52f57b3038F1B8EeE45F28b3C1967e22799C",
  // Base
  8453: "0x8909dc15e40173ff4699343b6eb8132c65e18ec6",
  // BNB
  56: "0x8909Dc15e40173Ff4699343b6eB8132c65e18eC6",
  // Polygon
  137: "0x9e5A52f57b3038F1B8EeE45F28b3C1967e22799C"
};
var INIT_CODE_HASH = "0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f";
var MINIMUM_LIQUIDITY = /* @__PURE__ */ JSBI.BigInt(1e3);
var ZERO = /* @__PURE__ */ JSBI.BigInt(0);
var ONE = /* @__PURE__ */ JSBI.BigInt(1);
var FIVE = /* @__PURE__ */ JSBI.BigInt(5);
var _997 = /* @__PURE__ */ JSBI.BigInt(997);
var _1000 = /* @__PURE__ */ JSBI.BigInt(1e3);
var BASIS_POINTS = /* @__PURE__ */ JSBI.BigInt(1e4);
var ZERO_PERCENT = /* @__PURE__ */ new Percent(ZERO);
var ONE_HUNDRED_PERCENT = /* @__PURE__ */ new Percent(ONE);
function _defineProperties(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf(o2);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf(o2, p2);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n4 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n4 === "Object" && o2.constructor)
    n4 = o2.constructor.name;
  if (n4 === "Map" || n4 === "Set")
    return Array.from(o2);
  if (n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++)
    arr2[i3] = arr[i3];
  return arr2;
}
function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i3 = 0;
      return function() {
        if (i3 >= o2.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o2[i3++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it = o2[Symbol.iterator]();
  return it.next.bind(it);
}
var CAN_SET_PROTOTYPE = "setPrototypeOf" in Object;
var InsufficientReservesError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(InsufficientReservesError2, _Error);
  function InsufficientReservesError2() {
    var _this;
    _this = _Error.call(this) || this;
    _this.isInsufficientReservesError = true;
    _this.name = _this.constructor.name;
    if (CAN_SET_PROTOTYPE)
      Object.setPrototypeOf(_assertThisInitialized(_this), (this instanceof InsufficientReservesError2 ? this.constructor : void 0).prototype);
    return _this;
  }
  return InsufficientReservesError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
var InsufficientInputAmountError = /* @__PURE__ */ function(_Error2) {
  _inheritsLoose(InsufficientInputAmountError2, _Error2);
  function InsufficientInputAmountError2() {
    var _this2;
    _this2 = _Error2.call(this) || this;
    _this2.isInsufficientInputAmountError = true;
    _this2.name = _this2.constructor.name;
    if (CAN_SET_PROTOTYPE)
      Object.setPrototypeOf(_assertThisInitialized(_this2), (this instanceof InsufficientInputAmountError2 ? this.constructor : void 0).prototype);
    return _this2;
  }
  return InsufficientInputAmountError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
var computePairAddress = function computePairAddress22(_ref) {
  var factoryAddress = _ref.factoryAddress, tokenA = _ref.tokenA, tokenB = _ref.tokenB;
  var _ref2 = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA], token0 = _ref2[0], token1 = _ref2[1];
  return getCreate2Address(factoryAddress, keccak256$1(["bytes"], [pack(["address", "address"], [token0.address, token1.address])]), INIT_CODE_HASH);
};
var Pair = /* @__PURE__ */ function() {
  function Pair2(currencyAmountA, tokenAmountB) {
    var tokenAmounts = currencyAmountA.currency.sortsBefore(tokenAmountB.currency) ? [currencyAmountA, tokenAmountB] : [tokenAmountB, currencyAmountA];
    this.liquidityToken = new Token$1(tokenAmounts[0].currency.chainId, Pair2.getAddress(tokenAmounts[0].currency, tokenAmounts[1].currency), 18, "UNI-V2", "Uniswap V2");
    this.tokenAmounts = tokenAmounts;
  }
  Pair2.getAddress = function getAddress2(tokenA, tokenB) {
    return computePairAddress({
      factoryAddress: FACTORY_ADDRESS_MAP[tokenA.chainId],
      tokenA,
      tokenB
    });
  };
  var _proto = Pair2.prototype;
  _proto.involvesToken = function involvesToken(token2) {
    return token2.equals(this.token0) || token2.equals(this.token1);
  };
  _proto.priceOf = function priceOf(token2) {
    !this.involvesToken(token2) ? invariant$1(false) : void 0;
    return token2.equals(this.token0) ? this.token0Price : this.token1Price;
  };
  _proto.reserveOf = function reserveOf(token2) {
    !this.involvesToken(token2) ? invariant$1(false) : void 0;
    return token2.equals(this.token0) ? this.reserve0 : this.reserve1;
  };
  _proto.getOutputAmount = function getOutputAmount(inputAmount, calculateFotFees) {
    if (calculateFotFees === void 0) {
      calculateFotFees = false;
    }
    !this.involvesToken(inputAmount.currency) ? invariant$1(false) : void 0;
    if (JSBI.equal(this.reserve0.quotient, ZERO) || JSBI.equal(this.reserve1.quotient, ZERO)) {
      throw new InsufficientReservesError();
    }
    var inputReserve = this.reserveOf(inputAmount.currency);
    var outputReserve = this.reserveOf(inputAmount.currency.equals(this.token0) ? this.token1 : this.token0);
    var percentAfterSellFees = calculateFotFees ? this.derivePercentAfterSellFees(inputAmount) : ZERO_PERCENT;
    var inputAmountAfterTax = percentAfterSellFees.greaterThan(ZERO_PERCENT) ? CurrencyAmount2.fromRawAmount(
      inputAmount.currency,
      percentAfterSellFees.multiply(inputAmount).quotient
      // fraction.quotient will round down by itself, which is desired
    ) : inputAmount;
    var inputAmountWithFeeAndAfterTax = JSBI.multiply(inputAmountAfterTax.quotient, _997);
    var numerator = JSBI.multiply(inputAmountWithFeeAndAfterTax, outputReserve.quotient);
    var denominator = JSBI.add(JSBI.multiply(inputReserve.quotient, _1000), inputAmountWithFeeAndAfterTax);
    var outputAmount = CurrencyAmount2.fromRawAmount(
      inputAmount.currency.equals(this.token0) ? this.token1 : this.token0,
      JSBI.divide(numerator, denominator)
      // JSBI.divide will round down by itself, which is desired
    );
    if (JSBI.equal(outputAmount.quotient, ZERO)) {
      throw new InsufficientInputAmountError();
    }
    var percentAfterBuyFees = calculateFotFees ? this.derivePercentAfterBuyFees(outputAmount) : ZERO_PERCENT;
    var outputAmountAfterTax = percentAfterBuyFees.greaterThan(ZERO_PERCENT) ? CurrencyAmount2.fromRawAmount(
      outputAmount.currency,
      outputAmount.multiply(percentAfterBuyFees).quotient
      // fraction.quotient will round down by itself, which is desired
    ) : outputAmount;
    if (JSBI.equal(outputAmountAfterTax.quotient, ZERO)) {
      throw new InsufficientInputAmountError();
    }
    return [outputAmountAfterTax, new Pair2(inputReserve.add(inputAmountAfterTax), outputReserve.subtract(outputAmountAfterTax))];
  };
  _proto.getInputAmount = function getInputAmount(outputAmount, calculateFotFees) {
    if (calculateFotFees === void 0) {
      calculateFotFees = false;
    }
    !this.involvesToken(outputAmount.currency) ? invariant$1(false) : void 0;
    var percentAfterBuyFees = calculateFotFees ? this.derivePercentAfterBuyFees(outputAmount) : ZERO_PERCENT;
    var outputAmountBeforeTax = percentAfterBuyFees.greaterThan(ZERO_PERCENT) ? CurrencyAmount2.fromRawAmount(
      outputAmount.currency,
      JSBI.add(outputAmount.divide(percentAfterBuyFees).quotient, ONE)
      // add 1 for rounding up
    ) : outputAmount;
    if (JSBI.equal(this.reserve0.quotient, ZERO) || JSBI.equal(this.reserve1.quotient, ZERO) || JSBI.greaterThanOrEqual(outputAmount.quotient, this.reserveOf(outputAmount.currency).quotient) || JSBI.greaterThanOrEqual(outputAmountBeforeTax.quotient, this.reserveOf(outputAmount.currency).quotient)) {
      throw new InsufficientReservesError();
    }
    var outputReserve = this.reserveOf(outputAmount.currency);
    var inputReserve = this.reserveOf(outputAmount.currency.equals(this.token0) ? this.token1 : this.token0);
    var numerator = JSBI.multiply(JSBI.multiply(inputReserve.quotient, outputAmountBeforeTax.quotient), _1000);
    var denominator = JSBI.multiply(JSBI.subtract(outputReserve.quotient, outputAmountBeforeTax.quotient), _997);
    var inputAmount = CurrencyAmount2.fromRawAmount(
      outputAmount.currency.equals(this.token0) ? this.token1 : this.token0,
      JSBI.add(JSBI.divide(numerator, denominator), ONE)
      // add 1 here is part of the formula, no rounding needed here, since there will not be decimal at this point
    );
    var percentAfterSellFees = calculateFotFees ? this.derivePercentAfterSellFees(inputAmount) : ZERO_PERCENT;
    var inputAmountBeforeTax = percentAfterSellFees.greaterThan(ZERO_PERCENT) ? CurrencyAmount2.fromRawAmount(
      inputAmount.currency,
      JSBI.add(inputAmount.divide(percentAfterSellFees).quotient, ONE)
      // add 1 for rounding up
    ) : inputAmount;
    return [inputAmountBeforeTax, new Pair2(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];
  };
  _proto.getLiquidityMinted = function getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB) {
    !totalSupply.currency.equals(this.liquidityToken) ? invariant$1(false) : void 0;
    var tokenAmounts = tokenAmountA.currency.sortsBefore(tokenAmountB.currency) ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];
    !(tokenAmounts[0].currency.equals(this.token0) && tokenAmounts[1].currency.equals(this.token1)) ? invariant$1(false) : void 0;
    var liquidity;
    if (JSBI.equal(totalSupply.quotient, ZERO)) {
      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].quotient, tokenAmounts[1].quotient)), MINIMUM_LIQUIDITY);
    } else {
      var amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].quotient, totalSupply.quotient), this.reserve0.quotient);
      var amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].quotient, totalSupply.quotient), this.reserve1.quotient);
      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1;
    }
    if (!JSBI.greaterThan(liquidity, ZERO)) {
      throw new InsufficientInputAmountError();
    }
    return CurrencyAmount2.fromRawAmount(this.liquidityToken, liquidity);
  };
  _proto.getLiquidityValue = function getLiquidityValue(token2, totalSupply, liquidity, feeOn, kLast) {
    if (feeOn === void 0) {
      feeOn = false;
    }
    !this.involvesToken(token2) ? invariant$1(false) : void 0;
    !totalSupply.currency.equals(this.liquidityToken) ? invariant$1(false) : void 0;
    !liquidity.currency.equals(this.liquidityToken) ? invariant$1(false) : void 0;
    !JSBI.lessThanOrEqual(liquidity.quotient, totalSupply.quotient) ? invariant$1(false) : void 0;
    var totalSupplyAdjusted;
    if (!feeOn) {
      totalSupplyAdjusted = totalSupply;
    } else {
      !!!kLast ? invariant$1(false) : void 0;
      var kLastParsed = JSBI.BigInt(kLast);
      if (!JSBI.equal(kLastParsed, ZERO)) {
        var rootK = sqrt(JSBI.multiply(this.reserve0.quotient, this.reserve1.quotient));
        var rootKLast = sqrt(kLastParsed);
        if (JSBI.greaterThan(rootK, rootKLast)) {
          var numerator = JSBI.multiply(totalSupply.quotient, JSBI.subtract(rootK, rootKLast));
          var denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast);
          var feeLiquidity = JSBI.divide(numerator, denominator);
          totalSupplyAdjusted = totalSupply.add(CurrencyAmount2.fromRawAmount(this.liquidityToken, feeLiquidity));
        } else {
          totalSupplyAdjusted = totalSupply;
        }
      } else {
        totalSupplyAdjusted = totalSupply;
      }
    }
    return CurrencyAmount2.fromRawAmount(token2, JSBI.divide(JSBI.multiply(liquidity.quotient, this.reserveOf(token2).quotient), totalSupplyAdjusted.quotient));
  };
  _proto.derivePercentAfterSellFees = function derivePercentAfterSellFees(inputAmount) {
    var sellFeeBips = this.token0.wrapped.equals(inputAmount.wrapped.currency) ? this.token0.wrapped.sellFeeBps : this.token1.wrapped.sellFeeBps;
    if (sellFeeBips != null && sellFeeBips.gt(BigNumber.from(0))) {
      return ONE_HUNDRED_PERCENT.subtract(new Percent(JSBI.BigInt(sellFeeBips)).divide(BASIS_POINTS));
    } else {
      return ZERO_PERCENT;
    }
  };
  _proto.derivePercentAfterBuyFees = function derivePercentAfterBuyFees(outputAmount) {
    var buyFeeBps = this.token0.wrapped.equals(outputAmount.wrapped.currency) ? this.token0.wrapped.buyFeeBps : this.token1.wrapped.buyFeeBps;
    if (buyFeeBps != null && buyFeeBps.gt(BigNumber.from(0))) {
      return ONE_HUNDRED_PERCENT.subtract(new Percent(JSBI.BigInt(buyFeeBps)).divide(BASIS_POINTS));
    } else {
      return ZERO_PERCENT;
    }
  };
  _createClass(Pair2, [{
    key: "token0Price",
    get: function get2() {
      var result = this.tokenAmounts[1].divide(this.tokenAmounts[0]);
      return new Price(this.token0, this.token1, result.denominator, result.numerator);
    }
    /**
     * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1
     */
  }, {
    key: "token1Price",
    get: function get2() {
      var result = this.tokenAmounts[0].divide(this.tokenAmounts[1]);
      return new Price(this.token1, this.token0, result.denominator, result.numerator);
    }
  }, {
    key: "chainId",
    get: function get2() {
      return this.token0.chainId;
    }
  }, {
    key: "token0",
    get: function get2() {
      return this.tokenAmounts[0].currency;
    }
  }, {
    key: "token1",
    get: function get2() {
      return this.tokenAmounts[1].currency;
    }
  }, {
    key: "reserve0",
    get: function get2() {
      return this.tokenAmounts[0];
    }
  }, {
    key: "reserve1",
    get: function get2() {
      return this.tokenAmounts[1];
    }
  }]);
  return Pair2;
}();
var Route = /* @__PURE__ */ function() {
  function Route2(pairs, input, output2) {
    this._midPrice = null;
    !(pairs.length > 0) ? invariant$1(false) : void 0;
    var chainId2 = pairs[0].chainId;
    !pairs.every(function(pair2) {
      return pair2.chainId === chainId2;
    }) ? invariant$1(false) : void 0;
    var wrappedInput = input.wrapped;
    !pairs[0].involvesToken(wrappedInput) ? invariant$1(false) : void 0;
    !(typeof output2 === "undefined" || pairs[pairs.length - 1].involvesToken(output2.wrapped)) ? invariant$1(false) : void 0;
    var path = [wrappedInput];
    for (var _iterator = _createForOfIteratorHelperLoose(pairs.entries()), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, i3 = _step$value[0], pair = _step$value[1];
      var currentInput = path[i3];
      !(currentInput.equals(pair.token0) || currentInput.equals(pair.token1)) ? invariant$1(false) : void 0;
      var _output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0;
      path.push(_output);
    }
    this.pairs = pairs;
    this.path = path;
    this.input = input;
    this.output = output2;
  }
  _createClass(Route2, [{
    key: "midPrice",
    get: function get2() {
      if (this._midPrice !== null)
        return this._midPrice;
      var prices = [];
      for (var _iterator2 = _createForOfIteratorHelperLoose(this.pairs.entries()), _step2; !(_step2 = _iterator2()).done; ) {
        var _step2$value = _step2.value, i3 = _step2$value[0], pair = _step2$value[1];
        prices.push(this.path[i3].equals(pair.token0) ? new Price(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.quotient, pair.reserve1.quotient) : new Price(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.quotient, pair.reserve0.quotient));
      }
      var reduced = prices.slice(1).reduce(function(accumulator, currentValue) {
        return accumulator.multiply(currentValue);
      }, prices[0]);
      return this._midPrice = new Price(this.input, this.output, reduced.denominator, reduced.numerator);
    }
  }, {
    key: "chainId",
    get: function get2() {
      return this.pairs[0].chainId;
    }
  }]);
  return Route2;
}();
const routeToString = (route) => {
  const routeStr = [];
  const tokens2 = route.protocol === distExports.Protocol.V3 ? route.tokenPath : (
    // MixedRoute and V2Route have path
    route.path
  );
  const tokenPath = _$3.map(tokens2, (token2) => `${token2.symbol}`);
  const pools = route.protocol === distExports.Protocol.V3 || route.protocol === distExports.Protocol.MIXED ? route.pools : route.pairs;
  const poolFeePath = _$3.map(pools, (pool) => {
    return `${pool instanceof Pool ? ` -- ${pool.fee / 1e4}% [${Pool.getAddress(pool.token0, pool.token1, pool.fee)}]` : ` -- [${Pair.getAddress(pool.token0, pool.token1)}]`} --> `;
  });
  for (let i3 = 0; i3 < tokenPath.length; i3++) {
    routeStr.push(tokenPath[i3]);
    if (i3 < poolFeePath.length) {
      routeStr.push(poolFeePath[i3]);
    }
  }
  return routeStr.join("");
};
const routeAmountsToString = (routeAmounts) => {
  const total = _$3.reduce(routeAmounts, (total2, cur) => {
    return total2.add(cur.amount);
  }, CurrencyAmount$2.fromRawAmount(routeAmounts[0].amount.currency, 0));
  const routeStrings = _$3.map(routeAmounts, ({ protocol, route, amount }) => {
    const portion = amount.divide(total);
    const percent = new Percent$3(portion.numerator, portion.denominator);
    return `[${protocol == distExports.Protocol.MIXED ? "V2 + V3" : protocol}] ${percent.toFixed(2)}% = ${routeToString(route)}`;
  });
  return _$3.join(routeStrings, ", ");
};
const poolToString = (p2) => {
  return `${p2.token0.symbol}/${p2.token1.symbol}${p2 instanceof Pool ? `/${p2.fee / 1e4}%` : ``}`;
};
const version$a = "abstract-provider/5.7.0";
var __awaiter$7 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$a = new Logger(version$a);
class ForkEvent extends Description {
  static isForkEvent(value) {
    return !!(value && value._isForkEvent);
  }
}
class Provider {
  constructor() {
    logger$a.checkAbstract(new.target, Provider);
    defineReadOnly(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter$7(this, void 0, void 0, function* () {
      const { block: block2, gasPrice } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((error) => {
          return null;
        })
      });
      let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
      if (block2 && block2.baseFeePerGas) {
        lastBaseFeePerGas = block2.baseFeePerGas;
        maxPriorityFeePerGas = BigNumber.from("1500000000");
        maxFeePerGas = block2.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };
    });
  }
  // Alias for "on"
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  // Alias for "off"
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  static isProvider(value) {
    return !!(value && value._isProvider);
  }
}
const version$9 = "abstract-signer/5.7.0";
var __awaiter$6 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$9 = new Logger(version$9);
const allowedTransactionKeys$2 = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
const forwardErrors = [
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED
];
class Signer {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    logger$9.checkAbstract(new.target, Signer);
    defineReadOnly(this, "_isSigner", true);
  }
  ///////////////////
  // Sub-classes MAY override these
  getBalance(blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  // Populates "from" if unspecified, and estimates the gas for the transaction
  estimateGas(transaction) {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  // Populates "from" if unspecified, and calls with the transaction
  call(transaction, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  // Populates all fields in a transaction, signs it and sends it to the network
  sendTransaction(transaction) {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name2);
    });
  }
  // Checks a transaction does not contain invalid keys and if
  // no "from" is provided, populates it.
  // - does NOT require a provider
  // - adds "from" is not present
  // - returns a COPY (safe to mutate the result)
  // By default called from: (overriding these prevents it)
  //   - call
  //   - estimateGas
  //   - populateTransaction (and therefor sendTransaction)
  checkTransaction(transaction) {
    for (const key2 in transaction) {
      if (allowedTransactionKeys$2.indexOf(key2) === -1) {
        logger$9.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction);
      }
    }
    const tx = shallowCopy(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger$9.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  // Populates ALL keys for a transaction and checks that "from" matches
  // this Signer. Should be used by sendTransaction but NOT by signTransaction.
  // By default called from: (overriding these prevents it)
  //   - sendTransaction
  //
  // Notes:
  //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
  populateTransaction(transaction) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter$6(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger$9.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger$9.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger$9.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger$9.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger$9.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error) => {
          if (forwardErrors.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger$9.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results) => {
          if (results[1] !== 0 && results[0] !== results[1]) {
            logger$9.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results[0];
        });
      }
      return yield resolveProperties(tx);
    });
  }
  ///////////////////
  // Sub-classes SHOULD leave these alone
  _checkProvider(operation) {
    if (!this.provider) {
      logger$9.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
}
class VoidSigner extends Signer {
  constructor(address, provider) {
    super();
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "provider", provider || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(message, operation) {
    return Promise.resolve().then(() => {
      logger$9.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation });
    });
  }
  signMessage(message) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(transaction) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(domain, types2, value) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(provider) {
    return new VoidSigner(this.address, provider);
  }
}
function createCommonjsModule(fn2, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base3) {
      return commonjsRequire$1(path, base3 === void 0 || base3 === null ? module.path : base3);
    }
  }, fn2(module, module.exports), module.exports;
}
function commonjsRequire$1() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert;
function assert(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert.equal = function assertEqual2(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var utils_1 = createCommonjsModule(function(module, exports) {
  var utils2 = exports;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i3 = 0; i3 < msg.length; i3++)
        res[i3] = msg[i3] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i3 = 0; i3 < msg.length; i3 += 2)
        res.push(parseInt(msg[i3] + msg[i3 + 1], 16));
    } else {
      for (var i3 = 0; i3 < msg.length; i3++) {
        var c2 = msg.charCodeAt(i3);
        var hi2 = c2 >> 8;
        var lo = c2 & 255;
        if (hi2)
          res.push(hi2, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils2.toArray = toArray2;
  function zero22(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils2.zero2 = zero22;
  function toHex2(msg) {
    var res = "";
    for (var i3 = 0; i3 < msg.length; i3++)
      res += zero22(msg[i3].toString(16));
    return res;
  }
  utils2.toHex = toHex2;
  utils2.encode = function encode4(arr, enc) {
    if (enc === "hex")
      return toHex2(arr);
    else
      return arr;
  };
});
var utils_1$1 = createCommonjsModule(function(module, exports) {
  var utils2 = exports;
  utils2.assert = minimalisticAssert;
  utils2.toArray = utils_1.toArray;
  utils2.zero2 = utils_1.zero2;
  utils2.toHex = utils_1.toHex;
  utils2.encode = utils_1.encode;
  function getNAF2(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k4 = num.clone();
    for (var i3 = 0; i3 < naf.length; i3++) {
      var z2;
      var mod = k4.andln(ws - 1);
      if (k4.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z2 = (ws >> 1) - mod;
        else
          z2 = mod;
        k4.isubn(z2);
      } else {
        z2 = 0;
      }
      naf[i3] = z2;
      k4.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k22) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k22 = k22.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k22.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k22.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k22.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k22.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty(obj, name2, computer) {
    var key2 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty;
  function parseBytes(bytes2) {
    return typeof bytes2 === "string" ? utils2.toArray(bytes2, "hex") : bytes2;
  }
  utils2.parseBytes = parseBytes;
  function intFromLE(bytes2) {
    return new BN$1(bytes2, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
});
var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN$1(conf.p, 16);
  this.red = conf.prime ? BN$1.red(conf.prime) : BN$1.mont(this.p);
  this.zero = new BN$1(0).toRed(this.red);
  this.one = new BN$1(1).toRed(this.red);
  this.two = new BN$1(2).toRed(this.red);
  this.n = conf.n && new BN$1(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base$1 = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k4) {
  assert$1(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF(k4, 1, this._bitLength);
  var I3 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I3 /= 3;
  var repr = [];
  var j2;
  var nafW;
  for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
    nafW = 0;
    for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a2 = this.jpoint(null, null, null);
  var b3 = this.jpoint(null, null, null);
  for (var i3 = I3; i3 > 0; i3--) {
    for (j2 = 0; j2 < repr.length; j2++) {
      nafW = repr[j2];
      if (nafW === i3)
        b3 = b3.mixedAdd(doubles.points[j2]);
      else if (nafW === -i3)
        b3 = b3.mixedAdd(doubles.points[j2].neg());
    }
    a2 = a2.add(b3);
  }
  return a2.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p2, k4) {
  var w2 = 4;
  var nafPoints = p2._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k4, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i3 = naf.length - 1; i3 >= 0; i3--) {
    for (var l2 = 0; i3 >= 0 && naf[i3] === 0; i3--)
      l2++;
    if (i3 >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i3 < 0)
      break;
    var z2 = naf[i3];
    assert$1(z2 !== 0);
    if (p2.type === "affine") {
      if (z2 > 0)
        acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
    } else {
      if (z2 > 0)
        acc = acc.add(wnd[z2 - 1 >> 1]);
      else
        acc = acc.add(wnd[-z2 - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i3;
  var j2;
  var p2;
  for (i3 = 0; i3 < len; i3++) {
    p2 = points[i3];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i3] = nafPoints.wnd;
    wnd[i3] = nafPoints.points;
  }
  for (i3 = len - 1; i3 >= 1; i3 -= 2) {
    var a2 = i3 - 1;
    var b3 = i3;
    if (wndWidth[a2] !== 1 || wndWidth[b3] !== 1) {
      naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
      naf[b3] = getNAF(coeffs[b3], wndWidth[b3], this._bitLength);
      max = Math.max(naf[a2].length, max);
      max = Math.max(naf[b3].length, max);
      continue;
    }
    var comb = [
      points[a2],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      points[b3]
      /* 7 */
    ];
    if (points[a2].y.cmp(points[b3].y) === 0) {
      comb[1] = points[a2].add(points[b3]);
      comb[2] = points[a2].toJ().mixedAdd(points[b3].neg());
    } else if (points[a2].y.cmp(points[b3].y.redNeg()) === 0) {
      comb[1] = points[a2].toJ().mixedAdd(points[b3]);
      comb[2] = points[a2].add(points[b3].neg());
    } else {
      comb[1] = points[a2].toJ().mixedAdd(points[b3]);
      comb[2] = points[a2].toJ().mixedAdd(points[b3].neg());
    }
    var index2 = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ];
    var jsf = getJSF(coeffs[a2], coeffs[b3]);
    max = Math.max(jsf[0].length, max);
    naf[a2] = new Array(max);
    naf[b3] = new Array(max);
    for (j2 = 0; j2 < max; j2++) {
      var ja2 = jsf[0][j2] | 0;
      var jb2 = jsf[1][j2] | 0;
      naf[a2][j2] = index2[(ja2 + 1) * 3 + (jb2 + 1)];
      naf[b3][j2] = 0;
      wnd[a2] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i3 = max; i3 >= 0; i3--) {
    var k4 = 0;
    while (i3 >= 0) {
      var zero = true;
      for (j2 = 0; j2 < len; j2++) {
        tmp[j2] = naf[j2][i3] | 0;
        if (tmp[j2] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k4++;
      i3--;
    }
    if (i3 >= 0)
      k4++;
    acc = acc.dblp(k4);
    if (i3 < 0)
      break;
    for (j2 = 0; j2 < len; j2++) {
      var z2 = tmp[j2];
      if (z2 === 0)
        continue;
      else if (z2 > 0)
        p2 = wnd[j2][z2 - 1 >> 1];
      else if (z2 < 0)
        p2 = wnd[j2][-z2 - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i3 = 0; i3 < len; i3++)
    wnd[i3] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate2() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes2, enc) {
  bytes2 = utils_1$1.toArray(bytes2, enc);
  var len = this.p.byteLength();
  if ((bytes2[0] === 4 || bytes2[0] === 6 || bytes2[0] === 7) && bytes2.length - 1 === 2 * len) {
    if (bytes2[0] === 6)
      assert$1(bytes2[bytes2.length - 1] % 2 === 0);
    else if (bytes2[0] === 7)
      assert$1(bytes2[bytes2.length - 1] % 2 === 1);
    var res = this.point(
      bytes2.slice(1, 1 + len),
      bytes2.slice(1 + len, 1 + 2 * len)
    );
    return res;
  } else if ((bytes2[0] === 2 || bytes2[0] === 3) && bytes2.length - 1 === len) {
    return this.pointFromX(bytes2.slice(1, 1 + len), bytes2[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode2(compact) {
  var len = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode(enc, compact) {
  return utils_1$1.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k4) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k4.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i3 = 0; i3 < power; i3 += step) {
    for (var j2 = 0; j2 < step; j2++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl3 = max === 1 ? null : this.dbl();
  for (var i3 = 1; i3 < max; i3++)
    res[i3] = res[i3 - 1].add(dbl3);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k4) {
  var r2 = this;
  for (var i3 = 0; i3 < k4; i3++)
    r2 = r2.dbl();
  return r2;
};
var inherits_browser = createCommonjsModule(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$2 = utils_1$1.assert;
function ShortCurve(conf) {
  base$1.call(this, "short", conf);
  this.a = new BN$1(conf.a, 16).toRed(this.red);
  this.b = new BN$1(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base$1);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$1(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$1(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$1(vec.a, 16),
        b: new BN$1(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red2 = num === this.p ? this.red : BN$1.mont(num);
  var tinv = new BN$1(2).toRed(red2).redInvm();
  var ntinv = tinv.redNeg();
  var s4 = new BN$1(3).toRed(red2).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s4).fromRed();
  var l2 = ntinv.redSub(s4).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v2 = this.n.clone();
  var x1 = new BN$1(1);
  var y1 = new BN$1(0);
  var x2 = new BN$1(0);
  var y2 = new BN$1(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b22;
  var prevR;
  var i3 = 0;
  var r2;
  var x3;
  while (u2.cmpn(0) !== 0) {
    var q2 = v2.div(u2);
    r2 = v2.sub(q2.mul(u2));
    x3 = x2.sub(q2.mul(x1));
    var y3 = y2.sub(q2.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x3;
    } else if (a1 && ++i3 === 2) {
      break;
    }
    prevR = r2;
    v2 = u2;
    u2 = r2;
    x2 = x1;
    x1 = x3;
    y2 = y1;
    y1 = y3;
  }
  a2 = r2.neg();
  b22 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b22.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b22 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b22 = b22.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b22 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k4) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k4).divRound(this.n);
  var c2 = v1.b.neg().mul(k4).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k4.sub(p1).sub(p2);
  var k22 = q1.add(q2).neg();
  return { k1, k2: k22 };
};
ShortCurve.prototype.pointFromX = function pointFromX(x2, odd) {
  x2 = new BN$1(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y2 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y3 = y2.redSqrt();
  if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y3.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y3 = y3.redNeg();
  return this.point(x2, y3);
};
ShortCurve.prototype.validate = function validate3(point3) {
  if (point3.inf)
    return true;
  var x2 = point3.x;
  var y2 = point3.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y2.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i3 = 0; i3 < points.length; i3++) {
    var split2 = this._endoSplit(coeffs[i3]);
    var p2 = points[i3];
    var beta = p2._getBeta();
    if (split2.k1.negative) {
      split2.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split2.k2.negative) {
      split2.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i3 * 2] = p2;
    npoints[i3 * 2 + 1] = beta;
    ncoeffs[i3 * 2] = split2.k1;
    ncoeffs[i3 * 2 + 1] = split2.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i3 * 2, jacobianResult);
  for (var j2 = 0; j2 < i3 * 2; j2++) {
    npoints[j2] = null;
    ncoeffs[j2] = null;
  }
  return res;
};
function Point(curve, x2, y2, isRed) {
  base$1.BasePoint.call(this, curve, "affine");
  if (x2 === null && y2 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$1(x2, 16);
    this.y = new BN$1(y2, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point, base$1.BasePoint);
ShortCurve.prototype.point = function point2(x2, y2, isRed) {
  return new Point(this, x2, y2, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red2) {
  return Point.fromJSON(this, obj, red2);
};
Point.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p2) {
      return curve.point(p2.x.redMul(curve.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point.fromJSON = function fromJSON(curve, obj, red2) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red2);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red2);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point.prototype.add = function add(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p2.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a2 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point.prototype.mul = function mul(k4) {
  k4 = new BN$1(k4, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k4))
    return this.curve._fixedNafMul(this, k4);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k4]);
  else
    return this.curve._wnafMul(this, k4);
};
Point.prototype.mulAdd = function mulAdd(k1, p2, k22) {
  var points = [this, p2];
  var coeffs = [k1, k22];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p2, k22) {
  var points = [this, p2];
  var coeffs = [k1, k22];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq2(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve, x2, y2, z2) {
  base$1.BasePoint.call(this, curve, "jacobian");
  if (x2 === null && y2 === null && z2 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$1(0);
  } else {
    this.x = new BN$1(x2, 16);
    this.y = new BN$1(y2, 16);
    this.z = new BN$1(z2, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base$1.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x2, y2, z2) {
  return new JPoint(this, x2, y2, z2);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add2(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s22 = p2.y.redMul(z2.redMul(this.z));
  var h4 = u1.redSub(u2);
  var r2 = s1.redSub(s22);
  if (h4.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h4.redSqr();
  var h32 = h22.redMul(h4);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h32).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h32));
  var nz = this.z.redMul(p2.z).redMul(h4);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z2);
  var s1 = this.y;
  var s22 = p2.y.redMul(z2).redMul(this.z);
  var h4 = u1.redSub(u2);
  var r2 = s1.redSub(s22);
  if (h4.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h4.redSqr();
  var h32 = h22.redMul(h4);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h32).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h32));
  var nz = this.z.redMul(h4);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i3;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i3 = 0; i3 < pow; i3++)
      r2 = r2.dbl();
    return r2;
  }
  var a2 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i3 = 0; i3 < pow; i3++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i3 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s4 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s4 = s4.redIAdd(s4);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m2.redSqr().redISub(s4).redISub(s4);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m2.redMul(s4.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a2 = this.x.redSqr();
    var b3 = this.y.redSqr();
    var c2 = b3.redSqr();
    var d2 = this.x.redAdd(b3).redSqr().redISub(a2).redISub(c2);
    d2 = d2.redIAdd(d2);
    var e2 = a2.redAdd(a2).redIAdd(a2);
    var f3 = e2.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f3.redISub(d2).redISub(d2);
    ny = e2.redMul(d2.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s4 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s4 = s4.redIAdd(s4);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m2.redSqr().redISub(s4).redISub(s4);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s4.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha2 = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha2 = alpha2.redAdd(alpha2).redIAdd(alpha2);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha2.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha2.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a2 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e2 = e2.redIAdd(e2);
  e2 = e2.redAdd(e2).redIAdd(e2);
  e2 = e2.redISub(mm);
  var ee2 = e2.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u2 = m2.redIAdd(e2).redSqr().redISub(mm).redISub(ee2).redISub(t2);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee2).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e2.redMul(ee2)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul2(k4, kbase) {
  k4 = new BN$1(k4, kbase);
  return this.curve._wnafMul(this, k4);
};
JPoint.prototype.eq = function eq3(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x2) {
  var zs = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc2 = x2.clone();
  var t2 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc2.iadd(this.curve.n);
    if (xc2.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module, exports) {
  var curve = exports;
  curve.base = base$1;
  curve.short = short_1;
  curve.mont = /*RicMoo:ethers:require(./mont)*/
  null;
  curve.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
});
var curves_1 = createCommonjsModule(function(module, exports) {
  var curves = exports;
  var assert2 = utils_1$1.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_1.edwards(options);
    else
      this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$3.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$3.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$3.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$3.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$3.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$3.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$3.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch (e2) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$3.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init2(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i3 = 0; i3 < this.V.length; i3++) {
    this.K[i3] = 0;
    this.V[i3] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function hmac() {
  return new hash$3.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update4(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add4, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add4;
    add4 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1.toArray(entropy, entropyEnc);
  add4 = utils_1.toArray(add4, addEnc);
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._update(entropy.concat(add4 || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len, enc, add4, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add4;
    add4 = enc;
    enc = null;
  }
  if (add4) {
    add4 = utils_1.toArray(add4, addEnc || "hex");
    this._update(add4);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add4);
  this._reseed++;
  return utils_1.encode(res, enc);
};
var assert$3 = utils_1$1.assert;
function KeyPair(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(ec2, {
    pub,
    pubEnc: enc
  });
};
KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;
  return new KeyPair(ec2, {
    priv,
    privEnc: enc
  });
};
KeyPair.prototype.validate = function validate4() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
  this.priv = new BN$1(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$3(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$3(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert$3(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
};
KeyPair.prototype.inspect = function inspect3() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1.assert;
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new BN$1(options.r, 16);
  this.s = new BN$1(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i3 = 0, off = p2.place; i3 < octetLen; i3++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding(buf) {
  var i3 = 0;
  var len = buf.length - 1;
  while (!buf[i3] && !(buf[i3 + 1] & 128) && i3 < len) {
    i3++;
  }
  if (i3 === 0) {
    return buf;
  }
  return buf.slice(i3);
}
Signature.prototype._importDER = function _importDER(data2, enc) {
  data2 = utils_1$1.toArray(data2, enc);
  var p2 = new Position();
  if (data2[p2.place++] !== 48) {
    return false;
  }
  var len = getLength(data2, p2);
  if (len === false) {
    return false;
  }
  if (len + p2.place !== data2.length) {
    return false;
  }
  if (data2[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data2, p2);
  if (rlen === false) {
    return false;
  }
  var r2 = data2.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data2[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength(data2, p2);
  if (slen === false) {
    return false;
  }
  if (data2.length !== slen + p2.place) {
    return false;
  }
  var s4 = data2.slice(p2.place, slen + p2.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s4[0] === 0) {
    if (s4[1] & 128) {
      s4 = s4.slice(1);
    } else {
      return false;
    }
  }
  this.r = new BN$1(r2);
  this.s = new BN$1(s4);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
  var r2 = this.r.toArray();
  var s4 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s4[0] & 128)
    s4 = [0].concat(s4);
  r2 = rmPadding(r2);
  s4 = rmPadding(s4);
  while (!s4[0] && !(s4[1] & 128)) {
    s4 = s4.slice(1);
  }
  var arr = [2];
  constructLength(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength(arr, s4.length);
  var backHalf = arr.concat(s4);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
};
var rand = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
);
var assert$5 = utils_1$1.assert;
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5(
      Object.prototype.hasOwnProperty.call(curves_1, options),
      "Unknown curve " + options
    );
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair(options) {
  return new key(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes2 = this.n.byteLength();
  var ns2 = this.n.sub(new BN$1(2));
  for (; ; ) {
    var priv = new BN$1(drbg.generate(bytes2));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC.prototype.sign = function sign2(msg, key2, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key2 = this.keyFromPrivate(key2, enc);
  msg = this._truncateToN(new BN$1(msg, 16));
  var bytes2 = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes2);
  var nonce = msg.toArray("be", bytes2);
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new BN$1(1));
  for (var iter = 0; ; iter++) {
    var k4 = options.k ? options.k(iter) : new BN$1(drbg.generate(this.n.byteLength()));
    k4 = this._truncateToN(k4, true);
    if (k4.cmpn(1) <= 0 || k4.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k4);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s4 = k4.invm(this.n).mul(r2.mul(key2.getPrivate()).iadd(msg));
    s4 = s4.umod(this.n);
    if (s4.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s4.cmp(this.nh) > 0) {
      s4 = this.n.sub(s4);
      recoveryParam ^= 1;
    }
    return new signature({ r: r2, s: s4, recoveryParam });
  }
};
EC.prototype.verify = function verify2(msg, signature$1, key2, enc) {
  msg = this._truncateToN(new BN$1(msg, 16));
  key2 = this.keyFromPublic(key2, enc);
  signature$1 = new signature(signature$1, "hex");
  var r2 = signature$1.r;
  var s4 = signature$1.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s4.cmpn(1) < 0 || s4.cmp(this.n) >= 0)
    return false;
  var sinv = s4.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p2;
  if (!this.curve._maxwellTrick) {
    p2 = this.g.mulAdd(u1, key2.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.getX().umod(this.n).cmp(r2) === 0;
  }
  p2 = this.g.jmulAdd(u1, key2.getPublic(), u2);
  if (p2.isInfinity())
    return false;
  return p2.eqXToP(r2);
};
EC.prototype.recoverPubKey = function(msg, signature$1, j2, enc) {
  assert$5((3 & j2) === j2, "The recovery param is more than two bits");
  signature$1 = new signature(signature$1, enc);
  var n4 = this.n;
  var e2 = new BN$1(msg);
  var r2 = signature$1.r;
  var s4 = signature$1.s;
  var isYOdd = j2 & 1;
  var isSecondKey = j2 >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$1.r.invm(n4);
  var s1 = n4.sub(e2).mul(rInv).umod(n4);
  var s22 = s4.mul(rInv).umod(n4);
  return this.g.mulAdd(s1, r2, s22);
};
EC.prototype.getKeyRecoveryParam = function(e2, signature$1, Q2, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i3 = 0; i3 < 4; i3++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e2, signature$1, i3);
    } catch (e3) {
      continue;
    }
    if (Qprime.eq(Q2))
      return i3;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module, exports) {
  var elliptic = exports;
  elliptic.version = /*RicMoo:ethers*/
  { version: "6.5.4" }.version;
  elliptic.utils = utils_1$1;
  elliptic.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_1;
  elliptic.curves = curves_1;
  elliptic.ec = ec;
  elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
});
var EC$1 = elliptic_1.ec;
const version$8 = "signing-key/5.7.0";
const logger$8 = new Logger(version$8);
let _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
class SigningKey {
  constructor(privateKey) {
    defineReadOnly(this, "curve", "secp256k1");
    defineReadOnly(this, "privateKey", hexlify(privateKey));
    if (hexDataLength(this.privateKey) !== 32) {
      logger$8.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    }
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
    defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
    defineReadOnly(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest9) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const digestBytes = arrayify(digest9);
    if (digestBytes.length !== 32) {
      logger$8.throwArgumentError("bad digest length", "digest", digest9);
    }
    const signature2 = keyPair2.sign(digestBytes, { canonical: true });
    return splitSignature({
      recoveryParam: signature2.recoveryParam,
      r: hexZeroPad("0x" + signature2.r.toString(16), 32),
      s: hexZeroPad("0x" + signature2.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
    return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
}
function recoverPublicKey(digest9, signature2) {
  const sig = splitSignature(signature2);
  const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(digest9), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key2, compressed) {
  const bytes2 = arrayify(key2);
  if (bytes2.length === 32) {
    const signingKey = new SigningKey(bytes2);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes2).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes2.length === 33) {
    if (compressed) {
      return hexlify(bytes2);
    }
    return "0x" + getCurve().keyFromPublic(bytes2).getPublic(false, "hex");
  } else if (bytes2.length === 65) {
    if (!compressed) {
      return hexlify(bytes2);
    }
    return "0x" + getCurve().keyFromPublic(bytes2).getPublic(true, "hex");
  }
  return logger$8.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const version$7 = "transactions/5.7.0";
const logger$7 = new Logger(version$7);
var TransactionTypes;
(function(TransactionTypes2) {
  TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
  TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
  TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress$1(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero$1;
  }
  return BigNumber.from(value);
}
function computeAddress(key2) {
  const publicKey = computePublicKey(key2);
  return getAddress$1(hexDataSlice(keccak256$2(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest9, signature2) {
  return computeAddress(recoverPublicKey(arrayify(digest9), signature2));
}
function formatNumber(value, name2) {
  const result = stripZeros(BigNumber.from(value).toHexString());
  if (result.length > 32) {
    logger$7.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress$1(addr),
    storageKeys: (storageKeys || []).map((storageKey, index2) => {
      if (hexDataLength(storageKey) !== 32) {
        logger$7.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index2}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set2, index2) => {
      if (Array.isArray(set2)) {
        if (set2.length > 2) {
          logger$7.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index2}]`, set2);
        }
        return accessSetify(set2[0], set2[1]);
      }
      return accessSetify(set2.address, set2.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b3) => a2.address.localeCompare(b3.address));
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set2) => [set2.address, set2.storageKeys]);
}
function _serializeEip1559(transaction, signature2) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger$7.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress$1(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode$5(fields)]);
}
function _serializeEip2930(transaction, signature2) {
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.gasPrice || 0, "gasPrice"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress$1(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode$5(fields)]);
}
function _parseEipSignature(tx, fields, serialize2) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger$7.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest9 = keccak256$2(serialize2(tx));
    tx.from = recoverAddress(digest9, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
  }
}
function _parseEip1559(payload) {
  const transaction = decode$5(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger$7.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak256$2(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode$5(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger$7.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak256$2(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction = decode$5(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger$7.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction[6]).toNumber();
  } catch (error) {
    return tx;
  }
  tx.r = hexZeroPad(transaction[7], 32);
  tx.s = hexZeroPad(transaction[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest9 = keccak256$2(encode$5(raw));
    try {
      tx.from = recoverAddress(digest9, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
    } catch (error) {
    }
    tx.hash = keccak256$2(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse(rawTransaction) {
  const payload = arrayify(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
  }
  return logger$7.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}
const version$6 = "contracts/5.7.0";
var __awaiter$5 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$6 = new Logger(version$6);
const allowedTransactionKeys$1 = {
  chainId: true,
  data: true,
  from: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true,
  customData: true,
  ccipReadEnabled: true
};
function resolveName(resolver, nameOrPromise) {
  return __awaiter$5(this, void 0, void 0, function* () {
    const name2 = yield nameOrPromise;
    if (typeof name2 !== "string") {
      logger$6.throwArgumentError("invalid address or ENS name", "name", name2);
    }
    try {
      return getAddress$1(name2);
    } catch (error) {
    }
    if (!resolver) {
      logger$6.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name2);
    if (address == null) {
      logger$6.throwArgumentError("resolver or addr is not configured for ENS name", "name", name2);
    }
    return address;
  });
}
function resolveAddresses(resolver, value, paramType) {
  return __awaiter$5(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index2) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index2] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger$6.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v2) => resolveAddresses(resolver, v2, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter$5(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy(args.pop());
    }
    logger$6.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter$5(this, void 0, void 0, function* () {
          if (getAddress$1(check.signer) !== check.override) {
            logger$6.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    const data2 = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data: data2,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes2 = arrayify(data2);
      for (let i3 = 0; i3 < bytes2.length; i3++) {
        intrinsic += 4;
        if (bytes2[i3]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger$6.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key2) => overrides[key2] != null);
    if (leftovers.length) {
      logger$6.throwError(`cannot override ${leftovers.map((l2) => JSON.stringify(l2)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter$5(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger$6.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait2 = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait2(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log3) => {
        let event = deepCopy(log3);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log3);
        } catch (e2) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data2, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data2, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter$5(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter$5(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger$6.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag$1(filter) {
  if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
    return "*";
  }
  return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
class RunningEvent {
  constructor(tag, filter) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "filter", filter);
    this._listeners = [];
  }
  addListener(listener, once3) {
    this._listeners.push({ listener, once: once3 });
  }
  removeListener(listener) {
    let done = false;
    this._listeners = this._listeners.filter((item) => {
      if (done || item.listener !== listener) {
        return true;
      }
      done = true;
      return false;
    });
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((i3) => i3.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(args) {
    const listenerCount2 = this.listenerCount();
    this._listeners = this._listeners.filter((item) => {
      const argsCopy = args.slice();
      setTimeout(() => {
        item.listener.apply(this, argsCopy);
      }, 0);
      return !item.once;
    });
    return listenerCount2;
  }
  prepareEvent(event) {
  }
  // Returns the array that will be applied to an emit
  getEmit(event) {
    return [event];
  }
}
class ErrorRunningEvent extends RunningEvent {
  constructor() {
    super("error", null);
  }
}
class FragmentRunningEvent extends RunningEvent {
  constructor(address, contractInterface, fragment, topics) {
    const filter = {
      address
    };
    let topic = contractInterface.getEventTopic(fragment);
    if (topics) {
      if (topic !== topics[0]) {
        logger$6.throwArgumentError("topic mismatch", "topics", topics);
      }
      filter.topics = topics.slice();
    } else {
      filter.topics = [topic];
    }
    super(getEventTag$1(filter), filter);
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
    defineReadOnly(this, "fragment", fragment);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();
    event.decode = (data2, topics) => {
      return this.interface.decodeEventLog(this.fragment, data2, topics);
    };
    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error) {
      event.args = null;
      event.decodeError = error;
    }
  }
  getEmit(event) {
    const errors = checkResultErrors(event.args);
    if (errors.length) {
      throw errors[0].error;
    }
    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }
}
class WildcardRunningEvent extends RunningEvent {
  constructor(address, contractInterface) {
    super("*", { address });
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;
      event.decode = (data2, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data2, topics);
      };
      event.args = parsed.args;
    } catch (error) {
    }
  }
}
class BaseContract {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    if (signerOrProvider == null) {
      defineReadOnly(this, "provider", null);
      defineReadOnly(this, "signer", null);
    } else if (Signer.isSigner(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider.provider || null);
      defineReadOnly(this, "signer", signerOrProvider);
    } else if (Provider.isProvider(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider);
      defineReadOnly(this, "signer", null);
    } else {
      logger$6.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }
    defineReadOnly(this, "callStatic", {});
    defineReadOnly(this, "estimateGas", {});
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "populateTransaction", {});
    defineReadOnly(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach((eventSignature) => {
        const event = this.interface.events[eventSignature];
        defineReadOnly(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });
        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }
        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach((name2) => {
        const filters = uniqueFilters[name2];
        if (filters.length === 1) {
          defineReadOnly(this.filters, name2, this.filters[filters[0]]);
        } else {
          logger$6.warn(`Duplicate definition of ${name2} (${filters.join(", ")})`);
        }
      });
    }
    defineReadOnly(this, "_runningEvents", {});
    defineReadOnly(this, "_wrappedEmits", {});
    if (addressOrName == null) {
      logger$6.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }
    defineReadOnly(this, "address", addressOrName);
    if (this.provider) {
      defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress$1(addressOrName)));
      } catch (error) {
        logger$6.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    }
    this.resolvedAddress.catch((e2) => {
    });
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach((signature2) => {
      const fragment = this.interface.functions[signature2];
      if (uniqueSignatures[signature2]) {
        logger$6.warn(`Duplicate ABI entry for ${JSON.stringify(signature2)}`);
        return;
      }
      uniqueSignatures[signature2] = true;
      {
        const name2 = fragment.name;
        if (!uniqueNames[`%${name2}`]) {
          uniqueNames[`%${name2}`] = [];
        }
        uniqueNames[`%${name2}`].push(signature2);
      }
      if (this[signature2] == null) {
        defineReadOnly(this, signature2, buildDefault(this, fragment, true));
      }
      if (this.functions[signature2] == null) {
        defineReadOnly(this.functions, signature2, buildDefault(this, fragment, false));
      }
      if (this.callStatic[signature2] == null) {
        defineReadOnly(this.callStatic, signature2, buildCall(this, fragment, true));
      }
      if (this.populateTransaction[signature2] == null) {
        defineReadOnly(this.populateTransaction, signature2, buildPopulate(this, fragment));
      }
      if (this.estimateGas[signature2] == null) {
        defineReadOnly(this.estimateGas, signature2, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach((name2) => {
      const signatures = uniqueNames[name2];
      if (signatures.length > 1) {
        return;
      }
      name2 = name2.substring(1);
      const signature2 = signatures[0];
      try {
        if (this[name2] == null) {
          defineReadOnly(this, name2, this[signature2]);
        }
      } catch (e2) {
      }
      if (this.functions[name2] == null) {
        defineReadOnly(this.functions, name2, this.functions[signature2]);
      }
      if (this.callStatic[name2] == null) {
        defineReadOnly(this.callStatic, name2, this.callStatic[signature2]);
      }
      if (this.populateTransaction[name2] == null) {
        defineReadOnly(this.populateTransaction, name2, this.populateTransaction[signature2]);
      }
      if (this.estimateGas[name2] == null) {
        defineReadOnly(this.estimateGas, name2, this.estimateGas[signature2]);
      }
    });
  }
  static getContractAddress(transaction) {
    return getContractAddress$1(transaction);
  }
  static getInterface(contractInterface) {
    if (Interface.isInterface(contractInterface)) {
      return contractInterface;
    }
    return new Interface(contractInterface);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(blockTag) {
    if (!this._deployedPromise) {
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code2) => {
          if (code2 === "0x") {
            logger$6.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }
          return this;
        });
      }
    }
    return this._deployedPromise;
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(overrides) {
    if (!this.signer) {
      logger$6.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    }
    const tx = shallowCopy(overrides || {});
    ["from", "to"].forEach(function(key2) {
      if (tx[key2] == null) {
        return;
      }
      logger$6.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  }
  // Reconnect to a different signer or provider
  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
    }
    const contract = new this.constructor(this.address, this.interface, signerOrProvider);
    if (this.deployTransaction) {
      defineReadOnly(contract, "deployTransaction", this.deployTransaction);
    }
    return contract;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }
  static isIndexed(value) {
    return Indexed.isIndexed(value);
  }
  _normalizeRunningEvent(runningEvent) {
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }
    return runningEvent;
  }
  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      }
      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      }
      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    }
    if (eventName.topics && eventName.topics.length > 0) {
      try {
        const topic = eventName.topics[0];
        if (typeof topic !== "string") {
          throw new Error("invalid topic");
        }
        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error) {
      }
      const filter = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag$1(filter), filter));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag];
      const emit2 = this._wrappedEmits[runningEvent.tag];
      if (emit2 && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit2);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(runningEvent, log3, listener) {
    const event = deepCopy(log3);
    event.removeListener = () => {
      if (!listener) {
        return;
      }
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
    };
    event.getBlock = () => {
      return this.provider.getBlock(log3.blockHash);
    };
    event.getTransaction = () => {
      return this.provider.getTransaction(log3.transactionHash);
    };
    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log3.transactionHash);
    };
    runningEvent.prepareEvent(event);
    return event;
  }
  _addEventListener(runningEvent, listener, once3) {
    if (!this.provider) {
      logger$6.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
    }
    runningEvent.addListener(listener, once3);
    this._runningEvents[runningEvent.tag] = runningEvent;
    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = (log3) => {
        let event = this._wrapEvent(runningEvent, log3, listener);
        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error) {
            event.decodeError = error.error;
          }
        }
        if (runningEvent.filter != null) {
          this.emit("event", event);
        }
        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      };
      this._wrappedEmits[runningEvent.tag] = wrappedEmit;
      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }
  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);
    const filter = shallowCopy(runningEvent.filter);
    if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger$6.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }
      filter.blockHash = fromBlockOrBlockhash;
    } else {
      filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter.toBlock = toBlock != null ? toBlock : "latest";
    }
    return this.provider.getLogs(filter).then((logs) => {
      return logs.map((log3) => this._wrapEvent(runningEvent, log3, null));
    });
  }
  on(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, false);
    return this;
  }
  once(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, true);
    return this;
  }
  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }
    const runningEvent = this._getRunningEvent(eventName);
    const result = runningEvent.run(args) > 0;
    this._checkRunningEvents(runningEvent);
    return result;
  }
  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }
    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key2) => {
        return accum + this._runningEvents[key2].listenerCount();
      }, 0);
    }
    return this._getRunningEvent(eventName).listenerCount();
  }
  listeners(eventName) {
    if (!this.provider) {
      return [];
    }
    if (eventName == null) {
      const result = [];
      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach((listener) => {
          result.push(listener);
        });
      }
      return result;
    }
    return this._getRunningEvent(eventName).listeners();
  }
  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }
    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent2 = this._runningEvents[tag];
        runningEvent2.removeAllListeners();
        this._checkRunningEvents(runningEvent2);
      }
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeAllListeners();
    this._checkRunningEvents(runningEvent);
    return this;
  }
  off(eventName, listener) {
    if (!this.provider) {
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeListener(listener);
    this._checkRunningEvents(runningEvent);
    return this;
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
}
class Contract extends BaseContract {
}
class ContractFactory {
  constructor(contractInterface, bytecode2, signer) {
    let bytecodeHex = null;
    if (typeof bytecode2 === "string") {
      bytecodeHex = bytecode2;
    } else if (isBytes(bytecode2)) {
      bytecodeHex = hexlify(bytecode2);
    } else if (bytecode2 && typeof bytecode2.object === "string") {
      bytecodeHex = bytecode2.object;
    } else {
      bytecodeHex = "!";
    }
    if (bytecodeHex.substring(0, 2) !== "0x") {
      bytecodeHex = "0x" + bytecodeHex;
    }
    if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {
      logger$6.throwArgumentError("invalid bytecode", "bytecode", bytecode2);
    }
    if (signer && !Signer.isSigner(signer)) {
      logger$6.throwArgumentError("invalid signer", "signer", signer);
    }
    defineReadOnly(this, "bytecode", bytecodeHex);
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    defineReadOnly(this, "signer", signer || null);
  }
  // @TODO: Future; rename to populateTransaction?
  getDeployTransaction(...args) {
    let tx = {};
    if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      tx = shallowCopy(args.pop());
      for (const key2 in tx) {
        if (!allowedTransactionKeys$1[key2]) {
          throw new Error("unknown transaction override " + key2);
        }
      }
    }
    ["data", "from", "to"].forEach((key2) => {
      if (tx[key2] == null) {
        return;
      }
      logger$6.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
    });
    if (tx.value) {
      const value = BigNumber.from(tx.value);
      if (!value.isZero() && !this.interface.deploy.payable) {
        logger$6.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: tx.value
        });
      }
    }
    logger$6.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
    tx.data = hexlify(concat$2([
      this.bytecode,
      this.interface.encodeDeploy(args)
    ]));
    return tx;
  }
  deploy(...args) {
    return __awaiter$5(this, void 0, void 0, function* () {
      let overrides = {};
      if (args.length === this.interface.deploy.inputs.length + 1) {
        overrides = args.pop();
      }
      logger$6.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
      const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
      params.push(overrides);
      const unsignedTx = this.getDeployTransaction(...params);
      const tx = yield this.signer.sendTransaction(unsignedTx);
      const address = getStatic(this.constructor, "getContractAddress")(tx);
      const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
      addContractWait(contract, tx);
      defineReadOnly(contract, "deployTransaction", tx);
      return contract;
    });
  }
  attach(address) {
    return this.constructor.getContract(address, this.interface, this.signer);
  }
  connect(signer) {
    return new this.constructor(this.interface, this.bytecode, signer);
  }
  static fromSolidity(compilerOutput, signer) {
    if (compilerOutput == null) {
      logger$6.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
    }
    if (typeof compilerOutput === "string") {
      compilerOutput = JSON.parse(compilerOutput);
    }
    const abi2 = compilerOutput.abi;
    let bytecode2 = null;
    if (compilerOutput.bytecode) {
      bytecode2 = compilerOutput.bytecode;
    } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
      bytecode2 = compilerOutput.evm.bytecode;
    }
    return new this(abi2, bytecode2, signer);
  }
  static getInterface(contractInterface) {
    return Contract.getInterface(contractInterface);
  }
  static getContractAddress(tx) {
    return getContractAddress$1(tx);
  }
  static getContract(address, contractInterface, signer) {
    return new Contract(address, contractInterface, signer);
  }
}
class BaseX {
  constructor(alphabet2) {
    defineReadOnly(this, "alphabet", alphabet2);
    defineReadOnly(this, "base", alphabet2.length);
    defineReadOnly(this, "_alphabetMap", {});
    defineReadOnly(this, "_leader", alphabet2.charAt(0));
    for (let i3 = 0; i3 < alphabet2.length; i3++) {
      this._alphabetMap[alphabet2.charAt(i3)] = i3;
    }
  }
  encode(value) {
    let source = arrayify(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i3 = 0; i3 < source.length; ++i3) {
      let carry = source[i3];
      for (let j2 = 0; j2 < digits.length; ++j2) {
        carry += digits[j2] << 8;
        digits[j2] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string2 = "";
    for (let k4 = 0; source[k4] === 0 && k4 < source.length - 1; ++k4) {
      string2 += this._leader;
    }
    for (let q2 = digits.length - 1; q2 >= 0; --q2) {
      string2 += this.alphabet[digits[q2]];
    }
    return string2;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes2 = [];
    if (value.length === 0) {
      return new Uint8Array(bytes2);
    }
    bytes2.push(0);
    for (let i3 = 0; i3 < value.length; i3++) {
      let byte2 = this._alphabetMap[value[i3]];
      if (byte2 === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte2;
      for (let j2 = 0; j2 < bytes2.length; ++j2) {
        carry += bytes2[j2] * this.base;
        bytes2[j2] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes2.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k4 = 0; value[k4] === this._leader && k4 < value.length - 1; ++k4) {
      bytes2.push(0);
    }
    return arrayify(new Uint8Array(bytes2.reverse()));
  }
}
new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
const version$5 = "networks/5.7.1";
const logger$5 = new Logger(version$5);
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      const skip = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const provider = new providers.PocketProvider(network, options.pocket);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        const skip = ["ropsten"];
        const provider = new providers.AnkrProvider(network, options.ankr);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func;
}
function etcDefaultProvider(url, network) {
  const func = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func;
}
const homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
const ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
const classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
const networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: ethDefaultProvider("sepolia")
  },
  // ETC (See: #351)
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ethDefaultProvider("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ethDefaultProvider("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork$1(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name2 in networks) {
      const standard2 = networks[name2];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger$5.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger$5.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}
const version$4 = "web/5.7.1";
var __awaiter$4 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl$1(href, options) {
  return __awaiter$4(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request2 = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request2.mode = "cors";
      request2.cache = "no-cache";
      request2.credentials = "same-origin";
      request2.redirect = "follow";
      request2.referrer = "client";
    }
    if (options.fetchOptions != null) {
      const opts = options.fetchOptions;
      if (opts.mode) {
        request2.mode = opts.mode;
      }
      if (opts.cache) {
        request2.cache = opts.cache;
      }
      if (opts.credentials) {
        request2.credentials = opts.credentials;
      }
      if (opts.redirect) {
        request2.redirect = opts.redirect;
      }
      if (opts.referrer) {
        request2.referrer = opts.referrer;
      }
    }
    const response = yield fetch(href, request2);
    const body2 = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key2) => {
        headers[key2.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key2) => {
        headers[key2.toLowerCase()] = response.headers.get(key2);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify(new Uint8Array(body2))
    };
  });
}
var __awaiter$3 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$4 = new Logger(version$4);
function staller(duration2) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration2);
  });
}
function bodyify(value, type) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {
      }
    }
    return hexlify(value);
  }
  return value;
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all2, code2) => {
    return String.fromCharCode(parseInt(code2, 16));
  }));
}
function _fetchData(connection, body2, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger$4.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger$4.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger$4.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout = connection.timeout;
    }
    if (connection.headers) {
      for (const key2 in connection.headers) {
        headers[key2.toLowerCase()] = { key: key2, value: String(connection.headers[key2]) };
        if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger$4.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode$3(toUtf8Bytes(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
    if (connection.fetchOptions != null) {
      options.fetchOptions = shallowCopy(connection.fetchOptions);
    }
  }
  const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] || "text/plain" },
        body: dataMatch[2] ? decode$4(dataMatch[3]) : unpercent(dataMatch[3])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger$4.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body2) {
    options.method = "POST";
    options.body = body2;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body2.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key2) => {
    const header = headers[key2];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer2 = null;
    const promise = new Promise(function(resolve, reject) {
      if (timeout) {
        timer2 = setTimeout(() => {
          if (timer2 == null) {
            return;
          }
          timer2 = null;
          reject(logger$4.makeError("timeout", Logger.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout,
            url
          }));
        }, timeout);
      }
    });
    const cancel = function() {
      if (timer2 == null) {
        return;
      }
      clearTimeout(timer2);
      timer2 = null;
    };
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter$3(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl$1(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location2 = response.headers.location || "";
              if (options.method === "GET" && location2.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall2 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall2 = parseInt(retryAfter) * 1e3;
                } else {
                  stall2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall2);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger$4.throwError("missing response", Logger.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body3 = response.body;
        if (allow304 && response.statusCode === 304) {
          body3 = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger$4.throwError("bad response", Logger.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body3, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body3, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout2);
                continue;
              }
            }
            runningTimeout.cancel();
            logger$4.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(body3, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body3;
      }
      return logger$4.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger$4.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body2 = null;
  if (json != null) {
    body2 = toUtf8Bytes(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k4) => k4.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body2, processJsonFunc);
}
function poll$1(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer2 = null;
    let done = false;
    const cancel = () => {
      if (done) {
        return false;
      }
      done = true;
      if (timer2) {
        clearTimeout(timer2);
      }
      return true;
    };
    if (options.timeout) {
      timer2 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout < options.floor) {
            timeout = options.floor;
          }
          if (timeout > options.ceiling) {
            timeout = options.ceiling;
          }
          setTimeout(check, timeout);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}
var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var ALPHABET_MAP = {};
for (var z$1 = 0; z$1 < ALPHABET.length; z$1++) {
  var x$2 = ALPHABET.charAt(z$1);
  if (ALPHABET_MAP[x$2] !== void 0)
    throw new TypeError(x$2 + " is ambiguous");
  ALPHABET_MAP[x$2] = z$1;
}
function polymodStep(pre) {
  var b3 = pre >> 25;
  return (pre & 33554431) << 5 ^ -(b3 >> 0 & 1) & 996825010 ^ -(b3 >> 1 & 1) & 642813549 ^ -(b3 >> 2 & 1) & 513874426 ^ -(b3 >> 3 & 1) & 1027748829 ^ -(b3 >> 4 & 1) & 705979059;
}
function prefixChk(prefix2) {
  var chk = 1;
  for (var i3 = 0; i3 < prefix2.length; ++i3) {
    var c2 = prefix2.charCodeAt(i3);
    if (c2 < 33 || c2 > 126)
      return "Invalid prefix (" + prefix2 + ")";
    chk = polymodStep(chk) ^ c2 >> 5;
  }
  chk = polymodStep(chk);
  for (i3 = 0; i3 < prefix2.length; ++i3) {
    var v2 = prefix2.charCodeAt(i3);
    chk = polymodStep(chk) ^ v2 & 31;
  }
  return chk;
}
function encode$2(prefix2, words, LIMIT) {
  LIMIT = LIMIT || 90;
  if (prefix2.length + 7 + words.length > LIMIT)
    throw new TypeError("Exceeds length limit");
  prefix2 = prefix2.toLowerCase();
  var chk = prefixChk(prefix2);
  if (typeof chk === "string")
    throw new Error(chk);
  var result = prefix2 + "1";
  for (var i3 = 0; i3 < words.length; ++i3) {
    var x2 = words[i3];
    if (x2 >> 5 !== 0)
      throw new Error("Non 5-bit word");
    chk = polymodStep(chk) ^ x2;
    result += ALPHABET.charAt(x2);
  }
  for (i3 = 0; i3 < 6; ++i3) {
    chk = polymodStep(chk);
  }
  chk ^= 1;
  for (i3 = 0; i3 < 6; ++i3) {
    var v2 = chk >> (5 - i3) * 5 & 31;
    result += ALPHABET.charAt(v2);
  }
  return result;
}
function __decode(str, LIMIT) {
  LIMIT = LIMIT || 90;
  if (str.length < 8)
    return str + " too short";
  if (str.length > LIMIT)
    return "Exceeds length limit";
  var lowered = str.toLowerCase();
  var uppered = str.toUpperCase();
  if (str !== lowered && str !== uppered)
    return "Mixed-case string " + str;
  str = lowered;
  var split2 = str.lastIndexOf("1");
  if (split2 === -1)
    return "No separator character for " + str;
  if (split2 === 0)
    return "Missing prefix for " + str;
  var prefix2 = str.slice(0, split2);
  var wordChars = str.slice(split2 + 1);
  if (wordChars.length < 6)
    return "Data too short";
  var chk = prefixChk(prefix2);
  if (typeof chk === "string")
    return chk;
  var words = [];
  for (var i3 = 0; i3 < wordChars.length; ++i3) {
    var c2 = wordChars.charAt(i3);
    var v2 = ALPHABET_MAP[c2];
    if (v2 === void 0)
      return "Unknown character " + c2;
    chk = polymodStep(chk) ^ v2;
    if (i3 + 6 >= wordChars.length)
      continue;
    words.push(v2);
  }
  if (chk !== 1)
    return "Invalid checksum for " + str;
  return { prefix: prefix2, words };
}
function decodeUnsafe() {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
}
function decode$3(str) {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
  throw new Error(res);
}
function convert$1(data2, inBits, outBits, pad3) {
  var value = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;
  var result = [];
  for (var i3 = 0; i3 < data2.length; ++i3) {
    value = value << inBits | data2[i3];
    bits += inBits;
    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }
  if (pad3) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits)
      return "Excess padding";
    if (value << outBits - bits & maxV)
      return "Non-zero padding";
  }
  return result;
}
function toWordsUnsafe(bytes2) {
  var res = convert$1(bytes2, 8, 5, true);
  if (Array.isArray(res))
    return res;
}
function toWords(bytes2) {
  var res = convert$1(bytes2, 8, 5, true);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
function fromWordsUnsafe(words) {
  var res = convert$1(words, 5, 8, false);
  if (Array.isArray(res))
    return res;
}
function fromWords(words) {
  var res = convert$1(words, 5, 8, false);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
var bech32 = {
  decodeUnsafe,
  decode: decode$3,
  encode: encode$2,
  toWordsUnsafe,
  toWords,
  fromWordsUnsafe,
  fromWords
};
const bech32$1 = /* @__PURE__ */ getDefaultExportFromCjs(bech32);
const version$3 = "providers/5.7.2";
const logger$3 = new Logger(version$3);
class Formatter {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data2 = this.data.bind(this);
    const hash2 = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number2 = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = (v2) => {
      return this.data(v2, true);
    };
    formats.transaction = {
      hash: hash2,
      type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash2, null),
      blockNumber: Formatter.allowNull(number2, null),
      transactionIndex: Formatter.allowNull(number2, null),
      confirmations: Formatter.allowNull(number2, null),
      from: address,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
      // must be set
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number2,
      data: data2,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number2),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data2)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number2),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number2),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number2,
      blockNumber: number2,
      transactionHash: hash2,
      address,
      topics: Formatter.arrayOf(hash2),
      data: data2,
      logIndex: number2,
      blockHash: hash2
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number2,
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      root: Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data2),
      blockHash: hash2,
      transactionHash: hash2,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number2,
      confirmations: Formatter.allowNull(number2, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number2),
      type
    };
    formats.block = {
      hash: Formatter.allowNull(hash2),
      parentHash: hash2,
      number: number2,
      timestamp: number2,
      nonce: Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: Formatter.allowNull(address),
      extraData: data2,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash2)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, void 0),
      toBlock: Formatter.allowNull(blockTag, void 0),
      blockHash: Formatter.allowNull(hash2, void 0),
      address: Formatter.allowNull(address, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number2),
      blockHash: Formatter.allowNull(hash2),
      transactionIndex: number2,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: Formatter.allowFalsish(data2, "0x"),
      topics: Formatter.arrayOf(hash2),
      transactionHash: hash2,
      logIndex: number2
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(number2) {
    if (number2 === "0x") {
      return 0;
    }
    return BigNumber.from(number2).toNumber();
  }
  type(number2) {
    if (number2 === "0x" || number2 == null) {
      return 0;
    }
    return BigNumber.from(number2).toNumber();
  }
  // Strict! Used on input.
  bigNumber(value) {
    return BigNumber.from(value);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString(value)) {
        return value.toLowerCase();
      }
    }
    return logger$3.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  // Requires an address
  // Strict! Used on input.
  address(value) {
    return getAddress$1(value);
  }
  callAddress(value) {
    if (!isHexString(value, 32)) {
      return null;
    }
    const address = getAddress$1(hexDataSlice(value, 12));
    return address === AddressZero ? null : address;
  }
  contractAddress(value) {
    return getContractAddress$1(value);
  }
  // Strict! Used on input.
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return blockTag;
    }
    if (typeof blockTag === "number" || isHexString(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger$3.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v2 = BigNumber.from(value);
    try {
      return v2.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value) {
    if (!isHexString(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value, 32);
  }
  _block(value, format) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format, value);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId2 = transaction.chainId;
      if (isHexString(chainId2)) {
        chainId2 = BigNumber.from(chainId2).toNumber();
      }
      result.chainId = chainId2;
    } else {
      let chainId2 = transaction.networkId;
      if (chainId2 == null && result.v == null) {
        chainId2 = transaction.chainId;
      }
      if (isHexString(chainId2)) {
        chainId2 = BigNumber.from(chainId2).toNumber();
      }
      if (typeof chainId2 !== "number" && result.v != null) {
        chainId2 = (result.v - 35) / 2;
        if (chainId2 < 0) {
          chainId2 = 0;
        }
        chainId2 = parseInt(chainId2);
      }
      if (typeof chainId2 !== "number") {
        chainId2 = 0;
      }
      result.chainId = chainId2;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return parse(value);
  }
  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = BigNumber.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger$3.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger$3.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger$3.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v2) => this.topics(v2));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }
  static check(format, object) {
    const result = {};
    for (const key2 in format) {
      try {
        const value = format[key2](object[key2]);
        if (value !== void 0) {
          result[key2] = value;
        }
      } catch (error) {
        error.checkKey = key2;
        error.checkValue = object[key2];
        throw error;
      }
    }
    return result;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(format, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format(value);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(format, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format(value);
    };
  }
  // Requires an Array satisfying check
  static arrayOf(format) {
    return function(array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      const result = [];
      array.forEach(function(value) {
        result.push(format(value));
      });
      return result;
    };
  }
}
var __awaiter$2 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$2 = new Logger(version$3);
const MAX_CCIP_REDIRECTS = 10;
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger$2.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data2) {
  if (data2 === "") {
    return [];
  }
  return data2.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger$2.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function stall(duration2) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration2);
  });
}
const PollableEvents = ["block", "network", "pending", "poll"];
let Event$1 = class Event2 {
  constructor(tag, listener, once3) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "listener", listener);
    defineReadOnly(this, "once", once3);
    this._lastBlockNumber = -2;
    this._inflight = false;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter = {};
    if (topics.length > 0) {
      filter.topics = topics;
    }
    if (address && address !== "*") {
      filter.address = address;
    }
    return filter;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
};
const coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
function base58Encode(data2) {
  return Base58.encode(concat$2([data2, hexDataSlice(sha256$2(sha256$2(data2)), 0, 4)]));
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result, start) {
  try {
    return toUtf8String(_parseBytes(result, start));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();
  const length2 = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length2);
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger$2.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value) {
  const result = arrayify(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
function encodeBytes$1(datas) {
  const result = [];
  let byteCount = 0;
  for (let i3 = 0; i3 < datas.length; i3++) {
    result.push(null);
    byteCount += 32;
  }
  for (let i3 = 0; i3 < datas.length; i3++) {
    const data2 = arrayify(datas[i3]);
    result[i3] = numPad(byteCount);
    result.push(numPad(data2.length));
    result.push(bytesPad(data2));
    byteCount += 32 + Math.ceil(data2.length / 32) * 32;
  }
  return hexConcat(result);
}
class Resolver {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(provider, address, name2, resolvedAddress) {
    defineReadOnly(this, "provider", provider);
    defineReadOnly(this, "name", name2);
    defineReadOnly(this, "address", provider.formatter.address(address));
    defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }
  supportsWildcard() {
    if (!this._supportsEip2544) {
      this._supportsEip2544 = this.provider.call({
        to: this.address,
        data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
      }).then((result) => {
        return BigNumber.from(result).eq(1);
      }).catch((error) => {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return false;
        }
        this._supportsEip2544 = null;
        throw error;
      });
    }
    return this._supportsEip2544;
  }
  _fetch(selector, parameters) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        ccipReadEnabled: true,
        data: hexConcat([selector, namehash$1(this.name), parameters || "0x"])
      };
      let parseBytes = false;
      if (yield this.supportsWildcard()) {
        parseBytes = true;
        tx.data = hexConcat(["0x9061b923", encodeBytes$1([dnsEncode(this.name), tx.data])]);
      }
      try {
        let result = yield this.provider.call(tx);
        if (arrayify(result).length % 32 === 4) {
          logger$2.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
            transaction: tx,
            data: result
          });
        }
        if (parseBytes) {
          result = _parseBytes(result, 0);
        }
        return result;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _fetchBytes(selector, parameters) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const result = yield this._fetch(selector, parameters);
      if (result != null) {
        return _parseBytes(result, 0);
      }
      return null;
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger$2.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes2 = arrayify(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length2 = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length2 * 2 && length2 >= 1 && length2 <= 75) {
          return base58Encode(concat$2([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length2 = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length2 * 2 && length2 >= 1 && length2 <= 75) {
          return base58Encode(concat$2([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length2 = bytes2[1];
      let version2 = bytes2[0];
      if (version2 === 0) {
        if (length2 !== 20 && length2 !== 32) {
          version2 = -1;
        }
      } else {
        version2 = -1;
      }
      if (version2 >= 0 && bytes2.length === 2 + length2 && length2 >= 1 && length2 <= 75) {
        const words = bech32$1.toWords(bytes2.slice(2));
        words.unshift(version2);
        return bech32$1.encode(coinInfo.prefix, words);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const result = yield this._fetch("0x3b3b57de");
          if (result === "0x" || result === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(result);
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger$2.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter$2(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i3 = 0; i3 < matchers.length; i3++) {
          const match2 = avatar.match(matchers[i3]);
          if (match2 == null) {
            continue;
          }
          const scheme = match2[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match2[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx), 0);
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url-base", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              const metadata2 = yield fetchJson(metadataUrl);
              if (!metadata2) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata2) });
              let imageUrl = metadata2.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter$2(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length2 = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length2 * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipns) {
        const length2 = parseInt(ipns[3], 16);
        if (ipns[4].length === length2 * 2) {
          return "ipns://" + Base58.encode("0x" + ipns[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
      if (skynet) {
        if (skynet[1].length === 34 * 2) {
          const urlSafe = { "=": "", "+": "-", "/": "_" };
          const hash2 = encode$3("0x" + skynet[1]).replace(/[=+\/]/g, (a2) => urlSafe[a2]);
          return "sia://" + hash2;
        }
      }
      return logger$2.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes(key2);
      keyBytes = concat$2([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat$2([keyBytes, hexZeroPad("0x", 32 - key2.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
}
let defaultFormatter = null;
let nextPollId = 1;
class BaseProvider extends Provider {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(network) {
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.disableCcipRead = false;
    this.formatter = new.target.getFormatter();
    defineReadOnly(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = getStatic(new.target, "getNetwork")(network);
      if (knownNetwork) {
        defineReadOnly(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger$2.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._maxFilterBlockRange = 10;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger$2.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            defineReadOnly(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return poll$1(() => {
      return this._ready().then((network) => {
        return network;
      }, (error) => {
        if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return void 0;
        }
        throw error;
      });
    });
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(network) {
    return getNetwork$1(network == null ? "homestead" : network);
  }
  ccipReadFetch(tx, calldata, urls) {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (this.disableCcipRead || urls.length === 0) {
        return null;
      }
      const sender = tx.to.toLowerCase();
      const data2 = calldata.toLowerCase();
      const errorMessages = [];
      for (let i3 = 0; i3 < urls.length; i3++) {
        const url = urls[i3];
        const href = url.replace("{sender}", sender).replace("{data}", data2);
        const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: data2, sender });
        const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
          value.status = response.statusCode;
          return value;
        });
        if (result.data) {
          return result.data;
        }
        const errorMessage = result.message || "unknown error";
        if (result.status >= 400 && result.status < 500) {
          return logger$2.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });
        }
        errorMessages.push(errorMessage);
      }
      return logger$2.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m2) => JSON.stringify(m2)).join(", ")}`, Logger.errors.SERVER_ERROR, {
        urls,
        errorMessages
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(maxAge) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter$2(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger$2.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger$2.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i3 = this._emitted.block + 1; i3 <= blockNumber; i3++) {
          this.emit("block", i3);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key2) => {
          if (key2 === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key2];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key2];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash2 = event.hash;
            let runner = this.getTransactionReceipt(hash2).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash2] = receipt.blockNumber;
              this.emit(hash2, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            if (!event._inflight) {
              event._inflight = true;
              if (event._lastBlockNumber === -2) {
                event._lastBlockNumber = blockNumber - 1;
              }
              const filter = event.filter;
              filter.fromBlock = event._lastBlockNumber + 1;
              filter.toBlock = blockNumber;
              const minFromBlock = filter.toBlock - this._maxFilterBlockRange;
              if (minFromBlock > filter.fromBlock) {
                filter.fromBlock = minFromBlock;
              }
              if (filter.fromBlock < 0) {
                filter.fromBlock = 0;
              }
              const runner = this.getLogs(filter).then((logs) => {
                event._inflight = false;
                if (logs.length === 0) {
                  return;
                }
                logs.forEach((log3) => {
                  if (log3.blockNumber > event._lastBlockNumber) {
                    event._lastBlockNumber = log3.blockNumber;
                  }
                  this._emitted["b:" + log3.blockHash] = log3.blockNumber;
                  this._emitted["t:" + log3.transactionHash] = log3.blockNumber;
                  this.emit(filter, log3);
                });
              }).catch((error) => {
                this.emit("error", error);
                event._inflight = false;
              });
              runners.push(runner);
            }
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return __awaiter$2(this, void 0, void 0, function* () {
      return logger$2.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter$2(this, void 0, void 0, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }
        const error = logger$2.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now = getTime();
    if (now - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout) {
    return __awaiter$2(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done = false;
        const alreadyDone = function() {
          if (done) {
            return true;
          }
          done = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter$2(this, void 0, void 0, function* () {
            if (done) {
              return;
            }
            yield stall(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter$2(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }
                  const block2 = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti2 = 0; ti2 < block2.transactions.length; ti2++) {
                    const tx = block2.transactions[ti2];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger$2.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout === "number" && timeout > 0) {
          const timer2 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger$2.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout }));
          }, timeout);
          if (timer2.unref) {
            timer2.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer2);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter$2(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position2, blockTag) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position2).then((p2) => hexValue(p2))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(tx, hash2, startBlock) {
    if (hash2 != null && hexDataLength(hash2) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash2 != null && tx.hash !== hash2) {
      logger$2.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash2 });
    }
    result.wait = (confirms, timeout) => __awaiter$2(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout == null) {
        timeout = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger$2.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t2) => hexlify(t2));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash2 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash2, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const values2 = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key2) => {
        if (values2[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values2[key2]).then((v2) => v2 ? this._getAddress(v2) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key2) => {
        if (values2[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values2[key2]).then((v2) => v2 ? BigNumber.from(v2) : null);
      });
      ["type"].forEach((key2) => {
        if (values2[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values2[key2]).then((v2) => v2 != null ? v2 : null);
      });
      if (values2.accessList) {
        tx.accessList = this.formatter.accessList(values2.accessList);
      }
      ["data"].forEach((key2) => {
        if (values2[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values2[key2]).then((v2) => v2 ? hexlify(v2) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties(tx));
    });
  }
  _getFilter(filter) {
    return __awaiter$2(this, void 0, void 0, function* () {
      filter = yield filter;
      const result = {};
      if (filter.address != null) {
        result.address = this._getAddress(filter.address);
      }
      ["blockHash", "topics"].forEach((key2) => {
        if (filter[key2] == null) {
          return;
        }
        result[key2] = filter[key2];
      });
      ["fromBlock", "toBlock"].forEach((key2) => {
        if (filter[key2] == null) {
          return;
        }
        result[key2] = this._getBlockTag(filter[key2]);
      });
      return this.formatter.filter(yield resolveProperties(result));
    });
  }
  _call(transaction, blockTag, attempt) {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (attempt >= MAX_CCIP_REDIRECTS) {
        logger$2.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
          redirects: attempt,
          transaction
        });
      }
      const txSender = transaction.to;
      const result = yield this.perform("call", { transaction, blockTag });
      if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4) {
        try {
          const data2 = hexDataSlice(result, 4);
          const sender = hexDataSlice(data2, 0, 32);
          if (!BigNumber.from(sender).eq(txSender)) {
            logger$2.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const urls = [];
          const urlsOffset = BigNumber.from(hexDataSlice(data2, 32, 64)).toNumber();
          const urlsLength = BigNumber.from(hexDataSlice(data2, urlsOffset, urlsOffset + 32)).toNumber();
          const urlsData = hexDataSlice(data2, urlsOffset + 32);
          for (let u2 = 0; u2 < urlsLength; u2++) {
            const url = _parseString(urlsData, u2 * 32);
            if (url == null) {
              logger$2.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction,
                data: result
              });
            }
            urls.push(url);
          }
          const calldata = _parseBytes(data2, 64);
          if (!BigNumber.from(hexDataSlice(data2, 100, 128)).isZero()) {
            logger$2.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const callbackSelector = hexDataSlice(data2, 96, 100);
          const extraData = _parseBytes(data2, 128);
          const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
          if (ccipResult == null) {
            logger$2.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const tx = {
            to: txSender,
            data: hexConcat([callbackSelector, encodeBytes$1([ccipResult, extraData])])
          };
          return this._call(tx, blockTag, attempt + 1);
        } catch (error) {
          if (error.code === Logger.errors.SERVER_ERROR) {
            throw error;
          }
        }
      }
      try {
        return hexlify(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction, blockTag },
          result,
          error
        });
      }
    });
  }
  call(transaction, blockTag) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const resolved = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag),
        ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
      });
      return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(transaction) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter$2(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger$2.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger$2.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger$2.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll$1(() => __awaiter$2(this, void 0, void 0, function* () {
        const block2 = yield this.perform("getBlock", params);
        if (block2 == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i3 = 0; i3 < block2.transactions.length; i3++) {
            const tx = block2.transactions[i3];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block2);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block2);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll$1(() => __awaiter$2(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll$1(() => __awaiter$2(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({ filter: this._getFilter(filter) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log3) => {
        if (log3.removed == null) {
          log3.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter$2(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger$2.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let currentName = name2;
      while (true) {
        if (currentName === "" || currentName === ".") {
          return null;
        }
        if (name2 !== "eth" && currentName === "eth") {
          return null;
        }
        const addr = yield this._getResolver(currentName, "getResolver");
        if (addr != null) {
          const resolver = new Resolver(this, addr, name2);
          if (currentName !== name2 && !(yield resolver.supportsWildcard())) {
            return null;
          }
          return resolver;
        }
        currentName = currentName.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(name2, operation) {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (operation == null) {
        operation = "ENS";
      }
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger$2.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
      }
      try {
        const addrData = yield this.call({
          to: network.ensAddress,
          data: "0x0178b8bf" + namehash$1(name2).substring(2)
        });
        return this.formatter.callAddress(addrData);
      } catch (error) {
      }
      return null;
    });
  }
  resolveName(name2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      name2 = yield name2;
      try {
        return Promise.resolve(this.formatter.address(name2));
      } catch (error) {
        if (isHexString(name2)) {
          throw error;
        }
      }
      if (typeof name2 !== "string") {
        logger$2.throwArgumentError("invalid ENS name", "name", name2);
      }
      const resolver = yield this.getResolver(name2);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter$2(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const node2 = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddr = yield this._getResolver(node2, "lookupAddress");
      if (resolverAddr == null) {
        return null;
      }
      const name2 = _parseString(yield this.call({
        to: resolverAddr,
        data: "0x691f3431" + namehash$1(node2).substring(2)
      }), 0);
      const addr = yield this.resolveName(name2);
      if (addr != address) {
        return null;
      }
      return name2;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const node2 = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(node2, "getAvatar");
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, node2);
        try {
          const avatar2 = yield resolver.getAvatar();
          if (avatar2) {
            return avatar2.url;
          }
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
        }
        try {
          const name2 = _parseString(yield this.call({
            to: resolverAddress,
            data: "0x691f3431" + namehash$1(node2).substring(2)
          }), 0);
          resolver = yield this.getResolver(name2);
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
          return null;
        }
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger$2.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once3) {
    const event = new Event$1(getEventTag(eventName), listener, once3);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
}
var __awaiter$1 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$1 = new Logger(version$3);
const errorGas = ["call", "estimateGas"];
function spelunk(value, requireData) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match("reverted")) {
    const data2 = isHexString(value.data) ? value.data : null;
    if (!requireData || data2) {
      return { message: value.message, data: data2 };
    }
  }
  if (typeof value === "object") {
    for (const key2 in value) {
      const result = spelunk(value[key2], requireData);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunk(JSON.parse(value), requireData);
    } catch (error) {
    }
  }
  return null;
}
function checkError(method, error, params) {
  const transaction = params.transaction || params.signedTransaction;
  if (method === "call") {
    const result = spelunk(error, true);
    if (result) {
      return result.data;
    }
    logger$1.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction,
      error
    });
  }
  if (method === "estimateGas") {
    let result = spelunk(error.body, false);
    if (result == null) {
      result = spelunk(error, false);
    }
    if (result) {
      logger$1.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        reason: result.message,
        method,
        transaction,
        error
      });
    }
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
    logger$1.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce (is )?too low/i)) {
    logger$1.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
    logger$1.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/i)) {
    logger$1.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
    logger$1.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
function timer(timeout) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout);
  });
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
const _constructorGuard = {};
class JsonRpcSigner extends Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    super();
    if (constructorGuard !== _constructorGuard) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly(this, "_index", addressOrIndex);
      defineReadOnly(this, "_address", null);
    } else {
      logger$1.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger$1.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger$1.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = shallowCopy(transaction);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction.gasLimit == null) {
      const estimate = shallowCopy(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter$1(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger$1.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties({
      tx: resolveProperties(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger$1.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash2) => {
        return hash2;
      }, (error) => {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$1.throwError("user rejected transaction", Logger.errors.ACTION_REJECTED, {
            action: "sendTransaction",
            transaction: tx
          });
        }
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger$1.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash2 = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield poll$1(() => __awaiter$1(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash2);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash2, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash2;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const data2 = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [hexlify(data2), address.toLowerCase()]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$1.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "signMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _legacySignMessage(message) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const data2 = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data2)]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$1.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_legacySignMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _signTypedData(domain, types2, value) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain, types2, value, (name2) => {
        return this.provider.resolveName(name2);
      });
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          address.toLowerCase(),
          JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types2, populated.value))
        ]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$1.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_signTypedData",
            from: address,
            messageData: { domain: populated.domain, types: types2, value: populated.value }
          });
        }
        throw error;
      }
    });
  }
  unlock(password) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash2) => {
      return {
        hash: hash2,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash2, confirmations);
        }
      };
    });
  }
}
const allowedTransactionKeys = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
class JsonRpcProvider extends BaseProvider {
  constructor(url, network) {
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve(network2);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly(this, "connection", Object.freeze({
        url
      }));
    } else {
      defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield timer(0);
      let chainId2 = null;
      try {
        chainId2 = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId2 = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId2 != null) {
        const getNetwork2 = getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber.from(chainId2).toNumber());
        } catch (error) {
          return logger$1.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            chainId: chainId2,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger$1.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a2) => this.formatter.address(a2));
    });
  }
  send(method, params) {
    const request2 = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(request2),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request2), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request: request2,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request: request2,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
    }
    return null;
  }
  perform(method, params) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy(params);
              params.transaction = shallowCopy(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger$1.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll2() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes.forEach(function(hash2) {
            self2._emitted["t:" + hash2.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash2).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll2();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      poll2();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = shallowCopy(allowedTransactionKeys);
    if (allowExtra) {
      for (const key2 in allowExtra) {
        if (allowExtra[key2]) {
          allowed[key2] = true;
        }
      }
    }
    checkProperties(transaction, allowed);
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      const value = hexValue(BigNumber.from(transaction[key2]));
      if (key2 === "gasLimit") {
        key2 = "gas";
      }
      result[key2] = value;
    });
    ["from", "to", "data"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      result[key2] = hexlify(transaction[key2]);
    });
    if (transaction.accessList) {
      result["accessList"] = accessListify(transaction.accessList);
    }
    return result;
  }
}
const logger = new Logger(version$3);
let _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request2 = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request2),
        provider: this
      });
      sendFunc(request2, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request: request2,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request: request2,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request2 = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request2),
      provider: this
    });
    return provider.request(request2).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request: request2,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request: request2,
        error,
        provider: this
      });
      throw error;
    });
  };
}
let Web3Provider$1 = class Web3Provider extends JsonRpcProvider {
  constructor(provider, network) {
    if (provider == null) {
      logger.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
};
const _abi$a = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
class IERC20Metadata__factory {
  static createInterface() {
    return new Interface(_abi$a);
  }
  static connect(address, signerOrProvider) {
    return new Contract(address, _abi$a, signerOrProvider);
  }
}
IERC20Metadata__factory.abi = _abi$a;
const USDC_MAINNET = new Token$4(ChainId$2.MAINNET, "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", 6, "USDC", "USD//C");
const USDT_MAINNET = new Token$4(ChainId$2.MAINNET, "0xdAC17F958D2ee523a2206206994597C13D831ec7", 6, "USDT", "Tether USD");
const WBTC_MAINNET = new Token$4(ChainId$2.MAINNET, "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599", 8, "WBTC", "Wrapped BTC");
const DAI_MAINNET = new Token$4(ChainId$2.MAINNET, "0x6B175474E89094C44Da98b954EedeAC495271d0F", 18, "DAI", "Dai Stablecoin");
const FEI_MAINNET = new Token$4(ChainId$2.MAINNET, "0x956F47F50A910163D8BF957Cf5846D573E7f87CA", 18, "FEI", "Fei USD");
new Token$4(ChainId$2.MAINNET, "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984", 18, "UNI", "Uniswap");
const USDC_ROPSTEN = new Token$4(ChainId$2.ROPSTEN, "0x07865c6e87b9f70255377e024ace6630c1eaa37f", 6, "USDC", "USD//C");
const USDT_ROPSTEN = new Token$4(ChainId$2.ROPSTEN, "0x516de3a7a567d81737e3a46ec4ff9cfd1fcb0136", 6, "USDT", "Tether USD");
const DAI_ROPSTEN = new Token$4(ChainId$2.ROPSTEN, "0xad6d458402f60fd3bd25163575031acdce07538d", 18, "DAI", "Dai Stablecoin");
const DAI_RINKEBY_1 = new Token$4(ChainId$2.RINKEBY, "0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea", 18, "DAI", "DAI");
const DAI_RINKEBY_2 = new Token$4(ChainId$2.RINKEBY, "0xc7AD46e0b8a400Bb3C915120d284AafbA8fc4735", 18, "DAI", "DAI");
const USDC_RINKEBY = new Token$4(ChainId$2.RINKEBY, "0x4DBCdF9B62e891a7cec5A2568C3F4FAF9E8Abe2b", 6, "tUSDC", "test USD//C");
const USDT_RINKEBY = new Token$4(ChainId$2.RINKEBY, "0xa689352b7c1cad82864beb1d90679356d3962f4d", 18, "USDT", "Tether USD");
const USDC_GRLI = new Token$4(ChainId$2.GRLI, "0x07865c6e87b9f70255377e024ace6630c1eaa37f", 6, "USDC", "USD//C");
const USDT_GRLI = new Token$4(ChainId$2.GRLI, "0xe583769738b6dd4e7caf8451050d1948be717679", 18, "USDT", "Tether USD");
const WBTC_GRLI = new Token$4(ChainId$2.GRLI, "0xa0a5ad2296b38bd3e3eb59aaeaf1589e8d9a29a9", 8, "WBTC", "Wrapped BTC");
const DAI_GRLI = new Token$4(ChainId$2.GRLI, "0x11fe4b6ae13d2a6055c8d9cf65c55bac32b5d844", 18, "DAI", "Dai Stablecoin");
new Token$4(ChainId$2.GRLI, "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984", 18, "UNI", "Uni token");
const USDC_KOVAN = new Token$4(ChainId$2.KOVAN, "0x31eeb2d0f9b6fd8642914ab10f4dd473677d80df", 6, "USDC", "USD//C");
const USDT_KOVAN = new Token$4(ChainId$2.KOVAN, "0xa325f1b1ebb748715dfbbaf62e0c6677e137f45d", 18, "USDT", "Tether USD");
const WBTC_KOVAN = new Token$4(ChainId$2.KOVAN, "0xe36bc5d8b689ad6d80e78c3e736670e80d4b329d", 8, "WBTC", "Wrapped BTC");
const DAI_KOVAN = new Token$4(ChainId$2.KOVAN, "0x9dc7b33c3b63fc00ed5472fbd7813edda6a64752", 18, "DAI", "Dai Stablecoin");
const USDC_OPTIMISM = new Token$4(ChainId$2.OPTIMISM, "0x7F5c764cBc14f9669B88837ca1490cCa17c31607", 6, "USDC", "USD//C");
const USDT_OPTIMISM = new Token$4(ChainId$2.OPTIMISM, "0x94b008aA00579c1307B0EF2c499aD98a8ce58e58", 6, "USDT", "Tether USD");
const WBTC_OPTIMISM = new Token$4(ChainId$2.OPTIMISM, "0x68f180fcCe6836688e9084f035309E29Bf0A2095", 8, "WBTC", "Wrapped BTC");
const DAI_OPTIMISM = new Token$4(ChainId$2.OPTIMISM, "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1", 18, "DAI", "Dai Stablecoin");
const USDC_OPTIMISTIC_KOVAN = new Token$4(ChainId$2.OPTIMISTIC_KOVAN, "0x3b8e53b3ab8e01fb57d0c9e893bc4d655aa67d84", 6, "USDC", "USD//C");
const USDT_OPTIMISTIC_KOVAN = new Token$4(ChainId$2.OPTIMISTIC_KOVAN, "0x7F5c764cBc14f9669B88837ca1490cCa17c31607", 6, "USDT", "Tether USD");
const WBTC_OPTIMISTIC_KOVAN = new Token$4(ChainId$2.OPTIMISTIC_KOVAN, "0x2382a8f65b9120E554d1836a504808aC864E169d", 8, "WBTC", "Wrapped BTC");
const DAI_OPTIMISTIC_KOVAN = new Token$4(ChainId$2.OPTIMISTIC_KOVAN, "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1", 18, "DAI", "Dai Stablecoin");
const USDC_ARBITRUM = new Token$4(ChainId$2.ARBITRUM_ONE, "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8", 6, "USDC", "USD//C");
const USDT_ARBITRUM = new Token$4(ChainId$2.ARBITRUM_ONE, "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9", 6, "USDT", "Tether USD");
const WBTC_ARBITRUM = new Token$4(ChainId$2.ARBITRUM_ONE, "0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f", 8, "WBTC", "Wrapped BTC");
const DAI_ARBITRUM = new Token$4(ChainId$2.ARBITRUM_ONE, "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1", 18, "DAI", "Dai Stablecoin");
const DAI_ARBITRUM_RINKEBY = new Token$4(ChainId$2.ARBITRUM_RINKEBY, "0x5364dc963c402aaf150700f38a8ef52c1d7d7f14", 18, "DAI", "Dai Stablecoin");
const USDT_ARBITRUM_RINKEBY = new Token$4(ChainId$2.ARBITRUM_RINKEBY, "0x920b9301c2de92186299cd2abc7199e25b9728b3", 6, "UDST", "Tether USD");
const USDC_ARBITRUM_RINKEBY = new Token$4(ChainId$2.ARBITRUM_RINKEBY, "0x09b98f8b2395d076514037ff7d39a091a536206c", 6, "USDC", "USD//C");
const UNI_ARBITRUM_RINKEBY = new Token$4(ChainId$2.ARBITRUM_RINKEBY, "0x049251a7175071316e089d0616d8b6aacd2c93b8", 18, "UNI", "Uni token");
const WMATIC_POLYGON = new Token$4(ChainId$2.POLYGON, "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270", 18, "WMATIC", "Wrapped MATIC");
const WETH_POLYGON = new Token$4(ChainId$2.POLYGON, "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619", 18, "WETH", "Wrapped Ether");
const USDC_POLYGON = new Token$4(ChainId$2.POLYGON, "0x2791bca1f2de4661ed88a30c99a7a9449aa84174", 6, "USDC", "USD//C");
new Token$4(ChainId$2.POLYGON, "0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063", 18, "DAI", "Dai Stablecoin");
const WMATIC_POLYGON_MUMBAI = new Token$4(ChainId$2.POLYGON_MUMBAI, "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889", 18, "WMATIC", "Wrapped MATIC");
new Token$4(ChainId$2.POLYGON_MUMBAI, "0xe11a86849d99f524cac3e7a0ec1241828e332c62", 6, "USDC", "USD//C");
const DAI_POLYGON_MUMBAI = new Token$4(ChainId$2.POLYGON_MUMBAI, "0x001b3b4d0f3714ca98ba10f6042daebf0b1b7b6f", 18, "DAI", "Dai Stablecoin");
new Token$4(ChainId$2.POLYGON_MUMBAI, "0xa6fa4fb5f76172d178d61b04b0ecd319c5d1c0aa", 18, "WETH", "Wrapped Ether");
const CELO = new Token$4(ChainId$2.CELO, "0x471EcE3750Da237f93B8E339c536989b8978a438", 18, "CELO", "Celo native asset");
const DAI_CELO = new Token$4(ChainId$2.CELO, "0xE4fE50cdD716522A56204352f00AA110F731932d", 18, "DAI", "Dai Stablecoin");
const CUSD_CELO = new Token$4(ChainId$2.CELO, "0x765DE816845861e75A25fCA122bb6898B8B1282a", 18, "CUSD", "Celo Dollar Stablecoin");
const CEUR_CELO = new Token$4(ChainId$2.CELO, "0xD8763CBa276a3738E6DE85b4b3bF5FDed6D6cA73", 18, "CEUR", "Celo Euro Stablecoin");
const CELO_ALFAJORES = new Token$4(ChainId$2.CELO_ALFAJORES, "0xF194afDf50B03e69Bd7D057c1Aa9e10c9954E4C9", 18, "CELO", "Celo native asset");
const DAI_CELO_ALFAJORES = new Token$4(ChainId$2.CELO_ALFAJORES, "0x7d91E51C8F218f7140188A155f5C75388630B6a8", 18, "DAI", "Dai Stablecoin");
const CUSD_CELO_ALFAJORES = new Token$4(ChainId$2.CELO_ALFAJORES, "0x874069Fa1Eb16D44d622F2e0Ca25eeA172369bC1", 18, "CUSD", "Celo Dollar Stablecoin");
const CEUR_CELO_ALFAJORES = new Token$4(ChainId$2.CELO_ALFAJORES, "0x10c892A6EC43a53E45D0B916B4b7D383B1b78C0F", 18, "CEUR", "Celo Euro Stablecoin");
const USDC_ETHEREUM_GNOSIS = new Token$4(ChainId$2.GNOSIS, "0xddafbb505ad214d7b80b1f830fccc89b60fb7a83", 6, "USDC", "USDC from Ethereum on Gnosis");
const WXDAI_GNOSIS = new Token$4(ChainId$2.GNOSIS, "0xe91d153e0b41518a2ce8dd3d7944fa863463a97d", 18, "WXDAI", "Wrapped XDAI on Gnosis");
const WBTC_GNOSIS = new Token$4(ChainId$2.GNOSIS, "0x8e5bbbb09ed1ebde8674cda39a0c169401db4252", 8, "WBTC", "Wrapped BTC from Ethereum on Gnosis");
const USDC_MOONBEAM = new Token$4(ChainId$2.MOONBEAM, "0x818ec0A7Fe18Ff94269904fCED6AE3DaE6d6dC0b", 6, "USDC", "USD Coin bridged using Multichain");
const WGLMR_MOONBEAM = new Token$4(ChainId$2.MOONBEAM, "0xAcc15dC74880C9944775448304B263D191c6077F", 18, "WGLMR", "Wrapped GLMR");
const DAI_MOONBEAM = new Token$4(ChainId$2.MOONBEAM, "0x818ec0A7Fe18Ff94269904fCED6AE3DaE6d6dC0b", 6, "DAI", "Dai on moonbeam bridged using Multichain");
const WBTC_MOONBEAM = new Token$4(ChainId$2.MOONBEAM, "0x922D641a426DcFFaeF11680e5358F34d97d112E1", 8, "WBTC", "Wrapped BTC bridged using Multichain");
class TokenProvider {
  constructor(chainId2, multicall2Provider) {
    this.chainId = chainId2;
    this.multicall2Provider = multicall2Provider;
  }
  async getTokens(_addresses, providerConfig) {
    const addressToToken = {};
    const symbolToToken = {};
    const addresses = _$3(_addresses).map((address) => address.toLowerCase()).uniq().value();
    if (addresses.length > 0) {
      const [symbolsResult, decimalsResult] = await Promise.all([
        this.multicall2Provider.callSameFunctionOnMultipleContracts({
          addresses,
          contractInterface: IERC20Metadata__factory.createInterface(),
          functionName: "symbol",
          providerConfig
        }),
        this.multicall2Provider.callSameFunctionOnMultipleContracts({
          addresses,
          contractInterface: IERC20Metadata__factory.createInterface(),
          functionName: "decimals",
          providerConfig
        })
      ]);
      const { results: symbols } = symbolsResult;
      const { results: decimals } = decimalsResult;
      for (let i3 = 0; i3 < addresses.length; i3++) {
        const address = addresses[i3];
        const symbolResult = symbols[i3];
        const decimalResult = decimals[i3];
        if (!(symbolResult === null || symbolResult === void 0 ? void 0 : symbolResult.success) || !(decimalResult === null || decimalResult === void 0 ? void 0 : decimalResult.success)) {
          log.info({
            symbolResult,
            decimalResult
          }, `Dropping token with address ${address} as symbol or decimal are invalid`);
          continue;
        }
        const symbol = symbolResult.result[0];
        const decimal = decimalResult.result[0];
        addressToToken[address.toLowerCase()] = new Token$4(this.chainId, address, decimal, symbol);
        symbolToToken[symbol.toLowerCase()] = addressToToken[address.toLowerCase()];
      }
      log.info(`Got token symbol and decimals for ${Object.values(addressToToken).length} out of ${addresses.length} tokens on-chain ${providerConfig ? `as of: ${providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber}` : ""}`);
    }
    return {
      getTokenByAddress: (address) => {
        return addressToToken[address.toLowerCase()];
      },
      getTokenBySymbol: (symbol) => {
        return symbolToToken[symbol.toLowerCase()];
      },
      getAllTokens: () => {
        return Object.values(addressToToken);
      }
    };
  }
}
const CACHE_SEED_TOKENS = {
  [ChainId$2.MAINNET]: {
    WETH: WRAPPED_NATIVE_CURRENCY[ChainId$2.MAINNET],
    USDC: USDC_MAINNET,
    USDT: USDT_MAINNET,
    WBTC: WBTC_MAINNET,
    DAI: DAI_MAINNET,
    // This token stores its symbol as bytes32, therefore can not be fetched on-chain using
    // our token providers.
    // This workaround adds it to the cache, so we won't try to fetch it on-chain.
    RING: new Token$4(ChainId$2.MAINNET, "0x9469D013805bFfB7D3DEBe5E7839237e535ec483", 18, "RING", "RING")
  },
  [ChainId$2.RINKEBY]: {
    WETH: WRAPPED_NATIVE_CURRENCY[ChainId$2.RINKEBY],
    DAI_1: DAI_RINKEBY_1,
    DAI_2: DAI_RINKEBY_2
  },
  [ChainId$2.OPTIMISM]: {
    USDC: USDC_OPTIMISM,
    USDT: USDT_OPTIMISM,
    WBTC: WBTC_OPTIMISM,
    DAI: DAI_OPTIMISM
  },
  [ChainId$2.OPTIMISTIC_KOVAN]: {
    USDC: USDC_OPTIMISTIC_KOVAN,
    USDT: USDT_OPTIMISTIC_KOVAN,
    WBTC: WBTC_OPTIMISTIC_KOVAN,
    DAI: DAI_OPTIMISTIC_KOVAN
  },
  [ChainId$2.ARBITRUM_ONE]: {
    USDC: USDC_ARBITRUM,
    USDT: USDT_ARBITRUM,
    WBTC: WBTC_ARBITRUM,
    DAI: DAI_ARBITRUM
  },
  [ChainId$2.ARBITRUM_RINKEBY]: {
    USDT: USDT_ARBITRUM_RINKEBY,
    UNI: UNI_ARBITRUM_RINKEBY,
    DAI: DAI_ARBITRUM_RINKEBY,
    USDC: USDC_ARBITRUM_RINKEBY
  },
  [ChainId$2.POLYGON]: {
    WMATIC: WMATIC_POLYGON,
    USDC: USDC_POLYGON
  },
  [ChainId$2.POLYGON_MUMBAI]: {
    WMATIC: WMATIC_POLYGON_MUMBAI,
    DAI: DAI_POLYGON_MUMBAI
  },
  [ChainId$2.CELO]: {
    CELO,
    CUSD: CUSD_CELO,
    CEUR: CEUR_CELO,
    DAI: DAI_CELO
  },
  [ChainId$2.CELO_ALFAJORES]: {
    CELO: CELO_ALFAJORES,
    CUSD: CUSD_CELO_ALFAJORES,
    CEUR: CUSD_CELO_ALFAJORES,
    DAI: DAI_CELO_ALFAJORES
  },
  [ChainId$2.GNOSIS]: {
    WXDAI: WRAPPED_NATIVE_CURRENCY[ChainId$2.GNOSIS],
    USDC_ETHEREUM_GNOSIS
  },
  [ChainId$2.MOONBEAM]: {
    USDC: USDC_MOONBEAM,
    DAI: DAI_MOONBEAM,
    WBTC: WBTC_MOONBEAM,
    WGLMR: WRAPPED_NATIVE_CURRENCY[ChainId$2.MOONBEAM]
  }
  // Currently we do not have providers for Moonbeam mainnet or Gnosis testnet
};
class CachingTokenProviderWithFallback {
  constructor(chainId2, tokenCache, primaryTokenProvider, fallbackTokenProvider) {
    this.chainId = chainId2;
    this.tokenCache = tokenCache;
    this.primaryTokenProvider = primaryTokenProvider;
    this.fallbackTokenProvider = fallbackTokenProvider;
    this.CACHE_KEY = (chainId3, address) => `token-${chainId3}-${address}`;
  }
  async getTokens(_addresses) {
    const seedTokens = CACHE_SEED_TOKENS[this.chainId];
    if (seedTokens) {
      for (const token2 of Object.values(seedTokens)) {
        await this.tokenCache.set(this.CACHE_KEY(this.chainId, token2.address.toLowerCase()), token2);
      }
    }
    const addressToToken = {};
    const symbolToToken = {};
    const addresses = _$3(_addresses).map((address) => address.toLowerCase()).uniq().value();
    const addressesToFindInPrimary = [];
    const addressesToFindInSecondary = [];
    for (const address of addresses) {
      if (await this.tokenCache.has(this.CACHE_KEY(this.chainId, address))) {
        addressToToken[address.toLowerCase()] = await this.tokenCache.get(this.CACHE_KEY(this.chainId, address));
        symbolToToken[addressToToken[address].symbol] = await this.tokenCache.get(this.CACHE_KEY(this.chainId, address));
      } else {
        addressesToFindInPrimary.push(address);
      }
    }
    log.info({ addressesToFindInPrimary }, `Found ${addresses.length - addressesToFindInPrimary.length} out of ${addresses.length} tokens in local cache. ${addressesToFindInPrimary.length > 0 ? `Checking primary token provider for ${addressesToFindInPrimary.length} tokens` : ``}
      `);
    if (addressesToFindInPrimary.length > 0) {
      const primaryTokenAccessor = await this.primaryTokenProvider.getTokens(addressesToFindInPrimary);
      for (const address of addressesToFindInPrimary) {
        const token2 = primaryTokenAccessor.getTokenByAddress(address);
        if (token2) {
          addressToToken[address.toLowerCase()] = token2;
          symbolToToken[addressToToken[address].symbol] = token2;
          await this.tokenCache.set(this.CACHE_KEY(this.chainId, address.toLowerCase()), addressToToken[address]);
        } else {
          addressesToFindInSecondary.push(address);
        }
      }
      log.info({ addressesToFindInSecondary }, `Found ${addressesToFindInPrimary.length - addressesToFindInSecondary.length} tokens in primary. ${this.fallbackTokenProvider ? `Checking secondary token provider for ${addressesToFindInSecondary.length} tokens` : `No fallback token provider specified. About to return.`}`);
    }
    if (this.fallbackTokenProvider && addressesToFindInSecondary.length > 0) {
      const secondaryTokenAccessor = await this.fallbackTokenProvider.getTokens(addressesToFindInSecondary);
      for (const address of addressesToFindInSecondary) {
        const token2 = secondaryTokenAccessor.getTokenByAddress(address);
        if (token2) {
          addressToToken[address.toLowerCase()] = token2;
          symbolToToken[addressToToken[address].symbol] = token2;
          await this.tokenCache.set(this.CACHE_KEY(this.chainId, address.toLowerCase()), addressToToken[address]);
        }
      }
    }
    return {
      getTokenByAddress: (address) => {
        return addressToToken[address.toLowerCase()];
      },
      getTokenBySymbol: (symbol) => {
        return symbolToToken[symbol.toLowerCase()];
      },
      getAllTokens: () => {
        return Object.values(addressToToken);
      }
    };
  }
}
class IGasPriceProvider {
}
const DEFAULT_PRIORITY_FEE_PERCENTILE = 50;
const DEFAULT_BLOCKS_TO_LOOK_BACK = 4;
class EIP1559GasPriceProvider extends IGasPriceProvider {
  constructor(provider, priorityFeePercentile = DEFAULT_PRIORITY_FEE_PERCENTILE, blocksToConsider = DEFAULT_BLOCKS_TO_LOOK_BACK) {
    super();
    this.provider = provider;
    this.priorityFeePercentile = priorityFeePercentile;
    this.blocksToConsider = blocksToConsider;
  }
  async getGasPrice() {
    const feeHistoryRaw = await this.provider.send("eth_feeHistory", [
      /**
       * @fix Use BigNumber.from(this.blocksToConsider).toHexString() after hardhat adds support
       * @see https://github.com/NomicFoundation/hardhat/issues/1585 .___.
       */
      BigNumber.from(this.blocksToConsider).toHexString().replace("0x0", "0x"),
      "latest",
      [this.priorityFeePercentile]
    ]);
    const feeHistory = {
      baseFeePerGas: _$3.map(feeHistoryRaw.baseFeePerGas, (b3) => BigNumber.from(b3)),
      gasUsedRatio: feeHistoryRaw.gasUsedRatio,
      oldestBlock: BigNumber.from(feeHistoryRaw.oldestBlock),
      reward: _$3.map(feeHistoryRaw.reward, (b3) => BigNumber.from(b3[0]))
    };
    const nextBlockBaseFeePerGas = feeHistory.baseFeePerGas[feeHistory.baseFeePerGas.length - 1];
    const averagePriorityFeePerGas = _$3.reduce(feeHistory.reward, (sum2, cur) => sum2.add(cur), BigNumber.from(0)).div(feeHistory.reward.length);
    log.info({
      feeHistory,
      feeHistoryReadable: {
        baseFeePerGas: _$3.map(feeHistory.baseFeePerGas, (f3) => f3.toString()),
        oldestBlock: feeHistory.oldestBlock.toString(),
        reward: _$3.map(feeHistory.reward, (r2) => r2.toString())
      },
      nextBlockBaseFeePerGas: nextBlockBaseFeePerGas.toString(),
      averagePriorityFeePerGas: averagePriorityFeePerGas.toString()
    }, "Got fee history from provider and computed gas estimate");
    const gasPriceWei = nextBlockBaseFeePerGas.add(averagePriorityFeePerGas);
    const blockNumber = feeHistory.oldestBlock.add(this.blocksToConsider);
    log.info(`Estimated gas price in wei: ${gasPriceWei} as of block ${blockNumber.toString()}`);
    return { gasPriceWei };
  }
}
var retry$3 = {};
function RetryOperation(timeouts, options) {
  if (typeof options === "boolean") {
    options = { forever: options };
  }
  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
  this._timeouts = timeouts;
  this._options = options || {};
  this._maxRetryTime = options && options.maxRetryTime || Infinity;
  this._fn = null;
  this._errors = [];
  this._attempts = 1;
  this._operationTimeout = null;
  this._operationTimeoutCb = null;
  this._timeout = null;
  this._operationStart = null;
  this._timer = null;
  if (this._options.forever) {
    this._cachedTimeouts = this._timeouts.slice(0);
  }
}
var retry_operation = RetryOperation;
RetryOperation.prototype.reset = function() {
  this._attempts = 1;
  this._timeouts = this._originalTimeouts.slice(0);
};
RetryOperation.prototype.stop = function() {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }
  if (this._timer) {
    clearTimeout(this._timer);
  }
  this._timeouts = [];
  this._cachedTimeouts = null;
};
RetryOperation.prototype.retry = function(err) {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }
  if (!err) {
    return false;
  }
  var currentTime = (/* @__PURE__ */ new Date()).getTime();
  if (err && currentTime - this._operationStart >= this._maxRetryTime) {
    this._errors.push(err);
    this._errors.unshift(new Error("RetryOperation timeout occurred"));
    return false;
  }
  this._errors.push(err);
  var timeout = this._timeouts.shift();
  if (timeout === void 0) {
    if (this._cachedTimeouts) {
      this._errors.splice(0, this._errors.length - 1);
      timeout = this._cachedTimeouts.slice(-1);
    } else {
      return false;
    }
  }
  var self2 = this;
  this._timer = setTimeout(function() {
    self2._attempts++;
    if (self2._operationTimeoutCb) {
      self2._timeout = setTimeout(function() {
        self2._operationTimeoutCb(self2._attempts);
      }, self2._operationTimeout);
      if (self2._options.unref) {
        self2._timeout.unref();
      }
    }
    self2._fn(self2._attempts);
  }, timeout);
  if (this._options.unref) {
    this._timer.unref();
  }
  return true;
};
RetryOperation.prototype.attempt = function(fn2, timeoutOps) {
  this._fn = fn2;
  if (timeoutOps) {
    if (timeoutOps.timeout) {
      this._operationTimeout = timeoutOps.timeout;
    }
    if (timeoutOps.cb) {
      this._operationTimeoutCb = timeoutOps.cb;
    }
  }
  var self2 = this;
  if (this._operationTimeoutCb) {
    this._timeout = setTimeout(function() {
      self2._operationTimeoutCb();
    }, self2._operationTimeout);
  }
  this._operationStart = (/* @__PURE__ */ new Date()).getTime();
  this._fn(this._attempts);
};
RetryOperation.prototype.try = function(fn2) {
  console.log("Using RetryOperation.try() is deprecated");
  this.attempt(fn2);
};
RetryOperation.prototype.start = function(fn2) {
  console.log("Using RetryOperation.start() is deprecated");
  this.attempt(fn2);
};
RetryOperation.prototype.start = RetryOperation.prototype.try;
RetryOperation.prototype.errors = function() {
  return this._errors;
};
RetryOperation.prototype.attempts = function() {
  return this._attempts;
};
RetryOperation.prototype.mainError = function() {
  if (this._errors.length === 0) {
    return null;
  }
  var counts = {};
  var mainError = null;
  var mainErrorCount = 0;
  for (var i3 = 0; i3 < this._errors.length; i3++) {
    var error = this._errors[i3];
    var message = error.message;
    var count = (counts[message] || 0) + 1;
    counts[message] = count;
    if (count >= mainErrorCount) {
      mainError = error;
      mainErrorCount = count;
    }
  }
  return mainError;
};
(function(exports) {
  var RetryOperation2 = retry_operation;
  exports.operation = function(options) {
    var timeouts = exports.timeouts(options);
    return new RetryOperation2(timeouts, {
      forever: options && (options.forever || options.retries === Infinity),
      unref: options && options.unref,
      maxRetryTime: options && options.maxRetryTime
    });
  };
  exports.timeouts = function(options) {
    if (options instanceof Array) {
      return [].concat(options);
    }
    var opts = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: Infinity,
      randomize: false
    };
    for (var key2 in options) {
      opts[key2] = options[key2];
    }
    if (opts.minTimeout > opts.maxTimeout) {
      throw new Error("minTimeout is greater than maxTimeout");
    }
    var timeouts = [];
    for (var i3 = 0; i3 < opts.retries; i3++) {
      timeouts.push(this.createTimeout(i3, opts));
    }
    if (options && options.forever && !timeouts.length) {
      timeouts.push(this.createTimeout(i3, opts));
    }
    timeouts.sort(function(a2, b3) {
      return a2 - b3;
    });
    return timeouts;
  };
  exports.createTimeout = function(attempt, opts) {
    var random2 = opts.randomize ? Math.random() + 1 : 1;
    var timeout = Math.round(random2 * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
    timeout = Math.min(timeout, opts.maxTimeout);
    return timeout;
  };
  exports.wrap = function(obj, options, methods) {
    if (options instanceof Array) {
      methods = options;
      options = null;
    }
    if (!methods) {
      methods = [];
      for (var key2 in obj) {
        if (typeof obj[key2] === "function") {
          methods.push(key2);
        }
      }
    }
    for (var i3 = 0; i3 < methods.length; i3++) {
      var method = methods[i3];
      var original = obj[method];
      obj[method] = function retryWrapper(original2) {
        var op = exports.operation(options);
        var args = Array.prototype.slice.call(arguments, 1);
        var callback = args.pop();
        args.push(function(err) {
          if (op.retry(err)) {
            return;
          }
          if (err) {
            arguments[0] = op.mainError();
          }
          callback.apply(this, arguments);
        });
        op.attempt(function() {
          original2.apply(obj, args);
        });
      }.bind(obj, original);
      obj[method].options = options;
    }
  };
})(retry$3);
var retry$2 = retry$3;
var retrier = retry$2;
function retry(fn2, opts) {
  function run(resolve, reject) {
    var options = opts || {};
    var op;
    if (!("randomize" in options)) {
      options.randomize = true;
    }
    op = retrier.operation(options);
    function bail(err) {
      reject(err || new Error("Aborted"));
    }
    function onError(err, num) {
      if (err.bail) {
        bail(err);
        return;
      }
      if (!op.retry(err)) {
        reject(op.mainError());
      } else if (options.onRetry) {
        options.onRetry(err, num);
      }
    }
    function runAttempt(num) {
      var val;
      try {
        val = fn2(bail, num);
      } catch (err) {
        onError(err, num);
        return;
      }
      Promise.resolve(val).then(resolve).catch(function catchIt(err) {
        onError(err, num);
      });
    }
    op.attempt(runAttempt);
  }
  return new Promise(run);
}
var lib = retry;
const retry$1 = /* @__PURE__ */ getDefaultExportFromCjs(lib);
class ETHGasStationInfoProvider extends IGasPriceProvider {
  constructor(url) {
    super();
    this.url = url;
  }
  async getGasPrice() {
    log.info(`About to get gas prices from gas station ${this.url}`);
    const response = await retry$1(async () => {
      return axios$1.get(this.url);
    }, { retries: 1 });
    const { data: gasPriceResponse, status } = response;
    if (status != 200) {
      log.error({ response }, `Unabled to get gas price from ${this.url}.`);
      throw new Error(`Unable to get gas price from ${this.url}`);
    }
    log.info({ gasPriceResponse }, 'Gas price response from API. About to parse "fast" to big number');
    const gasPriceWei = BigNumber.from(gasPriceResponse.fast).div(BigNumber.from(10)).mul(BigNumber.from(10).pow(9));
    log.info(`Gas price in wei: ${gasPriceWei} as of block ${gasPriceResponse.blockNum}`);
    return { gasPriceWei };
  }
}
class LegacyGasPriceProvider extends IGasPriceProvider {
  constructor(provider) {
    super();
    this.provider = provider;
  }
  async getGasPrice() {
    const gasPriceWei = await this.provider.getGasPrice();
    log.info({ gasPriceWei }, `Got gas price ${gasPriceWei} using eth_gasPrice RPC`);
    return {
      gasPriceWei
    };
  }
}
class IMulticallProvider {
}
var stats = {};
var isnumber = isNumber$1;
function isNumber$1(n4) {
  return !isNaN(parseFloat(n4)) && isFinite(n4);
}
stats.numbers = numbers;
stats.sum = sum;
stats.mean = mean;
stats.median = median;
stats.mode = mode$1;
stats.variance = populationVariance;
stats.sampleVariance = sampleVariance;
stats.populationVariance = populationVariance;
stats.stdev = populationStdev;
stats.sampleStdev = sampleStdev;
stats.populationStdev = populationStdev;
stats.percentile = percentile;
stats.histogram = histogram;
var isNumber = isnumber;
function numbers(vals) {
  var nums = [];
  if (vals == null)
    return nums;
  for (var i3 = 0; i3 < vals.length; i3++) {
    if (isNumber(vals[i3]))
      nums.push(+vals[i3]);
  }
  return nums;
}
function nsort(vals) {
  return vals.sort(function numericSort(a2, b3) {
    return a2 - b3;
  });
}
function sum(vals) {
  vals = numbers(vals);
  var total = 0;
  for (var i3 = 0; i3 < vals.length; i3++) {
    total += vals[i3];
  }
  return total;
}
function mean(vals) {
  vals = numbers(vals);
  if (vals.length === 0)
    return NaN;
  return sum(vals) / vals.length;
}
function median(vals) {
  vals = numbers(vals);
  if (vals.length === 0)
    return NaN;
  var half = vals.length / 2 | 0;
  vals = nsort(vals);
  if (vals.length % 2) {
    return vals[half];
  } else {
    return (vals[half - 1] + vals[half]) / 2;
  }
}
function mode$1(vals) {
  vals = numbers(vals);
  if (vals.length === 0)
    return NaN;
  var mode2 = NaN;
  var dist2 = {};
  for (var i3 = 0; i3 < vals.length; i3++) {
    var value = vals[i3];
    var me2 = dist2[value] || 0;
    me2++;
    dist2[value] = me2;
  }
  var rank = numbers(Object.keys(dist2).sort(function sortMembers(a2, b3) {
    return dist2[b3] - dist2[a2];
  }));
  mode2 = rank[0];
  if (dist2[rank[1]] == dist2[mode2]) {
    if (rank.length == vals.length) {
      return vals;
    }
    var modes = /* @__PURE__ */ new Set([mode2]);
    var modeCount = dist2[mode2];
    for (var i3 = 1; i3 < rank.length; i3++) {
      if (dist2[rank[i3]] == modeCount) {
        modes.add(rank[i3]);
      } else {
        break;
      }
    }
    return modes;
  }
  return mode2;
}
function valuesMinusMeanSquared(vals) {
  vals = numbers(vals);
  var avg = mean(vals);
  var diffs = [];
  for (var i3 = 0; i3 < vals.length; i3++) {
    diffs.push(Math.pow(vals[i3] - avg, 2));
  }
  return diffs;
}
function populationVariance(vals) {
  return mean(valuesMinusMeanSquared(vals));
}
function sampleVariance(vals) {
  var diffs = valuesMinusMeanSquared(vals);
  if (diffs.length <= 1)
    return NaN;
  return sum(diffs) / (diffs.length - 1);
}
function populationStdev(vals) {
  return Math.sqrt(populationVariance(vals));
}
function sampleStdev(vals) {
  return Math.sqrt(sampleVariance(vals));
}
function percentile(vals, ptile) {
  vals = numbers(vals);
  if (vals.length === 0 || ptile == null || ptile < 0)
    return NaN;
  if (ptile > 1)
    ptile = 1;
  vals = nsort(vals);
  var i3 = vals.length * ptile - 0.5;
  if ((i3 | 0) === i3)
    return vals[i3];
  var int_part = i3 | 0;
  var fract = i3 - int_part;
  return (1 - fract) * vals[int_part] + fract * vals[Math.min(int_part + 1, vals.length - 1)];
}
function histogram(vals, bins) {
  if (vals == null) {
    return null;
  }
  vals = nsort(numbers(vals));
  if (vals.length === 0) {
    return null;
  }
  if (bins == null) {
    bins = Math.sqrt(vals.length);
  }
  bins = Math.round(bins);
  if (bins < 1) {
    bins = 1;
  }
  var min = vals[0];
  var max = vals[vals.length - 1];
  if (min === max) {
    min = min - 0.5;
    max = max + 0.5;
  }
  var range = max - min;
  var binWidth = (range + range * 0.05) / bins;
  var midpoint = (min + max) / 2;
  var leftEdge = midpoint - binWidth * Math.floor(bins / 2);
  if (bins % 2 !== 0) {
    var leftEdge = midpoint - binWidth / 2 - binWidth * Math.floor(bins / 2);
  }
  var hist = {
    values: Array(bins).fill(0),
    bins,
    binWidth,
    binLimits: [leftEdge, leftEdge + binWidth * bins]
  };
  var binIndex = 0;
  for (var i3 = 0; i3 < vals.length; i3++) {
    while (vals[i3] > (binIndex + 1) * binWidth + leftEdge) {
      binIndex++;
    }
    hist.values[binIndex]++;
  }
  return hist;
}
const _abi$9 = [
  {
    inputs: [],
    name: "getCurrentBlockTimestamp",
    outputs: [
      {
        internalType: "uint256",
        name: "timestamp",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "addr",
        type: "address"
      }
    ],
    name: "getEthBalance",
    outputs: [
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "gasLimit",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          }
        ],
        internalType: "struct UniswapInterfaceMulticall.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "uint256",
        name: "blockNumber",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "gasUsed",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        internalType: "struct UniswapInterfaceMulticall.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const _bytecode$1 = "0x608060405234801561001057600080fd5b50610567806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80630f28c97d146100465780631749e1e3146100645780634d2301cc14610085575b600080fd5b61004e610098565b60405161005b919061041f565b60405180910390f35b6100776100723660046102a7565b61009c565b60405161005b929190610428565b61004e610093366004610286565b610220565b4290565b8051439060609067ffffffffffffffff811180156100b957600080fd5b506040519080825280602002602001820160405280156100f357816020015b6100e061023a565b8152602001906001900390816100d85790505b50905060005b835181101561021a57600080600086848151811061011357fe5b60200260200101516000015187858151811061012b57fe5b60200260200101516020015188868151811061014357fe5b60200260200101516040015192509250925060005a90506000808573ffffffffffffffffffffffffffffffffffffffff1685856040516101839190610403565b60006040518083038160008787f1925050503d80600081146101c1576040519150601f19603f3d011682016040523d82523d6000602084013e6101c6565b606091505b509150915060005a8403905060405180606001604052808415158152602001828152602001838152508989815181106101fb57fe5b60200260200101819052505050505050505080806001019150506100f9565b50915091565b73ffffffffffffffffffffffffffffffffffffffff163190565b604051806060016040528060001515815260200160008152602001606081525090565b803573ffffffffffffffffffffffffffffffffffffffff8116811461028157600080fd5b919050565b600060208284031215610297578081fd5b6102a08261025d565b9392505050565b600060208083850312156102b9578182fd5b823567ffffffffffffffff808211156102d0578384fd5b818501915085601f8301126102e3578384fd5b8135818111156102ef57fe5b6102fc8485830201610506565b81815284810190848601875b848110156103f457813587017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0606081838f03011215610346578a8bfd5b60408051606081018181108b8211171561035c57fe5b8252610369848d0161025d565b8152818401358c82015260608401358a811115610384578d8efd5b8085019450508e603f850112610398578c8dfd5b8b8401358a8111156103a657fe5b6103b68d85601f84011601610506565b93508084528f838287010111156103cb578d8efd5b808386018e86013783018c018d9052908101919091528552509287019290870190600101610308565b50909998505050505050505050565b6000825161041581846020870161052a565b9190910192915050565b90815260200190565b600060408083018584526020828186015281865180845260609350838701915083838202880101838901875b838110156104f6578983037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa001855281518051151584528681015187850152880151888401889052805188850181905260806104b582828801858c0161052a565b96880196601f919091017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01694909401909301925090850190600101610454565b50909a9950505050505050505050565b60405181810167ffffffffffffffff8111828210171561052257fe5b604052919050565b60005b8381101561054557818101518382015260200161052d565b83811115610554576000848401525b5050505056fea164736f6c6343000706000a";
class UniswapInterfaceMulticall__factory extends ContractFactory {
  constructor(signer) {
    super(_abi$9, _bytecode$1, signer);
  }
  deploy(overrides) {
    return super.deploy(overrides || {});
  }
  getDeployTransaction(overrides) {
    return super.getDeployTransaction(overrides || {});
  }
  attach(address) {
    return super.attach(address);
  }
  connect(signer) {
    return super.connect(signer);
  }
  static createInterface() {
    return new Interface(_abi$9);
  }
  static connect(address, signerOrProvider) {
    return new Contract(address, _abi$9, signerOrProvider);
  }
}
UniswapInterfaceMulticall__factory.bytecode = _bytecode$1;
UniswapInterfaceMulticall__factory.abi = _abi$9;
class UniswapMulticallProvider extends IMulticallProvider {
  constructor(chainId2, provider, gasLimitPerCall = 1e6) {
    super();
    this.chainId = chainId2;
    this.provider = provider;
    this.gasLimitPerCall = gasLimitPerCall;
    const multicallAddress = UNISWAP_MULTICALL_ADDRESSES[this.chainId];
    if (!multicallAddress) {
      throw new Error(`No address for Uniswap Multicall Contract on chain id: ${chainId2}`);
    }
    this.multicallContract = UniswapInterfaceMulticall__factory.connect(multicallAddress, this.provider);
  }
  async callSameFunctionOnMultipleContracts(params) {
    var _a;
    const { addresses, contractInterface, functionName, functionParams, providerConfig } = params;
    const blockNumberOverride = (_a = providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) !== null && _a !== void 0 ? _a : void 0;
    const fragment = contractInterface.getFunction(functionName);
    const callData = contractInterface.encodeFunctionData(fragment, functionParams);
    const calls = _$3.map(addresses, (address) => {
      return {
        target: address,
        callData,
        gasLimit: this.gasLimitPerCall
      };
    });
    log.debug({ calls }, `About to multicall for ${functionName} across ${addresses.length} addresses`);
    const { blockNumber, returnData: aggregateResults } = await this.multicallContract.callStatic.multicall(calls, {
      blockTag: blockNumberOverride
    });
    const results = [];
    for (let i3 = 0; i3 < aggregateResults.length; i3++) {
      const { success, returnData } = aggregateResults[i3];
      if (!success || returnData.length <= 2) {
        log.debug({ result: aggregateResults[i3] }, `Invalid result calling ${functionName} on address ${addresses[i3]}`);
        results.push({
          success: false,
          returnData
        });
        continue;
      }
      results.push({
        success: true,
        result: contractInterface.decodeFunctionResult(fragment, returnData)
      });
    }
    log.debug({ results }, `Results for multicall on ${functionName} across ${addresses.length} addresses as of block ${blockNumber}`);
    return { blockNumber, results };
  }
  async callSameFunctionOnContractWithMultipleParams(params) {
    var _a, _b;
    const { address, contractInterface, functionName, functionParams, additionalConfig, providerConfig } = params;
    const fragment = contractInterface.getFunction(functionName);
    const gasLimitPerCall = (_a = additionalConfig === null || additionalConfig === void 0 ? void 0 : additionalConfig.gasLimitPerCallOverride) !== null && _a !== void 0 ? _a : this.gasLimitPerCall;
    const blockNumberOverride = (_b = providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) !== null && _b !== void 0 ? _b : void 0;
    const calls = _$3.map(functionParams, (functionParam) => {
      const callData = contractInterface.encodeFunctionData(fragment, functionParam);
      return {
        target: address,
        callData,
        gasLimit: gasLimitPerCall
      };
    });
    log.debug({ calls }, `About to multicall for ${functionName} at address ${address} with ${functionParams.length} different sets of params`);
    const { blockNumber, returnData: aggregateResults } = await this.multicallContract.callStatic.multicall(calls, {
      blockTag: blockNumberOverride
    });
    const results = [];
    const gasUsedForSuccess = [];
    for (let i3 = 0; i3 < aggregateResults.length; i3++) {
      const { success, returnData, gasUsed } = aggregateResults[i3];
      if (!success || returnData.length <= 2) {
        log.debug({ result: aggregateResults[i3] }, `Invalid result calling ${functionName} with params ${functionParams[i3]}`);
        results.push({
          success: false,
          returnData
        });
        continue;
      }
      gasUsedForSuccess.push(gasUsed.toNumber());
      results.push({
        success: true,
        result: contractInterface.decodeFunctionResult(fragment, returnData)
      });
    }
    log.debug({ results, functionName, address }, `Results for multicall for ${functionName} at address ${address} with ${functionParams.length} different sets of params. Results as of block ${blockNumber}`);
    return {
      blockNumber,
      results,
      approxGasUsedPerSuccessCall: stats.percentile(gasUsedForSuccess, 99)
    };
  }
  async callMultipleFunctionsOnSameContract(params) {
    var _a, _b;
    const { address, contractInterface, functionNames, functionParams, additionalConfig, providerConfig } = params;
    const gasLimitPerCall = (_a = additionalConfig === null || additionalConfig === void 0 ? void 0 : additionalConfig.gasLimitPerCallOverride) !== null && _a !== void 0 ? _a : this.gasLimitPerCall;
    const blockNumberOverride = (_b = providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) !== null && _b !== void 0 ? _b : void 0;
    const calls = _$3.map(functionNames, (functionName, i3) => {
      const fragment = contractInterface.getFunction(functionName);
      const param = functionParams ? functionParams[i3] : [];
      const callData = contractInterface.encodeFunctionData(fragment, param);
      return {
        target: address,
        callData,
        gasLimit: gasLimitPerCall
      };
    });
    log.debug({ calls }, `About to multicall for ${functionNames.length} functions at address ${address} with ${functionParams === null || functionParams === void 0 ? void 0 : functionParams.length} different sets of params`);
    const { blockNumber, returnData: aggregateResults } = await this.multicallContract.callStatic.multicall(calls, {
      blockTag: blockNumberOverride
    });
    const results = [];
    const gasUsedForSuccess = [];
    for (let i3 = 0; i3 < aggregateResults.length; i3++) {
      const fragment = contractInterface.getFunction(functionNames[i3]);
      const { success, returnData, gasUsed } = aggregateResults[i3];
      if (!success || returnData.length <= 2) {
        log.debug({ result: aggregateResults[i3] }, `Invalid result calling ${functionNames[i3]} with ${functionParams ? functionParams[i3] : "0"} params`);
        results.push({
          success: false,
          returnData
        });
        continue;
      }
      gasUsedForSuccess.push(gasUsed.toNumber());
      results.push({
        success: true,
        result: contractInterface.decodeFunctionResult(fragment, returnData)
      });
    }
    log.debug({ results, functionNames, address }, `Results for multicall for ${functionNames.length} functions at address ${address} with ${functionParams ? functionParams.length : " 0"} different sets of params. Results as of block ${blockNumber}`);
    return {
      blockNumber,
      results,
      approxGasUsedPerSuccessCall: stats.percentile(gasUsedForSuccess, 99)
    };
  }
}
const DEFAULT_EIP_1559_SUPPORTED_CHAINS = [
  ChainId$2.MAINNET,
  ChainId$2.RINKEBY,
  ChainId$2.ROPSTEN,
  ChainId$2.GRLI,
  ChainId$2.POLYGON_MUMBAI
  // infura endpoint having difficulty w/ eip-1559 on kovan
  // ChainId.KOVAN,
];
class OnChainGasPriceProvider extends IGasPriceProvider {
  constructor(chainId2, eip1559GasPriceProvider, legacyGasPriceProvider, eipChains = DEFAULT_EIP_1559_SUPPORTED_CHAINS) {
    super();
    this.chainId = chainId2;
    this.eip1559GasPriceProvider = eip1559GasPriceProvider;
    this.legacyGasPriceProvider = legacyGasPriceProvider;
    this.eipChains = eipChains;
  }
  async getGasPrice() {
    if (this.eipChains.includes(this.chainId)) {
      return this.eip1559GasPriceProvider.getGasPrice();
    }
    return this.legacyGasPriceProvider.getGasPrice();
  }
}
class V3Route extends Route$2 {
  constructor() {
    super(...arguments);
    this.protocol = distExports.Protocol.V3;
  }
}
class V2Route extends Route {
  constructor() {
    super(...arguments);
    this.protocol = distExports.Protocol.V2;
  }
}
class MixedRoute extends distExports.MixedRouteSDK {
  constructor() {
    super(...arguments);
    this.protocol = distExports.Protocol.MIXED;
  }
}
var SwapToRatioStatus;
(function(SwapToRatioStatus2) {
  SwapToRatioStatus2[SwapToRatioStatus2["SUCCESS"] = 1] = "SUCCESS";
  SwapToRatioStatus2[SwapToRatioStatus2["NO_ROUTE_FOUND"] = 2] = "NO_ROUTE_FOUND";
  SwapToRatioStatus2[SwapToRatioStatus2["NO_SWAP_NEEDED"] = 3] = "NO_SWAP_NEEDED";
})(SwapToRatioStatus || (SwapToRatioStatus = {}));
const _abi$8 = [
  {
    inputs: [
      {
        internalType: "bytes",
        name: "path",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      }
    ],
    name: "quoteExactInput",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      },
      {
        internalType: "uint160[]",
        name: "v3SqrtPriceX96AfterList",
        type: "uint160[]"
      },
      {
        internalType: "uint32[]",
        name: "v3InitializedTicksCrossedList",
        type: "uint32[]"
      },
      {
        internalType: "uint256",
        name: "v3SwapGasEstimate",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "address",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
          }
        ],
        internalType: "struct IMixedRouteQuoterV1.QuoteExactInputSingleV2Params",
        name: "params",
        type: "tuple"
      }
    ],
    name: "quoteExactInputSingleV2",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "address",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
          },
          {
            internalType: "uint24",
            name: "fee",
            type: "uint24"
          },
          {
            internalType: "uint160",
            name: "sqrtPriceLimitX96",
            type: "uint160"
          }
        ],
        internalType: "struct IMixedRouteQuoterV1.QuoteExactInputSingleV3Params",
        name: "params",
        type: "tuple"
      }
    ],
    name: "quoteExactInputSingleV3",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      },
      {
        internalType: "uint160",
        name: "sqrtPriceX96After",
        type: "uint160"
      },
      {
        internalType: "uint32",
        name: "initializedTicksCrossed",
        type: "uint32"
      },
      {
        internalType: "uint256",
        name: "gasEstimate",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
class IMixedRouteQuoterV1__factory {
  static createInterface() {
    return new Interface(_abi$8);
  }
  static connect(address, signerOrProvider) {
    return new Contract(address, _abi$8, signerOrProvider);
  }
}
IMixedRouteQuoterV1__factory.abi = _abi$8;
const _abi$7 = [
  {
    inputs: [
      {
        internalType: "bytes",
        name: "path",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      }
    ],
    name: "quoteExactInput",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      },
      {
        internalType: "uint160[]",
        name: "sqrtPriceX96AfterList",
        type: "uint160[]"
      },
      {
        internalType: "uint32[]",
        name: "initializedTicksCrossedList",
        type: "uint32[]"
      },
      {
        internalType: "uint256",
        name: "gasEstimate",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "address",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
          },
          {
            internalType: "uint24",
            name: "fee",
            type: "uint24"
          },
          {
            internalType: "uint160",
            name: "sqrtPriceLimitX96",
            type: "uint160"
          }
        ],
        internalType: "struct IQuoterV2.QuoteExactInputSingleParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "quoteExactInputSingle",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      },
      {
        internalType: "uint160",
        name: "sqrtPriceX96After",
        type: "uint160"
      },
      {
        internalType: "uint32",
        name: "initializedTicksCrossed",
        type: "uint32"
      },
      {
        internalType: "uint256",
        name: "gasEstimate",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "path",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      }
    ],
    name: "quoteExactOutput",
    outputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      },
      {
        internalType: "uint160[]",
        name: "sqrtPriceX96AfterList",
        type: "uint160[]"
      },
      {
        internalType: "uint32[]",
        name: "initializedTicksCrossedList",
        type: "uint32[]"
      },
      {
        internalType: "uint256",
        name: "gasEstimate",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "address",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "uint24",
            name: "fee",
            type: "uint24"
          },
          {
            internalType: "uint160",
            name: "sqrtPriceLimitX96",
            type: "uint160"
          }
        ],
        internalType: "struct IQuoterV2.QuoteExactOutputSingleParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "quoteExactOutputSingle",
    outputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      },
      {
        internalType: "uint160",
        name: "sqrtPriceX96After",
        type: "uint160"
      },
      {
        internalType: "uint32",
        name: "initializedTicksCrossed",
        type: "uint32"
      },
      {
        internalType: "uint256",
        name: "gasEstimate",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
class IQuoterV2__factory {
  static createInterface() {
    return new Interface(_abi$7);
  }
  static connect(address, signerOrProvider) {
    return new Contract(address, _abi$7, signerOrProvider);
  }
}
IQuoterV2__factory.abi = _abi$7;
class BlockConflictError extends Error {
  constructor() {
    super(...arguments);
    this.name = "BlockConflictError";
  }
}
class SuccessRateError extends Error {
  constructor() {
    super(...arguments);
    this.name = "SuccessRateError";
  }
}
class ProviderBlockHeaderError extends Error {
  constructor() {
    super(...arguments);
    this.name = "ProviderBlockHeaderError";
  }
}
class ProviderTimeoutError extends Error {
  constructor() {
    super(...arguments);
    this.name = "ProviderTimeoutError";
  }
}
class ProviderGasError extends Error {
  constructor() {
    super(...arguments);
    this.name = "ProviderGasError";
  }
}
const DEFAULT_BATCH_RETRIES = 2;
class OnChainQuoteProvider {
  /**
   * Creates an instance of OnChainQuoteProvider.
   *
   * @param chainId The chain to get quotes for.
   * @param provider The web 3 provider.
   * @param multicall2Provider The multicall provider to use to get the quotes on-chain.
   * Only supports the Uniswap Multicall contract as it needs the gas limitting functionality.
   * @param retryOptions The retry options for each call to the multicall.
   * @param batchParams The parameters for each batched call to the multicall.
   * @param gasErrorFailureOverride The gas and chunk parameters to use when retrying a batch that failed due to out of gas.
   * @param successRateFailureOverrides The parameters for retries when we fail to get quotes.
   * @param blockNumberConfig Parameters for adjusting which block we get quotes from, and how to handle block header not found errors.
   * @param [quoterAddressOverride] Overrides the address of the quoter contract to use.
   */
  constructor(chainId2, provider, multicall2Provider, retryOptions = {
    retries: DEFAULT_BATCH_RETRIES,
    minTimeout: 25,
    maxTimeout: 250
  }, batchParams = {
    multicallChunk: 150,
    gasLimitPerCall: 1e6,
    quoteMinSuccessRate: 0.2
  }, gasErrorFailureOverride = {
    gasLimitOverride: 15e5,
    multicallChunk: 100
  }, successRateFailureOverrides = {
    gasLimitOverride: 13e5,
    multicallChunk: 110
  }, blockNumberConfig = {
    baseBlockOffset: 0,
    rollback: { enabled: false }
  }, quoterAddressOverride) {
    this.chainId = chainId2;
    this.provider = provider;
    this.multicall2Provider = multicall2Provider;
    this.retryOptions = retryOptions;
    this.batchParams = batchParams;
    this.gasErrorFailureOverride = gasErrorFailureOverride;
    this.successRateFailureOverrides = successRateFailureOverrides;
    this.blockNumberConfig = blockNumberConfig;
    this.quoterAddressOverride = quoterAddressOverride;
  }
  getQuoterAddress(useMixedRouteQuoter) {
    if (this.quoterAddressOverride) {
      return this.quoterAddressOverride;
    }
    const quoterAddress = useMixedRouteQuoter ? MIXED_ROUTE_QUOTER_V1_ADDRESSES$1[this.chainId] : QUOTER_V2_ADDRESSES[this.chainId];
    if (!quoterAddress) {
      throw new Error(`No address for the quoter contract on chain id: ${this.chainId}`);
    }
    return quoterAddress;
  }
  async getQuotesManyExactIn(amountIns, routes, providerConfig) {
    return this.getQuotesManyData(amountIns, routes, "quoteExactInput", providerConfig);
  }
  async getQuotesManyExactOut(amountOuts, routes, providerConfig) {
    return this.getQuotesManyData(amountOuts, routes, "quoteExactOutput", providerConfig);
  }
  async getQuotesManyData(amounts, routes, functionName, _providerConfig) {
    var _a;
    const useMixedRouteQuoter = routes.some((route) => route.protocol === distExports.Protocol.V2) || routes.some((route) => route.protocol === distExports.Protocol.MIXED);
    this.validateRoutes(routes, functionName, useMixedRouteQuoter);
    let multicallChunk = this.batchParams.multicallChunk;
    let gasLimitOverride = this.batchParams.gasLimitPerCall;
    const { baseBlockOffset, rollback } = this.blockNumberConfig;
    const originalBlockNumber = await this.provider.getBlockNumber();
    const providerConfig = {
      ..._providerConfig,
      blockNumber: (_a = _providerConfig === null || _providerConfig === void 0 ? void 0 : _providerConfig.blockNumber) !== null && _a !== void 0 ? _a : originalBlockNumber + baseBlockOffset
    };
    const inputs = _$3(routes).flatMap((route) => {
      const encodedRoute = route.protocol === distExports.Protocol.V3 ? encodeRouteToPath(
        route,
        functionName == "quoteExactOutput"
        // For exactOut must be true to ensure the routes are reversed.
      ) : distExports.encodeMixedRouteToPath(route instanceof V2Route ? new distExports.MixedRouteSDK(route.pairs, route.input, route.output) : route);
      const routeInputs = amounts.map((amount) => [
        encodedRoute,
        `0x${amount.quotient.toString(16)}`
      ]);
      return routeInputs;
    }).value();
    const normalizedChunk = Math.ceil(inputs.length / Math.ceil(inputs.length / multicallChunk));
    const inputsChunked = _$3.chunk(inputs, normalizedChunk);
    let quoteStates = _$3.map(inputsChunked, (inputChunk) => {
      return {
        status: "pending",
        inputs: inputChunk
      };
    });
    log.info(`About to get ${inputs.length} quotes in chunks of ${normalizedChunk} [${_$3.map(inputsChunked, (i3) => i3.length).join(",")}] ${gasLimitOverride ? `with a gas limit override of ${gasLimitOverride}` : ""} and block number: ${await providerConfig.blockNumber} [Original before offset: ${originalBlockNumber}].`);
    let haveRetriedForSuccessRate = false;
    let haveRetriedForBlockHeader = false;
    let blockHeaderRetryAttemptNumber = 0;
    let haveIncrementedBlockHeaderFailureCounter = false;
    let blockHeaderRolledBack = false;
    let haveRetriedForBlockConflictError = false;
    let haveRetriedForOutOfGas = false;
    let haveRetriedForTimeout = false;
    let haveRetriedForUnknownReason = false;
    let finalAttemptNumber = 1;
    const expectedCallsMade = quoteStates.length;
    let totalCallsMade = 0;
    const { results: quoteResults, blockNumber, approxGasUsedPerSuccessCall } = await retry$1(async (_bail, attemptNumber) => {
      haveIncrementedBlockHeaderFailureCounter = false;
      finalAttemptNumber = attemptNumber;
      const [success, failed, pending] = this.partitionQuotes(quoteStates);
      log.info(`Starting attempt: ${attemptNumber}.
          Currently ${success.length} success, ${failed.length} failed, ${pending.length} pending.
          Gas limit override: ${gasLimitOverride} Block number override: ${providerConfig.blockNumber}.`);
      quoteStates = await Promise.all(_$3.map(quoteStates, async (quoteState, idx) => {
        if (quoteState.status == "success") {
          return quoteState;
        }
        const { inputs: inputs2 } = quoteState;
        try {
          totalCallsMade = totalCallsMade + 1;
          const results = await this.multicall2Provider.callSameFunctionOnContractWithMultipleParams({
            address: this.getQuoterAddress(useMixedRouteQuoter),
            contractInterface: useMixedRouteQuoter ? IMixedRouteQuoterV1__factory.createInterface() : IQuoterV2__factory.createInterface(),
            functionName,
            functionParams: inputs2,
            providerConfig,
            additionalConfig: {
              gasLimitPerCallOverride: gasLimitOverride
            }
          });
          const successRateError = this.validateSuccessRate(results.results, haveRetriedForSuccessRate);
          if (successRateError) {
            return {
              status: "failed",
              inputs: inputs2,
              reason: successRateError,
              results
            };
          }
          return {
            status: "success",
            inputs: inputs2,
            results
          };
        } catch (err) {
          if (err.message.includes("header not found")) {
            return {
              status: "failed",
              inputs: inputs2,
              reason: new ProviderBlockHeaderError(err.message.slice(0, 500))
            };
          }
          if (err.message.includes("timeout")) {
            return {
              status: "failed",
              inputs: inputs2,
              reason: new ProviderTimeoutError(`Req ${idx}/${quoteStates.length}. Request had ${inputs2.length} inputs. ${err.message.slice(0, 500)}`)
            };
          }
          if (err.message.includes("out of gas")) {
            return {
              status: "failed",
              inputs: inputs2,
              reason: new ProviderGasError(err.message.slice(0, 500))
            };
          }
          return {
            status: "failed",
            inputs: inputs2,
            reason: new Error(`Unknown error from provider: ${err.message.slice(0, 500)}`)
          };
        }
      }));
      const [successfulQuoteStates, failedQuoteStates, pendingQuoteStates] = this.partitionQuotes(quoteStates);
      if (pendingQuoteStates.length > 0) {
        throw new Error("Pending quote after waiting for all promises.");
      }
      let retryAll = false;
      const blockNumberError = this.validateBlockNumbers(successfulQuoteStates, inputsChunked.length, gasLimitOverride);
      if (blockNumberError) {
        retryAll = true;
      }
      const reasonForFailureStr = _$3.map(failedQuoteStates, (failedQuoteState) => failedQuoteState.reason.name).join(", ");
      if (failedQuoteStates.length > 0) {
        log.info(`On attempt ${attemptNumber}: ${failedQuoteStates.length}/${quoteStates.length} quotes failed. Reasons: ${reasonForFailureStr}`);
        for (const failedQuoteState of failedQuoteStates) {
          const { reason: error } = failedQuoteState;
          log.info({ error }, `[QuoteFetchError] Attempt ${attemptNumber}. ${error.message}`);
          if (error instanceof BlockConflictError) {
            if (!haveRetriedForBlockConflictError) {
              metric.putMetric("QuoteBlockConflictErrorRetry", 1, MetricLoggerUnit.Count);
              haveRetriedForBlockConflictError = true;
            }
            retryAll = true;
          } else if (error instanceof ProviderBlockHeaderError) {
            if (!haveRetriedForBlockHeader) {
              metric.putMetric("QuoteBlockHeaderNotFoundRetry", 1, MetricLoggerUnit.Count);
              haveRetriedForBlockHeader = true;
            }
            if (!haveIncrementedBlockHeaderFailureCounter) {
              blockHeaderRetryAttemptNumber = blockHeaderRetryAttemptNumber + 1;
              haveIncrementedBlockHeaderFailureCounter = true;
            }
            if (rollback.enabled) {
              const { rollbackBlockOffset, attemptsBeforeRollback } = rollback;
              if (blockHeaderRetryAttemptNumber >= attemptsBeforeRollback && !blockHeaderRolledBack) {
                log.info(`Attempt ${attemptNumber}. Have failed due to block header ${blockHeaderRetryAttemptNumber - 1} times. Rolling back block number by ${rollbackBlockOffset} for next retry`);
                providerConfig.blockNumber = providerConfig.blockNumber ? await providerConfig.blockNumber + rollbackBlockOffset : await this.provider.getBlockNumber() + rollbackBlockOffset;
                retryAll = true;
                blockHeaderRolledBack = true;
              }
            }
          } else if (error instanceof ProviderTimeoutError) {
            if (!haveRetriedForTimeout) {
              metric.putMetric("QuoteTimeoutRetry", 1, MetricLoggerUnit.Count);
              haveRetriedForTimeout = true;
            }
          } else if (error instanceof ProviderGasError) {
            if (!haveRetriedForOutOfGas) {
              metric.putMetric("QuoteOutOfGasExceptionRetry", 1, MetricLoggerUnit.Count);
              haveRetriedForOutOfGas = true;
            }
            gasLimitOverride = this.gasErrorFailureOverride.gasLimitOverride;
            multicallChunk = this.gasErrorFailureOverride.multicallChunk;
            retryAll = true;
          } else if (error instanceof SuccessRateError) {
            if (!haveRetriedForSuccessRate) {
              metric.putMetric("QuoteSuccessRateRetry", 1, MetricLoggerUnit.Count);
              haveRetriedForSuccessRate = true;
              gasLimitOverride = this.successRateFailureOverrides.gasLimitOverride;
              multicallChunk = this.successRateFailureOverrides.multicallChunk;
              retryAll = true;
            }
          } else {
            if (!haveRetriedForUnknownReason) {
              metric.putMetric("QuoteUnknownReasonRetry", 1, MetricLoggerUnit.Count);
              haveRetriedForUnknownReason = true;
            }
          }
        }
      }
      if (retryAll) {
        log.info(`Attempt ${attemptNumber}. Resetting all requests to pending for next attempt.`);
        const normalizedChunk2 = Math.ceil(inputs.length / Math.ceil(inputs.length / multicallChunk));
        const inputsChunked2 = _$3.chunk(inputs, normalizedChunk2);
        quoteStates = _$3.map(inputsChunked2, (inputChunk) => {
          return {
            status: "pending",
            inputs: inputChunk
          };
        });
      }
      if (failedQuoteStates.length > 0) {
        if ((this.chainId == ChainId$2.ARBITRUM_ONE || this.chainId == ChainId$2.ARBITRUM_RINKEBY) && _$3.every(failedQuoteStates, (failedQuoteState) => failedQuoteState.reason instanceof ProviderGasError) && attemptNumber == this.retryOptions.retries) {
          log.error(`Failed to get quotes on Arbitrum due to provider gas error issue. Overriding error to return 0 quotes.`);
          return {
            results: [],
            blockNumber: BigNumber.from(0),
            approxGasUsedPerSuccessCall: 0
          };
        }
        throw new Error(`Failed to get ${failedQuoteStates.length} quotes. Reasons: ${reasonForFailureStr}`);
      }
      const callResults = _$3.map(successfulQuoteStates, (quoteState) => quoteState.results);
      return {
        results: _$3.flatMap(callResults, (result) => result.results),
        blockNumber: BigNumber.from(callResults[0].blockNumber),
        approxGasUsedPerSuccessCall: stats.percentile(_$3.map(callResults, (result) => result.approxGasUsedPerSuccessCall), 100)
      };
    }, {
      retries: DEFAULT_BATCH_RETRIES,
      ...this.retryOptions
    });
    const routesQuotes = this.processQuoteResults(quoteResults, routes, amounts);
    metric.putMetric("QuoteApproxGasUsedPerSuccessfulCall", approxGasUsedPerSuccessCall, MetricLoggerUnit.Count);
    metric.putMetric("QuoteNumRetryLoops", finalAttemptNumber - 1, MetricLoggerUnit.Count);
    metric.putMetric("QuoteTotalCallsToProvider", totalCallsMade, MetricLoggerUnit.Count);
    metric.putMetric("QuoteExpectedCallsToProvider", expectedCallsMade, MetricLoggerUnit.Count);
    metric.putMetric("QuoteNumRetriedCalls", totalCallsMade - expectedCallsMade, MetricLoggerUnit.Count);
    const [successfulQuotes, failedQuotes] = _$3(routesQuotes).flatMap((routeWithQuotes) => routeWithQuotes[1]).partition((quote) => quote.quote != null).value();
    log.info(`Got ${successfulQuotes.length} successful quotes, ${failedQuotes.length} failed quotes. Took ${finalAttemptNumber - 1} attempt loops. Total calls made to provider: ${totalCallsMade}. Have retried for timeout: ${haveRetriedForTimeout}`);
    return { routesWithQuotes: routesQuotes, blockNumber };
  }
  partitionQuotes(quoteStates) {
    const successfulQuoteStates = _$3.filter(quoteStates, (quoteState) => quoteState.status == "success");
    const failedQuoteStates = _$3.filter(quoteStates, (quoteState) => quoteState.status == "failed");
    const pendingQuoteStates = _$3.filter(quoteStates, (quoteState) => quoteState.status == "pending");
    return [successfulQuoteStates, failedQuoteStates, pendingQuoteStates];
  }
  processQuoteResults(quoteResults, routes, amounts) {
    const routesQuotes = [];
    const quotesResultsByRoute = _$3.chunk(quoteResults, amounts.length);
    const debugFailedQuotes = [];
    for (let i3 = 0; i3 < quotesResultsByRoute.length; i3++) {
      const route = routes[i3];
      const quoteResults2 = quotesResultsByRoute[i3];
      const quotes = _$3.map(quoteResults2, (quoteResult, index2) => {
        const amount = amounts[index2];
        if (!quoteResult.success) {
          const percent = 100 / amounts.length * (index2 + 1);
          const amountStr = amount.toFixed(Math.min(amount.currency.decimals, 2));
          const routeStr = routeToString(route);
          debugFailedQuotes.push({
            route: routeStr,
            percent,
            amount: amountStr
          });
          return {
            amount,
            quote: null,
            sqrtPriceX96AfterList: null,
            gasEstimate: null,
            initializedTicksCrossedList: null
          };
        }
        return {
          amount,
          quote: quoteResult.result[0],
          sqrtPriceX96AfterList: quoteResult.result[1],
          initializedTicksCrossedList: quoteResult.result[2],
          gasEstimate: quoteResult.result[3]
        };
      });
      routesQuotes.push([route, quotes]);
    }
    const debugChunk = 80;
    _$3.forEach(_$3.chunk(debugFailedQuotes, debugChunk), (quotes, idx) => {
      const failedQuotesByRoute = _$3.groupBy(quotes, (q2) => q2.route);
      const failedFlat = _$3.mapValues(failedQuotesByRoute, (f3) => _$3(f3).map((f4) => `${f4.percent}%[${f4.amount}]`).join(","));
      log.info({
        failedQuotes: _$3.map(failedFlat, (amounts2, routeStr) => `${routeStr} : ${amounts2}`)
      }, `Failed on chain quotes for routes Part ${idx}/${Math.ceil(debugFailedQuotes.length / debugChunk)}`);
    });
    return routesQuotes;
  }
  validateBlockNumbers(successfulQuoteStates, totalCalls, gasLimitOverride) {
    if (successfulQuoteStates.length <= 1) {
      return null;
    }
    const results = _$3.map(successfulQuoteStates, (quoteState) => quoteState.results);
    const blockNumbers = _$3.map(results, (result) => result.blockNumber);
    const uniqBlocks = _$3(blockNumbers).map((blockNumber) => blockNumber.toNumber()).uniq().value();
    if (uniqBlocks.length == 1) {
      return null;
    }
    return new BlockConflictError(`Quotes returned from different blocks. ${uniqBlocks}. ${totalCalls} calls were made with gas limit ${gasLimitOverride}`);
  }
  validateSuccessRate(allResults, haveRetriedForSuccessRate) {
    const numResults = allResults.length;
    const numSuccessResults = allResults.filter((result) => result.success).length;
    const successRate = 1 * numSuccessResults / numResults;
    const { quoteMinSuccessRate } = this.batchParams;
    if (successRate < quoteMinSuccessRate) {
      if (haveRetriedForSuccessRate) {
        log.info(`Quote success rate still below threshold despite retry. Continuing. ${quoteMinSuccessRate}: ${successRate}`);
        return;
      }
      return new SuccessRateError(`Quote success rate below threshold of ${quoteMinSuccessRate}: ${successRate}`);
    }
  }
  /**
   * Throw an error for incorrect routes / function combinations
   * @param routes Any combination of V3, V2, and Mixed routes.
   * @param functionName
   * @param useMixedRouteQuoter true if there are ANY V2Routes or MixedRoutes in the routes parameter
   */
  validateRoutes(routes, functionName, useMixedRouteQuoter) {
    if (routes.some((route) => route.protocol === distExports.Protocol.V3) && useMixedRouteQuoter) {
      throw new Error(`Cannot use mixed route quoter with V3 routes`);
    }
    if (functionName === "quoteExactOutput" && useMixedRouteQuoter) {
      throw new Error("Cannot call quoteExactOutput with V2 or Mixed routes");
    }
  }
}
const _abi$6 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_factoryV2",
        type: "address"
      },
      {
        internalType: "address",
        name: "factoryV3",
        type: "address"
      },
      {
        internalType: "address",
        name: "_positionManager",
        type: "address"
      },
      {
        internalType: "address",
        name: "_WETH9",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "WETH9",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "approveMax",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "approveMaxMinusOne",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "approveZeroThenMax",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "approveZeroThenMaxMinusOne",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "callPositionManager",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "paths",
        type: "bytes[]"
      },
      {
        internalType: "uint128[]",
        name: "amounts",
        type: "uint128[]"
      },
      {
        internalType: "uint24",
        name: "maximumTickDivergence",
        type: "uint24"
      },
      {
        internalType: "uint32",
        name: "secondsAgo",
        type: "uint32"
      }
    ],
    name: "checkOracleSlippage",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "path",
        type: "bytes"
      },
      {
        internalType: "uint24",
        name: "maximumTickDivergence",
        type: "uint24"
      },
      {
        internalType: "uint32",
        name: "secondsAgo",
        type: "uint32"
      }
    ],
    name: "checkOracleSlippage",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes",
            name: "path",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountOutMinimum",
            type: "uint256"
          }
        ],
        internalType: "struct IV3SwapRouter.ExactInputParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactInput",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "address",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint24",
            name: "fee",
            type: "uint24"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountOutMinimum",
            type: "uint256"
          },
          {
            internalType: "uint160",
            name: "sqrtPriceLimitX96",
            type: "uint160"
          }
        ],
        internalType: "struct IV3SwapRouter.ExactInputSingleParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactInputSingle",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes",
            name: "path",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amountOut",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountInMaximum",
            type: "uint256"
          }
        ],
        internalType: "struct IV3SwapRouter.ExactOutputParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactOutput",
    outputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "address",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint24",
            name: "fee",
            type: "uint24"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amountOut",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amountInMaximum",
            type: "uint256"
          },
          {
            internalType: "uint160",
            name: "sqrtPriceLimitX96",
            type: "uint160"
          }
        ],
        internalType: "struct IV3SwapRouter.ExactOutputSingleParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactOutputSingle",
    outputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "factory",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "factoryV2",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "getApprovalType",
    outputs: [
      {
        internalType: "enum IApproveAndCall.ApprovalType",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "token0",
            type: "address"
          },
          {
            internalType: "address",
            name: "token1",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount0Min",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount1Min",
            type: "uint256"
          }
        ],
        internalType: "struct IApproveAndCall.IncreaseLiquidityParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "increaseLiquidity",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "token0",
            type: "address"
          },
          {
            internalType: "address",
            name: "token1",
            type: "address"
          },
          {
            internalType: "uint24",
            name: "fee",
            type: "uint24"
          },
          {
            internalType: "int24",
            name: "tickLower",
            type: "int24"
          },
          {
            internalType: "int24",
            name: "tickUpper",
            type: "int24"
          },
          {
            internalType: "uint256",
            name: "amount0Min",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount1Min",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        internalType: "struct IApproveAndCall.MintParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "mint",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "previousBlockhash",
        type: "bytes32"
      },
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "",
        type: "bytes[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "",
        type: "bytes[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "positionManager",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "pull",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "refundETH",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "expiry",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermitAllowed",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "expiry",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermitAllowedIfNecessary",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "selfPermitIfNecessary",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amountOutMin",
        type: "uint256"
      },
      {
        internalType: "address[]",
        name: "path",
        type: "address[]"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "swapExactTokensForTokens",
    outputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amountInMax",
        type: "uint256"
      },
      {
        internalType: "address[]",
        name: "path",
        type: "address[]"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "swapTokensForExactTokens",
    outputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "sweepToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      }
    ],
    name: "sweepToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "feeBips",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "feeRecipient",
        type: "address"
      }
    ],
    name: "sweepTokenWithFee",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "feeBips",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "feeRecipient",
        type: "address"
      }
    ],
    name: "sweepTokenWithFee",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "int256",
        name: "amount0Delta",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "amount1Delta",
        type: "int256"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "uniswapV3SwapCallback",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "unwrapWETH9",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      }
    ],
    name: "unwrapWETH9",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "feeBips",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "feeRecipient",
        type: "address"
      }
    ],
    name: "unwrapWETH9WithFee",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountMinimum",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "feeBips",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "feeRecipient",
        type: "address"
      }
    ],
    name: "unwrapWETH9WithFee",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "wrapETH",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];
const _bytecode = "0x6101006040526000196000553480156200001857600080fd5b5060405162006135380380620061358339810160408190526200003b9162000087565b6001600160601b0319606094851b811660805291841b821660a05291831b811660c052911b1660e052620000e3565b80516001600160a01b03811681146200008257600080fd5b919050565b600080600080608085870312156200009d578384fd5b620000a8856200006a565b9350620000b8602086016200006a565b9250620000c8604086016200006a565b9150620000d8606086016200006a565b905092959194509250565b60805160601c60a05160601c60c05160601c60e05160601c615fb162000184600039806102c15280610b3c52806112ad52806113d7528061147e52806116af52806117d95280612d8f5280612def5280612e70525080611e4c52806124df5280613cdb52508061166f5280611b1a5280611e9c52806132a6525080610c625280610d365280610fe2528061164b5280612fc252806131855250615fb16000f3fe6080604052600436106102a45760003560e01c80639b2c0a371161016e578063dee00f35116100cb578063f100b2051161007f578063f2d5d56b11610064578063f2d5d56b1461066e578063f3995c6714610681578063fa461e33146106945761034f565b8063f100b2051461063b578063f25801a71461064e5761034f565b8063e0e189a0116100b0578063e0e189a0146105f5578063e90a182f14610608578063efdeed8e1461061b5761034f565b8063dee00f35146105b5578063df2ab5bb146105e25761034f565b8063b858183f11610122578063c45a015511610107578063c45a01551461057a578063cab372ce1461058f578063d4ef38de146105a25761034f565b8063b858183f14610554578063c2e3140a146105675761034f565b8063ab3fdd5011610153578063ab3fdd501461051b578063ac9650d81461052e578063b3a2af13146105415761034f565b80639b2c0a37146104f5578063a4a78f0c146105085761034f565b8063472b43f31161021c578063571ac8b0116101d0578063639d71a9116101b5578063639d71a9146104b857806368e0d4e1146104cb578063791b98bc146104e05761034f565b8063571ac8b0146104925780635ae401dc146104a55761034f565b80634961699711610201578063496169971461044a5780634aa4a4fc1461045d5780635023b4df1461047f5761034f565b8063472b43f31461042457806349404b7c146104375761034f565b80631c58db4f116102735780633068c554116102585780633068c554146103eb57806342712a67146103fe5780634659a494146104115761034f565b80631c58db4f146103b85780631f0464d1146103cb5761034f565b806304e45aaf1461035457806309b813461461037d57806311ed56c91461039057806312210e8a146103b05761034f565b3661034f573373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000161461034d57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f4e6f742057455448390000000000000000000000000000000000000000000000604482015290519081900360640190fd5b005b600080fd5b610367610362366004615543565b6106b4565b6040516103749190615dfd565b60405180910390f35b61036761038b3660046155de565b61083c565b6103a361039e366004615638565b61091c565b6040516103749190615b7a565b61034d610b28565b61034d6103c63660046157bb565b610b3a565b6103de6103d93660046152a7565b610bbe565b6040516103749190615afc565b61034d6103f93660046150d8565b610c48565b61036761040c366004615885565b610c5b565b61034d61041f366004615121565b610e35565b610367610432366004615885565b610ef5565b61034d6104453660046157eb565b6112a9565b61034d6104583660046157bb565b61146f565b34801561046957600080fd5b5061047261147c565b6040516103749190615a3c565b61036761048d366004615616565b6114a0565b61034d6104a0366004614feb565b611589565b6103de6104b33660046152a7565b6115bc565b61034d6104c6366004614feb565b611635565b3480156104d757600080fd5b50610472611649565b3480156104ec57600080fd5b5061047261166d565b61034d61050336600461581a565b611691565b61034d610516366004615121565b6118a7565b61034d610529366004614feb565b61197c565b6103de61053c36600461517c565b6119ba565b6103a361054f3660046152f1565b611b14565b61036761056236600461549d565b611bd2565b61034d610575366004615121565b611d95565b34801561058657600080fd5b50610472611e4a565b61034d61059d366004614feb565b611990565b61034d6105b0366004615858565b611e6e565b3480156105c157600080fd5b506105d56105d036600461500e565b611e7a565b6040516103749190615b8d565b61034d6105f0366004615039565b612027565b61034d61060336600461507a565b61213e565b61034d61061636600461500e565b6122a4565b34801561062757600080fd5b5061034d6106363660046151bc565b6122b3565b6103a3610649366004615627565b612305565b34801561065a57600080fd5b5061034d610669366004615324565b6123a5565b61034d61067c36600461500e565b6123f6565b61034d61068f366004615121565b612402565b3480156106a057600080fd5b5061034d6106af3660046153b8565b61249a565b600080600083608001511415610771575081516040517f70a0823100000000000000000000000000000000000000000000000000000000815260019173ffffffffffffffffffffffffffffffffffffffff16906370a082319061071b903090600401615a3c565b60206040518083038186803b15801561073357600080fd5b505afa158015610747573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076b91906157d3565b60808401525b6107ed836080015184606001518560c001516040518060400160405280886000015189604001518a602001516040516020016107af939291906159aa565b6040516020818303038152906040528152602001866107ce57336107d0565b305b73ffffffffffffffffffffffffffffffffffffffff1690526125de565b91508260a00151821015610836576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161082d90615c7d565b60405180910390fd5b50919050565b60006108b0604083018035906108559060208601614feb565b604080518082019091526000908061086d8880615e41565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505050908252503360209091015261278f565b505060005460608201358111156108f3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161082d90615c0f565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600055919050565b604080516101608101909152606090610b20907f8831645600000000000000000000000000000000000000000000000000000000908061095f6020870187614feb565b73ffffffffffffffffffffffffffffffffffffffff16815260200185602001602081019061098d9190614feb565b73ffffffffffffffffffffffffffffffffffffffff1681526020016109b860608701604088016157a1565b62ffffff1681526020016109d26080870160608801615379565b60020b81526020016109ea60a0870160808801615379565b60020b8152602090810190610a0a90610a0590880188614feb565b612976565b8152602001610a25866020016020810190610a059190614feb565b815260a0860135602082015260c08601356040820152606001610a4f610100870160e08801614feb565b73ffffffffffffffffffffffffffffffffffffffff1681526020017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff815250604051602401610a9e9190615cf8565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152611b14565b90505b919050565b4715610b3857610b383347612a1b565b565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b158015610ba257600080fd5b505af1158015610bb6573d6000803e3d6000fd5b505050505050565b60608380600143034014610c3357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f426c6f636b686173680000000000000000000000000000000000000000000000604482015290519081900360640190fd5b610c3d84846119ba565b91505b509392505050565b610c55848433858561213e565b50505050565b6000610cbb7f000000000000000000000000000000000000000000000000000000000000000087868680806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612b6992505050565b600081518110610cc757fe5b6020026020010151905084811115610d0b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161082d90615c0f565b610da484846000818110610d1b57fe5b9050602002016020810190610d309190614feb565b33610d9e7f000000000000000000000000000000000000000000000000000000000000000088886000818110610d6257fe5b9050602002016020810190610d779190614feb565b89896001818110610d8457fe5b9050602002016020810190610d999190614feb565b612ca2565b84612d8d565b73ffffffffffffffffffffffffffffffffffffffff821660011415610dcb57339150610dee565b73ffffffffffffffffffffffffffffffffffffffff821660021415610dee573091505b610e2c848480806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250869250612f6b915050565b95945050505050565b604080517f8fcbaf0c00000000000000000000000000000000000000000000000000000000815233600482015230602482015260448101879052606481018690526001608482015260ff851660a482015260c4810184905260e48101839052905173ffffffffffffffffffffffffffffffffffffffff881691638fcbaf0c9161010480830192600092919082900301818387803b158015610ed557600080fd5b505af1158015610ee9573d6000803e3d6000fd5b50505050505050505050565b60008086610fab575060018484600081610f0b57fe5b9050602002016020810190610f209190614feb565b73ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401610f589190615a3c565b60206040518083038186803b158015610f7057600080fd5b505afa158015610f84573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fa891906157d3565b96505b61103685856000818110610fbb57fe5b9050602002016020810190610fd09190614feb565b82610fdb5733610fdd565b305b6110307f00000000000000000000000000000000000000000000000000000000000000008989600081811061100e57fe5b90506020020160208101906110239190614feb565b8a8a6001818110610d8457fe5b8a612d8d565b73ffffffffffffffffffffffffffffffffffffffff83166001141561105d57339250611080565b73ffffffffffffffffffffffffffffffffffffffff831660021415611080573092505b600085857fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81018181106110b057fe5b90506020020160208101906110c59190614feb565b73ffffffffffffffffffffffffffffffffffffffff166370a08231856040518263ffffffff1660e01b81526004016110fd9190615a3c565b60206040518083038186803b15801561111557600080fd5b505afa158015611129573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061114d91906157d3565b905061118d868680806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250889250612f6b915050565b6112628187877fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81018181106111bf57fe5b90506020020160208101906111d49190614feb565b73ffffffffffffffffffffffffffffffffffffffff166370a08231876040518263ffffffff1660e01b815260040161120c9190615a3c565b60206040518083038186803b15801561122457600080fd5b505afa158015611238573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061125c91906157d3565b90613270565b92508683101561129e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161082d90615c7d565b505095945050505050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561133257600080fd5b505afa158015611346573d6000803e3d6000fd5b505050506040513d602081101561135c57600080fd5b50519050828110156113cf57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f496e73756666696369656e742057455448390000000000000000000000000000604482015290519081900360640190fd5b801561146a577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16632e1a7d4d826040518263ffffffff1660e01b815260040180828152602001915050600060405180830381600087803b15801561144857600080fd5b505af115801561145c573d6000803e3d6000fd5b5050505061146a8282612a1b565b505050565b61147981336112a9565b50565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000611549608083018035906114b99060608601614feb565b6114c960e0860160c08701614feb565b60405180604001604052808760200160208101906114e79190614feb565b6114f760608a0160408b016157a1565b61150460208b018b614feb565b604051602001611516939291906159aa565b60405160208183030381529060405281526020013373ffffffffffffffffffffffffffffffffffffffff1681525061278f565b90508160a001358111156108f3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161082d90615c0f565b6115b3817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff613280565b61147957600080fd5b606083806115c86133cc565b1115610c3357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f5472616e73616374696f6e20746f6f206f6c6400000000000000000000000000604482015290519081900360640190fd5b611640816000613280565b61158957600080fd5b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000821180156116a2575060648211155b6116ab57600080fd5b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561173457600080fd5b505afa158015611748573d6000803e3d6000fd5b505050506040513d602081101561175e57600080fd5b50519050848110156117d157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f496e73756666696369656e742057455448390000000000000000000000000000604482015290519081900360640190fd5b80156118a0577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16632e1a7d4d826040518263ffffffff1660e01b815260040180828152602001915050600060405180830381600087803b15801561184a57600080fd5b505af115801561185e573d6000803e3d6000fd5b50505050600061271061187a85846133d090919063ffffffff16565b8161188157fe5b0490508015611894576118948382612a1b565b610bb685828403612a1b565b5050505050565b604080517fdd62ed3e00000000000000000000000000000000000000000000000000000000815233600482015230602482015290517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9173ffffffffffffffffffffffffffffffffffffffff89169163dd62ed3e91604480820192602092909190829003018186803b15801561193c57600080fd5b505afa158015611950573d6000803e3d6000fd5b505050506040513d602081101561196657600080fd5b50511015610bb657610bb6868686868686610e35565b611987816000613280565b61199057600080fd5b6115b3817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe613280565b60608167ffffffffffffffff811180156119d357600080fd5b50604051908082528060200260200182016040528015611a0757816020015b60608152602001906001900390816119f25790505b50905060005b82811015611b0d5760008030868685818110611a2557fe5b9050602002810190611a379190615e41565b604051611a45929190615a10565b600060405180830381855af49150503d8060008114611a80576040519150601f19603f3d011682016040523d82523d6000602084013e611a85565b606091505b509150915081611aeb57604481511015611a9e57600080fd5b60048101905080806020019051810190611ab89190615433565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161082d9190615b7a565b80848481518110611af857fe5b60209081029190910101525050600101611a0d565b5092915050565b606060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1683604051611b5d9190615a20565b6000604051808303816000865af19150503d8060008114611b9a576040519150601f19603f3d011682016040523d82523d6000602084013e611b9f565b606091505b50925090508061083657604482511015611bb857600080fd5b60048201915081806020019051810190611ab89190615433565b600080600083604001511415611ca357600190506000611bf584600001516133f4565b50506040517f70a0823100000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff8216906370a0823190611c4c903090600401615a3c565b60206040518083038186803b158015611c6457600080fd5b505afa158015611c78573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c9c91906157d3565b6040850152505b600081611cb05733611cb2565b305b90505b6000611cc48560000151613425565b9050611d1d856040015182611cdd578660200151611cdf565b305b60006040518060400160405280611cf98b6000015161342d565b81526020018773ffffffffffffffffffffffffffffffffffffffff168152506125de565b60408601528015611d3d578451309250611d369061343c565b8552611d4a565b8460400151935050611d50565b50611cb5565b8360600151831015611d8e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161082d90615c7d565b5050919050565b604080517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523360048201523060248201529051869173ffffffffffffffffffffffffffffffffffffffff89169163dd62ed3e91604480820192602092909190829003018186803b158015611e0a57600080fd5b505afa158015611e1e573d6000803e3d6000fd5b505050506040513d6020811015611e3457600080fd5b50511015610bb657610bb6868686868686612402565b7f000000000000000000000000000000000000000000000000000000000000000081565b61146a83338484611691565b6000818373ffffffffffffffffffffffffffffffffffffffff1663dd62ed3e307f00000000000000000000000000000000000000000000000000000000000000006040518363ffffffff1660e01b8152600401611ed8929190615a5d565b60206040518083038186803b158015611ef057600080fd5b505afa158015611f04573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f2891906157d3565b10611f3557506000612021565b611f5f837fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff613280565b15611f6c57506001612021565b611f96837ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe613280565b15611fa357506002612021565b611fae836000613280565b611fb757600080fd5b611fe1837fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff613280565b15611fee57506003612021565b612018837ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe613280565b1561034f575060045b92915050565b60008373ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561209057600080fd5b505afa1580156120a4573d6000803e3d6000fd5b505050506040513d60208110156120ba57600080fd5b505190508281101561212d57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f496e73756666696369656e7420746f6b656e0000000000000000000000000000604482015290519081900360640190fd5b8015610c5557610c55848383613471565b60008211801561214f575060648211155b61215857600080fd5b60008573ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b1580156121c157600080fd5b505afa1580156121d5573d6000803e3d6000fd5b505050506040513d60208110156121eb57600080fd5b505190508481101561225e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f496e73756666696369656e7420746f6b656e0000000000000000000000000000604482015290519081900360640190fd5b8015610bb657600061271061227383866133d0565b8161227a57fe5b049050801561228e5761228e878483613471565b61229b8786838503613471565b50505050505050565b6122af828233612027565b5050565b6000806122c1868685613646565b915091508362ffffff1681830312610bb6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161082d90615c46565b6060610b2063219f5d1760e01b6040518060c001604052808560400135815260200161233d866000016020810190610a059190614feb565b8152602001612358866020016020810190610a059190614feb565b815260200185606001358152602001856080013581526020017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff815250604051602401610a9e9190615cb4565b6000806123b28584613859565b915091508362ffffff16818303126118a0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161082d90615c46565b6122af82333084613ae1565b604080517fd505accf000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018790526064810186905260ff8516608482015260a4810184905260c48101839052905173ffffffffffffffffffffffffffffffffffffffff88169163d505accf9160e480830192600092919082900301818387803b158015610ed557600080fd5b60008413806124a95750600083135b6124b257600080fd5b60006124c08284018461564a565b905060008060006124d484600001516133f4565b9250925092506125067f0000000000000000000000000000000000000000000000000000000000000000848484613cbe565b5060008060008a13612547578473ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161089612578565b8373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16108a5b915091508115612597576125928587602001513384612d8d565b610ee9565b85516125a290613425565b156125c75785516125b29061343c565b86526125c1813360008961278f565b50610ee9565b80600081905550610ee98487602001513384612d8d565b600073ffffffffffffffffffffffffffffffffffffffff8416600114156126075733935061262a565b73ffffffffffffffffffffffffffffffffffffffff84166002141561262a573093505b600080600061263c85600001516133f4565b9194509250905073ffffffffffffffffffffffffffffffffffffffff8083169084161060008061266d868686613cd4565b73ffffffffffffffffffffffffffffffffffffffff1663128acb088b856126938f613d12565b73ffffffffffffffffffffffffffffffffffffffff8e16156126b5578d6126db565b876126d45773fffd8963efd1fc6a506488495d951d5263988d256126db565b6401000276a45b8d6040516020016126ec9190615da6565b6040516020818303038152906040526040518663ffffffff1660e01b815260040161271b959493929190615a84565b6040805180830381600087803b15801561273457600080fd5b505af1158015612748573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061276c9190615395565b915091508261277b578161277d565b805b6000039b9a5050505050505050505050565b600073ffffffffffffffffffffffffffffffffffffffff8416600114156127b8573393506127db565b73ffffffffffffffffffffffffffffffffffffffff8416600214156127db573093505b60008060006127ed85600001516133f4565b9194509250905073ffffffffffffffffffffffffffffffffffffffff8084169083161060008061281e858786613cd4565b73ffffffffffffffffffffffffffffffffffffffff1663128acb088b856128448f613d12565b60000373ffffffffffffffffffffffffffffffffffffffff8e1615612869578d61288f565b876128885773fffd8963efd1fc6a506488495d951d5263988d2561288f565b6401000276a45b8d6040516020016128a09190615da6565b6040516020818303038152906040526040518663ffffffff1660e01b81526004016128cf959493929190615a84565b6040805180830381600087803b1580156128e857600080fd5b505af11580156128fc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129209190615395565b9150915060008361293557818360000361293b565b82826000035b909850905073ffffffffffffffffffffffffffffffffffffffff8a16612967578b811461296757600080fd5b50505050505050949350505050565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815260009073ffffffffffffffffffffffffffffffffffffffff8316906370a08231906129cb903090600401615a3c565b60206040518083038186803b1580156129e357600080fd5b505afa1580156129f7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b2091906157d3565b6040805160008082526020820190925273ffffffffffffffffffffffffffffffffffffffff84169083906040518082805190602001908083835b60208310612a9257805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09092019160209182019101612a55565b6001836020036101000a03801982511681845116808217855250505050505090500191505060006040518083038185875af1925050503d8060008114612af4576040519150601f19603f3d011682016040523d82523d6000602084013e612af9565b606091505b505090508061146a57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600360248201527f5354450000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6060600282511015612b7a57600080fd5b815167ffffffffffffffff81118015612b9257600080fd5b50604051908082528060200260200182016040528015612bbc578160200160208202803683370190505b5090508281600183510381518110612bd057fe5b602090810291909101015281517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff015b8015610c4057600080612c3d87866001860381518110612c1c57fe5b6020026020010151878681518110612c3057fe5b6020026020010151613d44565b91509150612c5f848481518110612c5057fe5b60200260200101518383613e2c565b846001850381518110612c6e57fe5b602090810291909101015250507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01612c00565b6000806000612cb18585613f02565b604080517fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606094851b811660208084019190915293851b81166034830152825160288184030181526048830184528051908501207fff0000000000000000000000000000000000000000000000000000000000000060688401529a90941b9093166069840152607d8301989098527f96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f609d808401919091528851808403909101815260bd909201909752805196019590952095945050505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16148015612de85750804710155b15612f31577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b158015612e5557600080fd5b505af1158015612e69573d6000803e3d6000fd5b50505050507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a9059cbb83836040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b158015612eff57600080fd5b505af1158015612f13573d6000803e3d6000fd5b505050506040513d6020811015612f2957600080fd5b50610c559050565b73ffffffffffffffffffffffffffffffffffffffff8316301415612f5f57612f5a848383613471565b610c55565b610c5584848484613ae1565b60005b600183510381101561146a57600080848381518110612f8957fe5b6020026020010151858460010181518110612fa057fe5b6020026020010151915091506000612fb88383613f02565b5090506000612fe87f00000000000000000000000000000000000000000000000000000000000000008585612ca2565b90506000806000808473ffffffffffffffffffffffffffffffffffffffff16630902f1ac6040518163ffffffff1660e01b815260040160606040518083038186803b15801561303657600080fd5b505afa15801561304a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061306e91906156da565b506dffffffffffffffffffffffffffff1691506dffffffffffffffffffffffffffff1691506000808773ffffffffffffffffffffffffffffffffffffffff168a73ffffffffffffffffffffffffffffffffffffffff16146130d05782846130d3565b83835b91509150613114828b73ffffffffffffffffffffffffffffffffffffffff166370a082318a6040518263ffffffff1660e01b815260040161120c9190615a3c565b9550613121868383613fa7565b9450505050506000808573ffffffffffffffffffffffffffffffffffffffff168873ffffffffffffffffffffffffffffffffffffffff161461316557826000613169565b6000835b91509150600060028c51038a10613180578a6131c1565b6131c17f0000000000000000000000000000000000000000000000000000000000000000898e8d600201815181106131b457fe5b6020026020010151612ca2565b604080516000815260208101918290527f022c0d9f0000000000000000000000000000000000000000000000000000000090915290915073ffffffffffffffffffffffffffffffffffffffff87169063022c0d9f906132299086908690869060248101615e06565b600060405180830381600087803b15801561324357600080fd5b505af1158015613257573d6000803e3d6000fd5b50506001909b019a50612f6e9950505050505050505050565b8082038281111561202157600080fd5b60008060008473ffffffffffffffffffffffffffffffffffffffff1663095ea7b360e01b7f0000000000000000000000000000000000000000000000000000000000000000866040516024016132d7929190615ad6565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009094169390931790925290516133609190615a20565b6000604051808303816000865af19150503d806000811461339d576040519150601f19603f3d011682016040523d82523d6000602084013e6133a2565b606091505b5091509150818015610e2c575080511580610e2c575080806020019051810190610e2c919061528d565b4290565b60008215806133eb575050818102818382816133e857fe5b04145b61202157600080fd5b60008080613402848261407d565b925061340f84601461417d565b905061341c84601761407d565b91509193909250565b516042111590565b6060610b20826000602b61426d565b8051606090610b209083906017907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe90161426d565b6040805173ffffffffffffffffffffffffffffffffffffffff8481166024830152604480830185905283518084039091018152606490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb000000000000000000000000000000000000000000000000000000001781529251825160009485949389169392918291908083835b6020831061354657805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09092019160209182019101613509565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d80600081146135a8576040519150601f19603f3d011682016040523d82523d6000602084013e6135ad565b606091505b50915091508180156135db5750805115806135db57508080602001905160208110156135d857600080fd5b50515b6118a057604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600260248201527f5354000000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b600080835185511461365757600080fd5b6000855167ffffffffffffffff8111801561367157600080fd5b506040519080825280602002602001820160405280156136ab57816020015b613698614e34565b8152602001906001900390816136905790505b5090506000865167ffffffffffffffff811180156136c857600080fd5b5060405190808252806020026020018201604052801561370257816020015b6136ef614e34565b8152602001906001900390816136e75790505b50905060005b8751811015613832576000806137318a848151811061372357fe5b602002602001015189613859565b9150915061373e82614454565b85848151811061374a57fe5b60200260200101516000019060020b908160020b8152505061376b81614454565b84848151811061377757fe5b60200260200101516000019060020b908160020b8152505088838151811061379b57fe5b60200260200101518584815181106137af57fe5b6020026020010151602001906fffffffffffffffffffffffffffffffff1690816fffffffffffffffffffffffffffffffff16815250508883815181106137f157fe5b602002602001015184848151811061380557fe5b6020908102919091018101516fffffffffffffffffffffffffffffffff9092169101525050600101613708565b5061383c82614465565b60020b935061384a81614465565b60020b92505050935093915050565b6000806000806138688661454d565b90506000805b82811015613a865760008060006138848b6133f4565b9250925092506000613897848484613cd4565b905060008063ffffffff8d166138c0576138b083614578565b600291820b9350900b9050613962565b6138ca838e614810565b8160020b915050809250508273ffffffffffffffffffffffffffffffffffffffff16633850c7bd6040518163ffffffff1660e01b815260040160e06040518083038186803b15801561391b57600080fd5b505afa15801561392f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906139539190615715565b50505060029290920b93505050505b600189038714156139a3578473ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff161099506139b2565b6139ac8e61343c565b9d508597505b6000871580613a5357508673ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff1610613a23578673ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff1610613a53565b8573ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff16105b90508015613a68579b82019b9a81019a613a73565b828d039c50818c039b505b50506001909501945061386e9350505050565b5082613ad7577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff850294507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff840293505b5050509250929050565b6040805173ffffffffffffffffffffffffffffffffffffffff85811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f23b872dd00000000000000000000000000000000000000000000000000000000178152925182516000948594938a169392918291908083835b60208310613bbe57805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09092019160209182019101613b81565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114613c20576040519150601f19603f3d011682016040523d82523d6000602084013e613c25565b606091505b5091509150818015613c53575080511580613c535750808060200190516020811015613c5057600080fd5b50515b610bb657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600360248201527f5354460000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6000610e2c85613ccf868686614c41565b614cbe565b6000613d0a7f0000000000000000000000000000000000000000000000000000000000000000613d05868686614c41565b614cee565b949350505050565b60007f80000000000000000000000000000000000000000000000000000000000000008210613d4057600080fd5b5090565b6000806000613d538585613f02565b509050600080613d64888888612ca2565b73ffffffffffffffffffffffffffffffffffffffff16630902f1ac6040518163ffffffff1660e01b815260040160606040518083038186803b158015613da957600080fd5b505afa158015613dbd573d6000803e3d6000fd5b505050506040513d6060811015613dd357600080fd5b5080516020909101516dffffffffffffffffffffffffffff918216935016905073ffffffffffffffffffffffffffffffffffffffff87811690841614613e1a578082613e1d565b81815b90999098509650505050505050565b6000808411613e9c57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f494e53554646494349454e545f4f55545055545f414d4f554e54000000000000604482015290519081900360640190fd5b600083118015613eac5750600082115b613eb557600080fd5b6000613ecd6103e8613ec786886133d0565b906133d0565b90506000613ee16103e5613ec78689613270565b9050613ef86001828481613ef157fe5b0490614e24565b9695505050505050565b6000808273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161415613f3e57600080fd5b8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1610613f78578284613f7b565b83835b909250905073ffffffffffffffffffffffffffffffffffffffff8216613fa057600080fd5b9250929050565b600080841161401757604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f494e53554646494349454e545f494e5055545f414d4f554e5400000000000000604482015290519081900360640190fd5b6000831180156140275750600082115b61403057600080fd5b600061403e856103e56133d0565b9050600061404c82856133d0565b9050600061406683614060886103e86133d0565b90614e24565b905080828161407157fe5b04979650505050505050565b6000818260140110156140f157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f746f416464726573735f6f766572666c6f770000000000000000000000000000604482015290519081900360640190fd5b816014018351101561416457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f746f416464726573735f6f75744f66426f756e64730000000000000000000000604482015290519081900360640190fd5b5001602001516c01000000000000000000000000900490565b6000818260030110156141f157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f746f55696e7432345f6f766572666c6f77000000000000000000000000000000604482015290519081900360640190fd5b816003018351101561426457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f746f55696e7432345f6f75744f66426f756e6473000000000000000000000000604482015290519081900360640190fd5b50016003015190565b60608182601f0110156142e157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b82828401101561435257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b818301845110156143c457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f736c6963655f6f75744f66426f756e6473000000000000000000000000000000604482015290519081900360640190fd5b6060821580156143e3576040519150600082526020820160405261444b565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561441c578051835260209283019201614404565b5050858452601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016604052505b50949350505050565b80600281900b8114610b2357600080fd5b6000806000805b84518110156144fa5784818151811061448157fe5b6020026020010151602001516fffffffffffffffffffffffffffffffff168582815181106144ab57fe5b60200260200101516000015160020b02830192508481815181106144cb57fe5b6020026020010151602001516fffffffffffffffffffffffffffffffff1682019150808060010191505061446c565b5080828161450457fe5b05925060008212801561451f575080828161451b57fe5b0715155b15611d8e5750507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01919050565b5160177fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec9091010490565b6000806000808473ffffffffffffffffffffffffffffffffffffffff16633850c7bd6040518163ffffffff1660e01b815260040160e06040518083038186803b1580156145c457600080fd5b505afa1580156145d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906145fc9190615715565b50939750919550935050600161ffff84161191506146489050576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161082d90615bd8565b6000808673ffffffffffffffffffffffffffffffffffffffff1663252c09d7856040518263ffffffff1660e01b81526004016146849190615dee565b60806040518083038186803b15801561469c57600080fd5b505afa1580156146b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906146d491906158e0565b5050915091506146e26133cc565b63ffffffff168263ffffffff16146146fc57849550614807565b60008361ffff1660018561ffff168761ffff1601038161471857fe5b06905060008060008a73ffffffffffffffffffffffffffffffffffffffff1663252c09d7856040518263ffffffff1660e01b81526004016147599190615dfd565b60806040518083038186803b15801561477157600080fd5b505afa158015614785573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906147a991906158e0565b93505092509250806147e7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161082d90615ba1565b82860363ffffffff811683870360060b816147fe57fe5b059a5050505050505b50505050915091565b60008063ffffffff831661488557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600260248201527f4250000000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b60408051600280825260608201835260009260208301908036833701905050905083816000815181106148b457fe5b602002602001019063ffffffff16908163ffffffff16815250506000816001815181106148dd57fe5b63ffffffff9092166020928302919091018201526040517f883bdbfd00000000000000000000000000000000000000000000000000000000815260048101828152835160248301528351600093849373ffffffffffffffffffffffffffffffffffffffff8b169363883bdbfd9388939192839260449091019185820191028083838b5b83811015614978578181015183820152602001614960565b505050509050019250505060006040518083038186803b15801561499b57600080fd5b505afa1580156149af573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160409081528110156149f657600080fd5b8101908080516040519392919084640100000000821115614a1657600080fd5b908301906020820185811115614a2b57600080fd5b8251866020820283011164010000000082111715614a4857600080fd5b82525081516020918201928201910280838360005b83811015614a75578181015183820152602001614a5d565b5050505090500160405260200180516040519392919084640100000000821115614a9e57600080fd5b908301906020820185811115614ab357600080fd5b8251866020820283011164010000000082111715614ad057600080fd5b82525081516020918201928201910280838360005b83811015614afd578181015183820152602001614ae5565b5050505090500160405250505091509150600082600081518110614b1d57fe5b602002602001015183600181518110614b3257fe5b6020026020010151039050600082600081518110614b4c57fe5b602002602001015183600181518110614b6157fe5b60200260200101510390508763ffffffff168260060b81614b7e57fe5b05965060008260060b128015614ba857508763ffffffff168260060b81614ba157fe5b0760060b15155b15614bd3577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff909601955b63ffffffff881673ffffffffffffffffffffffffffffffffffffffff0277ffffffffffffffffffffffffffffffffffffffff00000000602083901b1677ffffffffffffffffffffffffffffffffffffffffffffffff821681614c3157fe5b0496505050505050509250929050565b614c49614e4b565b8273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161115614c81579192915b506040805160608101825273ffffffffffffffffffffffffffffffffffffffff948516815292909316602083015262ffffff169181019190915290565b6000614cca8383614cee565b90503373ffffffffffffffffffffffffffffffffffffffff82161461202157600080fd5b6000816020015173ffffffffffffffffffffffffffffffffffffffff16826000015173ffffffffffffffffffffffffffffffffffffffff1610614d3057600080fd5b508051602080830151604093840151845173ffffffffffffffffffffffffffffffffffffffff94851681850152939091168385015262ffffff166060808401919091528351808403820181526080840185528051908301207fff0000000000000000000000000000000000000000000000000000000000000060a085015294901b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000001660a183015260b58201939093527fe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b5460d5808301919091528251808303909101815260f5909101909152805191012090565b8082018281101561202157600080fd5b604080518082019091526000808252602082015290565b604080516060810182526000808252602082018190529181019190915290565b8035610b2381615f52565b60008083601f840112614e87578182fd5b50813567ffffffffffffffff811115614e9e578182fd5b6020830191508360208083028501011115613fa057600080fd5b600082601f830112614ec8578081fd5b81356020614edd614ed883615ec8565b615ea4565b8281528181019085830183850287018401881015614ef9578586fd5b855b85811015614f345781356fffffffffffffffffffffffffffffffff81168114614f22578788fd5b84529284019290840190600101614efb565b5090979650505050505050565b80518015158114610b2357600080fd5b600082601f830112614f61578081fd5b8135614f6f614ed882615ee6565b818152846020838601011115614f83578283fd5b816020850160208301379081016020019190915292915050565b80516dffffffffffffffffffffffffffff81168114610b2357600080fd5b805161ffff81168114610b2357600080fd5b803562ffffff81168114610b2357600080fd5b8035610b2381615f83565b600060208284031215614ffc578081fd5b813561500781615f52565b9392505050565b60008060408385031215615020578081fd5b823561502b81615f52565b946020939093013593505050565b60008060006060848603121561504d578081fd5b833561505881615f52565b925060208401359150604084013561506f81615f52565b809150509250925092565b600080600080600060a08688031215615091578283fd5b853561509c81615f52565b94506020860135935060408601356150b381615f52565b92506060860135915060808601356150ca81615f52565b809150509295509295909350565b600080600080608085870312156150ed578182fd5b84356150f881615f52565b93506020850135925060408501359150606085013561511681615f52565b939692955090935050565b60008060008060008060c08789031215615139578384fd5b863561514481615f52565b95506020870135945060408701359350606087013561516281615f95565b9598949750929560808101359460a0909101359350915050565b6000806020838503121561518e578182fd5b823567ffffffffffffffff8111156151a4578283fd5b6151b085828601614e76565b90969095509350505050565b600080600080608085870312156151d1578182fd5b843567ffffffffffffffff808211156151e8578384fd5b818701915087601f8301126151fb578384fd5b8135602061520b614ed883615ec8565b82815281810190858301885b858110156152405761522e8e8684358b0101614f51565b84529284019290840190600101615217565b50909950505088013592505080821115615258578384fd5b5061526587828801614eb8565b93505061527460408601614fcd565b915061528260608601614fe0565b905092959194509250565b60006020828403121561529e578081fd5b61500782614f41565b6000806000604084860312156152bb578081fd5b83359250602084013567ffffffffffffffff8111156152d8578182fd5b6152e486828701614e76565b9497909650939450505050565b600060208284031215615302578081fd5b813567ffffffffffffffff811115615318578182fd5b613d0a84828501614f51565b600080600060608486031215615338578081fd5b833567ffffffffffffffff81111561534e578182fd5b61535a86828701614f51565b93505061536960208501614fcd565b9150604084013561506f81615f83565b60006020828403121561538a578081fd5b813561500781615f74565b600080604083850312156153a7578182fd5b505080516020909101519092909150565b600080600080606085870312156153cd578182fd5b8435935060208501359250604085013567ffffffffffffffff808211156153f2578384fd5b818701915087601f830112615405578384fd5b813581811115615413578485fd5b886020828501011115615424578485fd5b95989497505060200194505050565b600060208284031215615444578081fd5b815167ffffffffffffffff81111561545a578182fd5b8201601f8101841361546a578182fd5b8051615478614ed882615ee6565b81815285602083850101111561548c578384fd5b610e2c826020830160208601615f26565b6000602082840312156154ae578081fd5b813567ffffffffffffffff808211156154c5578283fd5b90830190608082860312156154d8578283fd5b6040516080810181811083821117156154ed57fe5b6040528235828111156154fe578485fd5b61550a87828601614f51565b8252506020830135915061551d82615f52565b816020820152604083013560408201526060830135606082015280935050505092915050565b600060e08284031215615554578081fd5b60405160e0810181811067ffffffffffffffff8211171561557157fe5b60405261557d83614e6b565b815261558b60208401614e6b565b602082015261559c60408401614fcd565b60408201526155ad60608401614e6b565b60608201526080830135608082015260a083013560a08201526155d260c08401614e6b565b60c08201529392505050565b6000602082840312156155ef578081fd5b813567ffffffffffffffff811115615605578182fd5b820160808185031215615007578182fd5b600060e08284031215610836578081fd5b600060a08284031215610836578081fd5b60006101008284031215610836578081fd5b60006020828403121561565b578081fd5b813567ffffffffffffffff80821115615672578283fd5b9083019060408286031215615685578283fd5b60405160408101818110838211171561569a57fe5b6040528235828111156156ab578485fd5b6156b787828601614f51565b825250602083013592506156ca83615f52565b6020810192909252509392505050565b6000806000606084860312156156ee578081fd5b6156f784614f9d565b925061570560208501614f9d565b9150604084015161506f81615f83565b600080600080600080600060e0888a03121561572f578485fd5b875161573a81615f52565b602089015190975061574b81615f74565b955061575960408901614fbb565b945061576760608901614fbb565b935061577560808901614fbb565b925060a088015161578581615f95565b915061579360c08901614f41565b905092959891949750929550565b6000602082840312156157b2578081fd5b61500782614fcd565b6000602082840312156157cc578081fd5b5035919050565b6000602082840312156157e4578081fd5b5051919050565b600080604083850312156157fd578182fd5b82359150602083013561580f81615f52565b809150509250929050565b6000806000806080858703121561582f578182fd5b84359350602085013561584181615f52565b925060408501359150606085013561511681615f52565b60008060006060848603121561586c578081fd5b8335925060208401359150604084013561506f81615f52565b60008060008060006080868803121561589c578283fd5b8535945060208601359350604086013567ffffffffffffffff8111156158c0578384fd5b6158cc88828901614e76565b90945092505060608601356150ca81615f52565b600080600080608085870312156158f5578182fd5b845161590081615f83565b8094505060208501518060060b8114615917578283fd5b604086015190935061592881615f52565b915061528260608601614f41565b73ffffffffffffffffffffffffffffffffffffffff169052565b60008151808452615968816020860160208601615f26565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b60020b9052565b62ffffff169052565b606093841b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000908116825260e89390931b7fffffff0000000000000000000000000000000000000000000000000000000000166014820152921b166017820152602b0190565b6000828483379101908152919050565b60008251615a32818460208701615f26565b9190910192915050565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b73ffffffffffffffffffffffffffffffffffffffff92831681529116602082015260400190565b600073ffffffffffffffffffffffffffffffffffffffff8088168352861515602084015285604084015280851660608401525060a06080830152615acb60a0830184615950565b979650505050505050565b73ffffffffffffffffffffffffffffffffffffffff929092168252602082015260400190565b6000602080830181845280855180835260408601915060408482028701019250838701855b82811015615b6d577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0888603018452615b5b858351615950565b94509285019290850190600101615b21565b5092979650505050505050565b6000602082526150076020830184615950565b6020810160058310615b9b57fe5b91905290565b60208082526003908201527f4f4e490000000000000000000000000000000000000000000000000000000000604082015260600190565b60208082526003908201527f4e454f0000000000000000000000000000000000000000000000000000000000604082015260600190565b60208082526012908201527f546f6f206d756368207265717565737465640000000000000000000000000000604082015260600190565b60208082526002908201527f5444000000000000000000000000000000000000000000000000000000000000604082015260600190565b60208082526013908201527f546f6f206c6974746c6520726563656976656400000000000000000000000000604082015260600190565b600060c082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015292915050565b600061016082019050615d0c828451615936565b6020830151615d1e6020840182615936565b506040830151615d3160408401826159a1565b506060830151615d44606084018261599a565b506080830151615d57608084018261599a565b5060a083015160a083015260c083015160c083015260e083015160e083015261010080840151818401525061012080840151615d9582850182615936565b505061014092830151919092015290565b600060208252825160406020840152615dc26060840182615950565b905073ffffffffffffffffffffffffffffffffffffffff60208501511660408401528091505092915050565b61ffff91909116815260200190565b90815260200190565b600085825284602083015273ffffffffffffffffffffffffffffffffffffffff8416604083015260806060830152613ef86080830184615950565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112615e75578283fd5b83018035915067ffffffffffffffff821115615e8f578283fd5b602001915036819003821315613fa057600080fd5b60405181810167ffffffffffffffff81118282101715615ec057fe5b604052919050565b600067ffffffffffffffff821115615edc57fe5b5060209081020190565b600067ffffffffffffffff821115615efa57fe5b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b60005b83811015615f41578181015183820152602001615f29565b83811115610c555750506000910152565b73ffffffffffffffffffffffffffffffffffffffff8116811461147957600080fd5b8060020b811461147957600080fd5b63ffffffff8116811461147957600080fd5b60ff8116811461147957600080fdfea164736f6c6343000706000a";
class SwapRouter02__factory extends ContractFactory {
  constructor(signer) {
    super(_abi$6, _bytecode, signer);
  }
  deploy(_factoryV2, factoryV3, _positionManager, _WETH9, overrides) {
    return super.deploy(_factoryV2, factoryV3, _positionManager, _WETH9, overrides || {});
  }
  getDeployTransaction(_factoryV2, factoryV3, _positionManager, _WETH9, overrides) {
    return super.getDeployTransaction(_factoryV2, factoryV3, _positionManager, _WETH9, overrides || {});
  }
  attach(address) {
    return super.attach(address);
  }
  connect(signer) {
    return super.connect(signer);
  }
  static createInterface() {
    return new Interface(_abi$6);
  }
  static connect(address, signerOrProvider) {
    return new Contract(address, _abi$6, signerOrProvider);
  }
}
SwapRouter02__factory.bytecode = _bytecode;
SwapRouter02__factory.abi = _abi$6;
class SwapRouterProvider {
  constructor(multicall2Provider) {
    this.multicall2Provider = multicall2Provider;
  }
  async getApprovalType(tokenInAmount, tokenOutAmount) {
    var _a, _b;
    const functionParams = [
      [
        tokenInAmount.currency.wrapped.address,
        tokenInAmount.quotient.toString()
      ],
      [
        tokenOutAmount.currency.wrapped.address,
        tokenOutAmount.quotient.toString()
      ]
    ];
    const tx = await this.multicall2Provider.callSameFunctionOnContractWithMultipleParams({
      address: SWAP_ROUTER_ADDRESS,
      contractInterface: SwapRouter02__factory.createInterface(),
      functionName: "getApprovalType",
      functionParams
    });
    if (!((_a = tx.results[0]) === null || _a === void 0 ? void 0 : _a.success) || !((_b = tx.results[1]) === null || _b === void 0 ? void 0 : _b.success)) {
      log.info({ results: tx.results }, "Failed to get approval type from swap router for token in or token out");
      throw new Error("Failed to get approval type from swap router for token in or token out");
    }
    const { result: approvalTokenIn } = tx.results[0];
    const { result: approvalTokenOut } = tx.results[1];
    return {
      approvalTokenIn: approvalTokenIn[0],
      approvalTokenOut: approvalTokenOut[0]
    };
  }
}
const _abi$5 = [
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_spender",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        name: "balance",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      },
      {
        name: "_spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    payable: true,
    stateMutability: "payable",
    type: "fallback"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  }
];
class Erc20__factory {
  static createInterface() {
    return new Interface(_abi$5);
  }
  static connect(address, signerOrProvider) {
    return new Contract(address, _abi$5, signerOrProvider);
  }
}
Erc20__factory.abi = _abi$5;
const name = "Uniswap Labs List";
const timestamp = "2021-12-21T23:59:15.901Z";
const version$2 = {
  major: 2,
  minor: 3,
  patch: 0
};
const tags = {};
const logoURI = "ipfs://QmNa8mQkrNKp1WEEeGjFezDmDeodkWRevGFN8JCV7b4Xir";
const keywords = [
  "uniswap",
  "default"
];
const tokens = [
  {
    chainId: 1,
    address: "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9",
    name: "Aave",
    symbol: "AAVE",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/12645/thumb/AAVE.png?1601374110"
  },
  {
    chainId: 1,
    address: "0xfF20817765cB7f73d4bde2e66e067E58D11095C2",
    name: "Amp",
    symbol: "AMP",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/12409/thumb/amp-200x200.png?1599625397"
  },
  {
    name: "Aragon Network Token",
    address: "0x960b236A07cf122663c4303350609A66A7B288C0",
    symbol: "ANT",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x960b236A07cf122663c4303350609A66A7B288C0/logo.png"
  },
  {
    name: "Balancer",
    address: "0xba100000625a3754423978a60c9317c58a424e3D",
    symbol: "BAL",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xba100000625a3754423978a60c9317c58a424e3D/logo.png"
  },
  {
    chainId: 1,
    address: "0xBA11D00c5f74255f56a5E366F4F77f5A186d7f55",
    name: "Band Protocol",
    symbol: "BAND",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/9545/thumb/band-protocol.png?1568730326"
  },
  {
    name: "Bancor Network Token",
    address: "0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C",
    symbol: "BNT",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C/logo.png"
  },
  {
    name: "Compound",
    address: "0xc00e94Cb662C3520282E6f5717214004A7f26888",
    symbol: "COMP",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xc00e94Cb662C3520282E6f5717214004A7f26888/logo.png"
  },
  {
    name: "Curve DAO Token",
    address: "0xD533a949740bb3306d119CC777fa900bA034cd52",
    symbol: "CRV",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xD533a949740bb3306d119CC777fa900bA034cd52/logo.png"
  },
  {
    chainId: 1,
    address: "0x41e5560054824eA6B0732E656E3Ad64E20e94E45",
    name: "Civic",
    symbol: "CVC",
    decimals: 8,
    logoURI: "https://assets.coingecko.com/coins/images/788/thumb/civic.png?1547034556"
  },
  {
    name: "Dai Stablecoin",
    address: "0x6B175474E89094C44Da98b954EedeAC495271d0F",
    symbol: "DAI",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6B175474E89094C44Da98b954EedeAC495271d0F/logo.png"
  },
  {
    chainId: 1,
    address: "0x0AbdAce70D3790235af448C88547603b945604ea",
    name: "district0x",
    symbol: "DNT",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/849/thumb/district0x.png?1547223762"
  },
  {
    chainId: 1,
    address: "0xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72",
    name: "Ethereum Name Service",
    symbol: "ENS",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/19785/thumb/acatxTm8_400x400.jpg?1635850140"
  },
  {
    name: "Gnosis Token",
    address: "0x6810e776880C02933D47DB1b9fc05908e5386b96",
    symbol: "GNO",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6810e776880C02933D47DB1b9fc05908e5386b96/logo.png"
  },
  {
    chainId: 1,
    address: "0xc944E90C64B2c07662A292be6244BDf05Cda44a7",
    name: "The Graph",
    symbol: "GRT",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/13397/thumb/Graph_Token.png?1608145566"
  },
  {
    chainId: 1,
    address: "0x85Eee30c52B0b379b046Fb0F85F4f3Dc3009aFEC",
    name: "Keep Network",
    symbol: "KEEP",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/3373/thumb/IuNzUb5b_400x400.jpg?1589526336"
  },
  {
    name: "Kyber Network Crystal",
    address: "0xdd974D5C2e2928deA5F71b9825b8b646686BD200",
    symbol: "KNC",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xdd974D5C2e2928deA5F71b9825b8b646686BD200/logo.png"
  },
  {
    name: "ChainLink Token",
    address: "0x514910771AF9Ca656af840dff83E8264EcF986CA",
    symbol: "LINK",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x514910771AF9Ca656af840dff83E8264EcF986CA/logo.png"
  },
  {
    name: "Loom Network",
    address: "0xA4e8C3Ec456107eA67d3075bF9e3DF3A75823DB0",
    symbol: "LOOM",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA4e8C3Ec456107eA67d3075bF9e3DF3A75823DB0/logo.png"
  },
  {
    name: "LoopringCoin V2",
    address: "0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD",
    symbol: "LRC",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD/logo.png"
  },
  {
    chainId: 1,
    address: "0x0F5D2fB29fb7d3CFeE444a200298f468908cC942",
    name: "Decentraland",
    symbol: "MANA",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/878/thumb/decentraland-mana.png?1550108745"
  },
  {
    chainId: 1,
    address: "0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0",
    name: "Polygon",
    symbol: "MATIC",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/4713/thumb/matic-token-icon.png?1624446912"
  },
  {
    name: "Maker",
    address: "0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2",
    symbol: "MKR",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2/logo.png"
  },
  {
    chainId: 1,
    address: "0xec67005c4E498Ec7f55E092bd1d35cbC47C91892",
    name: "Melon",
    symbol: "MLN",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/605/thumb/melon.png?1547034295"
  },
  {
    name: "Numeraire",
    address: "0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671",
    symbol: "NMR",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671/logo.png"
  },
  {
    chainId: 1,
    address: "0x4fE83213D56308330EC302a8BD641f1d0113A4Cc",
    name: "NuCypher",
    symbol: "NU",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/3318/thumb/photo1198982838879365035.jpg?1547037916"
  },
  {
    name: "Orchid",
    address: "0x4575f41308EC1483f3d399aa9a2826d74Da13Deb",
    symbol: "OXT",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x4575f41308EC1483f3d399aa9a2826d74Da13Deb/logo.png"
  },
  {
    name: "Republic Token",
    address: "0x408e41876cCCDC0F92210600ef50372656052a38",
    symbol: "REN",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x408e41876cCCDC0F92210600ef50372656052a38/logo.png"
  },
  {
    name: "Reputation Augur v1",
    address: "0x1985365e9f78359a9B6AD760e32412f4a445E862",
    symbol: "REP",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x1985365e9f78359a9B6AD760e32412f4a445E862/logo.png"
  },
  {
    name: "Reputation Augur v2",
    address: "0x221657776846890989a759BA2973e427DfF5C9bB",
    symbol: "REPv2",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x221657776846890989a759BA2973e427DfF5C9bB/logo.png"
  },
  {
    name: "Synthetix Network Token",
    address: "0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F",
    symbol: "SNX",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F/logo.png"
  },
  {
    name: "Storj Token",
    address: "0xB64ef51C888972c908CFacf59B47C1AfBC0Ab8aC",
    symbol: "STORJ",
    decimals: 8,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xB64ef51C888972c908CFacf59B47C1AfBC0Ab8aC/logo.png"
  },
  {
    name: "Synth sUSD",
    address: "0x57Ab1ec28D129707052df4dF418D58a2D46d5f51",
    symbol: "sUSD",
    decimals: 18,
    chainId: 1,
    logoURI: "https://assets.coingecko.com/coins/images/5013/thumb/sUSD.png?1616150765"
  },
  {
    chainId: 1,
    address: "0x8dAEBADE922dF735c38C80C7eBD708Af50815fAa",
    name: "tBTC",
    symbol: "TBTC",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/11224/thumb/tBTC.png?1589620754"
  },
  {
    name: "UMA Voting Token v1",
    address: "0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828",
    symbol: "UMA",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828/logo.png"
  },
  {
    name: "Uniswap",
    address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984",
    symbol: "UNI",
    decimals: 18,
    chainId: 1,
    logoURI: "ipfs://QmXttGpZrECX5qCyXbBQiqgQNytVGeZW5Anewvh2jc4psg"
  },
  {
    name: "USDCoin",
    address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    symbol: "USDC",
    decimals: 6,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png"
  },
  {
    name: "Tether USD",
    address: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
    symbol: "USDT",
    decimals: 6,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xdAC17F958D2ee523a2206206994597C13D831ec7/logo.png"
  },
  {
    name: "Wrapped BTC",
    address: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599",
    symbol: "WBTC",
    decimals: 8,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599/logo.png"
  },
  {
    name: "Wrapped Ether",
    address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
    symbol: "WETH",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png"
  },
  {
    chainId: 1,
    address: "0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e",
    name: "yearn finance",
    symbol: "YFI",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/11849/thumb/yfi-192x192.png?1598325330"
  },
  {
    name: "0x Protocol Token",
    address: "0xE41d2489571d322189246DaFA5ebDe1F4699F498",
    symbol: "ZRX",
    decimals: 18,
    chainId: 1,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xE41d2489571d322189246DaFA5ebDe1F4699F498/logo.png"
  },
  {
    name: "Dai Stablecoin",
    address: "0xaD6D458402F60fD3Bd25163575031ACDce07538D",
    symbol: "DAI",
    decimals: 18,
    chainId: 3,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xaD6D458402F60fD3Bd25163575031ACDce07538D/logo.png"
  },
  {
    name: "Uniswap",
    address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984",
    symbol: "UNI",
    decimals: 18,
    chainId: 3,
    logoURI: "ipfs://QmXttGpZrECX5qCyXbBQiqgQNytVGeZW5Anewvh2jc4psg"
  },
  {
    name: "Wrapped Ether",
    address: "0xc778417E063141139Fce010982780140Aa0cD5Ab",
    symbol: "WETH",
    decimals: 18,
    chainId: 3,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xc778417E063141139Fce010982780140Aa0cD5Ab/logo.png"
  },
  {
    name: "Dai Stablecoin",
    address: "0xc7AD46e0b8a400Bb3C915120d284AafbA8fc4735",
    symbol: "DAI",
    decimals: 18,
    chainId: 4,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xc7AD46e0b8a400Bb3C915120d284AafbA8fc4735/logo.png"
  },
  {
    name: "Maker",
    address: "0xF9bA5210F91D0474bd1e1DcDAeC4C58E359AaD85",
    symbol: "MKR",
    decimals: 18,
    chainId: 4,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xF9bA5210F91D0474bd1e1DcDAeC4C58E359AaD85/logo.png"
  },
  {
    name: "Uniswap",
    address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984",
    symbol: "UNI",
    decimals: 18,
    chainId: 4,
    logoURI: "ipfs://QmXttGpZrECX5qCyXbBQiqgQNytVGeZW5Anewvh2jc4psg"
  },
  {
    name: "Wrapped Ether",
    address: "0xc778417E063141139Fce010982780140Aa0cD5Ab",
    symbol: "WETH",
    decimals: 18,
    chainId: 4,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xc778417E063141139Fce010982780140Aa0cD5Ab/logo.png"
  },
  {
    name: "Uniswap",
    address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984",
    symbol: "UNI",
    decimals: 18,
    chainId: 5,
    logoURI: "ipfs://QmXttGpZrECX5qCyXbBQiqgQNytVGeZW5Anewvh2jc4psg"
  },
  {
    name: "Wrapped Ether",
    address: "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6",
    symbol: "WETH",
    decimals: 18,
    chainId: 5,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6/logo.png"
  },
  {
    name: "Dai Stablecoin",
    address: "0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa",
    symbol: "DAI",
    decimals: 18,
    chainId: 42,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa/logo.png"
  },
  {
    name: "Maker",
    address: "0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD",
    symbol: "MKR",
    decimals: 18,
    chainId: 42,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD/logo.png"
  },
  {
    name: "Uniswap",
    address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984",
    symbol: "UNI",
    decimals: 18,
    chainId: 42,
    logoURI: "ipfs://QmXttGpZrECX5qCyXbBQiqgQNytVGeZW5Anewvh2jc4psg"
  },
  {
    name: "Wrapped Ether",
    address: "0xd0A1E359811322d97991E03f863a0C30C2cF029C",
    symbol: "WETH",
    decimals: 18,
    chainId: 42,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xd0A1E359811322d97991E03f863a0C30C2cF029C/logo.png"
  },
  {
    chainId: 137,
    address: "0xD6DF932A45C0f255f85145f286eA0b292B21C90B",
    name: "Aave",
    symbol: "AAVE",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/12645/thumb/AAVE.png?1601374110"
  },
  {
    chainId: 137,
    address: "0x0621d647cecbFb64b79E44302c1933cB4f27054d",
    name: "Amp",
    symbol: "AMP",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/12409/thumb/amp-200x200.png?1599625397"
  },
  {
    name: "Balancer",
    address: "0x9a71012B13CA4d3D0Cdc72A177DF3ef03b0E76A3",
    symbol: "BAL",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xba100000625a3754423978a60c9317c58a424e3D/logo.png"
  },
  {
    chainId: 137,
    address: "0xA8b1E0764f85f53dfe21760e8AfE5446D82606ac",
    name: "Band Protocol",
    symbol: "BAND",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/9545/thumb/band-protocol.png?1568730326"
  },
  {
    name: "Bancor Network Token",
    address: "0xc26D47d5c33aC71AC5CF9F776D63Ba292a4F7842",
    symbol: "BNT",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C/logo.png"
  },
  {
    name: "Compound",
    address: "0x8505b9d2254A7Ae468c0E9dd10Ccea3A837aef5c",
    symbol: "COMP",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xc00e94Cb662C3520282E6f5717214004A7f26888/logo.png"
  },
  {
    name: "Curve DAO Token",
    address: "0x172370d5Cd63279eFa6d502DAB29171933a610AF",
    symbol: "CRV",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xD533a949740bb3306d119CC777fa900bA034cd52/logo.png"
  },
  {
    chainId: 137,
    address: "0x66Dc5A08091d1968e08C16aA5b27BAC8398b02Be",
    name: "Civic",
    symbol: "CVC",
    decimals: 8,
    logoURI: "https://assets.coingecko.com/coins/images/788/thumb/civic.png?1547034556"
  },
  {
    name: "Dai Stablecoin",
    address: "0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063",
    symbol: "DAI",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6B175474E89094C44Da98b954EedeAC495271d0F/logo.png"
  },
  {
    chainId: 137,
    address: "0xbD7A5Cf51d22930B8B3Df6d834F9BCEf90EE7c4f",
    name: "Ethereum Name Service",
    symbol: "ENS",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/19785/thumb/acatxTm8_400x400.jpg?1635850140"
  },
  {
    name: "Gnosis Token",
    address: "0x5FFD62D3C3eE2E81C00A7b9079FB248e7dF024A8",
    symbol: "GNO",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6810e776880C02933D47DB1b9fc05908e5386b96/logo.png"
  },
  {
    chainId: 137,
    address: "0x5fe2B58c013d7601147DcdD68C143A77499f5531",
    name: "The Graph",
    symbol: "GRT",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/13397/thumb/Graph_Token.png?1608145566"
  },
  {
    chainId: 137,
    address: "0x42f37A1296b2981F7C3cAcEd84c5096b2Eb0C72C",
    name: "Keep Network",
    symbol: "KEEP",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/3373/thumb/IuNzUb5b_400x400.jpg?1589526336"
  },
  {
    name: "Kyber Network Crystal",
    address: "0x324b28d6565f784d596422B0F2E5aB6e9CFA1Dc7",
    symbol: "KNC",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xdd974D5C2e2928deA5F71b9825b8b646686BD200/logo.png"
  },
  {
    name: "ChainLink Token",
    address: "0x53E0bca35eC356BD5ddDFebbD1Fc0fD03FaBad39",
    symbol: "LINK",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x514910771AF9Ca656af840dff83E8264EcF986CA/logo.png"
  },
  {
    name: "Loom Network",
    address: "0x66EfB7cC647e0efab02eBA4316a2d2941193F6b3",
    symbol: "LOOM",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA4e8C3Ec456107eA67d3075bF9e3DF3A75823DB0/logo.png"
  },
  {
    name: "LoopringCoin V2",
    address: "0x84e1670F61347CDaeD56dcc736FB990fBB47ddC1",
    symbol: "LRC",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD/logo.png"
  },
  {
    chainId: 137,
    address: "0xA1c57f48F0Deb89f569dFbE6E2B7f46D33606fD4",
    name: "Decentraland",
    symbol: "MANA",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/878/thumb/decentraland-mana.png?1550108745"
  },
  {
    name: "Maker",
    address: "0x6f7C932e7684666C9fd1d44527765433e01fF61d",
    symbol: "MKR",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2/logo.png"
  },
  {
    name: "Numeraire",
    address: "0x0Bf519071b02F22C17E7Ed5F4002ee1911f46729",
    symbol: "NMR",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671/logo.png"
  },
  {
    name: "Orchid",
    address: "0x9880e3dDA13c8e7D4804691A45160102d31F6060",
    symbol: "OXT",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x4575f41308EC1483f3d399aa9a2826d74Da13Deb/logo.png"
  },
  {
    name: "Republic Token",
    address: "0x19782D3Dc4701cEeeDcD90f0993f0A9126ed89d0",
    symbol: "REN",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x408e41876cCCDC0F92210600ef50372656052a38/logo.png"
  },
  {
    name: "Reputation Augur v2",
    address: "0x6563c1244820CfBd6Ca8820FBdf0f2847363F733",
    symbol: "REPv2",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x221657776846890989a759BA2973e427DfF5C9bB/logo.png"
  },
  {
    name: "Synthetix Network Token",
    address: "0x50B728D8D964fd00C2d0AAD81718b71311feF68a",
    symbol: "SNX",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F/logo.png"
  },
  {
    name: "Storj Token",
    address: "0xd72357dAcA2cF11A5F155b9FF7880E595A3F5792",
    symbol: "STORJ",
    decimals: 8,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xB64ef51C888972c908CFacf59B47C1AfBC0Ab8aC/logo.png"
  },
  {
    name: "Synth sUSD",
    address: "0xF81b4Bec6Ca8f9fe7bE01CA734F55B2b6e03A7a0",
    symbol: "sUSD",
    decimals: 18,
    chainId: 137,
    logoURI: "https://assets.coingecko.com/coins/images/5013/thumb/sUSD.png?1616150765"
  },
  {
    chainId: 137,
    address: "0x50a4a434247089848991DD8f09b889D4e2870aB6",
    name: "tBTC",
    symbol: "TBTC",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/11224/thumb/tBTC.png?1589620754"
  },
  {
    name: "UMA Voting Token v1",
    address: "0x3066818837c5e6eD6601bd5a91B0762877A6B731",
    symbol: "UMA",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828/logo.png"
  },
  {
    name: "Uniswap",
    address: "0xb33EaAd8d922B1083446DC23f610c2567fB5180f",
    symbol: "UNI",
    decimals: 18,
    chainId: 137,
    logoURI: "ipfs://QmXttGpZrECX5qCyXbBQiqgQNytVGeZW5Anewvh2jc4psg"
  },
  {
    name: "USDCoin",
    address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
    symbol: "USDC",
    decimals: 6,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png"
  },
  {
    name: "Tether USD",
    address: "0xc2132D05D31c914a87C6611C10748AEb04B58e8F",
    symbol: "USDT",
    decimals: 6,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xdAC17F958D2ee523a2206206994597C13D831ec7/logo.png"
  },
  {
    name: "Wrapped BTC",
    address: "0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6",
    symbol: "WBTC",
    decimals: 8,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599/logo.png"
  },
  {
    name: "Wrapped Ether",
    address: "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619",
    symbol: "WETH",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png"
  },
  {
    name: "Wrapped Matic",
    address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
    symbol: "WMATIC",
    decimals: 18,
    chainId: 137,
    logoURI: "https://assets.coingecko.com/coins/images/4713/thumb/matic-token-icon.png?1624446912"
  },
  {
    chainId: 137,
    address: "0xDA537104D6A5edd53c6fBba9A898708E465260b6",
    name: "yearn finance",
    symbol: "YFI",
    decimals: 18,
    logoURI: "https://assets.coingecko.com/coins/images/11849/thumb/yfi-192x192.png?1598325330"
  },
  {
    name: "0x Protocol Token",
    address: "0x5559Edb74751A0edE9DeA4DC23aeE72cCA6bE3D5",
    symbol: "ZRX",
    decimals: 18,
    chainId: 137,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xE41d2489571d322189246DaFA5ebDe1F4699F498/logo.png"
  },
  {
    name: "Wrapped Ether",
    address: "0xA6FA4fB5f76172d178d61B04b0ecd319C5d1C0aa",
    symbol: "WETH",
    decimals: 18,
    chainId: 80001,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png"
  },
  {
    name: "Wrapped Matic",
    address: "0xd0A1E359811322d97991E03f863a0C30C2cF029C",
    symbol: "WMATIC",
    decimals: 18,
    chainId: 80001,
    logoURI: "https://assets.coingecko.com/coins/images/4713/thumb/matic-token-icon.png?1624446912"
  }
];
const DEFAULT_TOKEN_LIST = {
  name,
  timestamp,
  version: version$2,
  tags,
  logoURI,
  keywords,
  tokens
};
var nodeCache = { exports: {} };
var node_cache = { exports: {} };
var clone = { exports: {} };
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone)
    return clone.exports;
  hasRequiredClone = 1;
  (function(module) {
    var clone2 = function() {
      function _instanceof(obj, type) {
        return type != null && obj instanceof type;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_2) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_2) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_2) {
        nativePromise = function() {
        };
      }
      function clone3(parent2, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent3, depth2) {
          if (parent3 === null)
            return null;
          if (depth2 === 0)
            return parent3;
          var child;
          var proto;
          if (typeof parent3 != "object") {
            return parent3;
          }
          if (_instanceof(parent3, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent3, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent3, nativePromise)) {
            child = new nativePromise(function(resolve, reject) {
              parent3.then(function(value) {
                resolve(_clone(value, depth2 - 1));
              }, function(err) {
                reject(_clone(err, depth2 - 1));
              });
            });
          } else if (clone3.__isArray(parent3)) {
            child = [];
          } else if (clone3.__isRegExp(parent3)) {
            child = new RegExp(parent3.source, __getRegExpFlags(parent3));
            if (parent3.lastIndex)
              child.lastIndex = parent3.lastIndex;
          } else if (clone3.__isDate(parent3)) {
            child = new Date(parent3.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent3)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent3.length);
            } else {
              child = new Buffer(parent3.length);
            }
            parent3.copy(child);
            return child;
          } else if (_instanceof(parent3, Error)) {
            child = Object.create(parent3);
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent3);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index2 = allParents.indexOf(parent3);
            if (index2 != -1) {
              return allChildren[index2];
            }
            allParents.push(parent3);
            allChildren.push(child);
          }
          if (_instanceof(parent3, nativeMap)) {
            parent3.forEach(function(value, key2) {
              var keyChild = _clone(key2, depth2 - 1);
              var valueChild = _clone(value, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent3, nativeSet)) {
            parent3.forEach(function(value) {
              var entryChild = _clone(value, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i3 in parent3) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i3);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i3] = _clone(parent3[i3], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent3);
            for (var i3 = 0; i3 < symbols.length; i3++) {
              var symbol = symbols[i3];
              var descriptor = Object.getOwnPropertyDescriptor(parent3, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent3[symbol], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent3);
            for (var i3 = 0; i3 < allPropertyNames.length; i3++) {
              var propertyName = allPropertyNames[i3];
              var descriptor = Object.getOwnPropertyDescriptor(parent3, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent3[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent2, depth);
      }
      clone3.clonePrototype = function clonePrototype(parent2) {
        if (parent2 === null)
          return null;
        var c2 = function() {
        };
        c2.prototype = parent2;
        return new c2();
      };
      function __objToStr(o2) {
        return Object.prototype.toString.call(o2);
      }
      clone3.__objToStr = __objToStr;
      function __isDate(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object Date]";
      }
      clone3.__isDate = __isDate;
      function __isArray(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object Array]";
      }
      clone3.__isArray = __isArray;
      function __isRegExp(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object RegExp]";
      }
      clone3.__isRegExp = __isRegExp;
      function __getRegExpFlags(re2) {
        var flags = "";
        if (re2.global)
          flags += "g";
        if (re2.ignoreCase)
          flags += "i";
        if (re2.multiline)
          flags += "m";
        return flags;
      }
      clone3.__getRegExpFlags = __getRegExpFlags;
      return clone3;
    }();
    if (module.exports) {
      module.exports = clone2;
    }
  })(clone);
  return clone.exports;
}
var events = { exports: {} };
var R$2 = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R$2 && typeof R$2.apply === "function" ? R$2.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R$2 && typeof R$2.ownKeys === "function") {
  ReflectOwnKeys = R$2.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
events.exports = EventEmitter$1;
events.exports.once = once2;
EventEmitter$1.EventEmitter = EventEmitter$1;
EventEmitter$1.prototype._events = void 0;
EventEmitter$1.prototype._eventsCount = 0;
EventEmitter$1.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter$1.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n4) {
  if (typeof n4 !== "number" || n4 < 0 || NumberIsNaN(n4)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n4 + ".");
  }
  this._maxListeners = n4;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter$1.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter$1.prototype.emit = function emit(type) {
  var args = [];
  for (var i3 = 1; i3 < arguments.length; i3++)
    args.push(arguments[i3]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er2;
    if (args.length > 0)
      er2 = args[0];
    if (er2 instanceof Error) {
      throw er2;
    }
    var err = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
    err.context = er2;
    throw err;
  }
  var handler = events2[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i3 = 0; i3 < len; ++i3)
      ReflectApply(listeners2[i3], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m2;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w2.name = "MaxListenersExceededWarning";
      w2.emitter = target;
      w2.type = type;
      w2.count = existing.length;
      ProcessEmitWarning(w2);
    }
  }
  return target;
}
EventEmitter$1.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
EventEmitter$1.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state2 = { fired: false, wrapFn: void 0, target, type, listener };
  var wrapped = onceWrapper.bind(state2);
  wrapped.listener = listener;
  state2.wrapFn = wrapped;
  return wrapped;
}
EventEmitter$1.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$1.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$1.prototype.removeListener = function removeListener(type, listener) {
  var list, events2, position2, i3, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position2 = -1;
    for (i3 = list.length - 1; i3 >= 0; i3--) {
      if (list[i3] === listener || list[i3].listener === listener) {
        originalListener = list[i3].listener;
        position2 = i3;
        break;
      }
    }
    if (position2 < 0)
      return this;
    if (position2 === 0)
      list.shift();
    else {
      spliceOne(list, position2);
    }
    if (list.length === 1)
      events2[type] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
EventEmitter$1.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2, i3;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys = Object.keys(events2);
    var key2;
    for (i3 = 0; i3 < keys.length; ++i3) {
      key2 = keys[i3];
      if (key2 === "removeListener")
        continue;
      this.removeAllListeners(key2);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (i3 = listeners2.length - 1; i3 >= 0; i3--) {
      this.removeListener(type, listeners2[i3]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter$1.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter$1.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter$1.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter$1.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter$1.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n4) {
  var copy2 = new Array(n4);
  for (var i3 = 0; i3 < n4; ++i3)
    copy2[i3] = arr[i3];
  return copy2;
}
function spliceOne(list, index2) {
  for (; index2 + 1 < list.length; index2++)
    list[index2] = list[index2 + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i3 = 0; i3 < ret.length; ++i3) {
    ret[i3] = arr[i3].listener || arr[i3];
  }
  return ret;
}
function once2(emitter, name2) {
  return new Promise(function(resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name2, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
    if (name2 !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name2, listener);
    } else {
      emitter.on(name2, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name2, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name2, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var eventsExports = events.exports;
const $g = /* @__PURE__ */ getDefaultExportFromCjs(eventsExports);
var hasRequiredNode_cache;
function requireNode_cache() {
  if (hasRequiredNode_cache)
    return node_cache.exports;
  hasRequiredNode_cache = 1;
  (function() {
    var EventEmitter2, clone2, splice = [].splice, boundMethodCheck = function(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new Error("Bound instance method accessed before binding");
      }
    }, indexOf = [].indexOf;
    clone2 = requireClone();
    EventEmitter2 = eventsExports.EventEmitter;
    node_cache.exports = function() {
      class NodeCache2 extends EventEmitter2 {
        constructor(options = {}) {
          super();
          this.get = this.get.bind(this);
          this.mget = this.mget.bind(this);
          this.set = this.set.bind(this);
          this.mset = this.mset.bind(this);
          this.del = this.del.bind(this);
          this.take = this.take.bind(this);
          this.ttl = this.ttl.bind(this);
          this.getTtl = this.getTtl.bind(this);
          this.keys = this.keys.bind(this);
          this.has = this.has.bind(this);
          this.getStats = this.getStats.bind(this);
          this.flushAll = this.flushAll.bind(this);
          this.flushStats = this.flushStats.bind(this);
          this.close = this.close.bind(this);
          this._checkData = this._checkData.bind(this);
          this._check = this._check.bind(this);
          this._isInvalidKey = this._isInvalidKey.bind(this);
          this._wrap = this._wrap.bind(this);
          this._getValLength = this._getValLength.bind(this);
          this._error = this._error.bind(this);
          this._initErrors = this._initErrors.bind(this);
          this.options = options;
          this._initErrors();
          this.data = {};
          this.options = Object.assign({
            // convert all elements to string
            forceString: false,
            // used standard size for calculating value size
            objectValueSize: 80,
            promiseValueSize: 80,
            arrayValueSize: 40,
            // standard time to live in seconds. 0 = infinity;
            stdTTL: 0,
            // time in seconds to check all data and delete expired keys
            checkperiod: 600,
            // en/disable cloning of variables. If `true` you'll get a copy of the cached variable. If `false` you'll save and get just the reference
            useClones: true,
            // whether values should be deleted automatically at expiration
            deleteOnExpire: true,
            // enable legacy callbacks
            enableLegacyCallbacks: false,
            // max amount of keys that are being stored
            maxKeys: -1
          }, this.options);
          if (this.options.enableLegacyCallbacks) {
            console.warn("WARNING! node-cache legacy callback support will drop in v6.x");
            ["get", "mget", "set", "del", "ttl", "getTtl", "keys", "has"].forEach((methodKey) => {
              var oldMethod;
              oldMethod = this[methodKey];
              this[methodKey] = function(...args) {
                var cb2, err, ref2, res;
                ref2 = args, [...args] = ref2, [cb2] = splice.call(args, -1);
                if (typeof cb2 === "function") {
                  try {
                    res = oldMethod(...args);
                    cb2(null, res);
                  } catch (error1) {
                    err = error1;
                    cb2(err);
                  }
                } else {
                  return oldMethod(...args, cb2);
                }
              };
            });
          }
          this.stats = {
            hits: 0,
            misses: 0,
            keys: 0,
            ksize: 0,
            vsize: 0
          };
          this.validKeyTypes = ["string", "number"];
          this._checkData();
          return;
        }
        get(key2) {
          var _ret, err;
          boundMethodCheck(this, NodeCache2);
          if ((err = this._isInvalidKey(key2)) != null) {
            throw err;
          }
          if (this.data[key2] != null && this._check(key2, this.data[key2])) {
            this.stats.hits++;
            _ret = this._unwrap(this.data[key2]);
            return _ret;
          } else {
            this.stats.misses++;
            return void 0;
          }
        }
        mget(keys) {
          var _err, err, i3, key2, len, oRet;
          boundMethodCheck(this, NodeCache2);
          if (!Array.isArray(keys)) {
            _err = this._error("EKEYSTYPE");
            throw _err;
          }
          oRet = {};
          for (i3 = 0, len = keys.length; i3 < len; i3++) {
            key2 = keys[i3];
            if ((err = this._isInvalidKey(key2)) != null) {
              throw err;
            }
            if (this.data[key2] != null && this._check(key2, this.data[key2])) {
              this.stats.hits++;
              oRet[key2] = this._unwrap(this.data[key2]);
            } else {
              this.stats.misses++;
            }
          }
          return oRet;
        }
        set(key2, value, ttl) {
          var _err, err, existent;
          boundMethodCheck(this, NodeCache2);
          if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {
            _err = this._error("ECACHEFULL");
            throw _err;
          }
          if (this.options.forceString && false === "string") {
            value = JSON.stringify(value);
          }
          if (ttl == null) {
            ttl = this.options.stdTTL;
          }
          if ((err = this._isInvalidKey(key2)) != null) {
            throw err;
          }
          existent = false;
          if (this.data[key2]) {
            existent = true;
            this.stats.vsize -= this._getValLength(this._unwrap(this.data[key2], false));
          }
          this.data[key2] = this._wrap(value, ttl);
          this.stats.vsize += this._getValLength(value);
          if (!existent) {
            this.stats.ksize += this._getKeyLength(key2);
            this.stats.keys++;
          }
          this.emit("set", key2, value);
          return true;
        }
        mset(keyValueSet) {
          var _err, err, i3, j2, key2, keyValuePair, len, len1, ttl, val;
          boundMethodCheck(this, NodeCache2);
          if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {
            _err = this._error("ECACHEFULL");
            throw _err;
          }
          for (i3 = 0, len = keyValueSet.length; i3 < len; i3++) {
            keyValuePair = keyValueSet[i3];
            ({ key: key2, val, ttl } = keyValuePair);
            if (ttl && typeof ttl !== "number") {
              _err = this._error("ETTLTYPE");
              throw _err;
            }
            if ((err = this._isInvalidKey(key2)) != null) {
              throw err;
            }
          }
          for (j2 = 0, len1 = keyValueSet.length; j2 < len1; j2++) {
            keyValuePair = keyValueSet[j2];
            ({ key: key2, val, ttl } = keyValuePair);
            this.set(key2, val, ttl);
          }
          return true;
        }
        del(keys) {
          var delCount, err, i3, key2, len, oldVal;
          boundMethodCheck(this, NodeCache2);
          if (!Array.isArray(keys)) {
            keys = [keys];
          }
          delCount = 0;
          for (i3 = 0, len = keys.length; i3 < len; i3++) {
            key2 = keys[i3];
            if ((err = this._isInvalidKey(key2)) != null) {
              throw err;
            }
            if (this.data[key2] != null) {
              this.stats.vsize -= this._getValLength(this._unwrap(this.data[key2], false));
              this.stats.ksize -= this._getKeyLength(key2);
              this.stats.keys--;
              delCount++;
              oldVal = this.data[key2];
              delete this.data[key2];
              this.emit("del", key2, oldVal.v);
            }
          }
          return delCount;
        }
        take(key2) {
          var _ret;
          boundMethodCheck(this, NodeCache2);
          _ret = this.get(key2);
          if (_ret != null) {
            this.del(key2);
          }
          return _ret;
        }
        ttl(key2, ttl) {
          var err;
          boundMethodCheck(this, NodeCache2);
          ttl || (ttl = this.options.stdTTL);
          if (!key2) {
            return false;
          }
          if ((err = this._isInvalidKey(key2)) != null) {
            throw err;
          }
          if (this.data[key2] != null && this._check(key2, this.data[key2])) {
            if (ttl >= 0) {
              this.data[key2] = this._wrap(this.data[key2].v, ttl, false);
            } else {
              this.del(key2);
            }
            return true;
          } else {
            return false;
          }
        }
        getTtl(key2) {
          var _ttl, err;
          boundMethodCheck(this, NodeCache2);
          if (!key2) {
            return void 0;
          }
          if ((err = this._isInvalidKey(key2)) != null) {
            throw err;
          }
          if (this.data[key2] != null && this._check(key2, this.data[key2])) {
            _ttl = this.data[key2].t;
            return _ttl;
          } else {
            return void 0;
          }
        }
        keys() {
          var _keys;
          boundMethodCheck(this, NodeCache2);
          _keys = Object.keys(this.data);
          return _keys;
        }
        has(key2) {
          var _exists;
          boundMethodCheck(this, NodeCache2);
          _exists = this.data[key2] != null && this._check(key2, this.data[key2]);
          return _exists;
        }
        getStats() {
          boundMethodCheck(this, NodeCache2);
          return this.stats;
        }
        flushAll(_startPeriod = true) {
          boundMethodCheck(this, NodeCache2);
          this.data = {};
          this.stats = {
            hits: 0,
            misses: 0,
            keys: 0,
            ksize: 0,
            vsize: 0
          };
          this._killCheckPeriod();
          this._checkData(_startPeriod);
          this.emit("flush");
        }
        flushStats() {
          boundMethodCheck(this, NodeCache2);
          this.stats = {
            hits: 0,
            misses: 0,
            keys: 0,
            ksize: 0,
            vsize: 0
          };
          this.emit("flush_stats");
        }
        close() {
          boundMethodCheck(this, NodeCache2);
          this._killCheckPeriod();
        }
        _checkData(startPeriod = true) {
          var key2, ref2, value;
          boundMethodCheck(this, NodeCache2);
          ref2 = this.data;
          for (key2 in ref2) {
            value = ref2[key2];
            this._check(key2, value);
          }
          if (startPeriod && this.options.checkperiod > 0) {
            this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1e3, startPeriod);
            if (this.checkTimeout != null && this.checkTimeout.unref != null) {
              this.checkTimeout.unref();
            }
          }
        }
        // ## _killCheckPeriod
        // stop the checkdata period. Only needed to abort the script in testing mode.
        _killCheckPeriod() {
          if (this.checkTimeout != null) {
            return clearTimeout(this.checkTimeout);
          }
        }
        _check(key2, data2) {
          var _retval;
          boundMethodCheck(this, NodeCache2);
          _retval = true;
          if (data2.t !== 0 && data2.t < Date.now()) {
            if (this.options.deleteOnExpire) {
              _retval = false;
              this.del(key2);
            }
            this.emit("expired", key2, this._unwrap(data2));
          }
          return _retval;
        }
        _isInvalidKey(key2) {
          var ref2;
          boundMethodCheck(this, NodeCache2);
          if (ref2 = typeof key2, indexOf.call(this.validKeyTypes, ref2) < 0) {
            return this._error("EKEYTYPE", {
              type: typeof key2
            });
          }
        }
        _wrap(value, ttl, asClone = true) {
          var livetime, now, ttlMultiplicator;
          boundMethodCheck(this, NodeCache2);
          if (!this.options.useClones) {
            asClone = false;
          }
          now = Date.now();
          livetime = 0;
          ttlMultiplicator = 1e3;
          if (ttl === 0) {
            livetime = 0;
          } else if (ttl) {
            livetime = now + ttl * ttlMultiplicator;
          } else {
            if (this.options.stdTTL === 0) {
              livetime = this.options.stdTTL;
            } else {
              livetime = now + this.options.stdTTL * ttlMultiplicator;
            }
          }
          return {
            t: livetime,
            v: asClone ? clone2(value) : value
          };
        }
        // ## _unwrap
        // internal method to extract get the value out of the wrapped value
        _unwrap(value, asClone = true) {
          if (!this.options.useClones) {
            asClone = false;
          }
          if (value.v != null) {
            if (asClone) {
              return clone2(value.v);
            } else {
              return value.v;
            }
          }
          return null;
        }
        // ## _getKeyLength
        // internal method the calculate the key length
        _getKeyLength(key2) {
          return key2.toString().length;
        }
        _getValLength(value) {
          boundMethodCheck(this, NodeCache2);
          if (typeof value === "string") {
            return value.length;
          } else if (this.options.forceString) {
            return JSON.stringify(value).length;
          } else if (Array.isArray(value)) {
            return this.options.arrayValueSize * value.length;
          } else if (typeof value === "number") {
            return 8;
          } else if (typeof (value != null ? value.then : void 0) === "function") {
            return this.options.promiseValueSize;
          } else if (typeof Buffer !== "undefined" && Buffer !== null ? Buffer.isBuffer(value) : void 0) {
            return value.length;
          } else if (value != null && typeof value === "object") {
            return this.options.objectValueSize * Object.keys(value).length;
          } else if (typeof value === "boolean") {
            return 8;
          } else {
            return 0;
          }
        }
        _error(type, data2 = {}) {
          var error;
          boundMethodCheck(this, NodeCache2);
          error = new Error();
          error.name = type;
          error.errorcode = type;
          error.message = this.ERRORS[type] != null ? this.ERRORS[type](data2) : "-";
          error.data = data2;
          return error;
        }
        _initErrors() {
          var _errMsg, _errT, ref2;
          boundMethodCheck(this, NodeCache2);
          this.ERRORS = {};
          ref2 = this._ERRORS;
          for (_errT in ref2) {
            _errMsg = ref2[_errT];
            this.ERRORS[_errT] = this.createErrorMessage(_errMsg);
          }
        }
        createErrorMessage(errMsg) {
          return function(args) {
            return errMsg.replace("__key", args.type);
          };
        }
      }
      NodeCache2.prototype._ERRORS = {
        "ENOTFOUND": "Key `__key` not found",
        "ECACHEFULL": "Cache max keys amount exceeded",
        "EKEYTYPE": "The key argument has to be of type `string` or `number`. Found: `__key`",
        "EKEYSTYPE": "The keys argument has to be an array.",
        "ETTLTYPE": "The ttl argument has to be a number."
      };
      return NodeCache2;
    }.call(this);
  }).call(commonjsGlobal);
  return node_cache.exports;
}
(function() {
  var exports;
  exports = nodeCache.exports = requireNode_cache();
  exports.version = "5.1.2";
}).call(commonjsGlobal);
var nodeCacheExports = nodeCache.exports;
const NodeCache = /* @__PURE__ */ getDefaultExportFromCjs(nodeCacheExports);
const _abi$4 = [
  {
    inputs: [
      {
        internalType: "address[]",
        name: "tokens",
        type: "address[]"
      },
      {
        internalType: "address[]",
        name: "baseTokens",
        type: "address[]"
      },
      {
        internalType: "uint256",
        name: "amountToBorrow",
        type: "uint256"
      }
    ],
    name: "batchValidate",
    outputs: [
      {
        internalType: "enum ITokenValidator.Status[]",
        name: "",
        type: "uint8[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "address[]",
        name: "baseTokens",
        type: "address[]"
      },
      {
        internalType: "uint256",
        name: "amountToBorrow",
        type: "uint256"
      }
    ],
    name: "validate",
    outputs: [
      {
        internalType: "enum ITokenValidator.Status",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
class ITokenValidator__factory {
  static createInterface() {
    return new Interface(_abi$4);
  }
  static connect(address, signerOrProvider) {
    return new Contract(address, _abi$4, signerOrProvider);
  }
}
ITokenValidator__factory.abi = _abi$4;
const DEFAULT_ALLOWLIST = /* @__PURE__ */ new Set([
  // RYOSHI. Does not allow transfers between contracts so fails validation.
  "0x777E2ae845272a2F540ebf6a3D03734A5a8f618e".toLowerCase()
]);
var TokenValidationResult;
(function(TokenValidationResult2) {
  TokenValidationResult2[TokenValidationResult2["UNKN"] = 0] = "UNKN";
  TokenValidationResult2[TokenValidationResult2["FOT"] = 1] = "FOT";
  TokenValidationResult2[TokenValidationResult2["STF"] = 2] = "STF";
})(TokenValidationResult || (TokenValidationResult = {}));
const TOKEN_VALIDATOR_ADDRESS = "0xb5ee1690b7dcc7859771148d0889be838fe108e0";
const AMOUNT_TO_FLASH_BORROW = "1000";
const GAS_LIMIT_PER_VALIDATE = 1e6;
class TokenValidatorProvider {
  constructor(chainId2, multicall2Provider, tokenValidationCache, tokenValidatorAddress = TOKEN_VALIDATOR_ADDRESS, gasLimitPerCall = GAS_LIMIT_PER_VALIDATE, amountToFlashBorrow = AMOUNT_TO_FLASH_BORROW, allowList = DEFAULT_ALLOWLIST) {
    this.chainId = chainId2;
    this.multicall2Provider = multicall2Provider;
    this.tokenValidationCache = tokenValidationCache;
    this.tokenValidatorAddress = tokenValidatorAddress;
    this.gasLimitPerCall = gasLimitPerCall;
    this.amountToFlashBorrow = amountToFlashBorrow;
    this.allowList = allowList;
    this.CACHE_KEY = (chainId3, address) => `token-${chainId3}-${address}`;
    this.BASES = [WRAPPED_NATIVE_CURRENCY[this.chainId].address];
  }
  async validateTokens(tokens2, providerConfig) {
    const tokenAddressToToken = _$3.keyBy(tokens2, "address");
    const addressesRaw = _$3(tokens2).map((token2) => token2.address).uniq().value();
    const addresses = [];
    const tokenToResult = {};
    for (const address of addressesRaw) {
      if (await this.tokenValidationCache.has(this.CACHE_KEY(this.chainId, address))) {
        tokenToResult[address.toLowerCase()] = await this.tokenValidationCache.get(this.CACHE_KEY(this.chainId, address));
      } else {
        addresses.push(address);
      }
    }
    log.info(`Got token validation results for ${addressesRaw.length - addresses.length} tokens from cache. Getting ${addresses.length} on-chain.`);
    const functionParams = _$3(addresses).map((address) => [address, this.BASES, this.amountToFlashBorrow]).value();
    const multicallResult = await this.multicall2Provider.callSameFunctionOnContractWithMultipleParams({
      address: this.tokenValidatorAddress,
      contractInterface: ITokenValidator__factory.createInterface(),
      functionName: "validate",
      functionParams,
      providerConfig,
      additionalConfig: {
        gasLimitPerCallOverride: this.gasLimitPerCall
      }
    });
    for (let i3 = 0; i3 < multicallResult.results.length; i3++) {
      const resultWrapper = multicallResult.results[i3];
      const tokenAddress = addresses[i3];
      const token2 = tokenAddressToToken[tokenAddress];
      if (this.allowList.has(token2.address.toLowerCase())) {
        tokenToResult[token2.address.toLowerCase()] = TokenValidationResult.UNKN;
        await this.tokenValidationCache.set(this.CACHE_KEY(this.chainId, token2.address.toLowerCase()), tokenToResult[token2.address.toLowerCase()]);
        continue;
      }
      if (!resultWrapper.success) {
        log.info({ result: resultWrapper }, `Failed to validate token ${token2.symbol}`);
        continue;
      }
      const validationResult = resultWrapper.result[0];
      tokenToResult[token2.address.toLowerCase()] = validationResult;
      await this.tokenValidationCache.set(this.CACHE_KEY(this.chainId, token2.address.toLowerCase()), tokenToResult[token2.address.toLowerCase()]);
    }
    return {
      getValidationByToken: (token2) => tokenToResult[token2.address.toLowerCase()]
    };
  }
}
const _abi$3 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "Burn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      }
    ],
    name: "Mint",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount0In",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount1In",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount0Out",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount1Out",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "Swap",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint112",
        name: "reserve0",
        type: "uint112"
      },
      {
        indexed: false,
        internalType: "uint112",
        name: "reserve1",
        type: "uint112"
      }
    ],
    name: "Sync",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MINIMUM_LIQUIDITY",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "PERMIT_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "burn",
    outputs: [
      {
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "factory",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getReserves",
    outputs: [
      {
        internalType: "uint112",
        name: "reserve0",
        type: "uint112"
      },
      {
        internalType: "uint112",
        name: "reserve1",
        type: "uint112"
      },
      {
        internalType: "uint32",
        name: "blockTimestampLast",
        type: "uint32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "kLast",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "mint",
    outputs: [
      {
        internalType: "uint256",
        name: "liquidity",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "price0CumulativeLast",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "price1CumulativeLast",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "skim",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount0Out",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount1Out",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "swap",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "sync",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "token0",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "token1",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
class IUniswapV2Pair__factory {
  static createInterface() {
    return new Interface(_abi$3);
  }
  static connect(address, signerOrProvider) {
    return new Contract(address, _abi$3, signerOrProvider);
  }
}
IUniswapV2Pair__factory.abi = _abi$3;
class V2PoolProvider {
  /**
   * Creates an instance of V2PoolProvider.
   * @param chainId The chain id to use.
   * @param multicall2Provider The multicall provider to use to get the pools.
   * @param retryOptions The retry options for each call to the multicall.
   */
  constructor(chainId2, multicall2Provider, retryOptions = {
    retries: 2,
    minTimeout: 50,
    maxTimeout: 500
  }) {
    this.chainId = chainId2;
    this.multicall2Provider = multicall2Provider;
    this.retryOptions = retryOptions;
    this.POOL_ADDRESS_CACHE = {};
  }
  async getPools(tokenPairs, providerConfig) {
    const poolAddressSet = /* @__PURE__ */ new Set();
    const sortedTokenPairs = [];
    const sortedPoolAddresses = [];
    for (const tokenPair of tokenPairs) {
      const [tokenA, tokenB] = tokenPair;
      const { poolAddress, token0, token1 } = this.getPoolAddress(tokenA, tokenB);
      if (poolAddressSet.has(poolAddress)) {
        continue;
      }
      poolAddressSet.add(poolAddress);
      sortedTokenPairs.push([token0, token1]);
      sortedPoolAddresses.push(poolAddress);
    }
    log.debug(`getPools called with ${tokenPairs.length} token pairs. Deduped down to ${poolAddressSet.size}`);
    const reservesResults = await this.getPoolsData(sortedPoolAddresses, "getReserves", providerConfig);
    log.info(`Got reserves for ${poolAddressSet.size} pools ${(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) ? `as of block: ${await (providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)}.` : ``}`);
    const poolAddressToPool = {};
    const invalidPools = [];
    for (let i3 = 0; i3 < sortedPoolAddresses.length; i3++) {
      const reservesResult = reservesResults[i3];
      if (!(reservesResult === null || reservesResult === void 0 ? void 0 : reservesResult.success)) {
        const [token02, token12] = sortedTokenPairs[i3];
        invalidPools.push([token02, token12]);
        continue;
      }
      const [token0, token1] = sortedTokenPairs[i3];
      const { reserve0, reserve1 } = reservesResult.result;
      const pool = new Pair(CurrencyAmount$2.fromRawAmount(token0, reserve0.toString()), CurrencyAmount$2.fromRawAmount(token1, reserve1.toString()));
      const poolAddress = sortedPoolAddresses[i3];
      poolAddressToPool[poolAddress] = pool;
    }
    if (invalidPools.length > 0) {
      log.info({
        invalidPools: _$3.map(invalidPools, ([token0, token1]) => `${token0.symbol}/${token1.symbol}`)
      }, `${invalidPools.length} pools invalid after checking their slot0 and liquidity results. Dropping.`);
    }
    const poolStrs = _$3.map(Object.values(poolAddressToPool), poolToString);
    log.debug({ poolStrs }, `Found ${poolStrs.length} valid pools`);
    return {
      getPool: (tokenA, tokenB) => {
        const { poolAddress } = this.getPoolAddress(tokenA, tokenB);
        return poolAddressToPool[poolAddress];
      },
      getPoolByAddress: (address) => poolAddressToPool[address],
      getAllPools: () => Object.values(poolAddressToPool)
    };
  }
  getPoolAddress(tokenA, tokenB) {
    const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];
    const cacheKey2 = `${this.chainId}/${token0.address}/${token1.address}`;
    const cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey2];
    if (cachedAddress) {
      return { poolAddress: cachedAddress, token0, token1 };
    }
    const poolAddress = Pair.getAddress(token0, token1);
    this.POOL_ADDRESS_CACHE[cacheKey2] = poolAddress;
    return { poolAddress, token0, token1 };
  }
  async getPoolsData(poolAddresses, functionName, providerConfig) {
    const { results, blockNumber } = await retry$1(async () => {
      return this.multicall2Provider.callSameFunctionOnMultipleContracts({
        addresses: poolAddresses,
        contractInterface: IUniswapV2Pair__factory.createInterface(),
        functionName,
        providerConfig
      });
    }, this.retryOptions);
    log.debug(`Pool data fetched as of block ${blockNumber}`);
    return results;
  }
}
const _abi$2 = [
  {
    inputs: [],
    name: "getPricesInWei",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
class GasDataArbitrum__factory {
  static createInterface() {
    return new Interface(_abi$2);
  }
  static connect(address, signerOrProvider) {
    return new Contract(address, _abi$2, signerOrProvider);
  }
}
GasDataArbitrum__factory.abi = _abi$2;
const _abi$1 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "DecimalsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "GasPriceUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "L1BaseFeeUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "OverheadUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "ScalarUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "gasPrice",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "getL1Fee",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "getL1GasUsed",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "l1BaseFee",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "overhead",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "scalar",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_decimals",
        type: "uint256"
      }
    ],
    name: "setDecimals",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_gasPrice",
        type: "uint256"
      }
    ],
    name: "setGasPrice",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_baseFee",
        type: "uint256"
      }
    ],
    name: "setL1BaseFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_overhead",
        type: "uint256"
      }
    ],
    name: "setOverhead",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_scalar",
        type: "uint256"
      }
    ],
    name: "setScalar",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
class GasPriceOracle__factory {
  static createInterface() {
    return new Interface(_abi$1);
  }
  static connect(address, signerOrProvider) {
    return new Contract(address, _abi$1, signerOrProvider);
  }
}
GasPriceOracle__factory.abi = _abi$1;
class OptimismGasDataProvider {
  constructor(chainId2, multicall2Provider, gasPriceAddress) {
    this.chainId = chainId2;
    this.multicall2Provider = multicall2Provider;
    if (chainId2 != ChainId$2.OPTIMISM && chainId2 != ChainId$2.OPTIMISTIC_KOVAN) {
      throw new Error("This data provider is used only on optimism networks.");
    }
    this.gasOracleAddress = gasPriceAddress !== null && gasPriceAddress !== void 0 ? gasPriceAddress : OVM_GASPRICE_ADDRESS;
  }
  /**
   * Gets the data constants needed to calculate the l1 security fee on Optimism.
   * @returns An OptimismGasData object that includes the l1BaseFee,
   * scalar, decimals, and overhead values.
   */
  async getGasData() {
    var _a, _b, _c, _d;
    const funcNames = ["l1BaseFee", "scalar", "decimals", "overhead"];
    const tx = await this.multicall2Provider.callMultipleFunctionsOnSameContract({
      address: this.gasOracleAddress,
      contractInterface: GasPriceOracle__factory.createInterface(),
      functionNames: funcNames
    });
    if (!((_a = tx.results[0]) === null || _a === void 0 ? void 0 : _a.success) || !((_b = tx.results[1]) === null || _b === void 0 ? void 0 : _b.success) || !((_c = tx.results[2]) === null || _c === void 0 ? void 0 : _c.success) || !((_d = tx.results[3]) === null || _d === void 0 ? void 0 : _d.success)) {
      log.info({ results: tx.results }, "Failed to get gas constants data from the optimism gas oracle");
      throw new Error("Failed to get gas constants data from the optimism gas oracle");
    }
    const { result: l1BaseFee } = tx.results[0];
    const { result: scalar } = tx.results[1];
    const { result: decimals } = tx.results[2];
    const { result: overhead } = tx.results[3];
    return {
      l1BaseFee: l1BaseFee[0],
      scalar: scalar[0],
      decimals: decimals[0],
      overhead: overhead[0]
    };
  }
}
class ArbitrumGasDataProvider {
  constructor(chainId2, provider, gasDataAddress) {
    this.chainId = chainId2;
    this.provider = provider;
    this.gasFeesAddress = gasDataAddress ? gasDataAddress : ARB_GASINFO_ADDRESS;
  }
  async getGasData() {
    const gasDataContract = GasDataArbitrum__factory.connect(this.gasFeesAddress, this.provider);
    const gasData = await gasDataContract.getPricesInWei();
    return {
      perL2TxFee: gasData[0],
      perL1CalldataFee: gasData[1],
      perArbGasTotal: gasData[5]
    };
  }
}
const _abi = [
  {
    inputs: [],
    name: "feeGrowthGlobal0X128",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeGrowthGlobal1X128",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "liquidity",
    outputs: [
      {
        internalType: "uint128",
        name: "",
        type: "uint128"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "observations",
    outputs: [
      {
        internalType: "uint32",
        name: "blockTimestamp",
        type: "uint32"
      },
      {
        internalType: "int56",
        name: "tickCumulative",
        type: "int56"
      },
      {
        internalType: "uint160",
        name: "secondsPerLiquidityCumulativeX128",
        type: "uint160"
      },
      {
        internalType: "bool",
        name: "initialized",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "key",
        type: "bytes32"
      }
    ],
    name: "positions",
    outputs: [
      {
        internalType: "uint128",
        name: "_liquidity",
        type: "uint128"
      },
      {
        internalType: "uint256",
        name: "feeGrowthInside0LastX128",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "feeGrowthInside1LastX128",
        type: "uint256"
      },
      {
        internalType: "uint128",
        name: "tokensOwed0",
        type: "uint128"
      },
      {
        internalType: "uint128",
        name: "tokensOwed1",
        type: "uint128"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "protocolFees",
    outputs: [
      {
        internalType: "uint128",
        name: "token0",
        type: "uint128"
      },
      {
        internalType: "uint128",
        name: "token1",
        type: "uint128"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "slot0",
    outputs: [
      {
        internalType: "uint160",
        name: "sqrtPriceX96",
        type: "uint160"
      },
      {
        internalType: "int24",
        name: "tick",
        type: "int24"
      },
      {
        internalType: "uint16",
        name: "observationIndex",
        type: "uint16"
      },
      {
        internalType: "uint16",
        name: "observationCardinality",
        type: "uint16"
      },
      {
        internalType: "uint16",
        name: "observationCardinalityNext",
        type: "uint16"
      },
      {
        internalType: "uint8",
        name: "feeProtocol",
        type: "uint8"
      },
      {
        internalType: "bool",
        name: "unlocked",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "int16",
        name: "wordPosition",
        type: "int16"
      }
    ],
    name: "tickBitmap",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "int24",
        name: "tick",
        type: "int24"
      }
    ],
    name: "ticks",
    outputs: [
      {
        internalType: "uint128",
        name: "liquidityGross",
        type: "uint128"
      },
      {
        internalType: "int128",
        name: "liquidityNet",
        type: "int128"
      },
      {
        internalType: "uint256",
        name: "feeGrowthOutside0X128",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "feeGrowthOutside1X128",
        type: "uint256"
      },
      {
        internalType: "int56",
        name: "tickCumulativeOutside",
        type: "int56"
      },
      {
        internalType: "uint160",
        name: "secondsPerLiquidityOutsideX128",
        type: "uint160"
      },
      {
        internalType: "uint32",
        name: "secondsOutside",
        type: "uint32"
      },
      {
        internalType: "bool",
        name: "initialized",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
class IUniswapV3PoolState__factory {
  static createInterface() {
    return new Interface(_abi);
  }
  static connect(address, signerOrProvider) {
    return new Contract(address, _abi, signerOrProvider);
  }
}
IUniswapV3PoolState__factory.abi = _abi;
class V3PoolProvider {
  /**
   * Creates an instance of V3PoolProvider.
   * @param chainId The chain id to use.
   * @param multicall2Provider The multicall provider to use to get the pools.
   * @param retryOptions The retry options for each call to the multicall.
   */
  constructor(chainId2, multicall2Provider, retryOptions = {
    retries: 2,
    minTimeout: 50,
    maxTimeout: 500
  }) {
    this.chainId = chainId2;
    this.multicall2Provider = multicall2Provider;
    this.retryOptions = retryOptions;
    this.POOL_ADDRESS_CACHE = {};
  }
  async getPools(tokenPairs, providerConfig) {
    const poolAddressSet = /* @__PURE__ */ new Set();
    const sortedTokenPairs = [];
    const sortedPoolAddresses = [];
    for (const tokenPair of tokenPairs) {
      const [tokenA, tokenB, feeAmount] = tokenPair;
      const { poolAddress, token0, token1 } = this.getPoolAddress(tokenA, tokenB, feeAmount);
      if (poolAddressSet.has(poolAddress)) {
        continue;
      }
      poolAddressSet.add(poolAddress);
      sortedTokenPairs.push([token0, token1, feeAmount]);
      sortedPoolAddresses.push(poolAddress);
    }
    log.debug(`getPools called with ${tokenPairs.length} token pairs. Deduped down to ${poolAddressSet.size}`);
    const [slot0Results, liquidityResults] = await Promise.all([
      this.getPoolsData(sortedPoolAddresses, "slot0", providerConfig),
      this.getPoolsData(sortedPoolAddresses, "liquidity", providerConfig)
    ]);
    log.info(`Got liquidity and slot0s for ${poolAddressSet.size} pools ${(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) ? `as of block: ${providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber}.` : ``}`);
    const poolAddressToPool = {};
    const invalidPools = [];
    for (let i3 = 0; i3 < sortedPoolAddresses.length; i3++) {
      const slot0Result = slot0Results[i3];
      const liquidityResult = liquidityResults[i3];
      if (!(slot0Result === null || slot0Result === void 0 ? void 0 : slot0Result.success) || !(liquidityResult === null || liquidityResult === void 0 ? void 0 : liquidityResult.success) || slot0Result.result.sqrtPriceX96.eq(0)) {
        const [token02, token12, fee2] = sortedTokenPairs[i3];
        invalidPools.push([token02, token12, fee2]);
        continue;
      }
      const [token0, token1, fee] = sortedTokenPairs[i3];
      const slot0 = slot0Result.result;
      const liquidity = liquidityResult.result[0];
      const pool = new Pool(token0, token1, fee, slot0.sqrtPriceX96.toString(), liquidity.toString(), slot0.tick);
      const poolAddress = sortedPoolAddresses[i3];
      poolAddressToPool[poolAddress] = pool;
    }
    if (invalidPools.length > 0) {
      log.info({
        invalidPools: _$3.map(invalidPools, ([token0, token1, fee]) => `${token0.symbol}/${token1.symbol}/${fee / 1e4}%`)
      }, `${invalidPools.length} pools invalid after checking their slot0 and liquidity results. Dropping.`);
    }
    const poolStrs = _$3.map(Object.values(poolAddressToPool), poolToString);
    log.debug({ poolStrs }, `Found ${poolStrs.length} valid pools`);
    return {
      getPool: (tokenA, tokenB, feeAmount) => {
        const { poolAddress } = this.getPoolAddress(tokenA, tokenB, feeAmount);
        return poolAddressToPool[poolAddress];
      },
      getPoolByAddress: (address) => poolAddressToPool[address],
      getAllPools: () => Object.values(poolAddressToPool)
    };
  }
  getPoolAddress(tokenA, tokenB, feeAmount) {
    const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];
    const cacheKey2 = `${this.chainId}/${token0.address}/${token1.address}/${feeAmount}`;
    const cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey2];
    if (cachedAddress) {
      return { poolAddress: cachedAddress, token0, token1 };
    }
    const poolAddress = computePoolAddress({
      factoryAddress: V3_CORE_FACTORY_ADDRESSES$1[this.chainId],
      tokenA: token0,
      tokenB: token1,
      fee: feeAmount
    });
    this.POOL_ADDRESS_CACHE[cacheKey2] = poolAddress;
    return { poolAddress, token0, token1 };
  }
  async getPoolsData(poolAddresses, functionName, providerConfig) {
    const { results, blockNumber } = await retry$1(async () => {
      return this.multicall2Provider.callSameFunctionOnMultipleContracts({
        addresses: poolAddresses,
        contractInterface: IUniswapV3PoolState__factory.createInterface(),
        functionName,
        providerConfig
      });
    }, this.retryOptions);
    log.debug(`Pool data fetched as of block ${blockNumber}`);
    return results;
  }
}
function buildTrade(tokenInCurrency, tokenOutCurrency, tradeType, routeAmounts) {
  const v3RouteAmounts = _$3.filter(routeAmounts, (routeAmount) => routeAmount.protocol === distExports.Protocol.V3);
  const v2RouteAmounts = _$3.filter(routeAmounts, (routeAmount) => routeAmount.protocol === distExports.Protocol.V2);
  const mixedRouteAmounts = _$3.filter(routeAmounts, (routeAmount) => routeAmount.protocol === distExports.Protocol.MIXED);
  const v3Routes = _$3.map(v3RouteAmounts, (routeAmount) => {
    const { route, amount, quote } = routeAmount;
    if (tradeType == TradeType$3.EXACT_INPUT) {
      const amountCurrency = CurrencyAmount$2.fromFractionalAmount(tokenInCurrency, amount.numerator, amount.denominator);
      const quoteCurrency = CurrencyAmount$2.fromFractionalAmount(tokenOutCurrency, quote.numerator, quote.denominator);
      const routeRaw = new Route$2(route.pools, amountCurrency.currency, quoteCurrency.currency);
      return {
        routev3: routeRaw,
        inputAmount: amountCurrency,
        outputAmount: quoteCurrency
      };
    } else {
      const quoteCurrency = CurrencyAmount$2.fromFractionalAmount(tokenInCurrency, quote.numerator, quote.denominator);
      const amountCurrency = CurrencyAmount$2.fromFractionalAmount(tokenOutCurrency, amount.numerator, amount.denominator);
      const routeCurrency = new Route$2(route.pools, quoteCurrency.currency, amountCurrency.currency);
      return {
        routev3: routeCurrency,
        inputAmount: quoteCurrency,
        outputAmount: amountCurrency
      };
    }
  });
  const v2Routes = _$3.map(v2RouteAmounts, (routeAmount) => {
    const { route, amount, quote } = routeAmount;
    if (tradeType == TradeType$3.EXACT_INPUT) {
      const amountCurrency = CurrencyAmount$2.fromFractionalAmount(tokenInCurrency, amount.numerator, amount.denominator);
      const quoteCurrency = CurrencyAmount$2.fromFractionalAmount(tokenOutCurrency, quote.numerator, quote.denominator);
      const routeV2SDK = new Route(route.pairs, amountCurrency.currency, quoteCurrency.currency);
      return {
        routev2: routeV2SDK,
        inputAmount: amountCurrency,
        outputAmount: quoteCurrency
      };
    } else {
      const quoteCurrency = CurrencyAmount$2.fromFractionalAmount(tokenInCurrency, quote.numerator, quote.denominator);
      const amountCurrency = CurrencyAmount$2.fromFractionalAmount(tokenOutCurrency, amount.numerator, amount.denominator);
      const routeV2SDK = new Route(route.pairs, quoteCurrency.currency, amountCurrency.currency);
      return {
        routev2: routeV2SDK,
        inputAmount: quoteCurrency,
        outputAmount: amountCurrency
      };
    }
  });
  const mixedRoutes = _$3.map(mixedRouteAmounts, (routeAmount) => {
    const { route, amount, quote } = routeAmount;
    if (tradeType != TradeType$3.EXACT_INPUT) {
      throw new Error("Mixed routes are only supported for exact input trades");
    }
    const amountCurrency = CurrencyAmount$2.fromFractionalAmount(tokenInCurrency, amount.numerator, amount.denominator);
    const quoteCurrency = CurrencyAmount$2.fromFractionalAmount(tokenOutCurrency, quote.numerator, quote.denominator);
    const routeRaw = new distExports.MixedRouteSDK(route.pools, amountCurrency.currency, quoteCurrency.currency);
    return {
      mixedRoute: routeRaw,
      inputAmount: amountCurrency,
      outputAmount: quoteCurrency
    };
  });
  const trade = new distExports.Trade({ v2Routes, v3Routes, mixedRoutes, tradeType });
  return trade;
}
function buildSwapMethodParameters(trade, swapConfig) {
  const { recipient, slippageTolerance, deadline, inputTokenPermit } = swapConfig;
  return distExports.SwapRouter.swapCallParameters(trade, {
    recipient,
    slippageTolerance,
    deadlineOrPreviousBlockhash: deadline,
    inputTokenPermit
  });
}
const UNSUPPORTED_TOKENS = {
  name: "Unsupported Token List",
  timestamp: "2021-01-05T20:47:02.923Z",
  version: {
    major: 1,
    minor: 0,
    patch: 0
  },
  tags: {},
  logoURI: "ipfs://QmNa8mQkrNKp1WEEeGjFezDmDeodkWRevGFN8JCV7b4Xir",
  keywords: ["uniswap", "unsupported", "broken"],
  tokens: [
    {
      name: "USD Token",
      address: "0xd233d1f6fd11640081abb8db125f722b5dc729dc",
      symbol: "USD",
      decimals: 9,
      chainId: 1,
      logoURI: ""
    },
    {
      name: "UNI HODL",
      address: "0x4bf5dc91E2555449293D7824028Eb8Fe5879B689",
      symbol: "UniH",
      decimals: 18,
      chainId: 1,
      logoURI: ""
    },
    {
      name: "Gold Tether",
      address: "0x4922a015c4407F87432B179bb209e125432E4a2A",
      symbol: "XAUt",
      decimals: 6,
      chainId: 1,
      logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x4922a015c4407F87432B179bb209e125432E4a2A/logo.png"
    },
    {
      name: "Grump Cat",
      address: "0x93B2FfF814FCaEFFB01406e80B4Ecd89Ca6A021b",
      symbol: "GRUMPY",
      decimals: 9,
      chainId: 1,
      logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x4922a015c4407F87432B179bb209e125432E4a2A/logo.png"
    },
    {
      name: "apeUSD-UMA Synthetic USD (Dec 2021)",
      address: "0xfA5e27893aee4805283D86e4283Da64F8c72dd56",
      symbol: "apeUSD-UMA-DEC21",
      decimals: 18,
      chainId: 1,
      logoURI: ""
    },
    {
      chainId: 1,
      address: "0xc6b11850241c5127eab73af4b6c68bc267cbbff4",
      name: "oWETHp Put 360 DEC2520",
      symbol: "oWETH-360P-12/25/20",
      decimals: 7
    },
    {
      chainId: 1,
      name: "oYFIp Put 25000 OCT0220",
      address: "0x452b421be5b30f0c6ad8c3f03c06bdaab4f5c56c",
      symbol: "oYFI-25000P-10/02/20",
      decimals: 7
    },
    {
      chainId: 1,
      name: "oWETHp Put 360 OCT3020",
      address: "0x0578779e746d7186253a36cf651ea786acfcf087",
      symbol: "oWETH-360P-10/30/20",
      decimals: 7
    },
    {
      chainId: 1,
      name: "ETHc Call 500 OCT3020",
      address: "0xf9aba2e43fb19184408ea3b572a0fd672946f87b",
      symbol: "oETH-500C-10/30/20",
      decimals: 6
    },
    {
      chainId: 1,
      name: "oBALp Put 22 OCT0220",
      address: "0xdb0991dfc7e828b5a2837dc82d68e16490562c8d",
      symbol: "oBAL-22P-10/02/20",
      decimals: 7
    },
    {
      chainId: 1,
      name: "oCOMPp Put 150 SEP2520",
      address: "0xe951ebe6b4420ab3f4844cf36dedd263d095b416",
      symbol: "oCOMP-150P-09/25/20",
      decimals: 7
    },
    {
      chainId: 1,
      name: "oCRVp Put 3 SEP252020",
      address: "0x9215bd49b59748419eac6bad9dbe247df06ebdb9",
      symbol: "oCRV-3P-09/25/20",
      decimals: 7
    },
    {
      chainId: 1,
      name: "oETHp Put 180 SEP2520",
      address: "0xE3A2c34Fa2F59ffa95C4ACd1E5663633d45Bc3AD",
      symbol: "oETH-180P-09/25/20",
      decimals: 7
    },
    {
      chainId: 1,
      name: "oETHc Call 400 SEP2520",
      address: "0x05977EBC26825C0CD6097E0Ad7204721516711Eb",
      symbol: "oETH-400C-09/25/20",
      decimals: 7
    },
    {
      chainId: 1,
      name: "oWETHp Put 380 SEP1820",
      address: "0x31f88266301b08631f9f0e33fd5c43c2a5d1e5b2",
      symbol: "oWETH-380P-09/18/20",
      decimals: 7
    },
    {
      chainId: 1,
      name: "oYFIp Put 8500 SEP1820",
      address: "0xd1cec2f67fdc4c60e0963515dfc3343f31e32e47",
      symbol: "oYFI-8500P-09/18/20",
      decimals: 7
    },
    {
      chainId: 1,
      name: "oWETHp Put 370 SEP1120",
      address: "0x15844029b2c2bf24506e9937739a9a912f1e4354",
      symbol: "oWETH-370P-09/11/20",
      decimals: 7
    },
    {
      chainId: 1,
      name: "oWETHp Put 400 SEP0420",
      address: "0x5562c33c383f6386be4f6dcdbd35a3a99bbcfde6",
      symbol: "oWETH-400P-09/04/20",
      decimals: 7
    },
    {
      chainId: 1,
      name: "oETHp Put 200 AUG2820",
      address: "0x3CBFC1397deF0602c2d211c70A1c0c38CEDB5448",
      symbol: "oWETH-400P-09/04/20",
      decimals: 7
    },
    {
      chainId: 1,
      name: "Opyn cDai Insurance",
      symbol: "ocDai",
      address: "0x98cc3bd6af1880fcfda17ac477b2f612980e5e33",
      decimals: 8
    },
    {
      chainId: 1,
      name: "Opyn cUSDC Insurance",
      symbol: "ocUSDC",
      address: "0x8ED9f862363fFdFD3a07546e618214b6D59F03d4",
      decimals: 8
    },
    {
      chainId: 1,
      address: "0x176C674Ee533C6139B0dc8b458D72A93dCB3e705",
      symbol: "iAAVE",
      name: "Synth Inverse Aave",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iAAVE.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0x8A8079c7149B8A1611e5C5d978DCA3bE16545F83",
      symbol: "iADA",
      name: "Synth Inverse Cardano",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iADA.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0xAFD870F32CE54EfdBF677466B612bf8ad164454B",
      symbol: "iBNB",
      name: "Synth Inverse Binance Coin",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iBNB.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0xD6014EA05BDe904448B743833dDF07c3C7837481",
      symbol: "iBTC",
      name: "Synth Inverse Bitcoin",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iBTC.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0x336213e1DDFC69f4701Fc3F86F4ef4A160c1159d",
      symbol: "iCEX",
      name: "Synth Inverse Centralised Exchange Index",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iCEX.svg",
      tags: ["index", "inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0x6345728B1ccE16E6f8C509950b5c84FFF88530d9",
      symbol: "iCOMP",
      name: "Synth Inverse Compound",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iCOMP.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0xCB98f42221b2C251A4E74A1609722eE09f0cc08E",
      symbol: "iDASH",
      name: "Synth Inverse Dash",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iDASH.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0x14d10003807AC60d07BB0ba82cAeaC8d2087c157",
      symbol: "iDEFI",
      name: "Synth Inverse DeFi Index",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iDEFI.svg",
      tags: ["index", "inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0x46a97629C9C1F58De6EC18C7F536e7E6d6A6ecDe",
      symbol: "iDOT",
      name: "Synth Inverse Polkadot",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iDOT.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0xF4EebDD0704021eF2a6Bbe993fdf93030Cd784b4",
      symbol: "iEOS",
      name: "Synth Inverse EOS",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iEOS.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0xd50c1746D835d2770dDA3703B69187bFfeB14126",
      symbol: "iETC",
      name: "Synth Inverse Ethereum Classic",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iETC.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0xA9859874e1743A32409f75bB11549892138BBA1E",
      symbol: "iETH",
      name: "Synth Inverse Ether",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iETH.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0x2d7aC061fc3db53c39fe1607fB8cec1B2C162B01",
      symbol: "iLINK",
      name: "Synth Inverse Chainlink",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iLINK.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0x79da1431150C9b82D2E5dfc1C68B33216846851e",
      symbol: "iLTC",
      name: "Synth Inverse Litecoin",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iLTC.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0xA5a5DF41883Cdc00c4cCC6E8097130535399d9a3",
      symbol: "iOIL",
      name: "Synth Inverse Perpetual Oil Futures",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iOIL.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0x0fEd38108bdb8e62ef7b5680E8E0726E2F29e0De",
      symbol: "iREN",
      name: "Synth Inverse Ren",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iREN.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0xC5807183a9661A533CB08CbC297594a0B864dc12",
      symbol: "iTRX",
      name: "Synth Inverse TRON",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iTRX.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0x36A00FF9072570eF4B9292117850B8FE08d96cce",
      symbol: "iUNI",
      name: "Synth Inverse Uniswap",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iUNI.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0x4AdF728E2Df4945082cDD6053869f51278fae196",
      symbol: "iXMR",
      name: "Synth Inverse Monero",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iXMR.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0x27269b3e45A4D3E79A3D6BFeE0C8fB13d0D711A6",
      symbol: "iXRP",
      name: "Synth Inverse Ripple",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iXRP.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0x8deef89058090ac5655A99EEB451a4f9183D1678",
      symbol: "iXTZ",
      name: "Synth Inverse Tezos",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iXTZ.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0x592244301CeA952d6daB2fdC1fE6bd9E53917306",
      symbol: "iYFI",
      name: "Synth Inverse yearn.finance",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/iYFI.svg",
      tags: ["inverse", "synth"]
    },
    {
      chainId: 1,
      address: "0xcD39b5434a0A92cf47D1F567a7dF84bE356814F0",
      symbol: "s1INCH",
      name: "Synth 1inch",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/s1INCH.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x7537AAe01f3B218DAE75e10d952473823F961B87",
      symbol: "sAAPL",
      name: "Synth Apple",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sAAPL.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xd2dF355C19471c8bd7D8A3aa27Ff4e26A21b4076",
      symbol: "sAAVE",
      name: "Synth Aave",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sAAVE.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xe36E2D3c7c34281FA3bC737950a68571736880A1",
      symbol: "sADA",
      name: "Synth Cardano",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sADA.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x9CF7E61853ea30A41b02169391b393B901eac457",
      symbol: "sAMZN",
      name: "Synth Amazon",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sAMZN.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xF48e200EAF9906362BB1442fca31e0835773b8B4",
      symbol: "sAUD",
      name: "Synth Australian Dollars",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sAUD.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x617aeCB6137B5108D1E7D4918e3725C8cEbdB848",
      symbol: "sBNB",
      name: "Synth Binance Coin",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sBNB.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6",
      symbol: "sBTC",
      name: "Synth Bitcoin",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sBTC.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xeABACD844A196D7Faf3CE596edeBF9900341B420",
      symbol: "sCEX",
      name: "Synth Centralised Exchange Index",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sCEX.svg",
      tags: ["index", "synth"]
    },
    {
      chainId: 1,
      address: "0x0F83287FF768D1c1e17a42F44d644D7F22e8ee1d",
      symbol: "sCHF",
      name: "Synth Swiss Franc",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sCHF.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x9EeF4CA7aB9fa8bc0650127341C2d3F707a40f8A",
      symbol: "sCOIN",
      name: "Synth Coinbase",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sCOIN.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xEb029507d3e043DD6C87F2917C4E82B902c35618",
      symbol: "sCOMP",
      name: "Synth Compound",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sCOMP.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xD38aEb759891882e78E957c80656572503D8c1B1",
      symbol: "sCRV",
      name: "Synth Curve DAO Token",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sCRV.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xfE33ae95A9f0DA8A845aF33516EDc240DCD711d6",
      symbol: "sDASH",
      name: "Synth Dash",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sDASH.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xe1aFe1Fd76Fd88f78cBf599ea1846231B8bA3B6B",
      symbol: "sDEFI",
      name: "Synth DeFi Index",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sDEFI.svg",
      tags: ["index", "synth"]
    },
    {
      chainId: 1,
      address: "0x1715AC0743102BF5Cd58EfBB6Cf2dC2685d967b6",
      symbol: "sDOT",
      name: "Synth Polkadot",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sDOT.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x88C8Cf3A212c0369698D13FE98Fcb76620389841",
      symbol: "sEOS",
      name: "Synth EOS",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sEOS.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x22602469d704BfFb0936c7A7cfcD18f7aA269375",
      symbol: "sETC",
      name: "Synth Ethereum Classic",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sETC.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb",
      symbol: "sETH",
      name: "Synth Ether",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sETH.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xD71eCFF9342A5Ced620049e616c5035F1dB98620",
      symbol: "sEUR",
      name: "Synth Euros",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sEUR.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xf50B5e535F62a56A9BD2d8e2434204E726c027Fa",
      symbol: "sFB",
      name: "Synth Facebook",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sFB.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x23348160D7f5aca21195dF2b70f28Fce2B0be9fC",
      symbol: "sFTSE",
      name: "Synth FTSE 100 Index",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sFTSE.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x97fe22E7341a0Cd8Db6F6C021A24Dc8f4DAD855F",
      symbol: "sGBP",
      name: "Synth Pound Sterling",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sGBP.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xC63B8ECCE56aB9C46184eC6aB85e4771fEa4c8AD",
      symbol: "sGOOG",
      name: "Synth Alphabet",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sGOOG.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xF6b1C627e95BFc3c1b4c9B825a032Ff0fBf3e07d",
      symbol: "sJPY",
      name: "Synth Japanese Yen",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sJPY.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x269895a3dF4D73b077Fc823dD6dA1B95f72Aaf9B",
      symbol: "sKRW",
      name: "Synth South Korean Won",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sKRW.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xbBC455cb4F1B9e4bFC4B73970d360c8f032EfEE6",
      symbol: "sLINK",
      name: "Synth Chainlink",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sLINK.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xC14103C2141E842e228FBaC594579e798616ce7A",
      symbol: "sLTC",
      name: "Synth Litecoin",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sLTC.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x745a824D6aBBD236AA794b5530062778A6Ad7523",
      symbol: "sMSFT",
      name: "Synth Microsoft",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sMSFT.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x5A7E3c07604EB515C16b36cd51906a65f021F609",
      symbol: "sNFLX",
      name: "Synth Netflix",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sNFLX.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x757de3ac6B830a931eF178C6634c5C551773155c",
      symbol: "sNIKKEI",
      name: "Synth Nikkei 225 Index",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sNIKKEI.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x6d16cF3EC5F763d4d99cB0B0b110eefD93B11B56",
      symbol: "sOIL",
      name: "Synth Perpetual Oil Futures",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sOIL.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xD31533E8d0f3DF62060e94B3F1318137bB6E3525",
      symbol: "sREN",
      name: "Synth Ren",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sREN.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x0352557B007A4Aae1511C114409b932F06F9E2f4",
      symbol: "sRUNE",
      name: "Synth THORChain",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sRUNE.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xf2E08356588EC5cd9E437552Da87C0076b4970B0",
      symbol: "sTRX",
      name: "Synth TRON",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sTRX.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x918dA91Ccbc32B7a6A0cc4eCd5987bbab6E31e6D",
      symbol: "sTSLA",
      name: "Synth Tesla",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sTSLA.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x30635297E450b930f8693297eBa160D9e6c8eBcf",
      symbol: "sUNI",
      name: "Synth Uniswap",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sUNI.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x6A22e5e94388464181578Aa7A6B869e00fE27846",
      symbol: "sXAG",
      name: "Synth Silver Ounce",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sXAG.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x261EfCdD24CeA98652B9700800a13DfBca4103fF",
      symbol: "sXAU",
      name: "Synth Gold Ounce",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sXAU.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x5299d6F7472DCc137D7f3C4BcfBBB514BaBF341A",
      symbol: "sXMR",
      name: "Synth Monero",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sXMR.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0xa2B0fDe6D710e201d0d608e924A484d1A5fEd57c",
      symbol: "sXRP",
      name: "Synth Ripple",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sXRP.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x2e59005c5c0f0a4D77CcA82653d48b46322EE5Cd",
      symbol: "sXTZ",
      name: "Synth Tezos",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sXTZ.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x992058B7DB08F9734d84485bfbC243C4ee6954A7",
      symbol: "sYFI",
      name: "Synth yearn.finance",
      decimals: 18,
      logoURI: "https://raw.githubusercontent.com/Synthetixio/synthetix-assets/v2.0.10/synths/sYFI.svg",
      tags: ["synth"]
    },
    {
      chainId: 1,
      address: "0x81ab848898b5ffD3354dbbEfb333D5D183eEDcB5",
      name: "yUSD Synthetic Expiring 1 September 2020",
      symbol: "yUSDSEP20",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0xB2FdD60AD80ca7bA89B9BAb3b5336c2601C020b4",
      name: "yUSD Synthetic Expiring 1 October 2020",
      symbol: "yUSDOCT20",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x208d174775dc39fe18b1b374972f77ddec6c0f73",
      name: "uUSDrBTC Synthetic Expiring 1 Oct 2020",
      symbol: "uUSDrBTC-OCT",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0xf06ddacf71e2992e2122a1a0168c6967afdf63ce",
      name: "uUSDrBTC Synthetic Expiring 31 Dec 2020",
      symbol: "uUSDrBTC-DEC",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0xd16c79c8a39d44b2f3eb45d2019cd6a42b03e2a9",
      name: "uUSDwETH Synthetic Expiring 31 Dec 2020",
      symbol: "uUSDwETH-DEC",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x3d995510f8d82c2ea341845932b5ddde0bead9a3",
      name: "uGAS-JAN21 Token Expiring 31 Jan 2021",
      symbol: "uGAS-JAN21",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x90f802c7e8fb5d40b0de583e34c065a3bd2020d8",
      name: "YD-ETH-MAR21 Token Expiring 31 Mar 2021",
      symbol: "YD-ETH-MAR21",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x002f0b1a71c5730cf2f4da1970a889207bdb6d0d",
      name: "YD-BTC-MAR21 Token Expiring 31 Mar 2021",
      symbol: "YD-BTC-MAR21",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x1062ad0e59fa67fa0b27369113098cc941dd0d5f",
      name: "UMA 35 Call Expirying 30 Apr 2021",
      symbol: "UMAc35-0421",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0xf93340b1a3adf7eedcaec25fae8171d4b736e89f",
      name: "pxUSD Synthetic USD Expiring 1 April 2021",
      symbol: "pxUSD_MAR2021",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x84bd083b1c8bf929f39c98bc17cf518f40154f58",
      name: "Mario Cash Synthetic Token Expiring 15 January 2021",
      symbol: "Mario Cash-JAN-2021",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x81fab276aec924fbde190cf379783526d413cf70",
      name: "uGAS-FEB21 Token Expiring 28 Feb 2021",
      symbol: "uGAS-FEB21",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x4e110603e70b0b5f1c403ee543b37e1f1244cf28",
      name: "uGAS-MAR21 Token Expiring 31 Mar 2021",
      symbol: "uGAS-MAR21",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0xcf55a7f92d5e0c6683debbc1fc20c0a6e056df13",
      name: "Zelda Elastic Cash",
      symbol: "Zelda Elastic Cash",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x654eebac62240e6c56bab5f6adf7cfa74a894510",
      name: "Zelda Spring Nuts Cash",
      symbol: "Zelda Spring Nuts Cash",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0xa48920cc1ad85d8ea13af5d7be180c0338c306dd",
      name: "Zelda Summer Nuts Cash",
      symbol: "Zelda Summer Nuts Cash",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x249a198d59b57fda5dda90630febc86fd8c7594c",
      name: "Zelda Whirlwind Cash",
      symbol: "Zelda Whirlwind Cash",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x5ed1406873c9eb91f6f9a67ac4e152387c1132e7",
      name: "Zelda Reinforced Cash",
      symbol: "Zelda Reinforced Cash",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x8104c9f13118320eefe5fbea8a44d600b85981ef",
      name: "Mini Mario Summer Cash",
      symbol: "Mini Mario Summer Cash",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x69746c719e59674b147df25f50e7cfa0673cb625",
      name: "Mini Mario Spring Cash",
      symbol: "Mini Mario Spring Cash",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x6b1257641d18791141f025eab36fb567c4b564ff",
      name: "Bitcoin Dominance Token 31 March 2021",
      symbol: "BTCDOM-MAR2021",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x4e83b6287588a96321b2661c5e041845ff7814af",
      name: "Altcoin Dominance Token 31 March 2021",
      symbol: "ALTDOM-MAR2021",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x59fec83ec709c893aedd1a144cf1828eb04127cd",
      name: "pxGOLD Synthetic GOLD Expiring 31 May 2021",
      symbol: "pxGOLD_MAY2021",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x89337BFb7938804c3776C9FB921EccAf5ab76758",
      name: "Compound Annualized Rate Future Expiring 28 March 2021",
      symbol: "CAR-USDC-MAR21",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0xec58d3aefc9aaa2e0036fa65f70d569f49d9d1ed",
      name: "uSTONKS Index Token April 2021",
      symbol: "uSTONKS_APR21",
      decimals: 6
    },
    {
      chainId: 1,
      address: "0xa6B9d7E3d76cF23549293Fb22c488E0Ea591A44e",
      name: "uGAS-JUN21 Token Expiring 30 Jun 2021",
      symbol: "uGAS-JUN21",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0xe813b65da6c38a04591aed3f082d32db7d53c382",
      name: "Yield Dollar [WETH Dec 2021]",
      symbol: "YD-ETH-DEC21",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x4b606e9eb2228c70f44453afe5a73e1fea258ce1",
      name: "pxUSD Synthetic USD Expiring 31 Mar 2022",
      symbol: "pxUSD_MAR2022",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x5247c0db4044fb6f97f32c7e1b48758019a5a912",
      name: "pxGOLD Synthetic Gold Expiring 31 Mar 2022",
      symbol: "pxGOLD_MAR2022",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x56fb1acaff95c0b6ebcd17c8361a63d98b1a5a11",
      name: "uForex CNYUSD Synthetic Token April 2021",
      symbol: "uCNYUSD-APR",
      decimals: 6
    },
    {
      chainId: 1,
      address: "0xd49fa405dce086c65d66ca1ca41f8e98583812b4",
      name: "uForex EURUSD Synthetic Token April 2021",
      symbol: "uEURUSD-APR",
      decimals: 6
    },
    {
      chainId: 1,
      address: "0x29dddacba3b231ee8d673dd0f0fa759ea145561b",
      name: "DEFI_PULSE_TOTAL_TVL Synthetic Token Expiring 15 April 2021",
      symbol: "TVL_ALL_APRIL15",
      decimals: 6
    },
    {
      chainId: 1,
      address: "0xcbe430927370e95b4b10cfc702c6017ec7abefc3",
      name: "Yield Dollar [WETH Jun 2021]",
      symbol: "YD-ETH-JUN21",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x4b7fb448df91c8ed973494f8c8c4f12daf3a8521",
      name: "Yield Dollar [renBTC Jun 2021]",
      symbol: "YD-BTC-JUN21",
      decimals: 8
    },
    {
      chainId: 1,
      address: "0x3108c33b6fb38efedaefd8b5f7ca01d5f5c7372d",
      name: "Yield Dollar UMA 21",
      symbol: "yUMA21",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x0cae9e4d663793c2a2A0b211c1Cf4bBca2B9cAa7",
      name: "Mirrored Amazon",
      symbol: "MAMZN",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x31c63146a635EB7465e5853020b39713AC356991",
      name: "M US Oil",
      symbol: "MUSO",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x59A921Db27Dd6d4d974745B7FfC5c33932653442",
      name: "M Google",
      symbol: "MGOOGL",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0xf72FCd9DCF0190923Fadd44811E240Ef4533fc86",
      name: "Mirrored ProShares",
      symbol: "MVIXY",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x56aA298a19C93c6801FDde870fA63EF75Cc0aF72",
      name: "Mirrored Alibaba",
      symbol: "MBABA",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x0e99cC0535BB6251F6679Fa6E65d6d3b430e840B",
      name: "Mirrored Facebook",
      symbol: "MFB",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x13B02c8dE71680e71F0820c996E4bE43c2F57d15",
      name: "Mirrored Invesco QQ",
      symbol: "MQQQ",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x41BbEDd7286dAab5910a1f15d12CBda839852BD7",
      name: "Mirrored Microsoft",
      symbol: "MMSFT",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x9d1555d8cB3C846Bb4f7D5B1B1080872c3166676",
      name: "Mirrored iShares Si",
      symbol: "MSLV",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x21cA39943E91d704678F5D00b6616650F066fD63",
      name: "Mirrored Tesla",
      symbol: "MTSLA",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0xe82bbB62fA81d0701643d1675FB50ec52fD3Df92",
      name: "DYDX Token",
      symbol: "DYDX",
      decimals: 18
    },
    {
      chainId: 10,
      address: "0xE405de8F52ba7559f9df3C368500B6E6ae6Cee49",
      name: "sETH",
      symbol: "Synth Ether",
      decimals: 18
    },
    {
      chainId: 10,
      address: "0x298B9B95708152ff6968aafd889c6586e9169f1D",
      name: "sBTC",
      symbol: "Synth Bitcoin",
      decimals: 18
    },
    {
      chainId: 10,
      address: "0xc5Db22719A06418028A40A9B5E9A7c02959D0d08",
      name: "sLINK",
      symbol: "Synth Link",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x6B60eE11b73230045cF9095E6e43AE9Ea638e172",
      name: "Shatner",
      symbol: "SHAT",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x7277a44D1325D81Ac58893002a1B40a41bea43fe",
      name: "FAANG Index",
      symbol: "FAANG",
      decimals: 18
    },
    {
      chainId: 1,
      address: "0x76175599887730786bdA1545D0D7AcE8737fEBB1",
      name: "ENS DAO",
      symbol: "ENS",
      decimals: 18
    }
  ]
};
const DEFAULT_ROUTING_CONFIG_BY_CHAIN = (chainId2) => {
  switch (chainId2) {
    case ChainId$2.OPTIMISM:
    case ChainId$2.OPTIMISTIC_KOVAN:
      return {
        v2PoolSelection: {
          topN: 3,
          topNDirectSwaps: 1,
          topNTokenInOut: 5,
          topNSecondHop: 2,
          topNWithEachBaseToken: 2,
          topNWithBaseToken: 6
        },
        v3PoolSelection: {
          topN: 2,
          topNDirectSwaps: 2,
          topNTokenInOut: 2,
          topNSecondHop: 1,
          topNWithEachBaseToken: 3,
          topNWithBaseToken: 3
        },
        maxSwapsPerPath: 3,
        minSplits: 1,
        maxSplits: 7,
        distributionPercent: 10,
        forceCrossProtocol: false
      };
    case ChainId$2.ARBITRUM_ONE:
    case ChainId$2.ARBITRUM_RINKEBY:
    case ChainId$2.CELO:
    case ChainId$2.CELO_ALFAJORES:
      return {
        v2PoolSelection: {
          topN: 3,
          topNDirectSwaps: 1,
          topNTokenInOut: 5,
          topNSecondHop: 2,
          topNWithEachBaseToken: 2,
          topNWithBaseToken: 6
        },
        v3PoolSelection: {
          topN: 2,
          topNDirectSwaps: 2,
          topNTokenInOut: 2,
          topNSecondHop: 1,
          topNWithEachBaseToken: 3,
          topNWithBaseToken: 2
        },
        maxSwapsPerPath: 2,
        minSplits: 1,
        maxSplits: 7,
        distributionPercent: 25,
        forceCrossProtocol: false
      };
    default:
      return {
        v2PoolSelection: {
          topN: 3,
          topNDirectSwaps: 1,
          topNTokenInOut: 5,
          topNSecondHop: 2,
          topNWithEachBaseToken: 2,
          topNWithBaseToken: 6
        },
        v3PoolSelection: {
          topN: 2,
          topNDirectSwaps: 2,
          topNTokenInOut: 3,
          topNSecondHop: 1,
          topNWithEachBaseToken: 3,
          topNWithBaseToken: 5
        },
        maxSwapsPerPath: 3,
        minSplits: 1,
        maxSplits: 7,
        distributionPercent: 5,
        forceCrossProtocol: false
      };
  }
};
const ETH_GAS_STATION_API_URL = "https://ethgasstation.info/api/ethgasAPI.json";
class V2RouteWithValidQuote {
  constructor({ amount, rawQuote, percent, route, gasModel, quoteToken, tradeType, v2PoolProvider }) {
    this.protocol = distExports.Protocol.V2;
    this.amount = amount;
    this.rawQuote = rawQuote;
    this.quote = CurrencyAmount$2.fromRawAmount(quoteToken, rawQuote.toString());
    this.percent = percent;
    this.route = route;
    this.gasModel = gasModel;
    this.quoteToken = quoteToken;
    this.tradeType = tradeType;
    const { gasEstimate, gasCostInToken, gasCostInUSD } = this.gasModel.estimateGasCost(this);
    this.gasCostInToken = gasCostInToken;
    this.gasCostInUSD = gasCostInUSD;
    this.gasEstimate = gasEstimate;
    if (this.tradeType == TradeType$3.EXACT_INPUT) {
      const quoteGasAdjusted = this.quote.subtract(gasCostInToken);
      this.quoteAdjustedForGas = quoteGasAdjusted;
    } else {
      const quoteGasAdjusted = this.quote.add(gasCostInToken);
      this.quoteAdjustedForGas = quoteGasAdjusted;
    }
    this.poolAddresses = _$3.map(route.pairs, (p2) => v2PoolProvider.getPoolAddress(p2.token0, p2.token1).poolAddress);
    this.tokenPath = this.route.path;
  }
  toString() {
    return `${this.percent.toFixed(2)}% QuoteGasAdj[${this.quoteAdjustedForGas.toExact()}] Quote[${this.quote.toExact()}] Gas[${this.gasEstimate.toString()}] = ${routeToString(this.route)}`;
  }
}
class V3RouteWithValidQuote {
  constructor({ amount, rawQuote, sqrtPriceX96AfterList, initializedTicksCrossedList, quoterGasEstimate, percent, route, gasModel, quoteToken, tradeType, v3PoolProvider }) {
    this.protocol = distExports.Protocol.V3;
    this.amount = amount;
    this.rawQuote = rawQuote;
    this.sqrtPriceX96AfterList = sqrtPriceX96AfterList;
    this.initializedTicksCrossedList = initializedTicksCrossedList;
    this.quoterGasEstimate = quoterGasEstimate;
    this.quote = CurrencyAmount$2.fromRawAmount(quoteToken, rawQuote.toString());
    this.percent = percent;
    this.route = route;
    this.gasModel = gasModel;
    this.quoteToken = quoteToken;
    this.tradeType = tradeType;
    const { gasEstimate, gasCostInToken, gasCostInUSD } = this.gasModel.estimateGasCost(this);
    this.gasCostInToken = gasCostInToken;
    this.gasCostInUSD = gasCostInUSD;
    this.gasEstimate = gasEstimate;
    if (this.tradeType == TradeType$3.EXACT_INPUT) {
      const quoteGasAdjusted = this.quote.subtract(gasCostInToken);
      this.quoteAdjustedForGas = quoteGasAdjusted;
    } else {
      const quoteGasAdjusted = this.quote.add(gasCostInToken);
      this.quoteAdjustedForGas = quoteGasAdjusted;
    }
    this.poolAddresses = _$3.map(route.pools, (p2) => v3PoolProvider.getPoolAddress(p2.token0, p2.token1, p2.fee).poolAddress);
    this.tokenPath = this.route.tokenPath;
  }
  toString() {
    return `${this.percent.toFixed(2)}% QuoteGasAdj[${this.quoteAdjustedForGas.toExact()}] Quote[${this.quote.toExact()}] Gas[${this.gasEstimate.toString()}] = ${routeToString(this.route)}`;
  }
}
class MixedRouteWithValidQuote {
  constructor({ amount, rawQuote, sqrtPriceX96AfterList, initializedTicksCrossedList, quoterGasEstimate, percent, route, mixedRouteGasModel, quoteToken, tradeType, v3PoolProvider, v2PoolProvider }) {
    this.protocol = distExports.Protocol.MIXED;
    this.amount = amount;
    this.rawQuote = rawQuote;
    this.sqrtPriceX96AfterList = sqrtPriceX96AfterList;
    this.initializedTicksCrossedList = initializedTicksCrossedList;
    this.quoterGasEstimate = quoterGasEstimate;
    this.quote = CurrencyAmount$2.fromRawAmount(quoteToken, rawQuote.toString());
    this.percent = percent;
    this.route = route;
    this.gasModel = mixedRouteGasModel;
    this.quoteToken = quoteToken;
    this.tradeType = tradeType;
    const { gasEstimate, gasCostInToken, gasCostInUSD } = this.gasModel.estimateGasCost(this);
    this.gasCostInToken = gasCostInToken;
    this.gasCostInUSD = gasCostInUSD;
    this.gasEstimate = gasEstimate;
    if (this.tradeType == TradeType$3.EXACT_INPUT) {
      const quoteGasAdjusted = this.quote.subtract(gasCostInToken);
      this.quoteAdjustedForGas = quoteGasAdjusted;
    } else {
      const quoteGasAdjusted = this.quote.add(gasCostInToken);
      this.quoteAdjustedForGas = quoteGasAdjusted;
    }
    this.poolAddresses = _$3.map(route.pools, (p2) => {
      return p2 instanceof Pool ? v3PoolProvider.getPoolAddress(p2.token0, p2.token1, p2.fee).poolAddress : v2PoolProvider.getPoolAddress(p2.token0, p2.token1).poolAddress;
    });
    this.tokenPath = this.route.path;
  }
  toString() {
    return `${this.percent.toFixed(2)}% QuoteGasAdj[${this.quoteAdjustedForGas.toExact()}] Quote[${this.quote.toExact()}] Gas[${this.gasEstimate.toString()}] = ${routeToString(this.route)}`;
  }
}
var comparators$2 = {};
var DEFAULT_COMPARATOR$2 = function(a2, b3) {
  if (a2 < b3)
    return -1;
  if (a2 > b3)
    return 1;
  return 0;
};
var DEFAULT_REVERSE_COMPARATOR = function(a2, b3) {
  if (a2 < b3)
    return 1;
  if (a2 > b3)
    return -1;
  return 0;
};
function reverseComparator$2(comparator) {
  return function(a2, b3) {
    return comparator(b3, a2);
  };
}
function createTupleComparator(size2) {
  if (size2 === 2) {
    return function(a2, b3) {
      if (a2[0] < b3[0])
        return -1;
      if (a2[0] > b3[0])
        return 1;
      if (a2[1] < b3[1])
        return -1;
      if (a2[1] > b3[1])
        return 1;
      return 0;
    };
  }
  return function(a2, b3) {
    var i3 = 0;
    while (i3 < size2) {
      if (a2[i3] < b3[i3])
        return -1;
      if (a2[i3] > b3[i3])
        return 1;
      i3++;
    }
    return 0;
  };
}
comparators$2.DEFAULT_COMPARATOR = DEFAULT_COMPARATOR$2;
comparators$2.DEFAULT_REVERSE_COMPARATOR = DEFAULT_REVERSE_COMPARATOR;
comparators$2.reverseComparator = reverseComparator$2;
comparators$2.createTupleComparator = createTupleComparator;
var support$1 = {};
support$1.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== "undefined";
support$1.SYMBOL_SUPPORT = typeof Symbol !== "undefined";
var support = support$1;
var ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;
var SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;
var foreach = function forEach2(iterable, callback) {
  var iterator2, k4, i3, l2, s4;
  if (!iterable)
    throw new Error("obliterator/forEach: invalid iterable.");
  if (typeof callback !== "function")
    throw new Error("obliterator/forEach: expecting a callback.");
  if (Array.isArray(iterable) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable) || typeof iterable === "string" || iterable.toString() === "[object Arguments]") {
    for (i3 = 0, l2 = iterable.length; i3 < l2; i3++)
      callback(iterable[i3], i3);
    return;
  }
  if (typeof iterable.forEach === "function") {
    iterable.forEach(callback);
    return;
  }
  if (SYMBOL_SUPPORT && Symbol.iterator in iterable && typeof iterable.next !== "function") {
    iterable = iterable[Symbol.iterator]();
  }
  if (typeof iterable.next === "function") {
    iterator2 = iterable;
    i3 = 0;
    while (s4 = iterator2.next(), s4.done !== true) {
      callback(s4.value, i3);
      i3++;
    }
    return;
  }
  for (k4 in iterable) {
    if (iterable.hasOwnProperty(k4)) {
      callback(iterable[k4], k4);
    }
  }
  return;
};
var iterables$1 = {};
var typedArrays = {};
(function(exports) {
  var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1, MAX_16BIT_INTEGER = Math.pow(2, 16) - 1, MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;
  var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1, MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1, MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;
  exports.getPointerArray = function(size2) {
    var maxIndex = size2 - 1;
    if (maxIndex <= MAX_8BIT_INTEGER)
      return Uint8Array;
    if (maxIndex <= MAX_16BIT_INTEGER)
      return Uint16Array;
    if (maxIndex <= MAX_32BIT_INTEGER)
      return Uint32Array;
    throw new Error("mnemonist: Pointer Array of size > 4294967295 is not supported.");
  };
  exports.getSignedPointerArray = function(size2) {
    var maxIndex = size2 - 1;
    if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)
      return Int8Array;
    if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)
      return Int16Array;
    if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)
      return Int32Array;
    return Float64Array;
  };
  exports.getNumberType = function(value) {
    if (value === (value | 0)) {
      if (Math.sign(value) === -1) {
        if (value <= 127 && value >= -128)
          return Int8Array;
        if (value <= 32767 && value >= -32768)
          return Int16Array;
        return Int32Array;
      } else {
        if (value <= 255)
          return Uint8Array;
        if (value <= 65535)
          return Uint16Array;
        return Uint32Array;
      }
    }
    return Float64Array;
  };
  var TYPE_PRIORITY = {
    Uint8Array: 1,
    Int8Array: 2,
    Uint16Array: 3,
    Int16Array: 4,
    Uint32Array: 5,
    Int32Array: 6,
    Float32Array: 7,
    Float64Array: 8
  };
  exports.getMinimalRepresentation = function(array, getter) {
    var maxType = null, maxPriority = 0, p2, t2, v2, i3, l2;
    for (i3 = 0, l2 = array.length; i3 < l2; i3++) {
      v2 = getter ? getter(array[i3]) : array[i3];
      t2 = exports.getNumberType(v2);
      p2 = TYPE_PRIORITY[t2.name];
      if (p2 > maxPriority) {
        maxPriority = p2;
        maxType = t2;
      }
    }
    return maxType;
  };
  exports.isTypedArray = function(value) {
    return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(value);
  };
  exports.concat = function() {
    var length2 = 0, i3, o2, l2;
    for (i3 = 0, l2 = arguments.length; i3 < l2; i3++)
      length2 += arguments[i3].length;
    var array = new arguments[0].constructor(length2);
    for (i3 = 0, o2 = 0; i3 < l2; i3++) {
      array.set(arguments[i3], o2);
      o2 += arguments[i3].length;
    }
    return array;
  };
  exports.indices = function(length2) {
    var PointerArray = exports.getPointerArray(length2);
    var array = new PointerArray(length2);
    for (var i3 = 0; i3 < length2; i3++)
      array[i3] = i3;
    return array;
  };
})(typedArrays);
var forEach$2 = foreach;
var typed = typedArrays;
function isArrayLike(target) {
  return Array.isArray(target) || typed.isTypedArray(target);
}
function guessLength(target) {
  if (typeof target.length === "number")
    return target.length;
  if (typeof target.size === "number")
    return target.size;
  return;
}
function toArray(target) {
  var l2 = guessLength(target);
  var array = typeof l2 === "number" ? new Array(l2) : [];
  var i3 = 0;
  forEach$2(target, function(value) {
    array[i3++] = value;
  });
  return array;
}
function toArrayWithIndices(target) {
  var l2 = guessLength(target);
  var IndexArray = typeof l2 === "number" ? typed.getPointerArray(l2) : Array;
  var array = typeof l2 === "number" ? new Array(l2) : [];
  var indices = typeof l2 === "number" ? new IndexArray(l2) : [];
  var i3 = 0;
  forEach$2(target, function(value) {
    array[i3] = value;
    indices[i3] = i3++;
  });
  return [array, indices];
}
iterables$1.isArrayLike = isArrayLike;
iterables$1.guessLength = guessLength;
iterables$1.toArray = toArray;
iterables$1.toArrayWithIndices = toArrayWithIndices;
var forEach$1 = foreach, comparators$1 = comparators$2, iterables = iterables$1;
var DEFAULT_COMPARATOR$1 = comparators$1.DEFAULT_COMPARATOR, reverseComparator$1 = comparators$1.reverseComparator;
function siftDown(compare2, heap2, startIndex, i3) {
  var item = heap2[i3], parentIndex, parent2;
  while (i3 > startIndex) {
    parentIndex = i3 - 1 >> 1;
    parent2 = heap2[parentIndex];
    if (compare2(item, parent2) < 0) {
      heap2[i3] = parent2;
      i3 = parentIndex;
      continue;
    }
    break;
  }
  heap2[i3] = item;
}
function siftUp$1(compare2, heap2, i3) {
  var endIndex = heap2.length, startIndex = i3, item = heap2[i3], childIndex = 2 * i3 + 1, rightIndex;
  while (childIndex < endIndex) {
    rightIndex = childIndex + 1;
    if (rightIndex < endIndex && compare2(heap2[childIndex], heap2[rightIndex]) >= 0) {
      childIndex = rightIndex;
    }
    heap2[i3] = heap2[childIndex];
    i3 = childIndex;
    childIndex = 2 * i3 + 1;
  }
  heap2[i3] = item;
  siftDown(compare2, heap2, startIndex, i3);
}
function push(compare2, heap2, item) {
  heap2.push(item);
  siftDown(compare2, heap2, 0, heap2.length - 1);
}
function pop(compare2, heap2) {
  var lastItem = heap2.pop();
  if (heap2.length !== 0) {
    var item = heap2[0];
    heap2[0] = lastItem;
    siftUp$1(compare2, heap2, 0);
    return item;
  }
  return lastItem;
}
function replace(compare2, heap2, item) {
  if (heap2.length === 0)
    throw new Error("mnemonist/heap.replace: cannot pop an empty heap.");
  var popped = heap2[0];
  heap2[0] = item;
  siftUp$1(compare2, heap2, 0);
  return popped;
}
function pushpop(compare2, heap2, item) {
  var tmp;
  if (heap2.length !== 0 && compare2(heap2[0], item) < 0) {
    tmp = heap2[0];
    heap2[0] = item;
    item = tmp;
    siftUp$1(compare2, heap2, 0);
  }
  return item;
}
function heapify(compare2, array) {
  var n4 = array.length, l2 = n4 >> 1, i3 = l2;
  while (--i3 >= 0)
    siftUp$1(compare2, array, i3);
}
function consume$1(compare2, heap2) {
  var l2 = heap2.length, i3 = 0;
  var array = new Array(l2);
  while (i3 < l2)
    array[i3++] = pop(compare2, heap2);
  return array;
}
function nsmallest(compare2, n4, iterable) {
  if (arguments.length === 2) {
    iterable = n4;
    n4 = compare2;
    compare2 = DEFAULT_COMPARATOR$1;
  }
  var reverseCompare = reverseComparator$1(compare2);
  var i3, l2, v2;
  var min = Infinity;
  var result;
  if (n4 === 1) {
    if (iterables.isArrayLike(iterable)) {
      for (i3 = 0, l2 = iterable.length; i3 < l2; i3++) {
        v2 = iterable[i3];
        if (min === Infinity || compare2(v2, min) < 0)
          min = v2;
      }
      result = new iterable.constructor(1);
      result[0] = min;
      return result;
    }
    forEach$1(iterable, function(value) {
      if (min === Infinity || compare2(value, min) < 0)
        min = value;
    });
    return [min];
  }
  if (iterables.isArrayLike(iterable)) {
    if (n4 >= iterable.length)
      return iterable.slice().sort(compare2);
    result = iterable.slice(0, n4);
    heapify(reverseCompare, result);
    for (i3 = n4, l2 = iterable.length; i3 < l2; i3++)
      if (reverseCompare(iterable[i3], result[0]) > 0)
        replace(reverseCompare, result, iterable[i3]);
    return result.sort(compare2);
  }
  var size2 = iterables.guessLength(iterable);
  if (size2 !== null && size2 < n4)
    n4 = size2;
  result = new Array(n4);
  i3 = 0;
  forEach$1(iterable, function(value) {
    if (i3 < n4) {
      result[i3] = value;
    } else {
      if (i3 === n4)
        heapify(reverseCompare, result);
      if (reverseCompare(value, result[0]) > 0)
        replace(reverseCompare, result, value);
    }
    i3++;
  });
  if (result.length > i3)
    result.length = i3;
  return result.sort(compare2);
}
function nlargest(compare2, n4, iterable) {
  if (arguments.length === 2) {
    iterable = n4;
    n4 = compare2;
    compare2 = DEFAULT_COMPARATOR$1;
  }
  var reverseCompare = reverseComparator$1(compare2);
  var i3, l2, v2;
  var max = -Infinity;
  var result;
  if (n4 === 1) {
    if (iterables.isArrayLike(iterable)) {
      for (i3 = 0, l2 = iterable.length; i3 < l2; i3++) {
        v2 = iterable[i3];
        if (max === -Infinity || compare2(v2, max) > 0)
          max = v2;
      }
      result = new iterable.constructor(1);
      result[0] = max;
      return result;
    }
    forEach$1(iterable, function(value) {
      if (max === -Infinity || compare2(value, max) > 0)
        max = value;
    });
    return [max];
  }
  if (iterables.isArrayLike(iterable)) {
    if (n4 >= iterable.length)
      return iterable.slice().sort(reverseCompare);
    result = iterable.slice(0, n4);
    heapify(compare2, result);
    for (i3 = n4, l2 = iterable.length; i3 < l2; i3++)
      if (compare2(iterable[i3], result[0]) > 0)
        replace(compare2, result, iterable[i3]);
    return result.sort(reverseCompare);
  }
  var size2 = iterables.guessLength(iterable);
  if (size2 !== null && size2 < n4)
    n4 = size2;
  result = new Array(n4);
  i3 = 0;
  forEach$1(iterable, function(value) {
    if (i3 < n4) {
      result[i3] = value;
    } else {
      if (i3 === n4)
        heapify(compare2, result);
      if (compare2(value, result[0]) > 0)
        replace(compare2, result, value);
    }
    i3++;
  });
  if (result.length > i3)
    result.length = i3;
  return result.sort(reverseCompare);
}
function Heap$1(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR$1;
  if (typeof this.comparator !== "function")
    throw new Error("mnemonist/Heap.constructor: given comparator should be a function.");
}
Heap$1.prototype.clear = function() {
  this.items = [];
  this.size = 0;
};
Heap$1.prototype.push = function(item) {
  push(this.comparator, this.items, item);
  return ++this.size;
};
Heap$1.prototype.peek = function() {
  return this.items[0];
};
Heap$1.prototype.pop = function() {
  if (this.size !== 0)
    this.size--;
  return pop(this.comparator, this.items);
};
Heap$1.prototype.replace = function(item) {
  return replace(this.comparator, this.items, item);
};
Heap$1.prototype.pushpop = function(item) {
  return pushpop(this.comparator, this.items, item);
};
Heap$1.prototype.consume = function() {
  this.size = 0;
  return consume$1(this.comparator, this.items);
};
Heap$1.prototype.toArray = function() {
  return consume$1(this.comparator, this.items.slice());
};
Heap$1.prototype.inspect = function() {
  var proxy2 = this.toArray();
  Object.defineProperty(proxy2, "constructor", {
    value: Heap$1,
    enumerable: false
  });
  return proxy2;
};
if (typeof Symbol !== "undefined")
  Heap$1.prototype[Symbol.for("nodejs.util.inspect.custom")] = Heap$1.prototype.inspect;
function MaxHeap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR$1;
  if (typeof this.comparator !== "function")
    throw new Error("mnemonist/MaxHeap.constructor: given comparator should be a function.");
  this.comparator = reverseComparator$1(this.comparator);
}
MaxHeap.prototype = Heap$1.prototype;
Heap$1.from = function(iterable, comparator) {
  var heap2 = new Heap$1(comparator);
  var items;
  if (iterables.isArrayLike(iterable))
    items = iterable.slice();
  else
    items = iterables.toArray(iterable);
  heapify(heap2.comparator, items);
  heap2.items = items;
  heap2.size = items.length;
  return heap2;
};
MaxHeap.from = function(iterable, comparator) {
  var heap2 = new MaxHeap(comparator);
  var items;
  if (iterables.isArrayLike(iterable))
    items = iterable.slice();
  else
    items = iterables.toArray(iterable);
  heapify(heap2.comparator, items);
  heap2.items = items;
  heap2.size = items.length;
  return heap2;
};
Heap$1.siftUp = siftUp$1;
Heap$1.siftDown = siftDown;
Heap$1.push = push;
Heap$1.pop = pop;
Heap$1.replace = replace;
Heap$1.pushpop = pushpop;
Heap$1.heapify = heapify;
Heap$1.consume = consume$1;
Heap$1.nsmallest = nsmallest;
Heap$1.nlargest = nlargest;
Heap$1.MinHeap = Heap$1;
Heap$1.MaxHeap = MaxHeap;
var heap = Heap$1;
var comparators = comparators$2, Heap = heap;
var DEFAULT_COMPARATOR = comparators.DEFAULT_COMPARATOR, reverseComparator = comparators.reverseComparator;
function siftUp(compare2, heap2, size2, i3) {
  var endIndex = size2, startIndex = i3, item = heap2[i3], childIndex = 2 * i3 + 1, rightIndex;
  while (childIndex < endIndex) {
    rightIndex = childIndex + 1;
    if (rightIndex < endIndex && compare2(heap2[childIndex], heap2[rightIndex]) >= 0) {
      childIndex = rightIndex;
    }
    heap2[i3] = heap2[childIndex];
    i3 = childIndex;
    childIndex = 2 * i3 + 1;
  }
  heap2[i3] = item;
  Heap.siftDown(compare2, heap2, startIndex, i3);
}
function consume(ArrayClass, compare2, heap2, size2) {
  var l2 = size2, i3 = l2;
  var array = new ArrayClass(size2), lastItem, item;
  while (i3 > 0) {
    lastItem = heap2[--i3];
    if (i3 !== 0) {
      item = heap2[0];
      heap2[0] = lastItem;
      siftUp(compare2, heap2, --size2, 0);
      lastItem = item;
    }
    array[i3] = lastItem;
  }
  return array;
}
function FixedReverseHeap(ArrayClass, comparator, capacity) {
  if (arguments.length === 2) {
    capacity = comparator;
    comparator = null;
  }
  this.ArrayClass = ArrayClass;
  this.capacity = capacity;
  this.items = new ArrayClass(capacity);
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;
  if (typeof capacity !== "number" && capacity <= 0)
    throw new Error("mnemonist/FixedReverseHeap.constructor: capacity should be a number > 0.");
  if (typeof this.comparator !== "function")
    throw new Error("mnemonist/FixedReverseHeap.constructor: given comparator should be a function.");
  this.comparator = reverseComparator(this.comparator);
}
FixedReverseHeap.prototype.clear = function() {
  this.size = 0;
};
FixedReverseHeap.prototype.push = function(item) {
  if (this.size < this.capacity) {
    this.items[this.size] = item;
    Heap.siftDown(this.comparator, this.items, 0, this.size);
    this.size++;
  } else {
    if (this.comparator(item, this.items[0]) > 0)
      Heap.replace(this.comparator, this.items, item);
  }
  return this.size;
};
FixedReverseHeap.prototype.peek = function() {
  return this.items[0];
};
FixedReverseHeap.prototype.consume = function() {
  var items = consume(this.ArrayClass, this.comparator, this.items, this.size);
  this.size = 0;
  return items;
};
FixedReverseHeap.prototype.toArray = function() {
  return consume(this.ArrayClass, this.comparator, this.items.slice(0, this.size), this.size);
};
FixedReverseHeap.prototype.inspect = function() {
  var proxy2 = this.toArray();
  Object.defineProperty(proxy2, "constructor", {
    value: FixedReverseHeap,
    enumerable: false
  });
  return proxy2;
};
if (typeof Symbol !== "undefined")
  FixedReverseHeap.prototype[Symbol.for("nodejs.util.inspect.custom")] = FixedReverseHeap.prototype.inspect;
var fixedReverseHeap = FixedReverseHeap;
const FixedReverseHeap$1 = /* @__PURE__ */ getDefaultExportFromCjs(fixedReverseHeap);
function Iterator$1(next2) {
  if (typeof next2 !== "function")
    throw new Error("obliterator/iterator: expecting a function!");
  this.next = next2;
}
if (typeof Symbol !== "undefined")
  Iterator$1.prototype[Symbol.iterator] = function() {
    return this;
  };
Iterator$1.of = function() {
  var args = arguments, l2 = args.length, i3 = 0;
  return new Iterator$1(function() {
    if (i3 >= l2)
      return { done: true };
    return { done: false, value: args[i3++] };
  });
};
Iterator$1.empty = function() {
  var iterator2 = new Iterator$1(function() {
    return { done: true };
  });
  return iterator2;
};
Iterator$1.fromSequence = function(sequence) {
  var i3 = 0, l2 = sequence.length;
  return new Iterator$1(function() {
    if (i3 >= l2)
      return { done: true };
    return { done: false, value: sequence[i3++] };
  });
};
Iterator$1.is = function(value) {
  if (value instanceof Iterator$1)
    return true;
  return typeof value === "object" && value !== null && typeof value.next === "function";
};
var iterator = Iterator$1;
var Iterator = iterator, forEach3 = foreach;
function Queue() {
  this.clear();
}
Queue.prototype.clear = function() {
  this.items = [];
  this.offset = 0;
  this.size = 0;
};
Queue.prototype.enqueue = function(item) {
  this.items.push(item);
  return ++this.size;
};
Queue.prototype.dequeue = function() {
  if (!this.size)
    return;
  var item = this.items[this.offset];
  if (++this.offset * 2 >= this.items.length) {
    this.items = this.items.slice(this.offset);
    this.offset = 0;
  }
  this.size--;
  return item;
};
Queue.prototype.peek = function() {
  if (!this.size)
    return;
  return this.items[this.offset];
};
Queue.prototype.forEach = function(callback, scope) {
  scope = arguments.length > 1 ? scope : this;
  for (var i3 = this.offset, j2 = 0, l2 = this.items.length; i3 < l2; i3++, j2++)
    callback.call(scope, this.items[i3], j2, this);
};
Queue.prototype.toArray = function() {
  return this.items.slice(this.offset);
};
Queue.prototype.values = function() {
  var items = this.items, i3 = this.offset;
  return new Iterator(function() {
    if (i3 >= items.length)
      return {
        done: true
      };
    var value = items[i3];
    i3++;
    return {
      value,
      done: false
    };
  });
};
Queue.prototype.entries = function() {
  var items = this.items, i3 = this.offset, j2 = 0;
  return new Iterator(function() {
    if (i3 >= items.length)
      return {
        done: true
      };
    var value = items[i3];
    i3++;
    return {
      value: [j2++, value],
      done: false
    };
  });
};
if (typeof Symbol !== "undefined")
  Queue.prototype[Symbol.iterator] = Queue.prototype.values;
Queue.prototype.toString = function() {
  return this.toArray().join(",");
};
Queue.prototype.toJSON = function() {
  return this.toArray();
};
Queue.prototype.inspect = function() {
  var array = this.toArray();
  Object.defineProperty(array, "constructor", {
    value: Queue,
    enumerable: false
  });
  return array;
};
if (typeof Symbol !== "undefined")
  Queue.prototype[Symbol.for("nodejs.util.inspect.custom")] = Queue.prototype.inspect;
Queue.from = function(iterable) {
  var queue2 = new Queue();
  forEach3(iterable, function(value) {
    queue2.enqueue(value);
  });
  return queue2;
};
Queue.of = function() {
  return Queue.from(arguments);
};
var queue = Queue;
const Queue$1 = /* @__PURE__ */ getDefaultExportFromCjs(queue);
const usdGasTokensByChain = {
  [ChainId$2.MAINNET]: [DAI_MAINNET, USDC_MAINNET, USDT_MAINNET],
  [ChainId$2.RINKEBY]: [DAI_RINKEBY_1, DAI_RINKEBY_2],
  [ChainId$2.ARBITRUM_ONE]: [DAI_ARBITRUM, USDC_ARBITRUM, USDT_ARBITRUM],
  [ChainId$2.OPTIMISM]: [DAI_OPTIMISM, USDC_OPTIMISM, USDT_OPTIMISM],
  [ChainId$2.OPTIMISTIC_KOVAN]: [
    DAI_OPTIMISTIC_KOVAN,
    USDC_OPTIMISTIC_KOVAN,
    USDT_OPTIMISTIC_KOVAN
  ],
  [ChainId$2.ARBITRUM_RINKEBY]: [DAI_ARBITRUM_RINKEBY, USDT_ARBITRUM_RINKEBY],
  [ChainId$2.KOVAN]: [DAI_KOVAN, USDC_KOVAN, USDT_KOVAN],
  [ChainId$2.GRLI]: [DAI_GRLI, USDC_GRLI, USDT_GRLI, WBTC_GRLI],
  [ChainId$2.ROPSTEN]: [DAI_ROPSTEN, USDC_ROPSTEN, USDT_ROPSTEN],
  [ChainId$2.POLYGON]: [USDC_POLYGON],
  [ChainId$2.POLYGON_MUMBAI]: [DAI_POLYGON_MUMBAI],
  [ChainId$2.CELO]: [CUSD_CELO],
  [ChainId$2.CELO_ALFAJORES]: [CUSD_CELO_ALFAJORES],
  [ChainId$2.GNOSIS]: [USDC_ETHEREUM_GNOSIS],
  [ChainId$2.MOONBEAM]: [USDC_MOONBEAM]
};
class IV2GasModelFactory {
}
class IOnChainGasModelFactory {
}
const COST_PER_UNINIT_TICK = BigNumber.from(0);
const BASE_SWAP_COST$1 = (id2) => {
  switch (id2) {
    case ChainId$2.MAINNET:
    case ChainId$2.ROPSTEN:
    case ChainId$2.RINKEBY:
    case ChainId$2.GRLI:
    case ChainId$2.OPTIMISM:
    case ChainId$2.OPTIMISTIC_KOVAN:
    case ChainId$2.KOVAN:
      return BigNumber.from(2e3);
    case ChainId$2.ARBITRUM_ONE:
    case ChainId$2.ARBITRUM_RINKEBY:
      return BigNumber.from(5e3);
    case ChainId$2.POLYGON:
    case ChainId$2.POLYGON_MUMBAI:
      return BigNumber.from(2e3);
    case ChainId$2.CELO:
    case ChainId$2.CELO_ALFAJORES:
      return BigNumber.from(2e3);
    case ChainId$2.GNOSIS:
      return BigNumber.from(2e3);
    case ChainId$2.MOONBEAM:
      return BigNumber.from(2e3);
  }
};
const COST_PER_INIT_TICK = (id2) => {
  switch (id2) {
    case ChainId$2.MAINNET:
    case ChainId$2.ROPSTEN:
    case ChainId$2.RINKEBY:
    case ChainId$2.GRLI:
    case ChainId$2.KOVAN:
      return BigNumber.from(31e3);
    case ChainId$2.OPTIMISM:
    case ChainId$2.OPTIMISTIC_KOVAN:
      return BigNumber.from(31e3);
    case ChainId$2.ARBITRUM_ONE:
    case ChainId$2.ARBITRUM_RINKEBY:
      return BigNumber.from(31e3);
    case ChainId$2.POLYGON:
    case ChainId$2.POLYGON_MUMBAI:
      return BigNumber.from(31e3);
    case ChainId$2.CELO:
    case ChainId$2.CELO_ALFAJORES:
      return BigNumber.from(31e3);
    case ChainId$2.GNOSIS:
      return BigNumber.from(31e3);
    case ChainId$2.MOONBEAM:
      return BigNumber.from(31e3);
  }
};
const COST_PER_HOP = (id2) => {
  switch (id2) {
    case ChainId$2.MAINNET:
    case ChainId$2.ROPSTEN:
    case ChainId$2.RINKEBY:
    case ChainId$2.GRLI:
    case ChainId$2.KOVAN:
    case ChainId$2.OPTIMISM:
    case ChainId$2.OPTIMISTIC_KOVAN:
      return BigNumber.from(8e4);
    case ChainId$2.ARBITRUM_ONE:
    case ChainId$2.ARBITRUM_RINKEBY:
      return BigNumber.from(8e4);
    case ChainId$2.POLYGON:
    case ChainId$2.POLYGON_MUMBAI:
      return BigNumber.from(8e4);
    case ChainId$2.CELO:
    case ChainId$2.CELO_ALFAJORES:
      return BigNumber.from(8e4);
    case ChainId$2.GNOSIS:
      return BigNumber.from(8e4);
    case ChainId$2.MOONBEAM:
      return BigNumber.from(8e4);
  }
};
class V3HeuristicGasModelFactory extends IOnChainGasModelFactory {
  constructor() {
    super();
  }
  async buildGasModel({ chainId: chainId2, gasPriceWei, v3poolProvider: poolProvider, token: token2, l2GasDataProvider }) {
    const l2GasData = l2GasDataProvider ? await l2GasDataProvider.getGasData() : void 0;
    const usdPool = await getHighestLiquidityV3USDPool(chainId2, poolProvider);
    const calculateL1GasFees = async (route) => {
      const swapOptions = {
        recipient: "0x0000000000000000000000000000000000000001",
        deadline: 100,
        slippageTolerance: new Percent$3(5, 1e4)
      };
      let l1Used = BigNumber.from(0);
      let l1FeeInWei = BigNumber.from(0);
      if (chainId2 == ChainId$2.OPTIMISM || chainId2 == ChainId$2.OPTIMISTIC_KOVAN) {
        [l1Used, l1FeeInWei] = this.calculateOptimismToL1SecurityFee(route, swapOptions, l2GasData);
      } else if (chainId2 == ChainId$2.ARBITRUM_ONE || chainId2 == ChainId$2.ARBITRUM_RINKEBY) {
        [l1Used, l1FeeInWei] = this.calculateArbitrumToL1SecurityFee(route, swapOptions, l2GasData);
      }
      const nativeCurrency2 = WRAPPED_NATIVE_CURRENCY[chainId2];
      const costNativeCurrency = CurrencyAmount$2.fromRawAmount(nativeCurrency2, l1FeeInWei.toString());
      const nativeTokenPrice = usdPool.token0.address == nativeCurrency2.address ? usdPool.token0Price : usdPool.token1Price;
      const gasCostL1USD = nativeTokenPrice.quote(costNativeCurrency);
      let gasCostL1QuoteToken = costNativeCurrency;
      if (!token2.equals(nativeCurrency2)) {
        const nativePool2 = await getHighestLiquidityV3NativePool(token2, poolProvider);
        if (!nativePool2) {
          log.info("Could not find a pool to convert the cost into the quote token");
          gasCostL1QuoteToken = CurrencyAmount$2.fromRawAmount(token2, 0);
        } else {
          const nativeTokenPrice2 = nativePool2.token0.address == nativeCurrency2.address ? nativePool2.token0Price : nativePool2.token1Price;
          gasCostL1QuoteToken = nativeTokenPrice2.quote(costNativeCurrency);
        }
      }
      return {
        gasUsedL1: l1Used,
        gasCostL1USD,
        gasCostL1QuoteToken
      };
    };
    const nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId2];
    if (token2.equals(nativeCurrency)) {
      const estimateGasCost2 = (routeWithValidQuote) => {
        const { totalGasCostNativeCurrency, baseGasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId2);
        const token0 = usdPool.token0.address == nativeCurrency.address;
        const nativeTokenPrice = token0 ? usdPool.token0Price : usdPool.token1Price;
        const gasCostInTermsOfUSD = nativeTokenPrice.quote(totalGasCostNativeCurrency);
        return {
          gasEstimate: baseGasUse,
          gasCostInToken: totalGasCostNativeCurrency,
          gasCostInUSD: gasCostInTermsOfUSD
        };
      };
      return {
        estimateGasCost: estimateGasCost2,
        calculateL1GasFees
      };
    }
    const nativePool = await getHighestLiquidityV3NativePool(token2, poolProvider);
    const usdToken = usdPool.token0.address == nativeCurrency.address ? usdPool.token1 : usdPool.token0;
    const estimateGasCost = (routeWithValidQuote) => {
      const { totalGasCostNativeCurrency, baseGasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId2);
      if (!nativePool) {
        log.info(`Unable to find ${nativeCurrency.symbol} pool with the quote token, ${token2.symbol} to produce gas adjusted costs. Route will not account for gas.`);
        return {
          gasEstimate: baseGasUse,
          gasCostInToken: CurrencyAmount$2.fromRawAmount(token2, 0),
          gasCostInUSD: CurrencyAmount$2.fromRawAmount(usdToken, 0)
        };
      }
      const token0 = nativePool.token0.address == nativeCurrency.address;
      const nativeTokenPrice = token0 ? nativePool.token0Price : nativePool.token1Price;
      let gasCostInTermsOfQuoteToken;
      try {
        gasCostInTermsOfQuoteToken = nativeTokenPrice.quote(totalGasCostNativeCurrency);
      } catch (err) {
        log.info({
          nativeTokenPriceBase: nativeTokenPrice.baseCurrency,
          nativeTokenPriceQuote: nativeTokenPrice.quoteCurrency,
          gasCostInEth: totalGasCostNativeCurrency.currency
        }, "Debug eth price token issue");
        throw err;
      }
      const token0USDPool = usdPool.token0.address == nativeCurrency.address;
      const nativeTokenPriceUSDPool = token0USDPool ? usdPool.token0Price : usdPool.token1Price;
      let gasCostInTermsOfUSD;
      try {
        gasCostInTermsOfUSD = nativeTokenPriceUSDPool.quote(totalGasCostNativeCurrency);
      } catch (err) {
        log.info({
          usdT1: usdPool.token0.symbol,
          usdT2: usdPool.token1.symbol,
          gasCostInNativeToken: totalGasCostNativeCurrency.currency.symbol
        }, "Failed to compute USD gas price");
        throw err;
      }
      return {
        gasEstimate: baseGasUse,
        gasCostInToken: gasCostInTermsOfQuoteToken,
        gasCostInUSD: gasCostInTermsOfUSD
      };
    };
    return {
      estimateGasCost: estimateGasCost.bind(this),
      calculateL1GasFees
    };
  }
  estimateGas(routeWithValidQuote, gasPriceWei, chainId2) {
    const totalInitializedTicksCrossed = BigNumber.from(Math.max(1, _$3.sum(routeWithValidQuote.initializedTicksCrossedList)));
    const totalHops = BigNumber.from(routeWithValidQuote.route.pools.length);
    const hopsGasUse = COST_PER_HOP(chainId2).mul(totalHops);
    const tickGasUse = COST_PER_INIT_TICK(chainId2).mul(totalInitializedTicksCrossed);
    const uninitializedTickGasUse = COST_PER_UNINIT_TICK.mul(0);
    const baseGasUse = BASE_SWAP_COST$1(chainId2).add(hopsGasUse).add(tickGasUse).add(uninitializedTickGasUse);
    const baseGasCostWei = gasPriceWei.mul(baseGasUse);
    const wrappedCurrency = WRAPPED_NATIVE_CURRENCY[chainId2];
    const totalGasCostNativeCurrency = CurrencyAmount$2.fromRawAmount(wrappedCurrency, baseGasCostWei.toString());
    return {
      totalGasCostNativeCurrency,
      totalInitializedTicksCrossed,
      baseGasUse
    };
  }
  /**
   * To avoid having a call to optimism's L1 security fee contract for every route and amount combination,
   * we replicate the gas cost accounting here.
   */
  calculateOptimismToL1SecurityFee(routes, swapConfig, gasData) {
    const { l1BaseFee, scalar, decimals, overhead } = gasData;
    const route = routes[0];
    const inputToken = route.tradeType == TradeType$3.EXACT_INPUT ? route.amount.currency : route.quote.currency;
    const outputToken = route.tradeType == TradeType$3.EXACT_INPUT ? route.quote.currency : route.amount.currency;
    const trade = buildTrade(inputToken, outputToken, route.tradeType, routes);
    const data2 = buildSwapMethodParameters(trade, swapConfig).calldata;
    const l1GasUsed = getL2ToL1GasUsed(data2, overhead);
    const l1Fee = l1GasUsed.mul(l1BaseFee);
    const unscaled = l1Fee.mul(scalar);
    const scaledConversion = BigNumber.from(10).pow(decimals);
    const scaled = unscaled.div(scaledConversion);
    return [l1GasUsed, scaled];
  }
  calculateArbitrumToL1SecurityFee(routes, swapConfig, gasData) {
    const { perL2TxFee, perL1CalldataFee } = gasData;
    const route = routes[0];
    const inputToken = route.tradeType == TradeType$3.EXACT_INPUT ? route.amount.currency : route.quote.currency;
    const outputToken = route.tradeType == TradeType$3.EXACT_INPUT ? route.quote.currency : route.amount.currency;
    const trade = buildTrade(inputToken, outputToken, route.tradeType, routes);
    const data2 = buildSwapMethodParameters(trade, swapConfig).calldata;
    const l1GasUsed = getL2ToL1GasUsed(data2, BigNumber.from(0));
    let l1Fee = l1GasUsed.mul(perL1CalldataFee);
    l1Fee = l1Fee.add(perL2TxFee);
    return [l1GasUsed, l1Fee];
  }
}
async function getBestSwapRoute(amount, percents, routesWithValidQuotes, routeType, chainId2, routingConfig, gasModel) {
  const now = Date.now();
  const { forceMixedRoutes } = routingConfig;
  if (forceMixedRoutes) {
    log.info({
      forceMixedRoutes
    }, "Forcing mixed routes by filtering out other route types");
    routesWithValidQuotes = _$3.filter(routesWithValidQuotes, (quotes) => {
      return quotes.protocol === distExports.Protocol.MIXED;
    });
    if (!routesWithValidQuotes) {
      return null;
    }
  }
  const percentToQuotes = {};
  for (const routeWithValidQuote of routesWithValidQuotes) {
    if (!percentToQuotes[routeWithValidQuote.percent]) {
      percentToQuotes[routeWithValidQuote.percent] = [];
    }
    percentToQuotes[routeWithValidQuote.percent].push(routeWithValidQuote);
  }
  metric.putMetric("BuildRouteWithValidQuoteObjects", Date.now() - now, MetricLoggerUnit.Milliseconds);
  const swapRoute = await getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId2, (rq) => rq.quoteAdjustedForGas, routingConfig, gasModel);
  if (!swapRoute) {
    return null;
  }
  const { routes: routeAmounts } = swapRoute;
  const totalAmount = _$3.reduce(routeAmounts, (total, routeAmount) => total.add(routeAmount.amount), CurrencyAmount$2.fromRawAmount(routeAmounts[0].amount.currency, 0));
  const missingAmount = amount.subtract(totalAmount);
  if (missingAmount.greaterThan(0)) {
    log.info({
      missingAmount: missingAmount.quotient.toString()
    }, `Optimal route's amounts did not equal exactIn/exactOut total. Adding missing amount to last route in array.`);
    routeAmounts[routeAmounts.length - 1].amount = routeAmounts[routeAmounts.length - 1].amount.add(missingAmount);
  }
  log.info({
    routes: routeAmountsToString(routeAmounts),
    numSplits: routeAmounts.length,
    amount: amount.toExact(),
    quote: swapRoute.quote.toExact(),
    quoteGasAdjusted: swapRoute.quoteGasAdjusted.toFixed(Math.min(swapRoute.quoteGasAdjusted.currency.decimals, 2)),
    estimatedGasUSD: swapRoute.estimatedGasUsedUSD.toFixed(Math.min(swapRoute.estimatedGasUsedUSD.currency.decimals, 2)),
    estimatedGasToken: swapRoute.estimatedGasUsedQuoteToken.toFixed(Math.min(swapRoute.estimatedGasUsedQuoteToken.currency.decimals, 2))
  }, `Found best swap route. ${routeAmounts.length} split.`);
  return swapRoute;
}
async function getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId2, by, routingConfig, gasModel) {
  var _a;
  const percentToSortedQuotes = _$3.mapValues(percentToQuotes, (routeQuotes) => {
    return routeQuotes.sort((routeQuoteA, routeQuoteB) => {
      if (routeType == TradeType$3.EXACT_INPUT) {
        return by(routeQuoteA).greaterThan(by(routeQuoteB)) ? -1 : 1;
      } else {
        return by(routeQuoteA).lessThan(by(routeQuoteB)) ? -1 : 1;
      }
    });
  });
  const quoteCompFn = routeType == TradeType$3.EXACT_INPUT ? (a2, b3) => a2.greaterThan(b3) : (a2, b3) => a2.lessThan(b3);
  const sumFn = (currencyAmounts) => {
    let sum2 = currencyAmounts[0];
    for (let i3 = 1; i3 < currencyAmounts.length; i3++) {
      sum2 = sum2.add(currencyAmounts[i3]);
    }
    return sum2;
  };
  let bestQuote;
  let bestSwap;
  const bestSwapsPerSplit = new FixedReverseHeap$1(Array, (a2, b3) => {
    return quoteCompFn(a2.quote, b3.quote) ? -1 : 1;
  }, 3);
  const { minSplits, maxSplits, forceCrossProtocol } = routingConfig;
  if (!percentToSortedQuotes[100] || minSplits > 1 || forceCrossProtocol) {
    log.info({
      percentToSortedQuotes: _$3.mapValues(percentToSortedQuotes, (p2) => p2.length)
    }, "Did not find a valid route without any splits. Continuing search anyway.");
  } else {
    bestQuote = by(percentToSortedQuotes[100][0]);
    bestSwap = [percentToSortedQuotes[100][0]];
    for (const routeWithQuote of percentToSortedQuotes[100].slice(0, 5)) {
      bestSwapsPerSplit.push({
        quote: by(routeWithQuote),
        routes: [routeWithQuote]
      });
    }
  }
  const queue2 = new Queue$1();
  for (let i3 = percents.length; i3 >= 0; i3--) {
    const percent = percents[i3];
    if (!percentToSortedQuotes[percent]) {
      continue;
    }
    queue2.enqueue({
      curRoutes: [percentToSortedQuotes[percent][0]],
      percentIndex: i3,
      remainingPercent: 100 - percent,
      special: false
    });
    if (!percentToSortedQuotes[percent] || !percentToSortedQuotes[percent][1]) {
      continue;
    }
    queue2.enqueue({
      curRoutes: [percentToSortedQuotes[percent][1]],
      percentIndex: i3,
      remainingPercent: 100 - percent,
      special: true
    });
  }
  let splits = 1;
  let startedSplit = Date.now();
  while (queue2.size > 0) {
    metric.putMetric(`Split${splits}Done`, Date.now() - startedSplit, MetricLoggerUnit.Milliseconds);
    startedSplit = Date.now();
    log.info({
      top5: _$3.map(Array.from(bestSwapsPerSplit.consume()), (q2) => `${q2.quote.toExact()} (${_$3(q2.routes).map((r2) => r2.toString()).join(", ")})`),
      onQueue: queue2.size
    }, `Top 3 with ${splits} splits`);
    bestSwapsPerSplit.clear();
    let layer = queue2.size;
    splits++;
    if (splits >= 3 && bestSwap && bestSwap.length < splits - 1) {
      break;
    }
    if (splits > maxSplits) {
      log.info("Max splits reached. Stopping search.");
      metric.putMetric(`MaxSplitsHitReached`, 1, MetricLoggerUnit.Count);
      break;
    }
    while (layer > 0) {
      layer--;
      const { remainingPercent, curRoutes, percentIndex, special } = queue2.dequeue();
      for (let i3 = percentIndex; i3 >= 0; i3--) {
        const percentA = percents[i3];
        if (percentA > remainingPercent) {
          continue;
        }
        if (!percentToSortedQuotes[percentA]) {
          continue;
        }
        const candidateRoutesA = percentToSortedQuotes[percentA];
        const routeWithQuoteA = findFirstRouteNotUsingUsedPools(curRoutes, candidateRoutesA, forceCrossProtocol);
        if (!routeWithQuoteA) {
          continue;
        }
        const remainingPercentNew = remainingPercent - percentA;
        const curRoutesNew = [...curRoutes, routeWithQuoteA];
        if (remainingPercentNew == 0 && splits >= minSplits) {
          const quotesNew = _$3.map(curRoutesNew, (r2) => by(r2));
          const quoteNew = sumFn(quotesNew);
          let gasCostL1QuoteToken2 = CurrencyAmount$2.fromRawAmount(quoteNew.currency, 0);
          if (HAS_L1_FEE.includes(chainId2)) {
            const onlyV3Routes = curRoutesNew.every((route) => route.protocol == distExports.Protocol.V3);
            if (gasModel == void 0 || !onlyV3Routes) {
              throw new Error("Can't compute L1 gas fees.");
            } else {
              const gasCostL1 = await gasModel.calculateL1GasFees(curRoutesNew);
              gasCostL1QuoteToken2 = gasCostL1.gasCostL1QuoteToken;
            }
          }
          const quoteAfterL1Adjust = routeType == TradeType$3.EXACT_INPUT ? quoteNew.subtract(gasCostL1QuoteToken2) : quoteNew.add(gasCostL1QuoteToken2);
          bestSwapsPerSplit.push({
            quote: quoteAfterL1Adjust,
            routes: curRoutesNew
          });
          if (!bestQuote || quoteCompFn(quoteAfterL1Adjust, bestQuote)) {
            bestQuote = quoteAfterL1Adjust;
            bestSwap = curRoutesNew;
            if (special) {
              metric.putMetric(`BestSwapNotPickingBestForPercent`, 1, MetricLoggerUnit.Count);
            }
          }
        } else {
          queue2.enqueue({
            curRoutes: curRoutesNew,
            remainingPercent: remainingPercentNew,
            percentIndex: i3,
            special
          });
        }
      }
    }
  }
  if (!bestSwap) {
    log.info(`Could not find a valid swap`);
    return void 0;
  }
  const postSplitNow = Date.now();
  let quoteGasAdjusted = sumFn(_$3.map(bestSwap, (routeWithValidQuote) => routeWithValidQuote.quoteAdjustedForGas));
  const estimatedGasUsed = _$3(bestSwap).map((routeWithValidQuote) => routeWithValidQuote.gasEstimate).reduce((sum2, routeWithValidQuote) => sum2.add(routeWithValidQuote), BigNumber.from(0));
  if (!usdGasTokensByChain[chainId2] || !usdGasTokensByChain[chainId2][0]) {
    throw new Error(`Could not find a USD token for computing gas costs on ${chainId2}`);
  }
  const usdToken = usdGasTokensByChain[chainId2][0];
  const usdTokenDecimals = usdToken.decimals;
  let gasCostsL1ToL2 = {
    gasUsedL1: BigNumber.from(0),
    gasCostL1USD: CurrencyAmount$2.fromRawAmount(usdToken, 0),
    gasCostL1QuoteToken: CurrencyAmount$2.fromRawAmount(
      // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
      (_a = bestSwap[0]) === null || _a === void 0 ? void 0 : _a.quoteToken,
      0
    )
  };
  if (HAS_L1_FEE.includes(chainId2)) {
    const onlyV3Routes = bestSwap.every((route) => route.protocol == distExports.Protocol.V3);
    if (gasModel == void 0 || !onlyV3Routes) {
      throw new Error("Can't compute L1 gas fees.");
    } else {
      gasCostsL1ToL2 = await gasModel.calculateL1GasFees(bestSwap);
    }
  }
  const { gasCostL1USD, gasCostL1QuoteToken } = gasCostsL1ToL2;
  const estimatedGasUsedUSDs = _$3(bestSwap).map((routeWithValidQuote) => {
    const decimalsDiff = usdTokenDecimals - routeWithValidQuote.gasCostInUSD.currency.decimals;
    if (decimalsDiff == 0) {
      return CurrencyAmount$2.fromRawAmount(usdToken, routeWithValidQuote.gasCostInUSD.quotient);
    }
    return CurrencyAmount$2.fromRawAmount(usdToken, JSBI.multiply(routeWithValidQuote.gasCostInUSD.quotient, JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(decimalsDiff))));
  }).value();
  let estimatedGasUsedUSD = sumFn(estimatedGasUsedUSDs);
  if (estimatedGasUsedUSD.currency != gasCostL1USD.currency) {
    const decimalsDiff = usdTokenDecimals - gasCostL1USD.currency.decimals;
    estimatedGasUsedUSD = estimatedGasUsedUSD.add(CurrencyAmount$2.fromRawAmount(usdToken, JSBI.multiply(gasCostL1USD.quotient, JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(decimalsDiff)))));
  } else {
    estimatedGasUsedUSD = estimatedGasUsedUSD.add(gasCostL1USD);
  }
  log.info({
    estimatedGasUsedUSD: estimatedGasUsedUSD.toExact(),
    normalizedUsdToken: usdToken,
    routeUSDGasEstimates: _$3.map(bestSwap, (b3) => `${b3.percent}% ${routeToString(b3.route)} ${b3.gasCostInUSD.toExact()}`),
    flatL1GasCostUSD: gasCostL1USD.toExact()
  }, "USD gas estimates of best route");
  const estimatedGasUsedQuoteToken = sumFn(_$3.map(bestSwap, (routeWithValidQuote) => routeWithValidQuote.gasCostInToken)).add(gasCostL1QuoteToken);
  const quote = sumFn(_$3.map(bestSwap, (routeWithValidQuote) => routeWithValidQuote.quote));
  if (routeType == TradeType$3.EXACT_INPUT) {
    const quoteGasAdjustedForL1 = quoteGasAdjusted.subtract(gasCostL1QuoteToken);
    quoteGasAdjusted = quoteGasAdjustedForL1;
  } else {
    const quoteGasAdjustedForL1 = quoteGasAdjusted.add(gasCostL1QuoteToken);
    quoteGasAdjusted = quoteGasAdjustedForL1;
  }
  const routeWithQuotes = bestSwap.sort((routeAmountA, routeAmountB) => routeAmountB.amount.greaterThan(routeAmountA.amount) ? 1 : -1);
  metric.putMetric("PostSplitDone", Date.now() - postSplitNow, MetricLoggerUnit.Milliseconds);
  return {
    quote,
    quoteGasAdjusted,
    estimatedGasUsed,
    estimatedGasUsedUSD,
    estimatedGasUsedQuoteToken,
    routes: routeWithQuotes
  };
}
const findFirstRouteNotUsingUsedPools = (usedRoutes, candidateRouteQuotes, forceCrossProtocol) => {
  const poolAddressSet = /* @__PURE__ */ new Set();
  const usedPoolAddresses = _$3(usedRoutes).flatMap((r2) => r2.poolAddresses).value();
  for (const poolAddress of usedPoolAddresses) {
    poolAddressSet.add(poolAddress);
  }
  const protocolsSet = /* @__PURE__ */ new Set();
  const usedProtocols = _$3(usedRoutes).flatMap((r2) => r2.protocol).uniq().value();
  for (const protocol of usedProtocols) {
    protocolsSet.add(protocol);
  }
  for (const routeQuote of candidateRouteQuotes) {
    const { poolAddresses, protocol } = routeQuote;
    if (poolAddresses.some((poolAddress) => poolAddressSet.has(poolAddress))) {
      continue;
    }
    const needToForce = forceCrossProtocol && protocolsSet.size == 1;
    if (needToForce && protocolsSet.has(protocol)) {
      continue;
    }
    return routeQuote;
  }
  return null;
};
function calculateRatioAmountIn(optimalRatio, inputTokenPrice, inputBalance, outputBalance) {
  const amountToSwapRaw = new Fraction$3(inputBalance.quotient).subtract(optimalRatio.multiply(outputBalance.quotient)).divide(optimalRatio.multiply(inputTokenPrice).add(1));
  if (amountToSwapRaw.lessThan(0)) {
    throw new Error("routeToRatio: insufficient input token amount");
  }
  return CurrencyAmount$2.fromRawAmount(inputBalance.currency, amountToSwapRaw.quotient);
}
function computeAllV3Routes(tokenIn, tokenOut, pools, maxHops) {
  return computeAllRoutes(tokenIn, tokenOut, (route, tokenIn2, tokenOut2) => {
    return new V3Route(route, tokenIn2, tokenOut2);
  }, pools, maxHops);
}
function computeAllV2Routes(tokenIn, tokenOut, pools, maxHops) {
  return computeAllRoutes(tokenIn, tokenOut, (route, tokenIn2, tokenOut2) => {
    return new V2Route(route, tokenIn2, tokenOut2);
  }, pools, maxHops);
}
function computeAllMixedRoutes(tokenIn, tokenOut, parts, maxHops) {
  const routesRaw = computeAllRoutes(tokenIn, tokenOut, (route, tokenIn2, tokenOut2) => {
    return new MixedRoute(route, tokenIn2, tokenOut2);
  }, parts, maxHops);
  return routesRaw.filter((route) => {
    return !route.pools.every((pool) => pool instanceof Pool) && !route.pools.every((pool) => pool instanceof Pair);
  });
}
function computeAllRoutes(tokenIn, tokenOut, buildRoute, pools, maxHops) {
  const poolsUsed = Array(pools.length).fill(false);
  const routes = [];
  const computeRoutes = (tokenIn2, tokenOut2, currentRoute, poolsUsed2, _previousTokenOut) => {
    if (currentRoute.length > maxHops) {
      return;
    }
    if (currentRoute.length > 0 && currentRoute[currentRoute.length - 1].involvesToken(tokenOut2)) {
      routes.push(buildRoute([...currentRoute], tokenIn2, tokenOut2));
      return;
    }
    for (let i3 = 0; i3 < pools.length; i3++) {
      if (poolsUsed2[i3]) {
        continue;
      }
      const curPool = pools[i3];
      const previousTokenOut = _previousTokenOut ? _previousTokenOut : tokenIn2;
      if (!curPool.involvesToken(previousTokenOut)) {
        continue;
      }
      const currentTokenOut = curPool.token0.equals(previousTokenOut) ? curPool.token1 : curPool.token0;
      currentRoute.push(curPool);
      poolsUsed2[i3] = true;
      computeRoutes(tokenIn2, tokenOut2, currentRoute, poolsUsed2, currentTokenOut);
      poolsUsed2[i3] = false;
      currentRoute.pop();
    }
  };
  computeRoutes(tokenIn, tokenOut, [], poolsUsed);
  log.info({
    routes: routes.map(routeToString)
  }, `Computed ${routes.length} possible routes.`);
  return routes;
}
const baseTokensByChain = {
  [ChainId$2.MAINNET]: [
    USDC_MAINNET,
    USDT_MAINNET,
    WBTC_MAINNET,
    DAI_MAINNET,
    WRAPPED_NATIVE_CURRENCY[1],
    FEI_MAINNET
  ],
  [ChainId$2.RINKEBY]: [DAI_RINKEBY_1, DAI_RINKEBY_2],
  [ChainId$2.OPTIMISM]: [
    DAI_OPTIMISM,
    USDC_OPTIMISM,
    USDT_OPTIMISM,
    WBTC_OPTIMISM
  ],
  [ChainId$2.OPTIMISTIC_KOVAN]: [
    DAI_OPTIMISTIC_KOVAN,
    USDC_OPTIMISTIC_KOVAN,
    WBTC_OPTIMISTIC_KOVAN,
    USDT_OPTIMISTIC_KOVAN
  ],
  [ChainId$2.ARBITRUM_ONE]: [
    DAI_ARBITRUM,
    USDC_ARBITRUM,
    WBTC_ARBITRUM,
    USDT_ARBITRUM
  ],
  [ChainId$2.ARBITRUM_RINKEBY]: [DAI_ARBITRUM_RINKEBY, USDT_ARBITRUM_RINKEBY],
  [ChainId$2.POLYGON]: [USDC_POLYGON, WMATIC_POLYGON],
  [ChainId$2.POLYGON_MUMBAI]: [DAI_POLYGON_MUMBAI, WMATIC_POLYGON_MUMBAI],
  [ChainId$2.CELO]: [CUSD_CELO, CEUR_CELO, CELO],
  [ChainId$2.CELO_ALFAJORES]: [
    CUSD_CELO_ALFAJORES,
    CEUR_CELO_ALFAJORES,
    CELO_ALFAJORES
  ],
  [ChainId$2.GNOSIS]: [WBTC_GNOSIS, WXDAI_GNOSIS, USDC_ETHEREUM_GNOSIS],
  [ChainId$2.MOONBEAM]: [
    DAI_MOONBEAM,
    USDC_MOONBEAM,
    WBTC_MOONBEAM,
    WGLMR_MOONBEAM
  ]
};
async function getV3CandidatePools({ tokenIn, tokenOut, routeType, routingConfig, subgraphProvider, tokenProvider, poolProvider, blockedTokenListProvider, chainId: chainId2 }) {
  var _a, _b, _c, _d, _e2;
  const { blockNumber, v3PoolSelection: { topN, topNDirectSwaps, topNTokenInOut, topNSecondHop, topNWithEachBaseToken, topNWithBaseToken } } = routingConfig;
  const tokenInAddress = tokenIn.address.toLowerCase();
  const tokenOutAddress = tokenOut.address.toLowerCase();
  const beforeSubgraphPools = Date.now();
  const allPoolsRaw = await subgraphProvider.getPools(tokenIn, tokenOut, {
    blockNumber
  });
  log.info({ samplePools: allPoolsRaw.slice(0, 3) }, "Got all pools from V3 subgraph provider");
  const allPools = _$3.map(allPoolsRaw, (pool) => {
    return {
      ...pool,
      token0: {
        ...pool.token0,
        id: pool.token0.id.toLowerCase()
      },
      token1: {
        ...pool.token1,
        id: pool.token1.id.toLowerCase()
      }
    };
  });
  metric.putMetric("V3SubgraphPoolsLoad", Date.now() - beforeSubgraphPools, MetricLoggerUnit.Milliseconds);
  let filteredPools = allPools;
  if (blockedTokenListProvider) {
    filteredPools = [];
    for (const pool of allPools) {
      const token0InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token0.id);
      const token1InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token1.id);
      if (token0InBlocklist || token1InBlocklist) {
        continue;
      }
      filteredPools.push(pool);
    }
  }
  const subgraphPoolsSorted = _$3(filteredPools).sortBy((tokenListPool) => -tokenListPool.tvlUSD).value();
  log.info(`After filtering blocked tokens went from ${allPools.length} to ${subgraphPoolsSorted.length}.`);
  const poolAddressesSoFar = /* @__PURE__ */ new Set();
  const addToAddressSet = (pools) => {
    _$3(pools).map((pool) => pool.id).forEach((poolAddress) => poolAddressesSoFar.add(poolAddress));
  };
  const baseTokens = (_a = baseTokensByChain[chainId2]) !== null && _a !== void 0 ? _a : [];
  const topByBaseWithTokenIn = _$3(baseTokens).flatMap((token2) => {
    return _$3(subgraphPoolsSorted).filter((subgraphPool) => {
      const tokenAddress = token2.address.toLowerCase();
      return subgraphPool.token0.id == tokenAddress && subgraphPool.token1.id == tokenInAddress || subgraphPool.token1.id == tokenAddress && subgraphPool.token0.id == tokenInAddress;
    }).sortBy((tokenListPool) => -tokenListPool.tvlUSD).slice(0, topNWithEachBaseToken).value();
  }).sortBy((tokenListPool) => -tokenListPool.tvlUSD).slice(0, topNWithBaseToken).value();
  const topByBaseWithTokenOut = _$3(baseTokens).flatMap((token2) => {
    return _$3(subgraphPoolsSorted).filter((subgraphPool) => {
      const tokenAddress = token2.address.toLowerCase();
      return subgraphPool.token0.id == tokenAddress && subgraphPool.token1.id == tokenOutAddress || subgraphPool.token1.id == tokenAddress && subgraphPool.token0.id == tokenOutAddress;
    }).sortBy((tokenListPool) => -tokenListPool.tvlUSD).slice(0, topNWithEachBaseToken).value();
  }).sortBy((tokenListPool) => -tokenListPool.tvlUSD).slice(0, topNWithBaseToken).value();
  let top2DirectSwapPool = _$3(subgraphPoolsSorted).filter((subgraphPool) => {
    return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == tokenInAddress && subgraphPool.token1.id == tokenOutAddress || subgraphPool.token1.id == tokenInAddress && subgraphPool.token0.id == tokenOutAddress);
  }).slice(0, topNDirectSwaps).value();
  if (top2DirectSwapPool.length == 0 && topNDirectSwaps > 0) {
    top2DirectSwapPool = _$3.map([FeeAmount.HIGH, FeeAmount.MEDIUM, FeeAmount.LOW, FeeAmount.LOWEST], (feeAmount) => {
      const { token0, token1, poolAddress } = poolProvider.getPoolAddress(tokenIn, tokenOut, feeAmount);
      return {
        id: poolAddress,
        feeTier: unparseFeeAmount(feeAmount),
        liquidity: "10000",
        token0: {
          id: token0.address
        },
        token1: {
          id: token1.address
        },
        tvlETH: 1e4,
        tvlUSD: 1e4
      };
    });
  }
  addToAddressSet(top2DirectSwapPool);
  const wrappedNativeAddress = (_b = WRAPPED_NATIVE_CURRENCY[chainId2]) === null || _b === void 0 ? void 0 : _b.address;
  let top2EthQuoteTokenPool = [];
  if (((_c = WRAPPED_NATIVE_CURRENCY[chainId2]) === null || _c === void 0 ? void 0 : _c.symbol) == ((_d = WRAPPED_NATIVE_CURRENCY[ChainId$2.MAINNET]) === null || _d === void 0 ? void 0 : _d.symbol) && tokenOut.symbol != "WETH" && tokenOut.symbol != "WETH9" && tokenOut.symbol != "ETH" || ((_e2 = WRAPPED_NATIVE_CURRENCY[chainId2]) === null || _e2 === void 0 ? void 0 : _e2.symbol) == WMATIC_POLYGON.symbol && tokenOut.symbol != "MATIC" && tokenOut.symbol != "WMATIC") {
    top2EthQuoteTokenPool = _$3(subgraphPoolsSorted).filter((subgraphPool) => {
      if (routeType == TradeType$3.EXACT_INPUT) {
        return subgraphPool.token0.id == wrappedNativeAddress && subgraphPool.token1.id == tokenOutAddress || subgraphPool.token1.id == wrappedNativeAddress && subgraphPool.token0.id == tokenOutAddress;
      } else {
        return subgraphPool.token0.id == wrappedNativeAddress && subgraphPool.token1.id == tokenInAddress || subgraphPool.token1.id == wrappedNativeAddress && subgraphPool.token0.id == tokenInAddress;
      }
    }).slice(0, 1).value();
  }
  addToAddressSet(top2EthQuoteTokenPool);
  const topByTVL = _$3(subgraphPoolsSorted).filter((subgraphPool) => {
    return !poolAddressesSoFar.has(subgraphPool.id);
  }).slice(0, topN).value();
  addToAddressSet(topByTVL);
  const topByTVLUsingTokenIn = _$3(subgraphPoolsSorted).filter((subgraphPool) => {
    return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == tokenInAddress || subgraphPool.token1.id == tokenInAddress);
  }).slice(0, topNTokenInOut).value();
  addToAddressSet(topByTVLUsingTokenIn);
  const topByTVLUsingTokenOut = _$3(subgraphPoolsSorted).filter((subgraphPool) => {
    return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == tokenOutAddress || subgraphPool.token1.id == tokenOutAddress);
  }).slice(0, topNTokenInOut).value();
  addToAddressSet(topByTVLUsingTokenOut);
  const topByTVLUsingTokenInSecondHops = _$3(topByTVLUsingTokenIn).map((subgraphPool) => {
    return tokenInAddress == subgraphPool.token0.id ? subgraphPool.token1.id : subgraphPool.token0.id;
  }).flatMap((secondHopId) => {
    return _$3(subgraphPoolsSorted).filter((subgraphPool) => {
      return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == secondHopId || subgraphPool.token1.id == secondHopId);
    }).slice(0, topNSecondHop).value();
  }).uniqBy((pool) => pool.id).sortBy((tokenListPool) => -tokenListPool.tvlUSD).slice(0, topNSecondHop).value();
  addToAddressSet(topByTVLUsingTokenInSecondHops);
  const topByTVLUsingTokenOutSecondHops = _$3(topByTVLUsingTokenOut).map((subgraphPool) => {
    return tokenOutAddress == subgraphPool.token0.id ? subgraphPool.token1.id : subgraphPool.token0.id;
  }).flatMap((secondHopId) => {
    return _$3(subgraphPoolsSorted).filter((subgraphPool) => {
      return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == secondHopId || subgraphPool.token1.id == secondHopId);
    }).slice(0, topNSecondHop).value();
  }).uniqBy((pool) => pool.id).sortBy((tokenListPool) => -tokenListPool.tvlUSD).slice(0, topNSecondHop).value();
  addToAddressSet(topByTVLUsingTokenOutSecondHops);
  const subgraphPools = _$3([
    ...topByBaseWithTokenIn,
    ...topByBaseWithTokenOut,
    ...top2DirectSwapPool,
    ...top2EthQuoteTokenPool,
    ...topByTVL,
    ...topByTVLUsingTokenIn,
    ...topByTVLUsingTokenOut,
    ...topByTVLUsingTokenInSecondHops,
    ...topByTVLUsingTokenOutSecondHops
  ]).compact().uniqBy((pool) => pool.id).value();
  const tokenAddresses = _$3(subgraphPools).flatMap((subgraphPool) => [subgraphPool.token0.id, subgraphPool.token1.id]).compact().uniq().value();
  log.info(`Getting the ${tokenAddresses.length} tokens within the ${subgraphPools.length} V3 pools we are considering`);
  const tokenAccessor = await tokenProvider.getTokens(tokenAddresses, {
    blockNumber
  });
  const printV3SubgraphPool = (s4) => {
    var _a2, _b2, _c2, _d2;
    return `${(_b2 = (_a2 = tokenAccessor.getTokenByAddress(s4.token0.id)) === null || _a2 === void 0 ? void 0 : _a2.symbol) !== null && _b2 !== void 0 ? _b2 : s4.token0.id}/${(_d2 = (_c2 = tokenAccessor.getTokenByAddress(s4.token1.id)) === null || _c2 === void 0 ? void 0 : _c2.symbol) !== null && _d2 !== void 0 ? _d2 : s4.token1.id}/${s4.feeTier}`;
  };
  log.info({
    topByBaseWithTokenIn: topByBaseWithTokenIn.map(printV3SubgraphPool),
    topByBaseWithTokenOut: topByBaseWithTokenOut.map(printV3SubgraphPool),
    topByTVL: topByTVL.map(printV3SubgraphPool),
    topByTVLUsingTokenIn: topByTVLUsingTokenIn.map(printV3SubgraphPool),
    topByTVLUsingTokenOut: topByTVLUsingTokenOut.map(printV3SubgraphPool),
    topByTVLUsingTokenInSecondHops: topByTVLUsingTokenInSecondHops.map(printV3SubgraphPool),
    topByTVLUsingTokenOutSecondHops: topByTVLUsingTokenOutSecondHops.map(printV3SubgraphPool),
    top2DirectSwap: top2DirectSwapPool.map(printV3SubgraphPool),
    top2EthQuotePool: top2EthQuoteTokenPool.map(printV3SubgraphPool)
  }, `V3 Candidate Pools`);
  const tokenPairsRaw = _$3.map(subgraphPools, (subgraphPool) => {
    const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);
    const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);
    let fee;
    try {
      fee = parseFeeAmount(subgraphPool.feeTier);
    } catch (err) {
      log.info({ subgraphPool }, `Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${subgraphPool.feeTier} because fee tier not supported`);
      return void 0;
    }
    if (!tokenA || !tokenB) {
      log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${fee} because ${tokenA ? subgraphPool.token1.id : subgraphPool.token0.id} not found by token provider`);
      return void 0;
    }
    return [tokenA, tokenB, fee];
  });
  const tokenPairs = _$3.compact(tokenPairsRaw);
  const beforePoolsLoad = Date.now();
  const poolAccessor = await poolProvider.getPools(tokenPairs);
  metric.putMetric("V3PoolsLoad", Date.now() - beforePoolsLoad, MetricLoggerUnit.Milliseconds);
  const poolsBySelection = {
    protocol: distExports.Protocol.V3,
    selections: {
      topByBaseWithTokenIn,
      topByBaseWithTokenOut,
      topByDirectSwapPool: top2DirectSwapPool,
      topByEthQuoteTokenPool: top2EthQuoteTokenPool,
      topByTVL,
      topByTVLUsingTokenIn,
      topByTVLUsingTokenOut,
      topByTVLUsingTokenInSecondHops,
      topByTVLUsingTokenOutSecondHops
    }
  };
  return { poolAccessor, candidatePools: poolsBySelection, subgraphPools };
}
async function getV2CandidatePools({ tokenIn, tokenOut, routeType, routingConfig, subgraphProvider, tokenProvider, poolProvider, blockedTokenListProvider, chainId: chainId2 }) {
  var _a;
  const { blockNumber, v2PoolSelection: { topN, topNDirectSwaps, topNTokenInOut, topNSecondHop, topNWithEachBaseToken, topNWithBaseToken } } = routingConfig;
  const tokenInAddress = tokenIn.address.toLowerCase();
  const tokenOutAddress = tokenOut.address.toLowerCase();
  const beforeSubgraphPools = Date.now();
  const allPoolsRaw = await subgraphProvider.getPools(tokenIn, tokenOut, {
    blockNumber
  });
  const allPools = _$3.map(allPoolsRaw, (pool) => {
    return {
      ...pool,
      token0: {
        ...pool.token0,
        id: pool.token0.id.toLowerCase()
      },
      token1: {
        ...pool.token1,
        id: pool.token1.id.toLowerCase()
      }
    };
  });
  metric.putMetric("V2SubgraphPoolsLoad", Date.now() - beforeSubgraphPools, MetricLoggerUnit.Milliseconds);
  let filteredPools = allPools;
  if (blockedTokenListProvider) {
    filteredPools = [];
    for (const pool of allPools) {
      const token0InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token0.id);
      const token1InBlocklist = await blockedTokenListProvider.getTokenByAddress(pool.token1.id);
      if (token0InBlocklist || token1InBlocklist) {
        continue;
      }
      filteredPools.push(pool);
    }
  }
  const subgraphPoolsSorted = _$3(filteredPools).sortBy((tokenListPool) => -tokenListPool.reserve).value();
  log.info(`After filtering blocked tokens went from ${allPools.length} to ${subgraphPoolsSorted.length}.`);
  const poolAddressesSoFar = /* @__PURE__ */ new Set();
  const addToAddressSet = (pools) => {
    _$3(pools).map((pool) => pool.id).forEach((poolAddress) => poolAddressesSoFar.add(poolAddress));
  };
  const baseTokens = (_a = baseTokensByChain[chainId2]) !== null && _a !== void 0 ? _a : [];
  const topByBaseWithTokenIn = _$3(baseTokens).flatMap((token2) => {
    return _$3(subgraphPoolsSorted).filter((subgraphPool) => {
      const tokenAddress = token2.address.toLowerCase();
      return subgraphPool.token0.id == tokenAddress && subgraphPool.token1.id == tokenInAddress || subgraphPool.token1.id == tokenAddress && subgraphPool.token0.id == tokenInAddress;
    }).sortBy((tokenListPool) => -tokenListPool.reserve).slice(0, topNWithEachBaseToken).value();
  }).sortBy((tokenListPool) => -tokenListPool.reserve).slice(0, topNWithBaseToken).value();
  const topByBaseWithTokenOut = _$3(baseTokens).flatMap((token2) => {
    return _$3(subgraphPoolsSorted).filter((subgraphPool) => {
      const tokenAddress = token2.address.toLowerCase();
      return subgraphPool.token0.id == tokenAddress && subgraphPool.token1.id == tokenOutAddress || subgraphPool.token1.id == tokenAddress && subgraphPool.token0.id == tokenOutAddress;
    }).sortBy((tokenListPool) => -tokenListPool.reserve).slice(0, topNWithEachBaseToken).value();
  }).sortBy((tokenListPool) => -tokenListPool.reserve).slice(0, topNWithBaseToken).value();
  let topByDirectSwapPool = [];
  if (topNDirectSwaps != 0) {
    const { token0, token1, poolAddress } = poolProvider.getPoolAddress(tokenIn, tokenOut);
    topByDirectSwapPool = [
      {
        id: poolAddress,
        token0: {
          id: token0.address
        },
        token1: {
          id: token1.address
        },
        supply: 1e4,
        reserve: 1e4,
        reserveUSD: 1e4
        // Not used. Set to arbitrary number.
      }
    ];
  }
  addToAddressSet(topByDirectSwapPool);
  const wethAddress = WRAPPED_NATIVE_CURRENCY[chainId2].address;
  let topByEthQuoteTokenPool = [];
  if (tokenOut.symbol != "WETH" && tokenOut.symbol != "WETH9" && tokenOut.symbol != "ETH") {
    topByEthQuoteTokenPool = _$3(subgraphPoolsSorted).filter((subgraphPool) => {
      if (routeType == TradeType$3.EXACT_INPUT) {
        return subgraphPool.token0.id == wethAddress && subgraphPool.token1.id == tokenOutAddress || subgraphPool.token1.id == wethAddress && subgraphPool.token0.id == tokenOutAddress;
      } else {
        return subgraphPool.token0.id == wethAddress && subgraphPool.token1.id == tokenInAddress || subgraphPool.token1.id == wethAddress && subgraphPool.token0.id == tokenInAddress;
      }
    }).slice(0, 1).value();
  }
  addToAddressSet(topByEthQuoteTokenPool);
  const topByTVL = _$3(subgraphPoolsSorted).filter((subgraphPool) => {
    return !poolAddressesSoFar.has(subgraphPool.id);
  }).slice(0, topN).value();
  addToAddressSet(topByTVL);
  const topByTVLUsingTokenIn = _$3(subgraphPoolsSorted).filter((subgraphPool) => {
    return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == tokenInAddress || subgraphPool.token1.id == tokenInAddress);
  }).slice(0, topNTokenInOut).value();
  addToAddressSet(topByTVLUsingTokenIn);
  const topByTVLUsingTokenOut = _$3(subgraphPoolsSorted).filter((subgraphPool) => {
    return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == tokenOutAddress || subgraphPool.token1.id == tokenOutAddress);
  }).slice(0, topNTokenInOut).value();
  addToAddressSet(topByTVLUsingTokenOut);
  const topByTVLUsingTokenInSecondHops = _$3(topByTVLUsingTokenIn).map((subgraphPool) => {
    return tokenInAddress == subgraphPool.token0.id ? subgraphPool.token1.id : subgraphPool.token0.id;
  }).flatMap((secondHopId) => {
    return _$3(subgraphPoolsSorted).filter((subgraphPool) => {
      return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == secondHopId || subgraphPool.token1.id == secondHopId);
    }).slice(0, topNSecondHop).value();
  }).uniqBy((pool) => pool.id).sortBy((tokenListPool) => -tokenListPool.reserve).slice(0, topNSecondHop).value();
  addToAddressSet(topByTVLUsingTokenInSecondHops);
  const topByTVLUsingTokenOutSecondHops = _$3(topByTVLUsingTokenOut).map((subgraphPool) => {
    return tokenOutAddress == subgraphPool.token0.id ? subgraphPool.token1.id : subgraphPool.token0.id;
  }).flatMap((secondHopId) => {
    return _$3(subgraphPoolsSorted).filter((subgraphPool) => {
      return !poolAddressesSoFar.has(subgraphPool.id) && (subgraphPool.token0.id == secondHopId || subgraphPool.token1.id == secondHopId);
    }).slice(0, topNSecondHop).value();
  }).uniqBy((pool) => pool.id).sortBy((tokenListPool) => -tokenListPool.reserve).slice(0, topNSecondHop).value();
  addToAddressSet(topByTVLUsingTokenOutSecondHops);
  const subgraphPools = _$3([
    ...topByBaseWithTokenIn,
    ...topByBaseWithTokenOut,
    ...topByDirectSwapPool,
    ...topByEthQuoteTokenPool,
    ...topByTVL,
    ...topByTVLUsingTokenIn,
    ...topByTVLUsingTokenOut,
    ...topByTVLUsingTokenInSecondHops,
    ...topByTVLUsingTokenOutSecondHops
  ]).compact().uniqBy((pool) => pool.id).value();
  const tokenAddresses = _$3(subgraphPools).flatMap((subgraphPool) => [subgraphPool.token0.id, subgraphPool.token1.id]).compact().uniq().value();
  log.info(`Getting the ${tokenAddresses.length} tokens within the ${subgraphPools.length} V2 pools we are considering`);
  const tokenAccessor = await tokenProvider.getTokens(tokenAddresses, {
    blockNumber
  });
  const printV2SubgraphPool = (s4) => {
    var _a2, _b, _c, _d;
    return `${(_b = (_a2 = tokenAccessor.getTokenByAddress(s4.token0.id)) === null || _a2 === void 0 ? void 0 : _a2.symbol) !== null && _b !== void 0 ? _b : s4.token0.id}/${(_d = (_c = tokenAccessor.getTokenByAddress(s4.token1.id)) === null || _c === void 0 ? void 0 : _c.symbol) !== null && _d !== void 0 ? _d : s4.token1.id}`;
  };
  log.info({
    topByBaseWithTokenIn: topByBaseWithTokenIn.map(printV2SubgraphPool),
    topByBaseWithTokenOut: topByBaseWithTokenOut.map(printV2SubgraphPool),
    topByTVL: topByTVL.map(printV2SubgraphPool),
    topByTVLUsingTokenIn: topByTVLUsingTokenIn.map(printV2SubgraphPool),
    topByTVLUsingTokenOut: topByTVLUsingTokenOut.map(printV2SubgraphPool),
    topByTVLUsingTokenInSecondHops: topByTVLUsingTokenInSecondHops.map(printV2SubgraphPool),
    topByTVLUsingTokenOutSecondHops: topByTVLUsingTokenOutSecondHops.map(printV2SubgraphPool),
    top2DirectSwap: topByDirectSwapPool.map(printV2SubgraphPool),
    top2EthQuotePool: topByEthQuoteTokenPool.map(printV2SubgraphPool)
  }, `V2 Candidate pools`);
  const tokenPairsRaw = _$3.map(subgraphPools, (subgraphPool) => {
    const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);
    const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);
    if (!tokenA || !tokenB) {
      log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}`);
      return void 0;
    }
    return [tokenA, tokenB];
  });
  const tokenPairs = _$3.compact(tokenPairsRaw);
  const beforePoolsLoad = Date.now();
  const poolAccessor = await poolProvider.getPools(tokenPairs, { blockNumber });
  metric.putMetric("V2PoolsLoad", Date.now() - beforePoolsLoad, MetricLoggerUnit.Milliseconds);
  const poolsBySelection = {
    protocol: distExports.Protocol.V2,
    selections: {
      topByBaseWithTokenIn,
      topByBaseWithTokenOut,
      topByDirectSwapPool,
      topByEthQuoteTokenPool,
      topByTVL,
      topByTVLUsingTokenIn,
      topByTVLUsingTokenOut,
      topByTVLUsingTokenInSecondHops,
      topByTVLUsingTokenOutSecondHops
    }
  };
  return { poolAccessor, candidatePools: poolsBySelection, subgraphPools };
}
async function getMixedRouteCandidatePools({ tokenIn, tokenOut, routeType, routingConfig, v3subgraphProvider, v2subgraphProvider, tokenProvider, v3poolProvider, v2poolProvider, blockedTokenListProvider, chainId: chainId2 }) {
  const { blockNumber } = routingConfig;
  const { subgraphPools: V3subgraphPools, candidatePools: V3candidatePools } = await getV3CandidatePools({
    tokenIn,
    tokenOut,
    tokenProvider,
    blockedTokenListProvider,
    poolProvider: v3poolProvider,
    routeType,
    subgraphProvider: v3subgraphProvider,
    routingConfig,
    chainId: chainId2
  });
  const { subgraphPools: V2subgraphPools, candidatePools: V2candidatePools } = await getV2CandidatePools({
    tokenIn,
    tokenOut,
    tokenProvider,
    blockedTokenListProvider,
    poolProvider: v2poolProvider,
    routeType,
    subgraphProvider: v2subgraphProvider,
    routingConfig,
    chainId: chainId2
  });
  const V2topByTVLPoolIds = new Set([
    ...V2candidatePools.selections.topByTVLUsingTokenIn,
    ...V2candidatePools.selections.topByBaseWithTokenIn,
    /// tokenOut:
    ...V2candidatePools.selections.topByTVLUsingTokenOut,
    ...V2candidatePools.selections.topByBaseWithTokenOut,
    /// Direct swap:
    ...V2candidatePools.selections.topByDirectSwapPool
  ].map((poolId) => poolId.id));
  let V2topByTVLSortedPools = _$3(V2subgraphPools).filter((pool) => V2topByTVLPoolIds.has(pool.id)).sortBy((pool) => -pool.reserveUSD).value();
  const V3sortedPools = _$3(V3subgraphPools).sortBy((pool) => -pool.tvlUSD).value();
  const buildV2Pools = [];
  V2topByTVLSortedPools.forEach((V2subgraphPool) => {
    const V3subgraphPool = V3sortedPools.find((pool) => pool.token0.id == V2subgraphPool.token0.id && pool.token1.id == V2subgraphPool.token1.id || pool.token0.id == V2subgraphPool.token1.id && pool.token1.id == V2subgraphPool.token0.id);
    if (V3subgraphPool) {
      if (V2subgraphPool.reserveUSD > V3subgraphPool.tvlUSD) {
        log.info({
          token0: V2subgraphPool.token0.id,
          token1: V2subgraphPool.token1.id,
          v2reserveUSD: V2subgraphPool.reserveUSD,
          v3tvlUSD: V3subgraphPool.tvlUSD
        }, `MixedRoute heuristic, found a V2 pool with higher liquidity than its V3 counterpart`);
        buildV2Pools.push(V2subgraphPool);
      }
    } else {
      log.info({
        token0: V2subgraphPool.token0.id,
        token1: V2subgraphPool.token1.id,
        v2reserveUSD: V2subgraphPool.reserveUSD
      }, `MixedRoute heuristic, found a V2 pool with no V3 counterpart`);
      buildV2Pools.push(V2subgraphPool);
    }
  });
  log.info(buildV2Pools.length, `Number of V2 candidate pools that fit first heuristic`);
  const subgraphPools = [...buildV2Pools, ...V3sortedPools];
  const tokenAddresses = _$3(subgraphPools).flatMap((subgraphPool) => [subgraphPool.token0.id, subgraphPool.token1.id]).compact().uniq().value();
  log.info(`Getting the ${tokenAddresses.length} tokens within the ${subgraphPools.length} pools we are considering`);
  const tokenAccessor = await tokenProvider.getTokens(tokenAddresses, {
    blockNumber
  });
  const V3tokenPairsRaw = _$3.map(V3sortedPools, (subgraphPool) => {
    const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);
    const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);
    let fee;
    try {
      fee = parseFeeAmount(subgraphPool.feeTier);
    } catch (err) {
      log.info({ subgraphPool }, `Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${subgraphPool.feeTier} because fee tier not supported`);
      return void 0;
    }
    if (!tokenA || !tokenB) {
      log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}/${fee} because ${tokenA ? subgraphPool.token1.id : subgraphPool.token0.id} not found by token provider`);
      return void 0;
    }
    return [tokenA, tokenB, fee];
  });
  const V3tokenPairs = _$3.compact(V3tokenPairsRaw);
  const V2tokenPairsRaw = _$3.map(buildV2Pools, (subgraphPool) => {
    const tokenA = tokenAccessor.getTokenByAddress(subgraphPool.token0.id);
    const tokenB = tokenAccessor.getTokenByAddress(subgraphPool.token1.id);
    if (!tokenA || !tokenB) {
      log.info(`Dropping candidate pool for ${subgraphPool.token0.id}/${subgraphPool.token1.id}`);
      return void 0;
    }
    return [tokenA, tokenB];
  });
  const V2tokenPairs = _$3.compact(V2tokenPairsRaw);
  const [V2poolAccessor, V3poolAccessor] = await Promise.all([
    v2poolProvider.getPools(V2tokenPairs, {
      blockNumber
    }),
    v3poolProvider.getPools(V3tokenPairs, {
      blockNumber
    })
  ]);
  const buildPoolsBySelection = (key2) => {
    return [
      ...buildV2Pools.filter((pool) => V2candidatePools.selections[key2].map((p2) => p2.id).includes(pool.id)),
      ...V3candidatePools.selections[key2]
    ];
  };
  const poolsBySelection = {
    protocol: distExports.Protocol.MIXED,
    selections: {
      topByBaseWithTokenIn: buildPoolsBySelection("topByBaseWithTokenIn"),
      topByBaseWithTokenOut: buildPoolsBySelection("topByBaseWithTokenOut"),
      topByDirectSwapPool: buildPoolsBySelection("topByDirectSwapPool"),
      topByEthQuoteTokenPool: buildPoolsBySelection("topByEthQuoteTokenPool"),
      topByTVL: buildPoolsBySelection("topByTVL"),
      topByTVLUsingTokenIn: buildPoolsBySelection("topByTVLUsingTokenIn"),
      topByTVLUsingTokenOut: buildPoolsBySelection("topByTVLUsingTokenOut"),
      topByTVLUsingTokenInSecondHops: buildPoolsBySelection("topByTVLUsingTokenInSecondHops"),
      topByTVLUsingTokenOutSecondHops: buildPoolsBySelection("topByTVLUsingTokenOutSecondHops")
    }
  };
  return {
    V2poolAccessor,
    V3poolAccessor,
    candidatePools: poolsBySelection,
    subgraphPools
  };
}
const BASE_SWAP_COST = BigNumber.from(135e3);
const COST_PER_EXTRA_HOP = BigNumber.from(5e4);
class V2HeuristicGasModelFactory extends IV2GasModelFactory {
  constructor() {
    super();
  }
  async buildGasModel({ chainId: chainId2, gasPriceWei, poolProvider, token: token2 }) {
    if (token2.equals(WRAPPED_NATIVE_CURRENCY[chainId2])) {
      const usdPool2 = await this.getHighestLiquidityUSDPool(chainId2, poolProvider);
      return {
        estimateGasCost: (routeWithValidQuote) => {
          const { gasCostInEth, gasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId2);
          const ethToken0 = usdPool2.token0.address == WRAPPED_NATIVE_CURRENCY[chainId2].address;
          const ethTokenPrice = ethToken0 ? usdPool2.token0Price : usdPool2.token1Price;
          const gasCostInTermsOfUSD = ethTokenPrice.quote(gasCostInEth);
          return {
            gasEstimate: gasUse,
            gasCostInToken: gasCostInEth,
            gasCostInUSD: gasCostInTermsOfUSD
          };
        }
      };
    }
    const ethPool = await this.getEthPool(chainId2, token2, poolProvider);
    if (!ethPool) {
      log.info("Unable to find ETH pool with the quote token to produce gas adjusted costs. Route will not account for gas.");
    }
    const usdPool = await this.getHighestLiquidityUSDPool(chainId2, poolProvider);
    return {
      estimateGasCost: (routeWithValidQuote) => {
        const usdToken = usdPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId2].address ? usdPool.token1 : usdPool.token0;
        const { gasCostInEth, gasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId2);
        if (!ethPool) {
          return {
            gasEstimate: gasUse,
            gasCostInToken: CurrencyAmount$2.fromRawAmount(token2, 0),
            gasCostInUSD: CurrencyAmount$2.fromRawAmount(usdToken, 0)
          };
        }
        const ethToken0 = ethPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId2].address;
        const ethTokenPrice = ethToken0 ? ethPool.token0Price : ethPool.token1Price;
        let gasCostInTermsOfQuoteToken;
        try {
          gasCostInTermsOfQuoteToken = ethTokenPrice.quote(gasCostInEth);
        } catch (err) {
          log.error({
            ethTokenPriceBase: ethTokenPrice.baseCurrency,
            ethTokenPriceQuote: ethTokenPrice.quoteCurrency,
            gasCostInEth: gasCostInEth.currency
          }, "Debug eth price token issue");
          throw err;
        }
        const ethToken0USDPool = usdPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId2].address;
        const ethTokenPriceUSDPool = ethToken0USDPool ? usdPool.token0Price : usdPool.token1Price;
        let gasCostInTermsOfUSD;
        try {
          gasCostInTermsOfUSD = ethTokenPriceUSDPool.quote(gasCostInEth);
        } catch (err) {
          log.error({
            usdT1: usdPool.token0.symbol,
            usdT2: usdPool.token1.symbol,
            gasCostInEthToken: gasCostInEth.currency.symbol
          }, "Failed to compute USD gas price");
          throw err;
        }
        return {
          gasEstimate: gasUse,
          gasCostInToken: gasCostInTermsOfQuoteToken,
          gasCostInUSD: gasCostInTermsOfUSD
        };
      }
    };
  }
  estimateGas(routeWithValidQuote, gasPriceWei, chainId2) {
    const hops = routeWithValidQuote.route.pairs.length;
    const gasUse = BASE_SWAP_COST.add(COST_PER_EXTRA_HOP.mul(hops - 1));
    const totalGasCostWei = gasPriceWei.mul(gasUse);
    const weth = WRAPPED_NATIVE_CURRENCY[chainId2];
    const gasCostInEth = CurrencyAmount$2.fromRawAmount(weth, totalGasCostWei.toString());
    return { gasCostInEth, gasUse };
  }
  async getEthPool(chainId2, token2, poolProvider) {
    const weth = WRAPPED_NATIVE_CURRENCY[chainId2];
    const poolAccessor = await poolProvider.getPools([[weth, token2]]);
    const pool = poolAccessor.getPool(weth, token2);
    if (!pool || pool.reserve0.equalTo(0) || pool.reserve1.equalTo(0)) {
      log.error({
        weth,
        token: token2,
        reserve0: pool === null || pool === void 0 ? void 0 : pool.reserve0.toExact(),
        reserve1: pool === null || pool === void 0 ? void 0 : pool.reserve1.toExact()
      }, `Could not find a valid WETH pool with ${token2.symbol} for computing gas costs.`);
      return null;
    }
    return pool;
  }
  async getHighestLiquidityUSDPool(chainId2, poolProvider) {
    const usdTokens = usdGasTokensByChain[chainId2];
    if (!usdTokens) {
      throw new Error(`Could not find a USD token for computing gas costs on ${chainId2}`);
    }
    const usdPools = _$3.map(usdTokens, (usdToken) => [
      usdToken,
      WRAPPED_NATIVE_CURRENCY[chainId2]
    ]);
    const poolAccessor = await poolProvider.getPools(usdPools);
    const poolsRaw = poolAccessor.getAllPools();
    const pools = _$3.filter(poolsRaw, (pool) => pool.reserve0.greaterThan(0) && pool.reserve1.greaterThan(0));
    if (pools.length == 0) {
      log.error({ pools }, `Could not find a USD/WETH pool for computing gas costs.`);
      throw new Error(`Can't find USD/WETH pool for computing gas costs.`);
    }
    const maxPool = _$3.maxBy(pools, (pool) => {
      if (pool.token0.equals(WRAPPED_NATIVE_CURRENCY[chainId2])) {
        return parseFloat(pool.reserve0.toSignificant(2));
      } else {
        return parseFloat(pool.reserve1.toSignificant(2));
      }
    });
    return maxPool;
  }
}
class MixedRouteHeuristicGasModelFactory extends IOnChainGasModelFactory {
  constructor() {
    super();
  }
  async buildGasModel({ chainId: chainId2, gasPriceWei, v3poolProvider: V3poolProvider, token: token2, v2poolProvider: V2poolProvider }) {
    const usdPool = await getHighestLiquidityV3USDPool(chainId2, V3poolProvider);
    const nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId2];
    if (token2.equals(nativeCurrency)) {
      const estimateGasCost2 = (routeWithValidQuote) => {
        const { totalGasCostNativeCurrency, baseGasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId2);
        const token0 = usdPool.token0.address == nativeCurrency.address;
        const nativeTokenPrice = token0 ? usdPool.token0Price : usdPool.token1Price;
        const gasCostInTermsOfUSD = nativeTokenPrice.quote(totalGasCostNativeCurrency);
        return {
          gasEstimate: baseGasUse,
          gasCostInToken: totalGasCostNativeCurrency,
          gasCostInUSD: gasCostInTermsOfUSD
        };
      };
      return {
        estimateGasCost: estimateGasCost2
      };
    }
    const nativeV3Pool = await getHighestLiquidityV3NativePool(token2, V3poolProvider);
    let nativeV2Pool;
    if (V2poolProvider) {
      nativeV2Pool = await getV2NativePool(token2, V2poolProvider);
    }
    const usdToken = usdPool.token0.address == nativeCurrency.address ? usdPool.token1 : usdPool.token0;
    const estimateGasCost = (routeWithValidQuote) => {
      const { totalGasCostNativeCurrency, baseGasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId2);
      if (!nativeV3Pool && !nativeV2Pool) {
        log.info(`Unable to find ${nativeCurrency.symbol} pool with the quote token, ${token2.symbol} to produce gas adjusted costs. Route will not account for gas.`);
        return {
          gasEstimate: baseGasUse,
          gasCostInToken: CurrencyAmount$2.fromRawAmount(token2, 0),
          gasCostInUSD: CurrencyAmount$2.fromRawAmount(usdToken, 0)
        };
      }
      const nativePool = !nativeV3Pool && nativeV2Pool ? nativeV2Pool : nativeV3Pool;
      const token0 = nativePool.token0.address == nativeCurrency.address;
      const nativeTokenPrice = token0 ? nativePool.token0Price : nativePool.token1Price;
      let gasCostInTermsOfQuoteToken;
      try {
        gasCostInTermsOfQuoteToken = nativeTokenPrice.quote(totalGasCostNativeCurrency);
      } catch (err) {
        log.info({
          nativeTokenPriceBase: nativeTokenPrice.baseCurrency,
          nativeTokenPriceQuote: nativeTokenPrice.quoteCurrency,
          gasCostInEth: totalGasCostNativeCurrency.currency
        }, "Debug eth price token issue");
        throw err;
      }
      const token0USDPool = usdPool.token0.address == nativeCurrency.address;
      const nativeTokenPriceUSDPool = token0USDPool ? usdPool.token0Price : usdPool.token1Price;
      let gasCostInTermsOfUSD;
      try {
        gasCostInTermsOfUSD = nativeTokenPriceUSDPool.quote(totalGasCostNativeCurrency);
      } catch (err) {
        log.info({
          usdT1: usdPool.token0.symbol,
          usdT2: usdPool.token1.symbol,
          gasCostInNativeToken: totalGasCostNativeCurrency.currency.symbol
        }, "Failed to compute USD gas price");
        throw err;
      }
      return {
        gasEstimate: baseGasUse,
        gasCostInToken: gasCostInTermsOfQuoteToken,
        gasCostInUSD: gasCostInTermsOfUSD
      };
    };
    return {
      estimateGasCost: estimateGasCost.bind(this)
    };
  }
  estimateGas(routeWithValidQuote, gasPriceWei, chainId2) {
    const totalInitializedTicksCrossed = BigNumber.from(Math.max(1, _$3.sum(routeWithValidQuote.initializedTicksCrossedList)));
    let baseGasUse = BigNumber.from(0);
    const route = routeWithValidQuote.route;
    const res = distExports.partitionMixedRouteByProtocol(route);
    res.map((section) => {
      if (section.every((pool) => pool instanceof Pool)) {
        baseGasUse = baseGasUse.add(BASE_SWAP_COST$1(chainId2));
        baseGasUse = baseGasUse.add(COST_PER_HOP(chainId2).mul(section.length));
      } else if (section.every((pool) => pool instanceof Pair)) {
        baseGasUse = baseGasUse.add(BASE_SWAP_COST);
        baseGasUse = baseGasUse.add(
          /// same behavior in v2 heuristic gas model factory
          COST_PER_EXTRA_HOP.mul(section.length - 1)
        );
      }
    });
    const tickGasUse = COST_PER_INIT_TICK(chainId2).mul(totalInitializedTicksCrossed);
    const uninitializedTickGasUse = COST_PER_UNINIT_TICK.mul(0);
    baseGasUse = baseGasUse.add(tickGasUse).add(uninitializedTickGasUse);
    const baseGasCostWei = gasPriceWei.mul(baseGasUse);
    const wrappedCurrency = WRAPPED_NATIVE_CURRENCY[chainId2];
    const totalGasCostNativeCurrency = CurrencyAmount$2.fromRawAmount(wrappedCurrency, baseGasCostWei.toString());
    return {
      totalGasCostNativeCurrency,
      totalInitializedTicksCrossed,
      baseGasUse
    };
  }
}
class AlphaRouter {
  constructor({ chainId: chainId2, provider, multicall2Provider, v3PoolProvider, onChainQuoteProvider, v2PoolProvider, v2QuoteProvider, v2SubgraphProvider, tokenProvider, blockedTokenListProvider, v3SubgraphProvider, gasPriceProvider, v3GasModelFactory, v2GasModelFactory, mixedRouteGasModelFactory, swapRouterProvider, optimismGasDataProvider, tokenValidatorProvider, arbitrumGasDataProvider, simulator }) {
    this.chainId = chainId2;
    this.provider = provider;
    this.multicall2Provider = multicall2Provider !== null && multicall2Provider !== void 0 ? multicall2Provider : new UniswapMulticallProvider(chainId2, provider, 375e3);
    this.v3PoolProvider = v3PoolProvider !== null && v3PoolProvider !== void 0 ? v3PoolProvider : new CachingV3PoolProvider(this.chainId, new V3PoolProvider(ID_TO_CHAIN_ID(chainId2), this.multicall2Provider), new NodeJSCache(new NodeCache({ stdTTL: 360, useClones: false })));
    this.simulator = simulator;
    if (onChainQuoteProvider) {
      this.onChainQuoteProvider = onChainQuoteProvider;
    } else {
      switch (chainId2) {
        case ChainId$2.OPTIMISM:
        case ChainId$2.OPTIMISTIC_KOVAN:
          this.onChainQuoteProvider = new OnChainQuoteProvider(chainId2, provider, this.multicall2Provider, {
            retries: 2,
            minTimeout: 100,
            maxTimeout: 1e3
          }, {
            multicallChunk: 110,
            gasLimitPerCall: 12e5,
            quoteMinSuccessRate: 0.1
          }, {
            gasLimitOverride: 3e6,
            multicallChunk: 45
          }, {
            gasLimitOverride: 3e6,
            multicallChunk: 45
          }, {
            baseBlockOffset: -10,
            rollback: {
              enabled: true,
              attemptsBeforeRollback: 1,
              rollbackBlockOffset: -10
            }
          });
          break;
        case ChainId$2.ARBITRUM_ONE:
        case ChainId$2.ARBITRUM_RINKEBY:
          this.onChainQuoteProvider = new OnChainQuoteProvider(chainId2, provider, this.multicall2Provider, {
            retries: 2,
            minTimeout: 100,
            maxTimeout: 1e3
          }, {
            multicallChunk: 10,
            gasLimitPerCall: 12e6,
            quoteMinSuccessRate: 0.1
          }, {
            gasLimitOverride: 3e7,
            multicallChunk: 6
          }, {
            gasLimitOverride: 3e7,
            multicallChunk: 6
          });
          break;
        case ChainId$2.CELO:
        case ChainId$2.CELO_ALFAJORES:
          this.onChainQuoteProvider = new OnChainQuoteProvider(chainId2, provider, this.multicall2Provider, {
            retries: 2,
            minTimeout: 100,
            maxTimeout: 1e3
          }, {
            multicallChunk: 10,
            gasLimitPerCall: 5e6,
            quoteMinSuccessRate: 0.1
          }, {
            gasLimitOverride: 5e6,
            multicallChunk: 5
          }, {
            gasLimitOverride: 625e4,
            multicallChunk: 4
          });
          break;
        default:
          this.onChainQuoteProvider = new OnChainQuoteProvider(chainId2, provider, this.multicall2Provider, {
            retries: 2,
            minTimeout: 100,
            maxTimeout: 1e3
          }, {
            multicallChunk: 210,
            gasLimitPerCall: 705e3,
            quoteMinSuccessRate: 0.15
          }, {
            gasLimitOverride: 2e6,
            multicallChunk: 70
          });
          break;
      }
    }
    this.v2PoolProvider = v2PoolProvider !== null && v2PoolProvider !== void 0 ? v2PoolProvider : new CachingV2PoolProvider(chainId2, new V2PoolProvider(chainId2, this.multicall2Provider), new NodeJSCache(new NodeCache({ stdTTL: 60, useClones: false })));
    this.v2QuoteProvider = v2QuoteProvider !== null && v2QuoteProvider !== void 0 ? v2QuoteProvider : new V2QuoteProvider();
    this.blockedTokenListProvider = blockedTokenListProvider !== null && blockedTokenListProvider !== void 0 ? blockedTokenListProvider : new CachingTokenListProvider(chainId2, UNSUPPORTED_TOKENS, new NodeJSCache(new NodeCache({ stdTTL: 3600, useClones: false })));
    this.tokenProvider = tokenProvider !== null && tokenProvider !== void 0 ? tokenProvider : new CachingTokenProviderWithFallback(chainId2, new NodeJSCache(new NodeCache({ stdTTL: 3600, useClones: false })), new CachingTokenListProvider(chainId2, DEFAULT_TOKEN_LIST, new NodeJSCache(new NodeCache({ stdTTL: 3600, useClones: false }))), new TokenProvider(chainId2, this.multicall2Provider));
    const chainName = ID_TO_NETWORK_NAME(chainId2);
    if (v2SubgraphProvider) {
      this.v2SubgraphProvider = v2SubgraphProvider;
    } else {
      this.v2SubgraphProvider = new V2SubgraphProviderWithFallBacks([
        new CachingV2SubgraphProvider(chainId2, new URISubgraphProvider(chainId2, `https://cloudflare-ipfs.com/ipns/api.uniswap.org/v1/pools/v2/${chainName}.json`, void 0, 0), new NodeJSCache(new NodeCache({ stdTTL: 300, useClones: false }))),
        new StaticV2SubgraphProvider(chainId2)
      ]);
    }
    if (v3SubgraphProvider) {
      this.v3SubgraphProvider = v3SubgraphProvider;
    } else {
      this.v3SubgraphProvider = new V3SubgraphProviderWithFallBacks([
        new CachingV3SubgraphProvider(chainId2, new URISubgraphProvider(chainId2, `https://cloudflare-ipfs.com/ipns/api.uniswap.org/v1/pools/v3/${chainName}.json`, void 0, 0), new NodeJSCache(new NodeCache({ stdTTL: 300, useClones: false }))),
        new StaticV3SubgraphProvider(chainId2, this.v3PoolProvider)
      ]);
    }
    this.gasPriceProvider = gasPriceProvider !== null && gasPriceProvider !== void 0 ? gasPriceProvider : new CachingGasStationProvider(chainId2, this.provider instanceof JsonRpcProvider ? new OnChainGasPriceProvider(chainId2, new EIP1559GasPriceProvider(this.provider), new LegacyGasPriceProvider(this.provider)) : new ETHGasStationInfoProvider(ETH_GAS_STATION_API_URL), new NodeJSCache(new NodeCache({ stdTTL: 15, useClones: false })));
    this.v3GasModelFactory = v3GasModelFactory !== null && v3GasModelFactory !== void 0 ? v3GasModelFactory : new V3HeuristicGasModelFactory();
    this.v2GasModelFactory = v2GasModelFactory !== null && v2GasModelFactory !== void 0 ? v2GasModelFactory : new V2HeuristicGasModelFactory();
    this.mixedRouteGasModelFactory = mixedRouteGasModelFactory !== null && mixedRouteGasModelFactory !== void 0 ? mixedRouteGasModelFactory : new MixedRouteHeuristicGasModelFactory();
    this.swapRouterProvider = swapRouterProvider !== null && swapRouterProvider !== void 0 ? swapRouterProvider : new SwapRouterProvider(this.multicall2Provider);
    if (chainId2 == ChainId$2.OPTIMISM || chainId2 == ChainId$2.OPTIMISTIC_KOVAN) {
      this.l2GasDataProvider = optimismGasDataProvider !== null && optimismGasDataProvider !== void 0 ? optimismGasDataProvider : new OptimismGasDataProvider(chainId2, this.multicall2Provider);
    }
    if (chainId2 == ChainId$2.ARBITRUM_ONE || chainId2 == ChainId$2.ARBITRUM_RINKEBY) {
      this.l2GasDataProvider = arbitrumGasDataProvider !== null && arbitrumGasDataProvider !== void 0 ? arbitrumGasDataProvider : new ArbitrumGasDataProvider(chainId2, this.provider);
    }
    if (tokenValidatorProvider) {
      this.tokenValidatorProvider = tokenValidatorProvider;
    } else if (this.chainId == ChainId$2.MAINNET) {
      this.tokenValidatorProvider = new TokenValidatorProvider(this.chainId, this.multicall2Provider, new NodeJSCache(new NodeCache({ stdTTL: 3e4, useClones: false })));
    }
  }
  async routeToRatio(token0Balance, token1Balance, position2, swapAndAddConfig, swapAndAddOptions, routingConfig = DEFAULT_ROUTING_CONFIG_BY_CHAIN(this.chainId)) {
    if (token1Balance.currency.wrapped.sortsBefore(token0Balance.currency.wrapped)) {
      [token0Balance, token1Balance] = [token1Balance, token0Balance];
    }
    let preSwapOptimalRatio = this.calculateOptimalRatio(position2, position2.pool.sqrtRatioX96, true);
    let zeroForOne;
    if (position2.pool.tickCurrent > position2.tickUpper) {
      zeroForOne = true;
    } else if (position2.pool.tickCurrent < position2.tickLower) {
      zeroForOne = false;
    } else {
      zeroForOne = new Fraction$3(token0Balance.quotient, token1Balance.quotient).greaterThan(preSwapOptimalRatio);
      if (!zeroForOne)
        preSwapOptimalRatio = preSwapOptimalRatio.invert();
    }
    const [inputBalance, outputBalance] = zeroForOne ? [token0Balance, token1Balance] : [token1Balance, token0Balance];
    let optimalRatio = preSwapOptimalRatio;
    let postSwapTargetPool = position2.pool;
    let exchangeRate = zeroForOne ? position2.pool.token0Price : position2.pool.token1Price;
    let swap = null;
    let ratioAchieved = false;
    let n4 = 0;
    while (!ratioAchieved) {
      n4++;
      if (n4 > swapAndAddConfig.maxIterations) {
        log.info("max iterations exceeded");
        return {
          status: SwapToRatioStatus.NO_ROUTE_FOUND,
          error: "max iterations exceeded"
        };
      }
      const amountToSwap = calculateRatioAmountIn(optimalRatio, exchangeRate, inputBalance, outputBalance);
      if (amountToSwap.equalTo(0)) {
        log.info(`no swap needed: amountToSwap = 0`);
        return {
          status: SwapToRatioStatus.NO_SWAP_NEEDED
        };
      }
      swap = await this.route(amountToSwap, outputBalance.currency, TradeType$3.EXACT_INPUT, void 0, {
        ...DEFAULT_ROUTING_CONFIG_BY_CHAIN(this.chainId),
        ...routingConfig,
        /// @dev We do not want to query for mixedRoutes for routeToRatio as they are not supported
        /// [Protocol.V3, Protocol.V2] will make sure we only query for V3 and V2
        protocols: [distExports.Protocol.V3, distExports.Protocol.V2]
      });
      if (!swap) {
        log.info("no route found from this.route()");
        return {
          status: SwapToRatioStatus.NO_ROUTE_FOUND,
          error: "no route found"
        };
      }
      const inputBalanceUpdated = inputBalance.subtract(swap.trade.inputAmount);
      const outputBalanceUpdated = outputBalance.add(swap.trade.outputAmount);
      const newRatio = inputBalanceUpdated.divide(outputBalanceUpdated);
      let targetPoolPriceUpdate;
      swap.route.forEach((route) => {
        if (route.protocol == distExports.Protocol.V3) {
          const v3Route = route;
          v3Route.route.pools.forEach((pool, i3) => {
            if (pool.token0.equals(position2.pool.token0) && pool.token1.equals(position2.pool.token1) && pool.fee == position2.pool.fee) {
              targetPoolPriceUpdate = JSBI.BigInt(v3Route.sqrtPriceX96AfterList[i3].toString());
              optimalRatio = this.calculateOptimalRatio(position2, JSBI.BigInt(targetPoolPriceUpdate.toString()), zeroForOne);
            }
          });
        }
      });
      if (!targetPoolPriceUpdate) {
        optimalRatio = preSwapOptimalRatio;
      }
      ratioAchieved = newRatio.equalTo(optimalRatio) || this.absoluteValue(newRatio.asFraction.divide(optimalRatio).subtract(1)).lessThan(swapAndAddConfig.ratioErrorTolerance);
      if (ratioAchieved && targetPoolPriceUpdate) {
        postSwapTargetPool = new Pool(position2.pool.token0, position2.pool.token1, position2.pool.fee, targetPoolPriceUpdate, position2.pool.liquidity, TickMath.getTickAtSqrtRatio(targetPoolPriceUpdate), position2.pool.tickDataProvider);
      }
      exchangeRate = swap.trade.outputAmount.divide(swap.trade.inputAmount);
      log.info({
        exchangeRate: exchangeRate.asFraction.toFixed(18),
        optimalRatio: optimalRatio.asFraction.toFixed(18),
        newRatio: newRatio.asFraction.toFixed(18),
        inputBalanceUpdated: inputBalanceUpdated.asFraction.toFixed(18),
        outputBalanceUpdated: outputBalanceUpdated.asFraction.toFixed(18),
        ratioErrorTolerance: swapAndAddConfig.ratioErrorTolerance.toFixed(18),
        iterationN: n4.toString()
      }, "QuoteToRatio Iteration Parameters");
      if (exchangeRate.equalTo(0)) {
        log.info("exchangeRate to 0");
        return {
          status: SwapToRatioStatus.NO_ROUTE_FOUND,
          error: "insufficient liquidity to swap to optimal ratio"
        };
      }
    }
    if (!swap) {
      return {
        status: SwapToRatioStatus.NO_ROUTE_FOUND,
        error: "no route found"
      };
    }
    let methodParameters;
    if (swapAndAddOptions) {
      methodParameters = await this.buildSwapAndAddMethodParameters(swap.trade, swapAndAddOptions, {
        initialBalanceTokenIn: inputBalance,
        initialBalanceTokenOut: outputBalance,
        preLiquidityPosition: position2
      });
    }
    return {
      status: SwapToRatioStatus.SUCCESS,
      result: { ...swap, methodParameters, optimalRatio, postSwapTargetPool }
    };
  }
  /**
   * @inheritdoc IRouter
   */
  async route(amount, quoteCurrency, tradeType, swapConfig, partialRoutingConfig = {}) {
    var _a;
    metric.putMetric(`QuoteRequestedForChain${this.chainId}`, 1, MetricLoggerUnit.Count);
    const blockNumber = (_a = partialRoutingConfig.blockNumber) !== null && _a !== void 0 ? _a : this.getBlockNumberPromise();
    const routingConfig = _$3.merge({}, DEFAULT_ROUTING_CONFIG_BY_CHAIN(this.chainId), partialRoutingConfig, { blockNumber });
    const { protocols } = routingConfig;
    const currencyIn = tradeType == TradeType$3.EXACT_INPUT ? amount.currency : quoteCurrency;
    const currencyOut = tradeType == TradeType$3.EXACT_INPUT ? quoteCurrency : amount.currency;
    const tokenIn = currencyIn.wrapped;
    const tokenOut = currencyOut.wrapped;
    const [percents, amounts] = this.getAmountDistribution(amount, routingConfig);
    const beforeGas = Date.now();
    const { gasPriceWei } = await this.gasPriceProvider.getGasPrice();
    metric.putMetric("GasPriceLoad", Date.now() - beforeGas, MetricLoggerUnit.Milliseconds);
    const quoteToken = quoteCurrency.wrapped;
    const quotePromises = [];
    const protocolsSet = new Set(protocols !== null && protocols !== void 0 ? protocols : []);
    const [v3gasModel, mixedRouteGasModel] = await Promise.all([
      this.v3GasModelFactory.buildGasModel({
        chainId: this.chainId,
        gasPriceWei,
        v3poolProvider: this.v3PoolProvider,
        token: quoteToken,
        v2poolProvider: this.v2PoolProvider,
        l2GasDataProvider: this.l2GasDataProvider
      }),
      this.mixedRouteGasModelFactory.buildGasModel({
        chainId: this.chainId,
        gasPriceWei,
        v3poolProvider: this.v3PoolProvider,
        token: quoteToken,
        v2poolProvider: this.v2PoolProvider
      })
    ]);
    if ((protocolsSet.size == 0 || protocolsSet.has(distExports.Protocol.V2) && protocolsSet.has(distExports.Protocol.V3)) && V2_SUPPORTED.includes(this.chainId)) {
      log.info({ protocols, tradeType }, "Routing across all protocols");
      quotePromises.push(this.getV3Quotes(tokenIn, tokenOut, amounts, percents, quoteToken, v3gasModel, tradeType, routingConfig));
      quotePromises.push(this.getV2Quotes(tokenIn, tokenOut, amounts, percents, quoteToken, gasPriceWei, tradeType, routingConfig));
      if (tradeType === TradeType$3.EXACT_INPUT && (this.chainId === ChainId$2.MAINNET || this.chainId === ChainId$2.GRLI) && /// The cases where protocols = [] and protocols = [V2, V3, MIXED]
      (protocolsSet.size == 0 || protocolsSet.has(distExports.Protocol.MIXED))) {
        log.info({ protocols, swapType: tradeType }, "Routing across MixedRoutes");
        quotePromises.push(this.getMixedRouteQuotes(tokenIn, tokenOut, amounts, percents, quoteToken, mixedRouteGasModel, tradeType, routingConfig));
      }
    } else {
      if (protocolsSet.has(distExports.Protocol.V3) || protocolsSet.size == 0 && !V2_SUPPORTED.includes(this.chainId)) {
        log.info({ protocols, swapType: tradeType }, "Routing across V3");
        quotePromises.push(this.getV3Quotes(tokenIn, tokenOut, amounts, percents, quoteToken, v3gasModel, tradeType, routingConfig));
      }
      if (protocolsSet.has(distExports.Protocol.V2)) {
        log.info({ protocols, swapType: tradeType }, "Routing across V2");
        quotePromises.push(this.getV2Quotes(tokenIn, tokenOut, amounts, percents, quoteToken, gasPriceWei, tradeType, routingConfig));
      }
      if (protocolsSet.has(distExports.Protocol.MIXED) && (this.chainId === ChainId$2.MAINNET || this.chainId === ChainId$2.GRLI) && tradeType == TradeType$3.EXACT_INPUT) {
        log.info({ protocols, swapType: tradeType }, "Routing across MixedRoutes");
        quotePromises.push(this.getMixedRouteQuotes(tokenIn, tokenOut, amounts, percents, quoteToken, mixedRouteGasModel, tradeType, routingConfig));
      }
    }
    const routesWithValidQuotesByProtocol = await Promise.all(quotePromises);
    let allRoutesWithValidQuotes = [];
    let allCandidatePools = [];
    for (const { routesWithValidQuotes, candidatePools } of routesWithValidQuotesByProtocol) {
      allRoutesWithValidQuotes = [
        ...allRoutesWithValidQuotes,
        ...routesWithValidQuotes
      ];
      allCandidatePools = [...allCandidatePools, candidatePools];
    }
    if (allRoutesWithValidQuotes.length == 0) {
      log.info({ allRoutesWithValidQuotes }, "Received no valid quotes");
      return null;
    }
    const beforeBestSwap = Date.now();
    const swapRouteRaw = await getBestSwapRoute(amount, percents, allRoutesWithValidQuotes, tradeType, this.chainId, routingConfig, v3gasModel);
    if (!swapRouteRaw) {
      return null;
    }
    const { quote, quoteGasAdjusted, estimatedGasUsed, routes: routeAmounts, estimatedGasUsedQuoteToken, estimatedGasUsedUSD } = swapRouteRaw;
    const trade = buildTrade(currencyIn, currencyOut, tradeType, routeAmounts);
    let methodParameters;
    if (swapConfig) {
      methodParameters = buildSwapMethodParameters(trade, swapConfig);
    }
    metric.putMetric("FindBestSwapRoute", Date.now() - beforeBestSwap, MetricLoggerUnit.Milliseconds);
    metric.putMetric(`QuoteFoundForChain${this.chainId}`, 1, MetricLoggerUnit.Count);
    this.emitPoolSelectionMetrics(swapRouteRaw, allCandidatePools);
    const swapRoute = {
      quote,
      quoteGasAdjusted,
      estimatedGasUsed,
      estimatedGasUsedQuoteToken,
      estimatedGasUsedUSD,
      gasPriceWei,
      route: routeAmounts,
      trade,
      methodParameters,
      blockNumber: BigNumber.from(await blockNumber)
    };
    if (swapConfig && swapConfig.simulate && methodParameters && methodParameters.calldata) {
      if (!this.simulator) {
        throw new Error("Simulator not initialized!");
      }
      const fromAddress = swapConfig.simulate.fromAddress;
      const beforeSimulate = Date.now();
      const swapRouteWithSimulation = await this.simulator.simulate(
        fromAddress,
        swapRoute,
        amount,
        // Quote will be in WETH even if quoteCurrency is ETH
        // So we init a new CurrencyAmount object here
        CurrencyAmount$2.fromRawAmount(quoteCurrency, quote.quotient.toString()),
        this.l2GasDataProvider ? await this.l2GasDataProvider.getGasData() : void 0
      );
      metric.putMetric("SimulateTransaction", Date.now() - beforeSimulate, MetricLoggerUnit.Milliseconds);
      return swapRouteWithSimulation;
    }
    return swapRoute;
  }
  async applyTokenValidatorToPools(pools, isInvalidFn) {
    if (!this.tokenValidatorProvider) {
      return pools;
    }
    log.info(`Running token validator on ${pools.length} pools`);
    const tokens2 = _$3.flatMap(pools, (pool) => [pool.token0, pool.token1]);
    const tokenValidationResults = await this.tokenValidatorProvider.validateTokens(tokens2);
    const poolsFiltered = _$3.filter(pools, (pool) => {
      const token0Validation = tokenValidationResults.getValidationByToken(pool.token0);
      const token1Validation = tokenValidationResults.getValidationByToken(pool.token1);
      const token0Invalid = isInvalidFn(pool.token0, token0Validation);
      const token1Invalid = isInvalidFn(pool.token1, token1Validation);
      if (token0Invalid || token1Invalid) {
        log.info(`Dropping pool ${poolToString(pool)} because token is invalid. ${pool.token0.symbol}: ${token0Validation}, ${pool.token1.symbol}: ${token1Validation}`);
      }
      return !token0Invalid && !token1Invalid;
    });
    return poolsFiltered;
  }
  async getV3Quotes(tokenIn, tokenOut, amounts, percents, quoteToken, gasModel, swapType, routingConfig) {
    log.info("Starting to get V3 quotes");
    const { poolAccessor, candidatePools } = await getV3CandidatePools({
      tokenIn,
      tokenOut,
      tokenProvider: this.tokenProvider,
      blockedTokenListProvider: this.blockedTokenListProvider,
      poolProvider: this.v3PoolProvider,
      routeType: swapType,
      subgraphProvider: this.v3SubgraphProvider,
      routingConfig,
      chainId: this.chainId
    });
    const poolsRaw = poolAccessor.getAllPools();
    const pools = await this.applyTokenValidatorToPools(poolsRaw, (token2, tokenValidation) => {
      if (!tokenValidation) {
        return false;
      }
      if (tokenValidation == TokenValidationResult.STF && (token2.equals(tokenIn) || token2.equals(tokenOut))) {
        return false;
      }
      return tokenValidation == TokenValidationResult.FOT || tokenValidation == TokenValidationResult.STF;
    });
    const { maxSwapsPerPath } = routingConfig;
    const routes = computeAllV3Routes(tokenIn, tokenOut, pools, maxSwapsPerPath);
    if (routes.length == 0) {
      return { routesWithValidQuotes: [], candidatePools };
    }
    const quoteFn = swapType == TradeType$3.EXACT_INPUT ? this.onChainQuoteProvider.getQuotesManyExactIn.bind(this.onChainQuoteProvider) : this.onChainQuoteProvider.getQuotesManyExactOut.bind(this.onChainQuoteProvider);
    const beforeQuotes = Date.now();
    log.info(`Getting quotes for V3 for ${routes.length} routes with ${amounts.length} amounts per route.`);
    const { routesWithQuotes } = await quoteFn(amounts, routes, {
      blockNumber: routingConfig.blockNumber
    });
    metric.putMetric("V3QuotesLoad", Date.now() - beforeQuotes, MetricLoggerUnit.Milliseconds);
    metric.putMetric("V3QuotesFetched", _$3(routesWithQuotes).map(([, quotes]) => quotes.length).sum(), MetricLoggerUnit.Count);
    const routesWithValidQuotes = [];
    for (const routeWithQuote of routesWithQuotes) {
      const [route, quotes] = routeWithQuote;
      for (let i3 = 0; i3 < quotes.length; i3++) {
        const percent = percents[i3];
        const amountQuote = quotes[i3];
        const { quote, amount, sqrtPriceX96AfterList, initializedTicksCrossedList, gasEstimate } = amountQuote;
        if (!quote || !sqrtPriceX96AfterList || !initializedTicksCrossedList || !gasEstimate) {
          log.debug({
            route: routeToString(route),
            amountQuote
          }, "Dropping a null V3 quote for route.");
          continue;
        }
        const routeWithValidQuote = new V3RouteWithValidQuote({
          route,
          rawQuote: quote,
          amount,
          percent,
          sqrtPriceX96AfterList,
          initializedTicksCrossedList,
          quoterGasEstimate: gasEstimate,
          gasModel,
          quoteToken,
          tradeType: swapType,
          v3PoolProvider: this.v3PoolProvider
        });
        routesWithValidQuotes.push(routeWithValidQuote);
      }
    }
    return { routesWithValidQuotes, candidatePools };
  }
  async getV2Quotes(tokenIn, tokenOut, amounts, percents, quoteToken, gasPriceWei, swapType, routingConfig) {
    log.info("Starting to get V2 quotes");
    const { poolAccessor, candidatePools } = await getV2CandidatePools({
      tokenIn,
      tokenOut,
      tokenProvider: this.tokenProvider,
      blockedTokenListProvider: this.blockedTokenListProvider,
      poolProvider: this.v2PoolProvider,
      routeType: swapType,
      subgraphProvider: this.v2SubgraphProvider,
      routingConfig,
      chainId: this.chainId
    });
    const poolsRaw = poolAccessor.getAllPools();
    const pools = await this.applyTokenValidatorToPools(poolsRaw, (token2, tokenValidation) => {
      if (!tokenValidation) {
        return false;
      }
      if (tokenValidation == TokenValidationResult.STF && (token2.equals(tokenIn) || token2.equals(tokenOut))) {
        return false;
      }
      return tokenValidation == TokenValidationResult.STF;
    });
    const { maxSwapsPerPath } = routingConfig;
    const routes = computeAllV2Routes(tokenIn, tokenOut, pools, maxSwapsPerPath);
    if (routes.length == 0) {
      return { routesWithValidQuotes: [], candidatePools };
    }
    const quoteFn = swapType == TradeType$3.EXACT_INPUT ? this.v2QuoteProvider.getQuotesManyExactIn.bind(this.v2QuoteProvider) : this.v2QuoteProvider.getQuotesManyExactOut.bind(this.v2QuoteProvider);
    const beforeQuotes = Date.now();
    log.info(`Getting quotes for V2 for ${routes.length} routes with ${amounts.length} amounts per route.`);
    const { routesWithQuotes } = await quoteFn(amounts, routes);
    const V2gasModel = await this.v2GasModelFactory.buildGasModel({
      chainId: this.chainId,
      gasPriceWei,
      poolProvider: this.v2PoolProvider,
      token: quoteToken
    });
    metric.putMetric("V2QuotesLoad", Date.now() - beforeQuotes, MetricLoggerUnit.Milliseconds);
    metric.putMetric("V2QuotesFetched", _$3(routesWithQuotes).map(([, quotes]) => quotes.length).sum(), MetricLoggerUnit.Count);
    const routesWithValidQuotes = [];
    for (const routeWithQuote of routesWithQuotes) {
      const [route, quotes] = routeWithQuote;
      for (let i3 = 0; i3 < quotes.length; i3++) {
        const percent = percents[i3];
        const amountQuote = quotes[i3];
        const { quote, amount } = amountQuote;
        if (!quote) {
          log.debug({
            route: routeToString(route),
            amountQuote
          }, "Dropping a null V2 quote for route.");
          continue;
        }
        const routeWithValidQuote = new V2RouteWithValidQuote({
          route,
          rawQuote: quote,
          amount,
          percent,
          gasModel: V2gasModel,
          quoteToken,
          tradeType: swapType,
          v2PoolProvider: this.v2PoolProvider
        });
        routesWithValidQuotes.push(routeWithValidQuote);
      }
    }
    return { routesWithValidQuotes, candidatePools };
  }
  async getMixedRouteQuotes(tokenIn, tokenOut, amounts, percents, quoteToken, mixedRouteGasModel, swapType, routingConfig) {
    log.info("Starting to get mixed quotes");
    if (swapType != TradeType$3.EXACT_INPUT) {
      throw new Error("Mixed route quotes are not supported for EXACT_OUTPUT");
    }
    const { V2poolAccessor, V3poolAccessor, candidatePools: mixedRouteCandidatePools } = await getMixedRouteCandidatePools({
      tokenIn,
      tokenOut,
      tokenProvider: this.tokenProvider,
      blockedTokenListProvider: this.blockedTokenListProvider,
      v3poolProvider: this.v3PoolProvider,
      v2poolProvider: this.v2PoolProvider,
      routeType: swapType,
      v3subgraphProvider: this.v3SubgraphProvider,
      v2subgraphProvider: this.v2SubgraphProvider,
      routingConfig,
      chainId: this.chainId
    });
    const V3poolsRaw = V3poolAccessor.getAllPools();
    const V2poolsRaw = V2poolAccessor.getAllPools();
    const poolsRaw = [...V3poolsRaw, ...V2poolsRaw];
    const candidatePools = mixedRouteCandidatePools;
    const pools = await this.applyTokenValidatorToPools(poolsRaw, (token2, tokenValidation) => {
      if (!tokenValidation) {
        return false;
      }
      if (tokenValidation == TokenValidationResult.STF && (token2.equals(tokenIn) || token2.equals(tokenOut))) {
        return false;
      }
      return tokenValidation == TokenValidationResult.FOT || tokenValidation == TokenValidationResult.STF;
    });
    const { maxSwapsPerPath } = routingConfig;
    const routes = computeAllMixedRoutes(tokenIn, tokenOut, pools, maxSwapsPerPath);
    if (routes.length == 0) {
      return { routesWithValidQuotes: [], candidatePools };
    }
    const quoteFn = this.onChainQuoteProvider.getQuotesManyExactIn.bind(this.onChainQuoteProvider);
    const beforeQuotes = Date.now();
    log.info(`Getting quotes for mixed for ${routes.length} routes with ${amounts.length} amounts per route.`);
    const { routesWithQuotes } = await quoteFn(amounts, routes, {
      blockNumber: routingConfig.blockNumber
    });
    metric.putMetric("MixedQuotesLoad", Date.now() - beforeQuotes, MetricLoggerUnit.Milliseconds);
    metric.putMetric("MixedQuotesFetched", _$3(routesWithQuotes).map(([, quotes]) => quotes.length).sum(), MetricLoggerUnit.Count);
    const routesWithValidQuotes = [];
    for (const routeWithQuote of routesWithQuotes) {
      const [route, quotes] = routeWithQuote;
      for (let i3 = 0; i3 < quotes.length; i3++) {
        const percent = percents[i3];
        const amountQuote = quotes[i3];
        const { quote, amount, sqrtPriceX96AfterList, initializedTicksCrossedList, gasEstimate } = amountQuote;
        if (!quote || !sqrtPriceX96AfterList || !initializedTicksCrossedList || !gasEstimate) {
          log.debug({
            route: routeToString(route),
            amountQuote
          }, "Dropping a null mixed quote for route.");
          continue;
        }
        const routeWithValidQuote = new MixedRouteWithValidQuote({
          route,
          rawQuote: quote,
          amount,
          percent,
          sqrtPriceX96AfterList,
          initializedTicksCrossedList,
          quoterGasEstimate: gasEstimate,
          mixedRouteGasModel,
          quoteToken,
          tradeType: swapType,
          v3PoolProvider: this.v3PoolProvider,
          v2PoolProvider: this.v2PoolProvider
        });
        routesWithValidQuotes.push(routeWithValidQuote);
      }
    }
    return { routesWithValidQuotes, candidatePools };
  }
  // Note multiplications here can result in a loss of precision in the amounts (e.g. taking 50% of 101)
  // This is reconcilled at the end of the algorithm by adding any lost precision to one of
  // the splits in the route.
  getAmountDistribution(amount, routingConfig) {
    const { distributionPercent } = routingConfig;
    const percents = [];
    const amounts = [];
    for (let i3 = 1; i3 <= 100 / distributionPercent; i3++) {
      percents.push(i3 * distributionPercent);
      amounts.push(amount.multiply(new Fraction$3(i3 * distributionPercent, 100)));
    }
    return [percents, amounts];
  }
  async buildSwapAndAddMethodParameters(trade, swapAndAddOptions, swapAndAddParameters) {
    const { swapOptions: { recipient, slippageTolerance, deadline, inputTokenPermit }, addLiquidityOptions: addLiquidityConfig } = swapAndAddOptions;
    const preLiquidityPosition = swapAndAddParameters.preLiquidityPosition;
    const finalBalanceTokenIn = swapAndAddParameters.initialBalanceTokenIn.subtract(trade.inputAmount);
    const finalBalanceTokenOut = swapAndAddParameters.initialBalanceTokenOut.add(trade.outputAmount);
    const approvalTypes = await this.swapRouterProvider.getApprovalType(finalBalanceTokenIn, finalBalanceTokenOut);
    const zeroForOne = finalBalanceTokenIn.currency.wrapped.sortsBefore(finalBalanceTokenOut.currency.wrapped);
    return distExports.SwapRouter.swapAndAddCallParameters(trade, {
      recipient,
      slippageTolerance,
      deadlineOrPreviousBlockhash: deadline,
      inputTokenPermit
    }, Position$1.fromAmounts({
      pool: preLiquidityPosition.pool,
      tickLower: preLiquidityPosition.tickLower,
      tickUpper: preLiquidityPosition.tickUpper,
      amount0: zeroForOne ? finalBalanceTokenIn.quotient.toString() : finalBalanceTokenOut.quotient.toString(),
      amount1: zeroForOne ? finalBalanceTokenOut.quotient.toString() : finalBalanceTokenIn.quotient.toString(),
      useFullPrecision: false
    }), addLiquidityConfig, approvalTypes.approvalTokenIn, approvalTypes.approvalTokenOut);
  }
  emitPoolSelectionMetrics(swapRouteRaw, allPoolsBySelection) {
    const poolAddressesUsed = /* @__PURE__ */ new Set();
    const { routes: routeAmounts } = swapRouteRaw;
    _$3(routeAmounts).flatMap((routeAmount) => {
      const { poolAddresses } = routeAmount;
      return poolAddresses;
    }).forEach((address) => {
      poolAddressesUsed.add(address.toLowerCase());
    });
    for (const poolsBySelection of allPoolsBySelection) {
      const { protocol } = poolsBySelection;
      _$3.forIn(poolsBySelection.selections, (pools, topNSelection) => {
        const topNUsed = _$3.findLastIndex(pools, (pool) => poolAddressesUsed.has(pool.id.toLowerCase())) + 1;
        metric.putMetric(_$3.capitalize(`${protocol}${topNSelection}`), topNUsed, MetricLoggerUnit.Count);
      });
    }
    let hasV3Route = false;
    let hasV2Route = false;
    let hasMixedRoute = false;
    for (const routeAmount of routeAmounts) {
      if (routeAmount.protocol == distExports.Protocol.V3) {
        hasV3Route = true;
      }
      if (routeAmount.protocol == distExports.Protocol.V2) {
        hasV2Route = true;
      }
      if (routeAmount.protocol == distExports.Protocol.MIXED) {
        hasMixedRoute = true;
      }
    }
    if (hasMixedRoute && (hasV3Route || hasV2Route)) {
      if (hasV3Route && hasV2Route) {
        metric.putMetric(`MixedAndV3AndV2SplitRoute`, 1, MetricLoggerUnit.Count);
        metric.putMetric(`MixedAndV3AndV2SplitRouteForChain${this.chainId}`, 1, MetricLoggerUnit.Count);
      } else if (hasV3Route) {
        metric.putMetric(`MixedAndV3SplitRoute`, 1, MetricLoggerUnit.Count);
        metric.putMetric(`MixedAndV3SplitRouteForChain${this.chainId}`, 1, MetricLoggerUnit.Count);
      } else if (hasV2Route) {
        metric.putMetric(`MixedAndV2SplitRoute`, 1, MetricLoggerUnit.Count);
        metric.putMetric(`MixedAndV2SplitRouteForChain${this.chainId}`, 1, MetricLoggerUnit.Count);
      }
    } else if (hasV3Route && hasV2Route) {
      metric.putMetric(`V3AndV2SplitRoute`, 1, MetricLoggerUnit.Count);
      metric.putMetric(`V3AndV2SplitRouteForChain${this.chainId}`, 1, MetricLoggerUnit.Count);
    } else if (hasMixedRoute) {
      if (routeAmounts.length > 1) {
        metric.putMetric(`MixedSplitRoute`, 1, MetricLoggerUnit.Count);
        metric.putMetric(`MixedSplitRouteForChain${this.chainId}`, 1, MetricLoggerUnit.Count);
      } else {
        metric.putMetric(`MixedRoute`, 1, MetricLoggerUnit.Count);
        metric.putMetric(`MixedRouteForChain${this.chainId}`, 1, MetricLoggerUnit.Count);
      }
    } else if (hasV3Route) {
      if (routeAmounts.length > 1) {
        metric.putMetric(`V3SplitRoute`, 1, MetricLoggerUnit.Count);
        metric.putMetric(`V3SplitRouteForChain${this.chainId}`, 1, MetricLoggerUnit.Count);
      } else {
        metric.putMetric(`V3Route`, 1, MetricLoggerUnit.Count);
        metric.putMetric(`V3RouteForChain${this.chainId}`, 1, MetricLoggerUnit.Count);
      }
    } else if (hasV2Route) {
      if (routeAmounts.length > 1) {
        metric.putMetric(`V2SplitRoute`, 1, MetricLoggerUnit.Count);
        metric.putMetric(`V2SplitRouteForChain${this.chainId}`, 1, MetricLoggerUnit.Count);
      } else {
        metric.putMetric(`V2Route`, 1, MetricLoggerUnit.Count);
        metric.putMetric(`V2RouteForChain${this.chainId}`, 1, MetricLoggerUnit.Count);
      }
    }
  }
  calculateOptimalRatio(position2, sqrtRatioX96, zeroForOne) {
    const upperSqrtRatioX96 = TickMath.getSqrtRatioAtTick(position2.tickUpper);
    const lowerSqrtRatioX96 = TickMath.getSqrtRatioAtTick(position2.tickLower);
    if (JSBI.greaterThan(sqrtRatioX96, upperSqrtRatioX96) || JSBI.lessThan(sqrtRatioX96, lowerSqrtRatioX96)) {
      return new Fraction$3(0, 1);
    }
    const precision = JSBI.BigInt("1" + "0".repeat(18));
    let optimalRatio = new Fraction$3(SqrtPriceMath.getAmount0Delta(sqrtRatioX96, upperSqrtRatioX96, precision, true), SqrtPriceMath.getAmount1Delta(sqrtRatioX96, lowerSqrtRatioX96, precision, true));
    if (!zeroForOne)
      optimalRatio = optimalRatio.invert();
    return optimalRatio;
  }
  async userHasSufficientBalance(fromAddress, tradeType, amount, quote) {
    try {
      const neededBalance = tradeType == TradeType$3.EXACT_INPUT ? amount : quote;
      let balance;
      if (neededBalance.currency.isNative) {
        balance = await this.provider.getBalance(fromAddress);
      } else {
        const tokenContract = Erc20__factory.connect(neededBalance.currency.address, this.provider);
        balance = await tokenContract.balanceOf(fromAddress);
      }
      return balance.gte(BigNumber.from(neededBalance.quotient.toString()));
    } catch (e2) {
      log.error(e2, "Error while checking user balance");
      return false;
    }
  }
  absoluteValue(fraction) {
    const numeratorAbs = JSBI.lessThan(fraction.numerator, JSBI.BigInt(0)) ? JSBI.unaryMinus(fraction.numerator) : fraction.numerator;
    const denominatorAbs = JSBI.lessThan(fraction.denominator, JSBI.BigInt(0)) ? JSBI.unaryMinus(fraction.denominator) : fraction.denominator;
    return new Fraction$3(numeratorAbs, denominatorAbs);
  }
  getBlockNumberPromise() {
    return retry$1(async (_b, attempt) => {
      if (attempt > 1) {
        log.info(`Get block number attempt ${attempt}`);
      }
      return this.provider.getBlockNumber();
    }, {
      retries: 2,
      minTimeout: 100,
      maxTimeout: 1e3
    });
  }
}
async function getV2NativePool(token2, poolProvider) {
  const chainId2 = token2.chainId;
  const weth = WRAPPED_NATIVE_CURRENCY[chainId2];
  const poolAccessor = await poolProvider.getPools([[weth, token2]]);
  const pool = poolAccessor.getPool(weth, token2);
  if (!pool || pool.reserve0.equalTo(0) || pool.reserve1.equalTo(0)) {
    log.error({
      weth,
      token: token2,
      reserve0: pool === null || pool === void 0 ? void 0 : pool.reserve0.toExact(),
      reserve1: pool === null || pool === void 0 ? void 0 : pool.reserve1.toExact()
    }, `Could not find a valid WETH pool with ${token2.symbol} for computing gas costs.`);
    return null;
  }
  return pool;
}
async function getHighestLiquidityV3NativePool(token2, poolProvider) {
  const nativeCurrency = WRAPPED_NATIVE_CURRENCY[token2.chainId];
  const nativePools = _$3([FeeAmount.HIGH, FeeAmount.MEDIUM, FeeAmount.LOW]).map((feeAmount) => {
    return [nativeCurrency, token2, feeAmount];
  }).value();
  const poolAccessor = await poolProvider.getPools(nativePools);
  const pools = _$3([FeeAmount.HIGH, FeeAmount.MEDIUM, FeeAmount.LOW]).map((feeAmount) => {
    return poolAccessor.getPool(nativeCurrency, token2, feeAmount);
  }).compact().value();
  if (pools.length == 0) {
    log.error({ pools }, `Could not find a ${nativeCurrency.symbol} pool with ${token2.symbol} for computing gas costs.`);
    return null;
  }
  const maxPool = _$3.maxBy(pools, (pool) => pool.liquidity);
  return maxPool;
}
async function getHighestLiquidityV3USDPool(chainId2, poolProvider) {
  const usdTokens = usdGasTokensByChain[chainId2];
  const wrappedCurrency = WRAPPED_NATIVE_CURRENCY[chainId2];
  if (!usdTokens) {
    throw new Error(`Could not find a USD token for computing gas costs on ${chainId2}`);
  }
  const usdPools = _$3([
    FeeAmount.HIGH,
    FeeAmount.MEDIUM,
    FeeAmount.LOW,
    FeeAmount.LOWEST
  ]).flatMap((feeAmount) => {
    return _$3.map(usdTokens, (usdToken) => [
      wrappedCurrency,
      usdToken,
      feeAmount
    ]);
  }).value();
  const poolAccessor = await poolProvider.getPools(usdPools);
  const pools = _$3([
    FeeAmount.HIGH,
    FeeAmount.MEDIUM,
    FeeAmount.LOW,
    FeeAmount.LOWEST
  ]).flatMap((feeAmount) => {
    const pools2 = [];
    for (const usdToken of usdTokens) {
      const pool = poolAccessor.getPool(wrappedCurrency, usdToken, feeAmount);
      if (pool) {
        pools2.push(pool);
      }
    }
    return pools2;
  }).compact().value();
  if (pools.length == 0) {
    const message = `Could not find a USD/${wrappedCurrency.symbol} pool for computing gas costs.`;
    log.error({ pools }, message);
    throw new Error(message);
  }
  const maxPool = _$3.maxBy(pools, (pool) => pool.liquidity);
  return maxPool;
}
function getL2ToL1GasUsed(data2, overhead) {
  const dataArr = data2.slice(2).match(/.{1,2}/g);
  const numBytes = dataArr.length;
  let count = 0;
  for (let i3 = 0; i3 < numBytes; i3 += 1) {
    const byte2 = parseInt(dataArr[i3], 16);
    if (byte2 == 0) {
      count += 4;
    } else {
      count += 16;
    }
  }
  const unsigned = overhead.add(count);
  const signedConversion = 68 * 16;
  return unsigned.add(signedConversion);
}
var utils$3 = {};
utils$3.promiseFinally = (promise, fn2) => {
  const success = (result) => {
    fn2();
    return result;
  };
  const error = (e2) => {
    fn2();
    return Promise.reject(e2);
  };
  return Promise.resolve(promise).then(success, error);
};
utils$3.toError = (value) => {
  value = typeof value === "function" ? value() : value;
  return typeof value === "string" ? new Error(value) : value;
};
const { promiseFinally, toError } = utils$3;
var src$1 = class Timeout {
  static set(delay2, rejectReason) {
    return new Timeout().set(delay2, rejectReason);
  }
  static wrap(promise, delay2, rejectReason) {
    return new Timeout().wrap(promise, delay2, rejectReason);
  }
  constructor() {
    this._id = null;
    this._delay = null;
  }
  get id() {
    return this._id;
  }
  get delay() {
    return this._delay;
  }
  set(delay2, rejectReason = "") {
    return new Promise((resolve, reject) => {
      this.clear();
      const fn2 = rejectReason ? () => reject(toError(rejectReason)) : resolve;
      this._id = setTimeout(fn2, delay2);
      this._delay = delay2;
    });
  }
  wrap(promise, delay2, rejectReason = "") {
    const wrappedPromise = promiseFinally(promise, () => this.clear());
    const timer2 = this.set(delay2, rejectReason);
    return Promise.race([
      wrappedPromise,
      timer2
    ]);
  }
  clear() {
    if (this._id) {
      clearTimeout(this._id);
    }
  }
};
const Timeout2 = /* @__PURE__ */ getDefaultExportFromCjs(src$1);
class URISubgraphProvider {
  constructor(chainId2, uri, timeout = 6e3, retries = 2) {
    this.chainId = chainId2;
    this.uri = uri;
    this.timeout = timeout;
    this.retries = retries;
  }
  async getPools() {
    log.info({ uri: this.uri }, `About to get subgraph pools from URI ${this.uri}`);
    let allPools = [];
    await retry$1(async () => {
      const timeout = new Timeout2();
      const timerPromise = timeout.set(this.timeout).then(() => {
        throw new Error(`Timed out getting pools from subgraph: ${this.timeout}`);
      });
      let response;
      try {
        response = await Promise.race([axios$1.get(this.uri), timerPromise]);
      } catch (err) {
        throw err;
      } finally {
        timeout.clear();
      }
      const { data: poolsBuffer, status } = response;
      if (status != 200) {
        log.error({ response }, `Unabled to get pools from ${this.uri}.`);
        throw new Error(`Unable to get pools from ${this.uri}`);
      }
      const pools = poolsBuffer;
      log.info({ uri: this.uri, chain: this.chainId }, `Got subgraph pools from uri. Num: ${pools.length}`);
      allPools = pools;
    }, {
      retries: this.retries,
      onRetry: (err, retry2) => {
        log.info({ err }, `Failed to get pools from uri ${this.uri}. Retry attempt: ${retry2}`);
      }
    });
    return allPools;
  }
}
class CachingV2PoolProvider {
  /**
   * Creates an instance of CachingV3PoolProvider.
   * @param chainId The chain id to use.
   * @param poolProvider The provider to use to get the pools when not in the cache.
   * @param cache Cache instance to hold cached pools.
   */
  constructor(chainId2, poolProvider, cache) {
    this.chainId = chainId2;
    this.poolProvider = poolProvider;
    this.cache = cache;
    this.POOL_KEY = (chainId3, address) => `pool-${chainId3}-${address}`;
  }
  async getPools(tokenPairs, providerConfig) {
    const poolAddressSet = /* @__PURE__ */ new Set();
    const poolsToGetTokenPairs = [];
    const poolsToGetAddresses = [];
    const poolAddressToPool = {};
    const blockNumber = await (providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber);
    for (const [tokenA, tokenB] of tokenPairs) {
      const { poolAddress, token0, token1 } = this.getPoolAddress(tokenA, tokenB);
      if (poolAddressSet.has(poolAddress)) {
        continue;
      }
      poolAddressSet.add(poolAddress);
      const cachedPool = await this.cache.get(this.POOL_KEY(this.chainId, poolAddress));
      if (cachedPool) {
        if (!blockNumber || blockNumber && cachedPool.block == blockNumber) {
          poolAddressToPool[poolAddress] = cachedPool.pair;
          continue;
        }
      }
      poolsToGetTokenPairs.push([token0, token1]);
      poolsToGetAddresses.push(poolAddress);
    }
    log.info({
      poolsFound: _$3.map(Object.values(poolAddressToPool), (p2) => p2.token0.symbol + " " + p2.token1.symbol),
      poolsToGetTokenPairs: _$3.map(poolsToGetTokenPairs, (t2) => t2[0].symbol + " " + t2[1].symbol)
    }, `Found ${Object.keys(poolAddressToPool).length} V2 pools already in local cache for block ${blockNumber}. About to get reserves for ${poolsToGetTokenPairs.length} pools.`);
    if (poolsToGetAddresses.length > 0) {
      const poolAccessor = await this.poolProvider.getPools(poolsToGetTokenPairs, providerConfig);
      for (const address of poolsToGetAddresses) {
        const pool = poolAccessor.getPoolByAddress(address);
        if (pool) {
          poolAddressToPool[address] = pool;
          await this.cache.set(this.POOL_KEY(this.chainId, address), {
            pair: pool,
            block: blockNumber
          });
        }
      }
    }
    return {
      getPool: (tokenA, tokenB) => {
        const { poolAddress } = this.getPoolAddress(tokenA, tokenB);
        return poolAddressToPool[poolAddress];
      },
      getPoolByAddress: (address) => poolAddressToPool[address],
      getAllPools: () => Object.values(poolAddressToPool)
    };
  }
  getPoolAddress(tokenA, tokenB) {
    return this.poolProvider.getPoolAddress(tokenA, tokenB);
  }
}
class CachingV2SubgraphProvider {
  /**
   * Creates an instance of CachingV2SubgraphProvider.
   * @param chainId The chain id to use.
   * @param subgraphProvider The provider to use to get the subgraph pools when not in the cache.
   * @param cache Cache instance to hold cached pools.
   */
  constructor(chainId2, subgraphProvider, cache) {
    this.chainId = chainId2;
    this.subgraphProvider = subgraphProvider;
    this.cache = cache;
    this.SUBGRAPH_KEY = (chainId3) => `subgraph-pools-v2-${chainId3}`;
  }
  async getPools() {
    const cachedPools = await this.cache.get(this.SUBGRAPH_KEY(this.chainId));
    if (cachedPools) {
      return cachedPools;
    }
    const pools = await this.subgraphProvider.getPools();
    await this.cache.set(this.SUBGRAPH_KEY(this.chainId), pools);
    return pools;
  }
}
class V2QuoteProvider {
  /* eslint-disable @typescript-eslint/no-empty-function */
  constructor() {
  }
  /* eslint-enable @typescript-eslint/no-empty-function */
  async getQuotesManyExactIn(amountIns, routes) {
    return this.getQuotes(amountIns, routes, TradeType$3.EXACT_INPUT);
  }
  async getQuotesManyExactOut(amountOuts, routes) {
    return this.getQuotes(amountOuts, routes, TradeType$3.EXACT_OUTPUT);
  }
  async getQuotes(amounts, routes, tradeType) {
    const routesWithQuotes = [];
    const debugStrs = [];
    for (const route of routes) {
      const amountQuotes = [];
      let insufficientInputAmountErrorCount = 0;
      let insufficientReservesErrorCount = 0;
      for (const amount of amounts) {
        try {
          if (tradeType == TradeType$3.EXACT_INPUT) {
            let outputAmount = amount.wrapped;
            for (const pair of route.pairs) {
              const [outputAmountNew] = pair.getOutputAmount(outputAmount);
              outputAmount = outputAmountNew;
            }
            amountQuotes.push({
              amount,
              quote: BigNumber.from(outputAmount.quotient.toString())
            });
          } else {
            let inputAmount = amount.wrapped;
            for (let i3 = route.pairs.length - 1; i3 >= 0; i3--) {
              const pair = route.pairs[i3];
              [inputAmount] = pair.getInputAmount(inputAmount);
            }
            amountQuotes.push({
              amount,
              quote: BigNumber.from(inputAmount.quotient.toString())
            });
          }
        } catch (err) {
          if (err instanceof InsufficientInputAmountError) {
            insufficientInputAmountErrorCount = insufficientInputAmountErrorCount + 1;
            amountQuotes.push({ amount, quote: null });
          } else if (err instanceof InsufficientReservesError) {
            insufficientReservesErrorCount = insufficientReservesErrorCount + 1;
            amountQuotes.push({ amount, quote: null });
          } else {
            throw err;
          }
        }
      }
      if (insufficientInputAmountErrorCount > 0 || insufficientReservesErrorCount > 0) {
        debugStrs.push(`${[
          routeToString(route)
        ]} Input: ${insufficientInputAmountErrorCount} Reserves: ${insufficientReservesErrorCount} }`);
      }
      routesWithQuotes.push([route, amountQuotes]);
    }
    if (debugStrs.length > 0) {
      log.info({ debugStrs }, `Failed quotes for V2 routes`);
    }
    return {
      routesWithQuotes
    };
  }
}
const BASES_TO_CHECK_TRADES_AGAINST$1 = {
  [ChainId$2.MAINNET]: [
    WRAPPED_NATIVE_CURRENCY[ChainId$2.MAINNET],
    DAI_MAINNET,
    USDC_MAINNET,
    USDT_MAINNET,
    WBTC_MAINNET
  ],
  [ChainId$2.ROPSTEN]: [WRAPPED_NATIVE_CURRENCY[ChainId$2.ROPSTEN]],
  [ChainId$2.RINKEBY]: [
    WRAPPED_NATIVE_CURRENCY[ChainId$2.RINKEBY],
    DAI_RINKEBY_1,
    DAI_RINKEBY_2
  ],
  [ChainId$2.GRLI]: [WRAPPED_NATIVE_CURRENCY[ChainId$2.GRLI]],
  [ChainId$2.KOVAN]: [WRAPPED_NATIVE_CURRENCY[ChainId$2.KOVAN]],
  //v2 not deployed on [optimism, arbitrum, polygon, celo, gnosis, moonbeam] and their testnets
  [ChainId$2.OPTIMISM]: [],
  [ChainId$2.ARBITRUM_ONE]: [],
  [ChainId$2.ARBITRUM_RINKEBY]: [],
  [ChainId$2.OPTIMISTIC_KOVAN]: [],
  [ChainId$2.POLYGON]: [],
  [ChainId$2.POLYGON_MUMBAI]: [],
  [ChainId$2.CELO]: [],
  [ChainId$2.CELO_ALFAJORES]: [],
  [ChainId$2.GNOSIS]: [],
  [ChainId$2.MOONBEAM]: []
};
class StaticV2SubgraphProvider {
  constructor(chainId2) {
    this.chainId = chainId2;
  }
  async getPools(tokenIn, tokenOut) {
    log.info("In static subgraph provider for V2");
    const bases2 = BASES_TO_CHECK_TRADES_AGAINST$1[this.chainId];
    const basePairs = _$3.flatMap(bases2, (base3) => bases2.map((otherBase) => [base3, otherBase]));
    if (tokenIn && tokenOut) {
      basePairs.push([tokenIn, tokenOut], ...bases2.map((base3) => [tokenIn, base3]), ...bases2.map((base3) => [tokenOut, base3]));
    }
    const pairs = _$3(basePairs).filter((tokens2) => Boolean(tokens2[0] && tokens2[1])).filter(([tokenA, tokenB]) => tokenA.address !== tokenB.address && !tokenA.equals(tokenB)).value();
    const poolAddressSet = /* @__PURE__ */ new Set();
    const subgraphPools = _$3(pairs).map(([tokenA, tokenB]) => {
      const poolAddress = Pair.getAddress(tokenA, tokenB);
      if (poolAddressSet.has(poolAddress)) {
        return void 0;
      }
      poolAddressSet.add(poolAddress);
      const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];
      return {
        id: poolAddress,
        liquidity: "100",
        token0: {
          id: token0.address
        },
        token1: {
          id: token1.address
        },
        supply: 100,
        reserve: 100,
        reserveUSD: 100
      };
    }).compact().value();
    return subgraphPools;
  }
}
var dist = {};
var browserPonyfill = { exports: {} };
(function(module, exports) {
  var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
  var __self__ = function() {
    function F2() {
      this.fetch = false;
      this.DOMException = global2.DOMException;
    }
    F2.prototype = global2;
    return new F2();
  }();
  (function(self2) {
    (function(exports2) {
      var support2 = {
        searchParams: "URLSearchParams" in self2,
        iterable: "Symbol" in self2 && "iterator" in Symbol,
        blob: "FileReader" in self2 && "Blob" in self2 && function() {
          try {
            new Blob();
            return true;
          } catch (e2) {
            return false;
          }
        }(),
        formData: "FormData" in self2,
        arrayBuffer: "ArrayBuffer" in self2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support2.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView2 = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name2) {
        if (typeof name2 !== "string") {
          name2 = String(name2);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name2)) {
          throw new TypeError("Invalid character in header field name");
        }
        return name2.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items) {
        var iterator2 = {
          next: function() {
            var value = items.shift();
            return { done: value === void 0, value };
          }
        };
        if (support2.iterable) {
          iterator2[Symbol.iterator] = function() {
            return iterator2;
          };
        }
        return iterator2;
      }
      function Headers2(headers) {
        this.map = {};
        if (headers instanceof Headers2) {
          headers.forEach(function(value, name2) {
            this.append(name2, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name2) {
            this.append(name2, headers[name2]);
          }, this);
        }
      }
      Headers2.prototype.append = function(name2, value) {
        name2 = normalizeName(name2);
        value = normalizeValue(value);
        var oldValue = this.map[name2];
        this.map[name2] = oldValue ? oldValue + ", " + value : value;
      };
      Headers2.prototype["delete"] = function(name2) {
        delete this.map[normalizeName(name2)];
      };
      Headers2.prototype.get = function(name2) {
        name2 = normalizeName(name2);
        return this.has(name2) ? this.map[name2] : null;
      };
      Headers2.prototype.has = function(name2) {
        return this.map.hasOwnProperty(normalizeName(name2));
      };
      Headers2.prototype.set = function(name2, value) {
        this.map[normalizeName(name2)] = normalizeValue(value);
      };
      Headers2.prototype.forEach = function(callback, thisArg) {
        for (var name2 in this.map) {
          if (this.map.hasOwnProperty(name2)) {
            callback.call(thisArg, this.map[name2], name2, this);
          }
        }
      };
      Headers2.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name2) {
          items.push(name2);
        });
        return iteratorFor(items);
      };
      Headers2.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers2.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name2) {
          items.push([name2, value]);
        });
        return iteratorFor(items);
      };
      if (support2.iterable) {
        Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
      }
      function consumed(body2) {
        if (body2.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body2.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise;
      }
      function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i3 = 0; i3 < view.length; i3++) {
          chars[i3] = String.fromCharCode(view[i3]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body2) {
          this._bodyInit = body2;
          if (!body2) {
            this._bodyText = "";
          } else if (typeof body2 === "string") {
            this._bodyText = body2;
          } else if (support2.blob && Blob.prototype.isPrototypeOf(body2)) {
            this._bodyBlob = body2;
          } else if (support2.formData && FormData.prototype.isPrototypeOf(body2)) {
            this._bodyFormData = body2;
          } else if (support2.searchParams && URLSearchParams.prototype.isPrototypeOf(body2)) {
            this._bodyText = body2.toString();
          } else if (support2.arrayBuffer && support2.blob && isDataView(body2)) {
            this._bodyArrayBuffer = bufferClone(body2.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support2.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body2) || isArrayBufferView2(body2))) {
            this._bodyArrayBuffer = bufferClone(body2);
          } else {
            this._bodyText = body2 = Object.prototype.toString.call(body2);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body2 === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support2.searchParams && URLSearchParams.prototype.isPrototypeOf(body2)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support2.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support2.formData) {
          this.formData = function() {
            return this.text().then(decode2);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request(input, options) {
        options = options || {};
        var body2 = options.body;
        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers2(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body2 && input._bodyInit != null) {
            body2 = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers2(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body2) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body2);
      }
      Request.prototype.clone = function() {
        return new Request(this, { body: this._bodyInit });
      };
      function decode2(body2) {
        var form = new FormData();
        body2.trim().split("&").forEach(function(bytes2) {
          if (bytes2) {
            var split2 = bytes2.split("=");
            var name2 = split2.shift().replace(/\+/g, " ");
            var value = split2.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name2), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders2(rawHeaders) {
        var headers = new Headers2();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line2) {
          var parts = line2.split(":");
          var key2 = parts.shift().trim();
          if (key2) {
            var value = parts.join(":").trim();
            headers.append(key2, value);
          }
        });
        return headers;
      }
      Body.call(Request.prototype);
      function Response(bodyInit, options) {
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === void 0 ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options ? options.statusText : "OK";
        this.headers = new Headers2(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response.prototype);
      Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers2(this.headers),
          url: this.url
        });
      };
      Response.error = function() {
        var response = new Response(null, { status: 0, statusText: "" });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response(null, { status, headers: { location: url } });
      };
      exports2.DOMException = self2.DOMException;
      try {
        new exports2.DOMException();
      } catch (err) {
        exports2.DOMException = function(message, name2) {
          this.message = message;
          this.name = name2;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports2.DOMException.prototype = Object.create(Error.prototype);
        exports2.DOMException.prototype.constructor = exports2.DOMException;
      }
      function fetch2(input, init3) {
        return new Promise(function(resolve, reject) {
          var request2 = new Request(input, init3);
          if (request2.signal && request2.signal.aborted) {
            return reject(new exports2.DOMException("Aborted", "AbortError"));
          }
          var xhr2 = new XMLHttpRequest();
          function abortXhr() {
            xhr2.abort();
          }
          xhr2.onload = function() {
            var options = {
              status: xhr2.status,
              statusText: xhr2.statusText,
              headers: parseHeaders2(xhr2.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr2 ? xhr2.responseURL : options.headers.get("X-Request-URL");
            var body2 = "response" in xhr2 ? xhr2.response : xhr2.responseText;
            resolve(new Response(body2, options));
          };
          xhr2.onerror = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr2.ontimeout = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr2.onabort = function() {
            reject(new exports2.DOMException("Aborted", "AbortError"));
          };
          xhr2.open(request2.method, request2.url, true);
          if (request2.credentials === "include") {
            xhr2.withCredentials = true;
          } else if (request2.credentials === "omit") {
            xhr2.withCredentials = false;
          }
          if ("responseType" in xhr2 && support2.blob) {
            xhr2.responseType = "blob";
          }
          request2.headers.forEach(function(value, name2) {
            xhr2.setRequestHeader(name2, value);
          });
          if (request2.signal) {
            request2.signal.addEventListener("abort", abortXhr);
            xhr2.onreadystatechange = function() {
              if (xhr2.readyState === 4) {
                request2.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr2.send(typeof request2._bodyInit === "undefined" ? null : request2._bodyInit);
        });
      }
      fetch2.polyfill = true;
      if (!self2.fetch) {
        self2.fetch = fetch2;
        self2.Headers = Headers2;
        self2.Request = Request;
        self2.Response = Response;
      }
      exports2.Headers = Headers2;
      exports2.Request = Request;
      exports2.Response = Response;
      exports2.fetch = fetch2;
      Object.defineProperty(exports2, "__esModule", { value: true });
      return exports2;
    })({});
  })(__self__);
  __self__.fetch.ponyfill = true;
  delete __self__.fetch.polyfill;
  var ctx = __self__;
  exports = ctx.fetch;
  exports.default = ctx.fetch;
  exports.fetch = ctx.fetch;
  exports.Headers = ctx.Headers;
  exports.Request = ctx.Request;
  exports.Response = ctx.Response;
  module.exports = exports;
})(browserPonyfill, browserPonyfill.exports);
var browserPonyfillExports = browserPonyfill.exports;
const fetch$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserPonyfillExports);
var nodejsCustomInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : void 0;
const nodejsCustomInspectSymbol$1 = nodejsCustomInspectSymbol;
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect4(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (_typeof(value)) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? "[function ".concat(value.name, "]") : "[function]";
    case "object":
      if (value === null) {
        return "null";
      }
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (previouslySeenValues.indexOf(value) !== -1) {
    return "[Circular]";
  }
  var seenValues = [].concat(previouslySeenValues, [value]);
  var customInspectFn = getCustomFn(value);
  if (customInspectFn !== void 0) {
    var customValue = customInspectFn.call(value);
    if (customValue !== value) {
      return typeof customValue === "string" ? customValue : formatValue(customValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function formatObject(object, seenValues) {
  var keys = Object.keys(object);
  if (keys.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  var properties2 = keys.map(function(key2) {
    var value = formatValue(object[key2], seenValues);
    return key2 + ": " + value;
  });
  return "{ " + properties2.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  var len = Math.min(MAX_ARRAY_LENGTH, array.length);
  var remaining = array.length - len;
  var items = [];
  for (var i3 = 0; i3 < len; ++i3) {
    items.push(formatValue(array[i3], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push("... ".concat(remaining, " more items"));
  }
  return "[" + items.join(", ") + "]";
}
function getCustomFn(object) {
  var customInspectFn = object[String(nodejsCustomInspectSymbol$1)];
  if (typeof customInspectFn === "function") {
    return customInspectFn;
  }
  if (typeof object.inspect === "function") {
    return object.inspect;
  }
}
function getObjectTag(object) {
  var tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    var name2 = object.constructor.name;
    if (typeof name2 === "string" && name2 !== "") {
      return name2;
    }
  }
  return tag;
}
function invariant(condition, message) {
  var booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}
function defineInspect(classObject) {
  var fn2 = classObject.prototype.toJSON;
  typeof fn2 === "function" || invariant(0);
  classObject.prototype.inspect = fn2;
  if (nodejsCustomInspectSymbol$1) {
    classObject.prototype[nodejsCustomInspectSymbol$1] = fn2;
  }
}
var Location = /* @__PURE__ */ function() {
  function Location2(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  var _proto = Location2.prototype;
  _proto.toJSON = function toJSON2() {
    return {
      start: this.start,
      end: this.end
    };
  };
  return Location2;
}();
defineInspect(Location);
var Token = /* @__PURE__ */ function() {
  function Token2(kind, start, end, line2, column2, prev2, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line2;
    this.column = column2;
    this.value = value;
    this.prev = prev2;
    this.next = null;
  }
  var _proto2 = Token2.prototype;
  _proto2.toJSON = function toJSON2() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  };
  return Token2;
}();
defineInspect(Token);
function isNode(maybeNode) {
  return maybeNode != null && typeof maybeNode.kind === "string";
}
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: ["name", "variableDefinitions", "directives", "selectionSet"],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are experimental and may be changed
    // or removed in the future.
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: ["description", "name", "type", "defaultValue", "directives"],
  InterfaceTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var BREAK = Object.freeze({});
function visit(root, visitor) {
  var visitorKeys = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : QueryDocumentKeys;
  var stack = void 0;
  var inArray = Array.isArray(root);
  var keys = [root];
  var index2 = -1;
  var edits = [];
  var node2 = void 0;
  var key2 = void 0;
  var parent2 = void 0;
  var path = [];
  var ancestors = [];
  var newRoot = root;
  do {
    index2++;
    var isLeaving = index2 === keys.length;
    var isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key2 = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node2 = parent2;
      parent2 = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node2 = node2.slice();
        } else {
          var clone2 = {};
          for (var _i2 = 0, _Object$keys2 = Object.keys(node2); _i2 < _Object$keys2.length; _i2++) {
            var k4 = _Object$keys2[_i2];
            clone2[k4] = node2[k4];
          }
          node2 = clone2;
        }
        var editOffset = 0;
        for (var ii2 = 0; ii2 < edits.length; ii2++) {
          var editKey = edits[ii2][0];
          var editValue = edits[ii2][1];
          if (inArray) {
            editKey -= editOffset;
          }
          if (inArray && editValue === null) {
            node2.splice(editKey, 1);
            editOffset++;
          } else {
            node2[editKey] = editValue;
          }
        }
      }
      index2 = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else {
      key2 = parent2 ? inArray ? index2 : keys[index2] : void 0;
      node2 = parent2 ? parent2[key2] : newRoot;
      if (node2 === null || node2 === void 0) {
        continue;
      }
      if (parent2) {
        path.push(key2);
      }
    }
    var result = void 0;
    if (!Array.isArray(node2)) {
      if (!isNode(node2)) {
        throw new Error("Invalid AST Node: ".concat(inspect4(node2), "."));
      }
      var visitFn = getVisitFn(visitor, node2.kind, isLeaving);
      if (visitFn) {
        result = visitFn.call(visitor, node2, key2, parent2, path, ancestors);
        if (result === BREAK) {
          break;
        }
        if (result === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== void 0) {
          edits.push([key2, result]);
          if (!isLeaving) {
            if (isNode(result)) {
              node2 = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key2, node2]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _visitorKeys$node$kin;
      stack = {
        inArray,
        index: index2,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node2);
      keys = inArray ? node2 : (_visitorKeys$node$kin = visitorKeys[node2.kind]) !== null && _visitorKeys$node$kin !== void 0 ? _visitorKeys$node$kin : [];
      index2 = -1;
      edits = [];
      if (parent2) {
        ancestors.push(parent2);
      }
      parent2 = node2;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    newRoot = edits[edits.length - 1][1];
  }
  return newRoot;
}
function getVisitFn(visitor, kind, isLeaving) {
  var kindVisitor = visitor[kind];
  if (kindVisitor) {
    if (!isLeaving && typeof kindVisitor === "function") {
      return kindVisitor;
    }
    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;
    if (typeof kindSpecificVisitor === "function") {
      return kindSpecificVisitor;
    }
  } else {
    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;
    if (specificVisitor) {
      if (typeof specificVisitor === "function") {
        return specificVisitor;
      }
      var specificKindVisitor = specificVisitor[kind];
      if (typeof specificKindVisitor === "function") {
        return specificKindVisitor;
      }
    }
  }
}
function printBlockString(value) {
  var indentation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  var preferMultipleLines = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var isSingleLine = value.indexOf("\n") === -1;
  var hasLeadingSpace = value[0] === " " || value[0] === "	";
  var hasTrailingQuote = value[value.length - 1] === '"';
  var hasTrailingSlash = value[value.length - 1] === "\\";
  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;
  var result = "";
  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
    result += "\n" + indentation;
  }
  result += indentation ? value.replace(/\n/g, "\n" + indentation) : value;
  if (printAsMultipleLines) {
    result += "\n";
  }
  return '"""' + result.replace(/"""/g, '\\"""') + '"""';
}
function print(ast) {
  return visit(ast, {
    leave: printDocASTReducer
  });
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: function Name(node2) {
    return node2.value;
  },
  Variable: function Variable(node2) {
    return "$" + node2.name;
  },
  // Document
  Document: function Document2(node2) {
    return join(node2.definitions, "\n\n") + "\n";
  },
  OperationDefinition: function OperationDefinition(node2) {
    var op = node2.operation;
    var name2 = node2.name;
    var varDefs = wrap("(", join(node2.variableDefinitions, ", "), ")");
    var directives = join(node2.directives, " ");
    var selectionSet = node2.selectionSet;
    return !name2 && !directives && !varDefs && op === "query" ? selectionSet : join([op, join([name2, varDefs]), directives, selectionSet], " ");
  },
  VariableDefinition: function VariableDefinition(_ref) {
    var variable = _ref.variable, type = _ref.type, defaultValue = _ref.defaultValue, directives = _ref.directives;
    return variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "));
  },
  SelectionSet: function SelectionSet(_ref2) {
    var selections = _ref2.selections;
    return block(selections);
  },
  Field: function Field(_ref3) {
    var alias = _ref3.alias, name2 = _ref3.name, args = _ref3.arguments, directives = _ref3.directives, selectionSet = _ref3.selectionSet;
    var prefix2 = wrap("", alias, ": ") + name2;
    var argsLine = prefix2 + wrap("(", join(args, ", "), ")");
    if (argsLine.length > MAX_LINE_LENGTH) {
      argsLine = prefix2 + wrap("(\n", indent(join(args, "\n")), "\n)");
    }
    return join([argsLine, join(directives, " "), selectionSet], " ");
  },
  Argument: function Argument(_ref4) {
    var name2 = _ref4.name, value = _ref4.value;
    return name2 + ": " + value;
  },
  // Fragments
  FragmentSpread: function FragmentSpread(_ref5) {
    var name2 = _ref5.name, directives = _ref5.directives;
    return "..." + name2 + wrap(" ", join(directives, " "));
  },
  InlineFragment: function InlineFragment(_ref6) {
    var typeCondition = _ref6.typeCondition, directives = _ref6.directives, selectionSet = _ref6.selectionSet;
    return join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " ");
  },
  FragmentDefinition: function FragmentDefinition(_ref7) {
    var name2 = _ref7.name, typeCondition = _ref7.typeCondition, variableDefinitions = _ref7.variableDefinitions, directives = _ref7.directives, selectionSet = _ref7.selectionSet;
    return (
      // Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      "fragment ".concat(name2).concat(wrap("(", join(variableDefinitions, ", "), ")"), " ") + "on ".concat(typeCondition, " ").concat(wrap("", join(directives, " "), " ")) + selectionSet
    );
  },
  // Value
  IntValue: function IntValue(_ref8) {
    var value = _ref8.value;
    return value;
  },
  FloatValue: function FloatValue(_ref9) {
    var value = _ref9.value;
    return value;
  },
  StringValue: function StringValue(_ref10, key2) {
    var value = _ref10.value, isBlockString = _ref10.block;
    return isBlockString ? printBlockString(value, key2 === "description" ? "" : "  ") : JSON.stringify(value);
  },
  BooleanValue: function BooleanValue(_ref11) {
    var value = _ref11.value;
    return value ? "true" : "false";
  },
  NullValue: function NullValue() {
    return "null";
  },
  EnumValue: function EnumValue(_ref12) {
    var value = _ref12.value;
    return value;
  },
  ListValue: function ListValue(_ref13) {
    var values2 = _ref13.values;
    return "[" + join(values2, ", ") + "]";
  },
  ObjectValue: function ObjectValue(_ref14) {
    var fields = _ref14.fields;
    return "{" + join(fields, ", ") + "}";
  },
  ObjectField: function ObjectField(_ref15) {
    var name2 = _ref15.name, value = _ref15.value;
    return name2 + ": " + value;
  },
  // Directive
  Directive: function Directive(_ref16) {
    var name2 = _ref16.name, args = _ref16.arguments;
    return "@" + name2 + wrap("(", join(args, ", "), ")");
  },
  // Type
  NamedType: function NamedType(_ref17) {
    var name2 = _ref17.name;
    return name2;
  },
  ListType: function ListType(_ref18) {
    var type = _ref18.type;
    return "[" + type + "]";
  },
  NonNullType: function NonNullType(_ref19) {
    var type = _ref19.type;
    return type + "!";
  },
  // Type System Definitions
  SchemaDefinition: addDescription(function(_ref20) {
    var directives = _ref20.directives, operationTypes = _ref20.operationTypes;
    return join(["schema", join(directives, " "), block(operationTypes)], " ");
  }),
  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
    var operation = _ref21.operation, type = _ref21.type;
    return operation + ": " + type;
  },
  ScalarTypeDefinition: addDescription(function(_ref22) {
    var name2 = _ref22.name, directives = _ref22.directives;
    return join(["scalar", name2, join(directives, " ")], " ");
  }),
  ObjectTypeDefinition: addDescription(function(_ref23) {
    var name2 = _ref23.name, interfaces = _ref23.interfaces, directives = _ref23.directives, fields = _ref23.fields;
    return join(["type", name2, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
  }),
  FieldDefinition: addDescription(function(_ref24) {
    var name2 = _ref24.name, args = _ref24.arguments, type = _ref24.type, directives = _ref24.directives;
    return name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "));
  }),
  InputValueDefinition: addDescription(function(_ref25) {
    var name2 = _ref25.name, type = _ref25.type, defaultValue = _ref25.defaultValue, directives = _ref25.directives;
    return join([name2 + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ");
  }),
  InterfaceTypeDefinition: addDescription(function(_ref26) {
    var name2 = _ref26.name, interfaces = _ref26.interfaces, directives = _ref26.directives, fields = _ref26.fields;
    return join(["interface", name2, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
  }),
  UnionTypeDefinition: addDescription(function(_ref27) {
    var name2 = _ref27.name, directives = _ref27.directives, types2 = _ref27.types;
    return join(["union", name2, join(directives, " "), types2 && types2.length !== 0 ? "= " + join(types2, " | ") : ""], " ");
  }),
  EnumTypeDefinition: addDescription(function(_ref28) {
    var name2 = _ref28.name, directives = _ref28.directives, values2 = _ref28.values;
    return join(["enum", name2, join(directives, " "), block(values2)], " ");
  }),
  EnumValueDefinition: addDescription(function(_ref29) {
    var name2 = _ref29.name, directives = _ref29.directives;
    return join([name2, join(directives, " ")], " ");
  }),
  InputObjectTypeDefinition: addDescription(function(_ref30) {
    var name2 = _ref30.name, directives = _ref30.directives, fields = _ref30.fields;
    return join(["input", name2, join(directives, " "), block(fields)], " ");
  }),
  DirectiveDefinition: addDescription(function(_ref31) {
    var name2 = _ref31.name, args = _ref31.arguments, repeatable = _ref31.repeatable, locations = _ref31.locations;
    return "directive @" + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ");
  }),
  SchemaExtension: function SchemaExtension(_ref32) {
    var directives = _ref32.directives, operationTypes = _ref32.operationTypes;
    return join(["extend schema", join(directives, " "), block(operationTypes)], " ");
  },
  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
    var name2 = _ref33.name, directives = _ref33.directives;
    return join(["extend scalar", name2, join(directives, " ")], " ");
  },
  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
    var name2 = _ref34.name, interfaces = _ref34.interfaces, directives = _ref34.directives, fields = _ref34.fields;
    return join(["extend type", name2, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
  },
  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
    var name2 = _ref35.name, interfaces = _ref35.interfaces, directives = _ref35.directives, fields = _ref35.fields;
    return join(["extend interface", name2, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
  },
  UnionTypeExtension: function UnionTypeExtension(_ref36) {
    var name2 = _ref36.name, directives = _ref36.directives, types2 = _ref36.types;
    return join(["extend union", name2, join(directives, " "), types2 && types2.length !== 0 ? "= " + join(types2, " | ") : ""], " ");
  },
  EnumTypeExtension: function EnumTypeExtension(_ref37) {
    var name2 = _ref37.name, directives = _ref37.directives, values2 = _ref37.values;
    return join(["extend enum", name2, join(directives, " "), block(values2)], " ");
  },
  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
    var name2 = _ref38.name, directives = _ref38.directives, fields = _ref38.fields;
    return join(["extend input", name2, join(directives, " "), block(fields)], " ");
  }
};
function addDescription(cb2) {
  return function(node2) {
    return join([node2.description, cb2(node2)], "\n");
  };
}
function join(maybeArray) {
  var _maybeArray$filter$jo;
  var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter(function(x2) {
    return x2;
  }).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString) {
  var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function isMultiline(str) {
  return str.indexOf("\n") !== -1;
}
function hasMultilineItems(maybeArray) {
  return maybeArray != null && maybeArray.some(isMultiline);
}
const printer = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  print
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(printer);
var createRequestBody$1 = {};
var _public = {};
var ReactNativeFile$1 = function ReactNativeFile(_ref) {
  var uri = _ref.uri, name2 = _ref.name, type = _ref.type;
  this.uri = uri;
  this.name = name2;
  this.type = type;
};
var ReactNativeFile2 = ReactNativeFile$1;
var isExtractableFile = function isExtractableFile2(value) {
  return typeof File !== "undefined" && value instanceof File || typeof Blob !== "undefined" && value instanceof Blob || value instanceof ReactNativeFile2;
};
var defaultIsExtractableFile = isExtractableFile;
var extractFiles = function extractFiles2(value, path, isExtractableFile3) {
  if (path === void 0) {
    path = "";
  }
  if (isExtractableFile3 === void 0) {
    isExtractableFile3 = defaultIsExtractableFile;
  }
  var clone2;
  var files = /* @__PURE__ */ new Map();
  function addFile(paths, file) {
    var storedPaths = files.get(file);
    if (storedPaths)
      storedPaths.push.apply(storedPaths, paths);
    else
      files.set(file, paths);
  }
  if (isExtractableFile3(value)) {
    clone2 = null;
    addFile([path], value);
  } else {
    var prefix2 = path ? path + "." : "";
    if (typeof FileList !== "undefined" && value instanceof FileList)
      clone2 = Array.prototype.map.call(value, function(file, i4) {
        addFile(["" + prefix2 + i4], file);
        return null;
      });
    else if (Array.isArray(value))
      clone2 = value.map(function(child, i4) {
        var result2 = extractFiles2(child, "" + prefix2 + i4, isExtractableFile3);
        result2.files.forEach(addFile);
        return result2.clone;
      });
    else if (value && value.constructor === Object) {
      clone2 = {};
      for (var i3 in value) {
        var result = extractFiles2(value[i3], "" + prefix2 + i3, isExtractableFile3);
        result.files.forEach(addFile);
        clone2[i3] = result.clone;
      }
    } else
      clone2 = value;
  }
  return {
    clone: clone2,
    files
  };
};
_public.ReactNativeFile = ReactNativeFile$1;
_public.extractFiles = extractFiles;
_public.isExtractableFile = isExtractableFile;
var browser$2 = typeof self == "object" ? self.FormData : window.FormData;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(createRequestBody$1, "__esModule", { value: true });
var extract_files_1 = _public;
var form_data_1 = __importDefault$1(browser$2);
var isExtractableFileEnhanced = function(value) {
  return extract_files_1.isExtractableFile(value) || value !== null && typeof value === "object" && typeof value.pipe === "function";
};
function createRequestBody(query, variables, operationName) {
  var _a = extract_files_1.extractFiles({ query, variables, operationName }, "", isExtractableFileEnhanced), clone2 = _a.clone, files = _a.files;
  if (files.size === 0) {
    if (!Array.isArray(query)) {
      return JSON.stringify(clone2);
    }
    if (typeof variables !== "undefined" && !Array.isArray(variables)) {
      throw new Error("Cannot create request body with given variable type, array expected");
    }
    var payload = query.reduce(function(accu, currentQuery, index2) {
      accu.push({ query: currentQuery, variables: variables ? variables[index2] : void 0 });
      return accu;
    }, []);
    return JSON.stringify(payload);
  }
  var Form = typeof FormData === "undefined" ? form_data_1.default : FormData;
  var form = new Form();
  form.append("operations", JSON.stringify(clone2));
  var map = {};
  var i3 = 0;
  files.forEach(function(paths) {
    map[++i3] = paths;
  });
  form.append("map", JSON.stringify(map));
  i3 = 0;
  files.forEach(function(paths, file) {
    form.append("" + ++i3, file);
  });
  return form;
}
createRequestBody$1.default = createRequestBody;
var types$1 = {};
var __extends$1 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b3) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
      d3.__proto__ = b4;
    } || function(d3, b4) {
      for (var p2 in b4)
        if (Object.prototype.hasOwnProperty.call(b4, p2))
          d3[p2] = b4[p2];
    };
    return extendStatics2(d2, b3);
  };
  return function(d2, b3) {
    if (typeof b3 !== "function" && b3 !== null)
      throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
    extendStatics2(d2, b3);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
  };
}();
Object.defineProperty(types$1, "__esModule", { value: true });
types$1.ClientError = void 0;
var ClientError = (
  /** @class */
  function(_super) {
    __extends$1(ClientError2, _super);
    function ClientError2(response, request2) {
      var _this = this;
      var message = ClientError2.extractMessage(response) + ": " + JSON.stringify({
        response,
        request: request2
      });
      _this = _super.call(this, message) || this;
      Object.setPrototypeOf(_this, ClientError2.prototype);
      _this.response = response;
      _this.request = request2;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(_this, ClientError2);
      }
      return _this;
    }
    ClientError2.extractMessage = function(response) {
      try {
        return response.errors[0].message;
      } catch (e2) {
        return "GraphQL Error (Code: " + response.status + ")";
      }
    };
    return ClientError2;
  }(Error)
);
types$1.ClientError = ClientError;
(function(exports) {
  var __assign2 = commonjsGlobal && commonjsGlobal.__assign || function() {
    __assign2 = Object.assign || function(t2) {
      for (var s4, i3 = 1, n4 = arguments.length; i3 < n4; i3++) {
        s4 = arguments[i3];
        for (var p2 in s4)
          if (Object.prototype.hasOwnProperty.call(s4, p2))
            t2[p2] = s4[p2];
      }
      return t2;
    };
    return __assign2.apply(this, arguments);
  };
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k4, k22) {
    if (k22 === void 0)
      k22 = k4;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k4];
    } });
  } : function(o2, m2, k4, k22) {
    if (k22 === void 0)
      k22 = k4;
    o2[k22] = m2[k4];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k4 in mod)
        if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod, k4))
          __createBinding2(result, mod, k4);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body2) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f3, y2, t2, g2;
    return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n4) {
      return function(v2) {
        return step([n4, v2]);
      };
    }
    function step(op) {
      if (f3)
        throw new TypeError("Generator is already executing.");
      while (_2)
        try {
          if (f3 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
            return t2;
          if (y2 = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body2.call(thisArg, _2);
        } catch (e2) {
          op = [6, e2];
          y2 = 0;
        } finally {
          f3 = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var __rest2 = commonjsGlobal && commonjsGlobal.__rest || function(s4, e2) {
    var t2 = {};
    for (var p2 in s4)
      if (Object.prototype.hasOwnProperty.call(s4, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s4[p2];
    if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s4); i3 < p2.length; i3++) {
        if (e2.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p2[i3]))
          t2[p2[i3]] = s4[p2[i3]];
      }
    return t2;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.gql = exports.batchRequests = exports.request = exports.rawRequest = exports.GraphQLClient = exports.ClientError = void 0;
  var cross_fetch_1 = __importStar2(browserPonyfillExports), CrossFetch = cross_fetch_1;
  var printer_1 = require$$1;
  var createRequestBody_1 = __importDefault2(createRequestBody$1);
  var types_1 = types$1;
  Object.defineProperty(exports, "ClientError", { enumerable: true, get: function() {
    return types_1.ClientError;
  } });
  var resolveHeaders = function(headers) {
    var oHeaders = {};
    if (headers) {
      if (typeof Headers !== "undefined" && headers instanceof Headers || headers instanceof CrossFetch.Headers) {
        oHeaders = HeadersInstanceToPlainObject(headers);
      } else if (Array.isArray(headers)) {
        headers.forEach(function(_a) {
          var name2 = _a[0], value = _a[1];
          oHeaders[name2] = value;
        });
      } else {
        oHeaders = headers;
      }
    }
    return oHeaders;
  };
  var queryCleanner = function(str) {
    return str.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim();
  };
  var buildGetQueryParams = function(_a) {
    var query = _a.query, variables = _a.variables, operationName = _a.operationName;
    if (!Array.isArray(query)) {
      var search = ["query=" + encodeURIComponent(queryCleanner(query))];
      if (variables) {
        search.push("variables=" + encodeURIComponent(JSON.stringify(variables)));
      }
      if (operationName) {
        search.push("operationName=" + encodeURIComponent(operationName));
      }
      return search.join("&");
    }
    if (typeof variables !== "undefined" && !Array.isArray(variables)) {
      throw new Error("Cannot create query with given variable type, array expected");
    }
    var payload = query.reduce(function(accu, currentQuery, index2) {
      accu.push({
        query: queryCleanner(currentQuery),
        variables: variables ? JSON.stringify(variables[index2]) : void 0
      });
      return accu;
    }, []);
    return "query=" + encodeURIComponent(JSON.stringify(payload));
  };
  var post = function(_a) {
    var url = _a.url, query = _a.query, variables = _a.variables, operationName = _a.operationName, headers = _a.headers, fetch2 = _a.fetch, fetchOptions = _a.fetchOptions;
    return __awaiter2(void 0, void 0, void 0, function() {
      var body2;
      return __generator2(this, function(_b) {
        switch (_b.label) {
          case 0:
            body2 = createRequestBody_1.default(query, variables, operationName);
            return [4, fetch2(url, __assign2({ method: "POST", headers: __assign2(__assign2({}, typeof body2 === "string" ? { "Content-Type": "application/json" } : {}), headers), body: body2 }, fetchOptions))];
          case 1:
            return [2, _b.sent()];
        }
      });
    });
  };
  var get2 = function(_a) {
    var url = _a.url, query = _a.query, variables = _a.variables, operationName = _a.operationName, headers = _a.headers, fetch2 = _a.fetch, fetchOptions = _a.fetchOptions;
    return __awaiter2(void 0, void 0, void 0, function() {
      var queryParams;
      return __generator2(this, function(_b) {
        switch (_b.label) {
          case 0:
            queryParams = buildGetQueryParams({
              query,
              variables,
              operationName
            });
            return [4, fetch2(url + "?" + queryParams, __assign2({ method: "GET", headers }, fetchOptions))];
          case 1:
            return [2, _b.sent()];
        }
      });
    });
  };
  var GraphQLClient = (
    /** @class */
    function() {
      function GraphQLClient2(url, options) {
        this.url = url;
        this.options = options || {};
      }
      GraphQLClient2.prototype.rawRequest = function(query, variables, requestHeaders) {
        var _a = this.options, headers = _a.headers, _b = _a.fetch, fetch2 = _b === void 0 ? cross_fetch_1.default : _b, _c = _a.method, method = _c === void 0 ? "POST" : _c, fetchOptions = __rest2(_a, ["headers", "fetch", "method"]);
        var url = this.url;
        return makeRequest({
          url,
          query,
          variables,
          headers: __assign2(__assign2({}, resolveHeaders(headers)), resolveHeaders(requestHeaders)),
          operationName: void 0,
          fetch: fetch2,
          method,
          fetchOptions
        });
      };
      GraphQLClient2.prototype.request = function(document2, variables, requestHeaders) {
        return __awaiter2(this, void 0, void 0, function() {
          var _a, headers, _b, fetch2, _c, method, fetchOptions, url, _d, query, operationName, data2;
          return __generator2(this, function(_e2) {
            switch (_e2.label) {
              case 0:
                _a = this.options, headers = _a.headers, _b = _a.fetch, fetch2 = _b === void 0 ? cross_fetch_1.default : _b, _c = _a.method, method = _c === void 0 ? "POST" : _c, fetchOptions = __rest2(_a, ["headers", "fetch", "method"]);
                url = this.url;
                _d = resolveRequestDocument(document2), query = _d.query, operationName = _d.operationName;
                return [4, makeRequest({
                  url,
                  query,
                  variables,
                  headers: __assign2(__assign2({}, resolveHeaders(headers)), resolveHeaders(requestHeaders)),
                  operationName,
                  fetch: fetch2,
                  method,
                  fetchOptions
                })];
              case 1:
                data2 = _e2.sent().data;
                return [2, data2];
            }
          });
        });
      };
      GraphQLClient2.prototype.batchRequests = function(documents, requestHeaders) {
        return __awaiter2(this, void 0, void 0, function() {
          var _a, headers, _b, fetch2, _c, method, fetchOptions, url, queries, variables, data2;
          return __generator2(this, function(_d) {
            switch (_d.label) {
              case 0:
                _a = this.options, headers = _a.headers, _b = _a.fetch, fetch2 = _b === void 0 ? cross_fetch_1.default : _b, _c = _a.method, method = _c === void 0 ? "POST" : _c, fetchOptions = __rest2(_a, ["headers", "fetch", "method"]);
                url = this.url;
                queries = documents.map(function(_a2) {
                  var document2 = _a2.document;
                  return resolveRequestDocument(document2).query;
                });
                variables = documents.map(function(_a2) {
                  var variables2 = _a2.variables;
                  return variables2;
                });
                return [4, makeRequest({
                  url,
                  query: queries,
                  variables,
                  headers: __assign2(__assign2({}, resolveHeaders(headers)), resolveHeaders(requestHeaders)),
                  operationName: void 0,
                  fetch: fetch2,
                  method,
                  fetchOptions
                })];
              case 1:
                data2 = _d.sent().data;
                return [2, data2];
            }
          });
        });
      };
      GraphQLClient2.prototype.setHeaders = function(headers) {
        this.options.headers = headers;
        return this;
      };
      GraphQLClient2.prototype.setHeader = function(key2, value) {
        var _a;
        var headers = this.options.headers;
        if (headers) {
          headers[key2] = value;
        } else {
          this.options.headers = (_a = {}, _a[key2] = value, _a);
        }
        return this;
      };
      GraphQLClient2.prototype.setEndpoint = function(value) {
        this.url = value;
        return this;
      };
      return GraphQLClient2;
    }()
  );
  exports.GraphQLClient = GraphQLClient;
  function makeRequest(_a) {
    var url = _a.url, query = _a.query, variables = _a.variables, headers = _a.headers, operationName = _a.operationName, fetch2 = _a.fetch, _b = _a.method, method = _b === void 0 ? "POST" : _b, fetchOptions = _a.fetchOptions;
    return __awaiter2(this, void 0, void 0, function() {
      var fetcher, isBathchingQuery, response, result, successfullyReceivedData, headers_1, status_1, errorResult;
      return __generator2(this, function(_c) {
        switch (_c.label) {
          case 0:
            fetcher = method.toUpperCase() === "POST" ? post : get2;
            isBathchingQuery = Array.isArray(query);
            return [4, fetcher({
              url,
              query,
              variables,
              operationName,
              headers,
              fetch: fetch2,
              fetchOptions
            })];
          case 1:
            response = _c.sent();
            return [4, getResult2(response)];
          case 2:
            result = _c.sent();
            successfullyReceivedData = isBathchingQuery && Array.isArray(result) ? !result.some(function(_a2) {
              var data2 = _a2.data;
              return !data2;
            }) : !!result.data;
            if (response.ok && !result.errors && successfullyReceivedData) {
              headers_1 = response.headers, status_1 = response.status;
              return [2, __assign2(__assign2({}, isBathchingQuery ? { data: result } : result), { headers: headers_1, status: status_1 })];
            } else {
              errorResult = typeof result === "string" ? { error: result } : result;
              throw new types_1.ClientError(__assign2(__assign2({}, errorResult), { status: response.status, headers: response.headers }), { query, variables });
            }
        }
      });
    });
  }
  function rawRequest(url, query, variables, requestHeaders) {
    return __awaiter2(this, void 0, void 0, function() {
      var client2;
      return __generator2(this, function(_a) {
        client2 = new GraphQLClient(url);
        return [2, client2.rawRequest(query, variables, requestHeaders)];
      });
    });
  }
  exports.rawRequest = rawRequest;
  function request2(url, document2, variables, requestHeaders) {
    return __awaiter2(this, void 0, void 0, function() {
      var client2;
      return __generator2(this, function(_a) {
        client2 = new GraphQLClient(url);
        return [2, client2.request(document2, variables, requestHeaders)];
      });
    });
  }
  exports.request = request2;
  function batchRequests(url, documents, requestHeaders) {
    return __awaiter2(this, void 0, void 0, function() {
      var client2;
      return __generator2(this, function(_a) {
        client2 = new GraphQLClient(url);
        return [2, client2.batchRequests(documents, requestHeaders)];
      });
    });
  }
  exports.batchRequests = batchRequests;
  exports.default = request2;
  function getResult2(response) {
    var contentType = response.headers.get("Content-Type");
    if (contentType && contentType.startsWith("application/json")) {
      return response.json();
    } else {
      return response.text();
    }
  }
  function resolveRequestDocument(document2) {
    var _a;
    if (typeof document2 === "string")
      return { query: document2 };
    var operationName = void 0;
    var operationDefinitions = document2.definitions.filter(function(definition) {
      return definition.kind === "OperationDefinition";
    });
    if (operationDefinitions.length === 1) {
      operationName = (_a = operationDefinitions[0].name) === null || _a === void 0 ? void 0 : _a.value;
    }
    return { query: printer_1.print(document2), operationName };
  }
  function gql(chunks) {
    var variables = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      variables[_i - 1] = arguments[_i];
    }
    return chunks.reduce(function(accumulator, chunk, index2) {
      return "" + accumulator + chunk + (index2 in variables ? variables[index2] : "");
    }, "");
  }
  exports.gql = gql;
  function HeadersInstanceToPlainObject(headers) {
    var o2 = {};
    headers.forEach(function(v2, k4) {
      o2[k4] = v2;
    });
    return o2;
  }
})(dist);
({
  [ChainId$2.MAINNET]: "https://api.thegraph.com/subgraphs/name/ianlapham/uniswapv2",
  [ChainId$2.RINKEBY]: "https://api.thegraph.com/subgraphs/name/ianlapham/uniswap-v2-rinkeby"
});
class V2SubgraphProviderWithFallBacks {
  /**
   * Creates an instance of V2SubgraphProviderWithFallBacks.
   * @param fallbacks Ordered list of `IV2SubgraphProvider` to try to get pools from.
   */
  constructor(fallbacks) {
    this.fallbacks = fallbacks;
  }
  async getPools(tokenIn, tokenOut, providerConfig) {
    for (let i3 = 0; i3 < this.fallbacks.length; i3++) {
      const provider = this.fallbacks[i3];
      try {
        const pools = await provider.getPools(tokenIn, tokenOut, providerConfig);
        return pools;
      } catch (err) {
        log.info(`Failed to get subgraph pools for V2 from fallback #${i3}`);
      }
    }
    throw new Error("Failed to get subgraph pools from any providers");
  }
}
class CachingV3PoolProvider {
  /**
   * Creates an instance of CachingV3PoolProvider.
   * @param chainId The chain id to use.
   * @param poolProvider The provider to use to get the pools when not in the cache.
   * @param cache Cache instance to hold cached pools.
   */
  constructor(chainId2, poolProvider, cache) {
    this.chainId = chainId2;
    this.poolProvider = poolProvider;
    this.cache = cache;
    this.POOL_KEY = (chainId3, address) => `pool-${chainId3}-${address}`;
  }
  async getPools(tokenPairs, providerConfig) {
    const poolAddressSet = /* @__PURE__ */ new Set();
    const poolsToGetTokenPairs = [];
    const poolsToGetAddresses = [];
    const poolAddressToPool = {};
    for (const [tokenA, tokenB, feeAmount] of tokenPairs) {
      const { poolAddress, token0, token1 } = this.getPoolAddress(tokenA, tokenB, feeAmount);
      if (poolAddressSet.has(poolAddress)) {
        continue;
      }
      poolAddressSet.add(poolAddress);
      const cachedPool = await this.cache.get(this.POOL_KEY(this.chainId, poolAddress));
      if (cachedPool) {
        poolAddressToPool[poolAddress] = cachedPool;
        continue;
      }
      poolsToGetTokenPairs.push([token0, token1, feeAmount]);
      poolsToGetAddresses.push(poolAddress);
    }
    log.info({
      poolsFound: _$3.map(Object.values(poolAddressToPool), (p2) => `${p2.token0.symbol} ${p2.token1.symbol} ${p2.fee}`),
      poolsToGetTokenPairs: _$3.map(poolsToGetTokenPairs, (t2) => `${t2[0].symbol} ${t2[1].symbol} ${t2[2]}`)
    }, `Found ${Object.keys(poolAddressToPool).length} V3 pools already in local cache. About to get liquidity and slot0s for ${poolsToGetTokenPairs.length} pools.`);
    if (poolsToGetAddresses.length > 0) {
      const poolAccessor = await this.poolProvider.getPools(poolsToGetTokenPairs, providerConfig);
      for (const address of poolsToGetAddresses) {
        const pool = poolAccessor.getPoolByAddress(address);
        if (pool) {
          poolAddressToPool[address] = pool;
          await this.cache.set(this.POOL_KEY(this.chainId, address), pool);
        }
      }
    }
    return {
      getPool: (tokenA, tokenB, feeAmount) => {
        const { poolAddress } = this.getPoolAddress(tokenA, tokenB, feeAmount);
        return poolAddressToPool[poolAddress];
      },
      getPoolByAddress: (address) => poolAddressToPool[address],
      getAllPools: () => Object.values(poolAddressToPool)
    };
  }
  getPoolAddress(tokenA, tokenB, feeAmount) {
    return this.poolProvider.getPoolAddress(tokenA, tokenB, feeAmount);
  }
}
class CachingV3SubgraphProvider {
  /**
   * Creates an instance of CachingV3SubgraphProvider.
   * @param chainId The chain id to use.
   * @param subgraphProvider The provider to use to get the subgraph pools when not in the cache.
   * @param cache Cache instance to hold cached pools.
   */
  constructor(chainId2, subgraphProvider, cache) {
    this.chainId = chainId2;
    this.subgraphProvider = subgraphProvider;
    this.cache = cache;
    this.SUBGRAPH_KEY = (chainId3) => `subgraph-pools-${chainId3}`;
  }
  async getPools() {
    const cachedPools = await this.cache.get(this.SUBGRAPH_KEY(this.chainId));
    if (cachedPools) {
      return cachedPools;
    }
    const pools = await this.subgraphProvider.getPools();
    await this.cache.set(this.SUBGRAPH_KEY(this.chainId), pools);
    return pools;
  }
}
const BASES_TO_CHECK_TRADES_AGAINST = {
  [ChainId$2.MAINNET]: [
    WRAPPED_NATIVE_CURRENCY[ChainId$2.MAINNET],
    DAI_MAINNET,
    USDC_MAINNET,
    USDT_MAINNET,
    WBTC_MAINNET
  ],
  [ChainId$2.ROPSTEN]: [
    WRAPPED_NATIVE_CURRENCY[ChainId$2.ROPSTEN],
    DAI_ROPSTEN,
    USDT_ROPSTEN,
    USDC_ROPSTEN
  ],
  [ChainId$2.RINKEBY]: [
    WRAPPED_NATIVE_CURRENCY[ChainId$2.RINKEBY],
    DAI_RINKEBY_1,
    DAI_RINKEBY_2,
    USDC_RINKEBY,
    USDT_RINKEBY
  ],
  [ChainId$2.GRLI]: [
    WRAPPED_NATIVE_CURRENCY[ChainId$2.GRLI],
    USDT_GRLI,
    USDC_GRLI,
    WBTC_GRLI,
    DAI_GRLI
  ],
  [ChainId$2.KOVAN]: [
    WRAPPED_NATIVE_CURRENCY[ChainId$2.KOVAN],
    USDC_KOVAN,
    USDT_KOVAN,
    WBTC_KOVAN,
    DAI_KOVAN
  ],
  [ChainId$2.OPTIMISM]: [
    WRAPPED_NATIVE_CURRENCY[ChainId$2.OPTIMISM],
    USDC_OPTIMISM,
    DAI_OPTIMISM,
    USDT_OPTIMISM,
    WBTC_OPTIMISM
  ],
  [ChainId$2.ARBITRUM_ONE]: [
    WRAPPED_NATIVE_CURRENCY[ChainId$2.ARBITRUM_ONE],
    WBTC_ARBITRUM,
    DAI_ARBITRUM,
    USDC_ARBITRUM,
    USDT_ARBITRUM
  ],
  [ChainId$2.ARBITRUM_RINKEBY]: [
    WRAPPED_NATIVE_CURRENCY[ChainId$2.ARBITRUM_RINKEBY],
    DAI_ARBITRUM_RINKEBY,
    UNI_ARBITRUM_RINKEBY,
    USDT_ARBITRUM_RINKEBY
  ],
  [ChainId$2.OPTIMISTIC_KOVAN]: [
    WRAPPED_NATIVE_CURRENCY[ChainId$2.OPTIMISTIC_KOVAN],
    DAI_OPTIMISTIC_KOVAN,
    WBTC_OPTIMISTIC_KOVAN,
    USDT_OPTIMISTIC_KOVAN,
    USDC_OPTIMISTIC_KOVAN
  ],
  [ChainId$2.POLYGON]: [USDC_POLYGON, WETH_POLYGON, WMATIC_POLYGON],
  [ChainId$2.POLYGON_MUMBAI]: [
    DAI_POLYGON_MUMBAI,
    WRAPPED_NATIVE_CURRENCY[ChainId$2.POLYGON_MUMBAI],
    WMATIC_POLYGON_MUMBAI
  ],
  [ChainId$2.CELO]: [CELO, CUSD_CELO, CEUR_CELO, DAI_CELO],
  [ChainId$2.CELO_ALFAJORES]: [
    CELO_ALFAJORES,
    CUSD_CELO_ALFAJORES,
    CEUR_CELO_ALFAJORES,
    DAI_CELO_ALFAJORES
  ],
  [ChainId$2.GNOSIS]: [
    WRAPPED_NATIVE_CURRENCY[ChainId$2.GNOSIS],
    WBTC_GNOSIS,
    WXDAI_GNOSIS,
    USDC_ETHEREUM_GNOSIS
  ],
  [ChainId$2.MOONBEAM]: [
    WRAPPED_NATIVE_CURRENCY[ChainId$2.MOONBEAM],
    DAI_MOONBEAM,
    USDC_MOONBEAM,
    WBTC_MOONBEAM
  ]
};
class StaticV3SubgraphProvider {
  constructor(chainId2, poolProvider) {
    this.chainId = chainId2;
    this.poolProvider = poolProvider;
  }
  async getPools(tokenIn, tokenOut) {
    log.info("In static subgraph provider for V3");
    const bases2 = BASES_TO_CHECK_TRADES_AGAINST[this.chainId];
    const basePairs = _$3.flatMap(bases2, (base3) => bases2.map((otherBase) => [base3, otherBase]));
    if (tokenIn && tokenOut) {
      basePairs.push([tokenIn, tokenOut], ...bases2.map((base3) => [tokenIn, base3]), ...bases2.map((base3) => [tokenOut, base3]));
    }
    const pairs = _$3(basePairs).filter((tokens2) => Boolean(tokens2[0] && tokens2[1])).filter(([tokenA, tokenB]) => tokenA.address !== tokenB.address && !tokenA.equals(tokenB)).flatMap(([tokenA, tokenB]) => {
      return [
        [tokenA, tokenB, FeeAmount.LOWEST],
        [tokenA, tokenB, FeeAmount.LOW],
        [tokenA, tokenB, FeeAmount.MEDIUM],
        [tokenA, tokenB, FeeAmount.HIGH]
      ];
    }).value();
    log.info(`V3 Static subgraph provider about to get ${pairs.length} pools on-chain`);
    const poolAccessor = await this.poolProvider.getPools(pairs);
    const pools = poolAccessor.getAllPools();
    const poolAddressSet = /* @__PURE__ */ new Set();
    const subgraphPools = _$3(pools).map((pool) => {
      const { token0, token1, fee, liquidity } = pool;
      const poolAddress = Pool.getAddress(pool.token0, pool.token1, pool.fee);
      if (poolAddressSet.has(poolAddress)) {
        return void 0;
      }
      poolAddressSet.add(poolAddress);
      const liquidityNumber = JSBI.toNumber(liquidity);
      return {
        id: poolAddress,
        feeTier: unparseFeeAmount(fee),
        liquidity: liquidity.toString(),
        token0: {
          id: token0.address
        },
        token1: {
          id: token1.address
        },
        // As a very rough proxy we just use liquidity for TVL.
        tvlETH: liquidityNumber,
        tvlUSD: liquidityNumber
      };
    }).compact().value();
    return subgraphPools;
  }
}
({
  [ChainId$2.MAINNET]: "https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3",
  [ChainId$2.RINKEBY]: "https://api.thegraph.com/subgraphs/name/ianlapham/uniswap-v3-rinkeby",
  [ChainId$2.OPTIMISM]: "https://api.thegraph.com/subgraphs/name/ianlapham/optimism-post-regenesis",
  [ChainId$2.ARBITRUM_ONE]: "https://api.thegraph.com/subgraphs/name/ianlapham/arbitrum-minimal",
  [ChainId$2.POLYGON]: "https://api.thegraph.com/subgraphs/name/ianlapham/uniswap-v3-polygon",
  [ChainId$2.CELO]: "https://api.thegraph.com/subgraphs/name/jesse-sawa/uniswap-celo",
  [ChainId$2.GRLI]: "https://api.thegraph.com/subgraphs/name/ianlapham/uniswap-v3-gorli"
});
class V3SubgraphProviderWithFallBacks {
  constructor(fallbacks) {
    this.fallbacks = fallbacks;
  }
  async getPools(tokenIn, tokenOut, providerConfig) {
    for (let i3 = 0; i3 < this.fallbacks.length; i3++) {
      const provider = this.fallbacks[i3];
      try {
        const pools = await provider.getPools(tokenIn, tokenOut, providerConfig);
        return pools;
      } catch (err) {
        log.info(`Failed to get subgraph pools for V3 from fallback #${i3}`);
      }
    }
    throw new Error("Failed to get subgraph pools from any providers");
  }
}
const ERC20ABI = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "subtractedValue",
        type: "uint256"
      }
    ],
    name: "decreaseAllowance",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "addedValue",
        type: "uint256"
      }
    ],
    name: "increaseAllowance",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const V3_SWAP_Router_ADRRESS = "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45";
const testnet_url = "https://holesky-fullnode-testnet.rpc.grove.city/v1/e62fd814";
const chainId = Number("3");
const Web3Provider2 = new JsonRpcProvider(testnet_url);
const router = new AlphaRouter({ chainId, provider: Web3Provider2 });
const name0 = "Wrapped Ether";
const symbol0 = "WETH";
const decimal0 = 18;
const address0 = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
const name1 = "Uniswap Token";
const symbol1 = "UNI";
const decimal1 = 18;
const address1 = "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984";
const WETH = new Token$4(chainId, address0, decimal0, symbol0, name0);
const UNI = new Token$4(chainId, address1, decimal1, symbol1, name1);
const getWethContract = () => new Contract(address0, ERC20ABI, Web3Provider2);
const getUniContract = () => new Contract(address1, ERC20ABI, Web3Provider2);
const getPrice = async (inputAmount, slippageAmount, deadline, walletAddress) => {
  const percentSlippage = new Percent$3(slippageAmount, 100);
  const wei = parseUnits(inputAmount.toString(), decimal0);
  const currencyAmount = CurrencyAmount$4.fromRawAmount(WETH, JSBI.BigInt(wei));
  const route = await router.route(
    currencyAmount,
    UNI,
    TradeType$3.EXACT_INPUT,
    {
      recipient: walletAddress,
      slippageTolerance: percentSlippage,
      deadline
    }
  );
  const transaction = {
    data: route.methodParameters.calldata,
    to: V3_SWAP_Router_ADRRESS,
    value: BigNumber.from(route.methodParameters.value),
    from: walletAddress,
    gasPrice: BigNumber.from(route.gasPriceWei),
    gasLimit: hexlify(1e6)
  };
  const quoteAmountOut = route.quote.toFixed(6);
  const ratio = (inputAmount / quoteAmountOut).toFixed(3);
  return [
    transaction,
    quoteAmountOut,
    ratio
  ];
};
const runSwap = async (transaction, signer) => {
  const approvalAmount = parseUnits("10", 18).toString();
  const contract0 = getWethContract();
  await contract0.connect(signer).approve(
    V3_SWAP_Router_ADRRESS,
    approvalAmount
  );
  signer.sendTransaction(transaction);
};
const Swap = ({ user, balance, unibal, activeButton }) => {
  const [data2, setData] = reactExports.useState({
    inputCurrency: "",
    inputAmount: void 0,
    outputAmount: 2,
    outputCurrency: "",
    totalAmount: ""
  });
  const [deadline, setDeadline] = reactExports.useState(10);
  const [ratio, setRatio] = reactExports.useState(void 0);
  const [transaction, setTransaction] = reactExports.useState(void 0);
  const [signer, setSigner] = reactExports.useState(void 0);
  const [bal, setBal] = reactExports.useState(void 0);
  const [uniBal, setUniBal] = reactExports.useState(void 0);
  const [error, setError] = reactExports.useState(null);
  const [wethContract, setWethContract] = reactExports.useState(void 0);
  const [uniContract, setUniContract] = reactExports.useState(void 0);
  reactExports.useEffect(() => {
    const wethContract2 = getWethContract();
    setWethContract(wethContract2);
    const uniContract2 = getUniContract();
    setUniContract(uniContract2);
    if (activeButton !== null) {
      if (user) {
        wethContract2.balanceOf(user).then((res) => {
          const wethBalance = Number(ethers.utils.formatEther(res));
          if (wethBalance === 0)
            ;
          else {
            setWethAmount(wethBalance);
          }
        }).catch((error2) => {
          setError(error2);
          console.error("Error fetching WETH balance:", error2);
        });
        uniContract2.balanceOf(user).then((res) => {
          setUniAmount(Number(ethers.utils.formatEther(res)));
        });
      }
    }
  }, []);
  reactExports.useEffect(() => {
    const signerAddres = user;
    setSigner(user);
    setBal(balance);
    setUniBal(unibal);
    if (signerAddres && data2.inputAmount !== void 0) {
      getPrice(
        data2.inputAmount,
        data2.outputAmount,
        Math.floor(Date.now() / 1e3 + deadline * 60),
        signerAddres
      ).then((data22) => {
        setTransaction(data22[0]);
        setOutputAmount(data22[1]);
        setRatio(data22[2]);
      });
    }
  }, [data2.inputAmount]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Stack$1,
    {
      gap: 2,
      mt: 2,
      sx: { background: "#fff", py: 4, px: 2, borderRadius: 2 },
      children: [
        error ? /* @__PURE__ */ jsxRuntimeExports.jsx(Alert$1, { severity: "error", children: "No balance detected in Wallet" }) : "",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "h3", color: "secondary", children: "Swap" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectItem,
          {
            value: data2.inputCurrency,
            label: "Select CryptoCurrency",
            menus: [
              ["ethereum", "WETH"]
            ],
            handleChange: (e2) => setData((prev2) => ({ ...prev2, inputCurrency: e2.target.value }))
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField$1,
          {
            label: "Amount",
            value: data2.inputAmount,
            onChange: (e2) => setData((prev2) => ({ ...prev2, inputAmount: e2.target.value }))
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectItem,
          {
            value: data2.outputCurrency,
            label: "Select Output CryptoCurrency",
            menus: [
              ["uniswap", "UNI"]
            ],
            handleChange: (e2) => setData((prev2) => ({ ...prev2, outputCurrency: e2.target.value }))
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Stack$1,
          {
            flexDirection: "row",
            justifyContent: "space-between",
            alignItems: "center",
            children: [
              ratio && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "h4", color: "initial", children: `1 UNI = ${ratio} WETH` }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { sx: { fontSize: 18, width: 100 }, variant: "contained", color: "primary", onClick: () => runSwap(transaction, signer), children: "swap" })
            ]
          }
        )
      ]
    }
  ) });
};
const Liquidity = (props) => {
  const [data2, setData] = reactExports.useState({
    inputCurrency: "",
    inputAmount: "",
    outputCurrency: "",
    totalAmount: "",
    liquidity: {
      firstCrypto: "bitcoin",
      firstCryptoamount: "",
      secondCrypto: "ethereum",
      secondCryptoamount: "",
      lpToken: "SEMILP",
      totalAmountLiquidity: ""
    }
  });
  const [totalValue, setTotalValue] = reactExports.useState("");
  reactExports.useEffect(() => {
    let value = data2.liquidity.firstCryptoamount * 382.421;
    let fee = value / 100 * 0.3;
    value = value - fee;
    setTotalValue(value);
  }, [data2.liquidity.secondCrypto]);
  const addLiquidity = async () => {
    const provider = new Web3Provider$1(window.ethereum);
    const decimal02 = 18;
    const address02 = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
    const decimal12 = 18;
    const address12 = "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984";
    const uniswapRouterAddress = "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45";
    const uniswapRouter = new Contract(uniswapRouterAddress, ERC20ABI, provider.getSigner());
    const token0 = new Contract(address02, ["function approve(address spender, uint amount)"], provider.getSigner());
    const token1 = new Contract(address12, ["function approve(address spender, uint amount)"], provider.getSigner());
    const amount0Desired = parseUnits(data2.liquidity.firstCryptoamount, decimal02);
    const amount1Desired = parseUnits("380.412", decimal12);
    const amount0Min = 0;
    const amount1Min = 0;
    const deadline = Math.floor(Date.now() / 1e3) + 60 * 10;
    await token0.approve(uniswapRouter.address, amount0Desired);
    await token1.approve(uniswapRouter.address, amount1Desired);
    const tx = await uniswapRouter.addLiquidity(
      address02,
      address12,
      amount0Desired,
      amount1Desired,
      amount0Min,
      amount1Min,
      window.ethereum.selectedAddress,
      deadline
    );
    await tx.wait();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Stack$1,
    {
      gap: 2,
      mt: 2,
      sx: { background: "#fff", py: 4, px: 2, borderRadius: 2 },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "h3", color: "secondary", children: "Liquidity" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectItem,
          {
            value: data2.liquidity.firstCrypto,
            label: "Select Cryptocurrency 1",
            menus: [
              ["ethereum", "WETH"],
              ,
            ],
            handleChange: (e2) => setData((prev2) => ({
              ...prev2,
              liquidity: { ...prev2.liquidity, firstCrypto: e2.target.value }
            }))
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-field", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "input-amount-1", children: "Enter Amount 1:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              id: "input-amount-1",
              placeholder: "Enter Amount",
              value: data2.liquidity.firstCryptoamount,
              onChange: (e2) => setData((prev2) => ({
                ...prev2,
                liquidity: {
                  ...prev2.liquidity,
                  firstCryptoamount: e2.target.value
                }
              }))
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectItem,
          {
            value: data2.liquidity.secondCrypto,
            label: "Select Cryptocurrency 2",
            menus: [
              ["uniSwap", "UNI"]
            ],
            handleChange: (e2) => setData((prev2) => ({
              ...prev2,
              liquidity: { ...prev2.liquidity, secondCrypto: e2.target.value }
            }))
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-field", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "input-amount-2", children: "Fee :" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              id: "input-amount-2",
              placeholder: "0.30% fee",
              value: data2.liquidity.secondCryptoamount,
              readOnly: true
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-field", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "total-amount", children: "Uni : " }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              id: "total-amount",
              className: "input-total",
              readOnly: true,
              value: totalValue
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            className: "button",
            sx: { fontSize: 18, width: 200 },
            variant: "contained",
            color: "primary",
            onClick: () => addLiquidity(),
            children: "Add Liquidity"
          }
        )
      ]
    }
  ) });
};
const stakingAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "stakingToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "rewardToken",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "RewardsClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Staked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdrawn",
    type: "event"
  },
  {
    inputs: [],
    name: "REWARD_RATE",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "earned",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getReward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "lastUpdateTime",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "rewardPerToken",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "rewardPerTokenStored",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "rewards",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "s_rewardToken",
    outputs: [
      {
        internalType: "contract IERC20",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "s_stakingToken",
    outputs: [
      {
        internalType: "contract IERC20",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "stake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "stakedBalance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "userRewardPerTokenPaid",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "withdrawStakedTokens",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const stakeTokenAbi = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "initialSupply",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "allowance",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256"
      }
    ],
    name: "ERC20InsufficientAllowance",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256"
      }
    ],
    name: "ERC20InsufficientBalance",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "approver",
        type: "address"
      }
    ],
    name: "ERC20InvalidApprover",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "ERC20InvalidReceiver",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "ERC20InvalidSender",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "ERC20InvalidSpender",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const Staking = ({ activeButton }) => {
  const [network, setNetwork] = reactExports.useState("Unsupported Network 'Use Sepolia Network'");
  const approvedTokenRef = reactExports.useRef();
  const [data2, setData] = reactExports.useState({
    inputCurrency: "",
    inputAmount: "",
    outputCurrency: "",
    totalAmount: "",
    staking: {
      token: "SemiFuel",
      stakeDuration: "",
      stakeAmount: ""
    }
  });
  const [signer, setSigner] = reactExports.useState(null);
  reactExports.useState(null);
  const [stakingContract, setStakingContract] = reactExports.useState(null);
  const [stakeTokenContract, setStakeTokenContract] = reactExports.useState(null);
  const [chainId2, setChainId] = reactExports.useState(null);
  const [selectedAccount, setSelectedAccount] = reactExports.useState(null);
  const [stakedAmount, setStakedAmount] = reactExports.useState("");
  const [rewardRate, setRewardRate] = reactExports.useState("");
  const [rewardVal, setRewardVal] = reactExports.useState("");
  const stakeAmountRef = reactExports.useRef();
  const withdrawStakeAmountRef = reactExports.useRef();
  const approveToken = async (e2) => {
    e2.preventDefault();
    const amount = approvedTokenRef.current.value.trim();
    if (isNaN(amount) || amount <= 0) {
      console.error("Please enter a valid positive number");
      return;
    }
    const amountToSend = parseUnits(amount, 18);
    try {
      const transaction = await stakeTokenContract.approve(selectedAccount, amountToSend);
      if (transaction) {
        alert("success");
      }
      approvedTokenRef.current.value = "";
    } catch (error) {
      console.error(error.message);
    }
  };
  const stakeToken = async (e2) => {
    e2.preventDefault();
    const amount = stakeAmountRef.current.value.trim();
    if (isNaN(amount) || amount <= 0) {
      toast.error("Please enter a valid positive number.");
      return;
    }
    const amountToStake = parseUnits(amount, 18);
    try {
      const transaction = await stakingContract.stake(amountToStake);
      if (transaction) {
        alert("success");
      }
      stakeAmountRef.current.value = "";
    } catch (error) {
      toast.error("Staking Failed");
      console.error(error.message);
    }
  };
  const withdrawStakeToken = async (e2) => {
    e2.preventDefault();
    const amount = withdrawStakeAmountRef.current.value.trim();
    if (isNaN(amount) || amount <= 0) {
      console.error("Please enter a valid positive number");
      return;
    }
    const amountToWithdraw = parseUnits(amount, 18);
    try {
      const transaction = await stakingContract.withdrawStakedTokens(amountToWithdraw);
      if (transaction) {
        alert("success");
      }
      withdrawStakeAmountRef.current.value = "";
      setIsReload(!isReload);
    } catch (error) {
      toast.error("Staking Failed");
      console.error(error.message);
    }
  };
  const claimReward = async () => {
    try {
      const transaction = await stakingContract.getReward();
      if (transaction) {
        alert("success");
      }
    } catch (error) {
      console.error("Claim Reward Failed", error.message);
    }
  };
  reactExports.useEffect(() => {
    const fetchStakedBalance = async () => {
      try {
        const amountStakedWei = await stakingContract.stakedBalance(selectedAccount);
        const amountStakedEth = formatUnits$1(amountStakedWei.toString(), 18);
        setStakedAmount(amountStakedEth);
      } catch (error) {
        console.error(error.message);
      }
    };
    stakingContract && fetchStakedBalance();
    const fetchRewardRate = async () => {
      try {
        const rewardRateWei = await stakingContract.REWARD_RATE();
        const rewardRateEth = formatUnits$1(rewardRateWei.toString(), 18);
        setRewardRate(rewardRateEth);
      } catch (error) {
        toast.error("Error fetching reward rate");
        console.error(error.message);
      }
    };
    stakingContract && fetchRewardRate();
    const fetchStakeRewardInfo = async () => {
      try {
        const rewardValueWei = await stakingContract.earned(selectedAccount);
        const rewardValueEth = formatUnits$1(rewardValueWei.toString(), 18);
        const roundedReward = parseFloat(rewardValueEth).toFixed(2);
        setRewardVal(roundedReward);
      } catch (error) {
        toast.error("Error fetching the reward:");
        console.error(error.message);
      }
    };
    const interval = setInterval(() => {
      stakingContract && fetchStakeRewardInfo();
    }, 2e4);
    return () => clearInterval(interval);
  }, [stakingContract, selectedAccount]);
  reactExports.useEffect(() => {
    if (activeButton === "staking") {
      const onLoad = async () => {
        try {
          if (window.ethereum === null) {
            throw new Error("Metamsk is not installed");
          }
          const accounts = await window.ethereum.request({
            method: "eth_requestAccounts"
          });
          let chainIdHex = await window.ethereum.request({
            method: "eth_chainId"
          });
          let chainId22 = parseInt(chainIdHex, 16);
          setChainId(chainId22);
          let selectedAccount2 = accounts[0];
          if (!selectedAccount2) {
            throw new Error("No ethereum accounts available");
          }
          setSelectedAccount(selectedAccount2);
          let provider2 = await new Web3Provider$1(window.ethereum);
          let signer2 = await provider2.getSigner();
          setSigner(signer2);
          const stakingContractAddress = "0xfB528B5905C8f9398fb625Ab4155C567A75cCC9F";
          const stakeTokenContractAddress = "0x5263fdc29e84891ded4e0fb8be4084398d9a6e84";
          let stakingContract2 = new Contract(stakingContractAddress, stakingAbi, signer2);
          let stakeTokenContract2 = new Contract(stakeTokenContractAddress, stakeTokenAbi, signer2);
          setStakingContract(stakingContract2);
          setStakeTokenContract(stakeTokenContract2);
          if (chainId22 === 11155111) {
            setNetwork("Sepolia Network");
          }
        } catch (error) {
          console.error(error);
          throw error;
        }
      };
      onLoad();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Stack$1,
    {
      gap: 2,
      mt: 2,
      sx: { background: "#fff", py: 4, px: 2, borderRadius: 2 },
      children: network !== "Unsupported Network 'Use Sepolia Network'" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "h3", color: "secondary", children: "Staking" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "h4", color: "primary", children: network }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$1, { variant: "h6", color: "secondary", children: [
          "Stake Amount: ",
          stakedAmount
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$1, { variant: "h6", color: "secondary", children: [
          "Reward Rate: ",
          rewardRate,
          " token per second"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$1, { variant: "h6", color: "secondary", children: [
          "Earned Reward: ",
          rewardVal
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: approveToken, className: "token-amount-form", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "token-input-label", children: "Token Approval:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "text", ref: approvedTokenRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              className: "button",
              sx: { fontSize: 8, width: 90, padding: 0.2, marginLeft: 1, color: "white" },
              variant: "contained",
              color: "primary",
              onClick: () => approveToken(),
              type: "submit",
              children: "Token Approval"
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectItem,
          {
            value: data2.staking.token,
            label: "Select Token",
            menus: [
              ["Sepolia", "Stake Token"]
            ],
            handleChange: (e2) => setData((prev2) => ({
              ...prev2,
              staking: { ...prev2.staking, token: e2.target.value }
            }))
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { style: { display: "flex", alignItems: "center" }, onSubmit: stakeToken, className: "stake-amount-form", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "stake-input-label", children: "Enter Staked Amount:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "text", ref: stakeAmountRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              className: "button",
              type: "submit",
              label: "Stake Token",
              sx: { fontSize: 8, width: 90, padding: 0.2, marginLeft: 1, color: "white", alignSelf: "flex-end" },
              variant: "contained",
              color: "primary",
              onClick: stakeToken,
              children: "Stake"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { className: "withdraw-form", onSubmit: withdrawStakeToken, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Withdraw Token:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "text", ref: withdrawStakeAmountRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              className: "button",
              sx: { fontSize: 8, width: 90, padding: 0.2, marginLeft: 1, color: "white" },
              variant: "contained",
              color: "primary",
              onClick: withdrawStakeToken,
              type: "submit",
              children: "Amount To WithDraw"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flex: 1, justifyContent: "flex-end" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            type: "button",
            label: "Claim Reward",
            onClick: claimReward,
            sx: { fontSize: 10, width: 90, padding: 1, marginLeft: 1, color: "white", alignSelf: "flex-end" },
            variant: "contained",
            color: "primary",
            children: "Claim Reward"
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "thank-you-message", style: { display: "none", color: "white", marginTop: "10px", textAlign: "right" }, children: "Thank you for staking!" })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "h4", color: "primary", children: network }) })
    }
  ) });
};
const NFTMarket = () => {
  const [data2, setData] = reactExports.useState({
    nft: {
      selectNft: "nft1",
      balance: "",
      price: ""
    }
  });
  const [currentForm, setCurrentForm] = reactExports.useState(null);
  const buyNFT = () => {
  };
  const sellNFT = () => {
  };
  const tradeNFT = () => {
  };
  const handleButtonClick = (form) => {
    setCurrentForm((prevForm) => prevForm === form ? null : form);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Stack$1,
    {
      gap: 2,
      mt: 2,
      sx: {
        background: "#fff",
        py: 4,
        px: 2,
        borderRadius: 2
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "h3", color: "secondary", children: "NFT Market" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            sx: { fontSize: 18, width: 150 },
            variant: currentForm === "buy" ? "contained" : "outlined",
            onClick: () => handleButtonClick("buy"),
            children: "Buy NFT"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            sx: { fontSize: 18, width: 150 },
            variant: currentForm === "sell" ? "contained" : "outlined",
            onClick: () => handleButtonClick("sell"),
            children: "Sell NFT"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            sx: { fontSize: 18, width: 150 },
            variant: currentForm === "trade" ? "contained" : "outlined",
            onClick: () => handleButtonClick("trade"),
            children: "Trade NFT"
          }
        ),
        currentForm === "buy" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "h3", color: "secondary", children: "NFT Buy" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SelectItem,
            {
              value: data2.nft.selectNft,
              label: "Select NFT",
              menus: [
                ["nft1", "NFT 1"],
                ["nft2", "NFT 2"],
                ["nft3", "NFT 3"]
              ],
              handleChange: (e2) => setData((prevData) => ({
                ...prevData,
                nft: { ...prevData.nft, selectNft: e2.target.value }
              }))
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-field", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: `nft-balance-${currentForm || "default"}`, children: "Balance:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$1,
              {
                type: "text",
                id: `nft-balance-${currentForm || "default"}`,
                readOnly: true,
                value: data2.nft.balance
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-field", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: `nft-price-${currentForm || "default"}`, children: "Price:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$1,
              {
                type: "text",
                id: `nft-price-${currentForm || "default"}`,
                readOnly: true,
                value: data2.nft.price
              }
            )
          ] })
        ] }),
        currentForm === "sell" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "h3", color: "secondary", children: "NFT Sell" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SelectItem,
            {
              value: data2.nft.selectNft,
              label: "Select NFT",
              menus: [
                ["nft1", "NFT 1"],
                ["nft2", "NFT 2"],
                ["nft3", "NFT 3"]
              ],
              handleChange: (e2) => setData((prevData) => ({
                ...prevData,
                nft: { ...prevData.nft, selectNft: e2.target.value }
              }))
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-field", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: `nft-balance-${currentForm || "default"}`, children: "Balance:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$1,
              {
                type: "text",
                id: `nft-balance-${currentForm || "default"}`,
                readOnly: true,
                value: data2.nft.balance
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-field", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: `nft-price-${currentForm || "default"}`, children: "Price:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$1,
              {
                type: "text",
                id: `nft-price-${currentForm || "default"}`,
                readOnly: true,
                value: data2.nft.price
              }
            )
          ] })
        ] }),
        currentForm === "trade" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "h3", color: "secondary", children: "NFT Trade" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SelectItem,
            {
              value: data2.nft.selectNft,
              label: "Select NFT",
              menus: [
                ["nft1", "NFT 1"],
                ["nft2", "NFT 2"],
                ["nft3", "NFT 3"]
              ],
              handleChange: (e2) => setData((prevData) => ({
                ...prevData,
                nft: { ...prevData.nft, selectNft: e2.target.value }
              }))
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-field", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: `nft-balance-${currentForm || "default"}`, children: "Balance:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$1,
              {
                type: "text",
                id: `nft-balance-${currentForm || "default"}`,
                readOnly: true,
                value: data2.nft.balance
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-field", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: `nft-price-${currentForm || "default"}`, children: "Price:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$1,
              {
                type: "text",
                id: `nft-price-${currentForm || "default"}`,
                readOnly: true,
                value: data2.nft.price
              }
            )
          ] })
        ] }),
        currentForm === "buy" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            className: "button",
            onClick: buyNFT,
            color: "primary",
            variant: "contained",
            sx: { fontSize: 18, width: 150, alignSelf: "center" },
            children: "Buy NFT"
          }
        ),
        currentForm === "sell" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            className: "button",
            onClick: sellNFT,
            color: "primary",
            variant: "contained",
            sx: { fontSize: 18, width: 150, alignSelf: "center" },
            children: "Sell NFT"
          }
        ),
        currentForm === "trade" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            className: "button",
            onClick: tradeNFT,
            color: "primary",
            variant: "contained",
            sx: { fontSize: 18, width: 150, alignSelf: " center" },
            children: "Trade NFT"
          }
        )
      ]
    }
  );
};
const twitterLogo = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2048%2048'%20width='48px'%20height='48px'%3e%3cpath%20fill='%2303A9F4'%20d='M42,12.429c-1.323,0.586-2.746,0.977-4.247,1.162c1.526-0.906,2.7-2.351,3.251-4.058c-1.428,0.837-3.01,1.452-4.693,1.776C34.967,9.884,33.05,9,30.926,9c-4.08,0-7.387,3.278-7.387,7.32c0,0.572,0.067,1.129,0.193,1.67c-6.138-0.308-11.582-3.226-15.224-7.654c-0.64,1.082-1,2.349-1,3.686c0,2.541,1.301,4.778,3.285,6.096c-1.211-0.037-2.351-0.374-3.349-0.914c0,0.022,0,0.055,0,0.086c0,3.551,2.547,6.508,5.923,7.181c-0.617,0.169-1.269,0.263-1.941,0.263c-0.477,0-0.942-0.054-1.392-0.135c0.94,2.902,3.667,5.023,6.898,5.086c-2.528,1.96-5.712,3.134-9.174,3.134c-0.598,0-1.183-0.034-1.761-0.104C9.268,36.786,13.152,38,17.321,38c13.585,0,21.017-11.156,21.017-20.834c0-0.317-0.01-0.633-0.025-0.945C39.763,15.197,41.013,13.905,42,12.429'/%3e%3c/svg%3e";
const instaLogo = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20viewBox='0,0,256,256'%20width='50px'%20height='50px'%3e%3cg%20fill='%23ff0c56'%20fill-rule='nonzero'%20stroke='none'%20stroke-width='1'%20stroke-linecap='butt'%20stroke-linejoin='miter'%20stroke-miterlimit='10'%20stroke-dasharray=''%20stroke-dashoffset='0'%20font-family='none'%20font-weight='none'%20font-size='none'%20text-anchor='none'%20style='mix-blend-mode:%20normal'%3e%3cg%20transform='scale(5.12,5.12)'%3e%3cpath%20d='M16,3c-7.16752,0%20-13,5.83248%20-13,13v18c0,7.16752%205.83248,13%2013,13h18c7.16752,0%2013,-5.83248%2013,-13v-18c0,-7.16752%20-5.83248,-13%20-13,-13zM16,5h18c6.08648,0%2011,4.91352%2011,11v18c0,6.08648%20-4.91352,11%20-11,11h-18c-6.08648,0%20-11,-4.91352%20-11,-11v-18c0,-6.08648%204.91352,-11%2011,-11zM37,11c-1.10457,0%20-2,0.89543%20-2,2c0,1.10457%200.89543,2%202,2c1.10457,0%202,-0.89543%202,-2c0,-1.10457%20-0.89543,-2%20-2,-2zM25,14c-6.06329,0%20-11,4.93671%20-11,11c0,6.06329%204.93671,11%2011,11c6.06329,0%2011,-4.93671%2011,-11c0,-6.06329%20-4.93671,-11%20-11,-11zM25,16c4.98241,0%209,4.01759%209,9c0,4.98241%20-4.01759,9%20-9,9c-4.98241,0%20-9,-4.01759%20-9,-9c0,-4.98241%204.01759,-9%209,-9z'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
/**
* @vue/shared v3.4.15
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function makeMap(str, expectsLowerCase) {
  const set2 = new Set(str.split(","));
  return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
}
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key2) => hasOwnProperty$1.call(val, key2);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$1 = (val) => val !== null && typeof val === "object";
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isIntegerKey = (key2) => isString(key2) && key2 !== "NaN" && key2[0] !== "-" && "" + parseInt(key2, 10) === key2;
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
/**
* @vue/reactivity v3.4.15
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffect;
function cleanupDepEffect(dep, effect2) {
  const trackId = dep.get(effect2);
  if (trackId !== void 0 && effect2._trackId !== trackId) {
    dep.delete(effect2);
    if (dep.size === 0) {
      dep.cleanup();
    }
  }
}
let shouldTrack = true;
let pauseScheduleStack = 0;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function pauseScheduling() {
  pauseScheduleStack++;
}
function resetScheduling() {
  pauseScheduleStack--;
  while (!pauseScheduleStack && queueEffectSchedulers.length) {
    queueEffectSchedulers.shift()();
  }
}
function trackEffect(effect2, dep, debuggerEventExtraInfo) {
  if (dep.get(effect2) !== effect2._trackId) {
    dep.set(effect2, effect2._trackId);
    const oldDep = effect2.deps[effect2._depsLength];
    if (oldDep !== dep) {
      if (oldDep) {
        cleanupDepEffect(oldDep, effect2);
      }
      effect2.deps[effect2._depsLength++] = dep;
    } else {
      effect2._depsLength++;
    }
  }
}
const queueEffectSchedulers = [];
function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
  pauseScheduling();
  for (const effect2 of dep.keys()) {
    if (effect2._dirtyLevel < dirtyLevel && dep.get(effect2) === effect2._trackId) {
      const lastDirtyLevel = effect2._dirtyLevel;
      effect2._dirtyLevel = dirtyLevel;
      if (lastDirtyLevel === 0) {
        effect2._shouldSchedule = true;
        effect2.trigger();
      }
    }
  }
  scheduleEffects(dep);
  resetScheduling();
}
function scheduleEffects(dep) {
  for (const effect2 of dep.keys()) {
    if (effect2.scheduler && effect2._shouldSchedule && (!effect2._runnings || effect2.allowRecurse) && dep.get(effect2) === effect2._trackId) {
      effect2._shouldSchedule = false;
      queueEffectSchedulers.push(effect2.scheduler);
    }
  }
}
const createDep = (cleanup, computed2) => {
  const dep = /* @__PURE__ */ new Map();
  dep.cleanup = cleanup;
  dep.computed = computed2;
  return dep;
};
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
function track(target, type, key2) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key2);
    if (!dep) {
      depsMap.set(key2, dep = createDep(() => depsMap.delete(key2)));
    }
    trackEffect(
      activeEffect,
      dep
    );
  }
}
function trigger(target, type, key2, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key2 === "length" && isArray(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key22) => {
      if (key22 === "length" || !isSymbol(key22) && key22 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key2 !== void 0) {
      deps.push(depsMap.get(key2));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key2)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  pauseScheduling();
  for (const dep of deps) {
    if (dep) {
      triggerEffects(
        dep,
        2
      );
    }
  }
  resetScheduling();
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key2) => key2 !== "arguments" && key2 !== "caller").map((key2) => Symbol[key2]).filter(isSymbol)
);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key2) => {
    instrumentations[key2] = function(...args) {
      const arr = toRaw(this);
      for (let i3 = 0, l2 = this.length; i3 < l2; i3++) {
        track(arr, "get", i3 + "");
      }
      const res = arr[key2](...args);
      if (res === -1 || res === false) {
        return arr[key2](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key2) => {
    instrumentations[key2] = function(...args) {
      pauseTracking();
      pauseScheduling();
      const res = toRaw(this)[key2].apply(this, args);
      resetScheduling();
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty(key2) {
  const obj = toRaw(this);
  track(obj, "has", key2);
  return obj.hasOwnProperty(key2);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _shallow = false) {
    this._isReadonly = _isReadonly;
    this._shallow = _shallow;
  }
  get(target, key2, receiver) {
    const isReadonly2 = this._isReadonly, shallow = this._shallow;
    if (key2 === "__v_isReactive") {
      return !isReadonly2;
    } else if (key2 === "__v_isReadonly") {
      return isReadonly2;
    } else if (key2 === "__v_isShallow") {
      return shallow;
    } else if (key2 === "__v_raw") {
      if (receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the reciever is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key2)) {
        return Reflect.get(arrayInstrumentations, key2, receiver);
      }
      if (key2 === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key2, receiver);
    if (isSymbol(key2) ? builtInSymbols.has(key2) : isNonTrackableKeys(key2)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key2);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key2) ? res : res.value;
    }
    if (isObject$1(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(shallow = false) {
    super(false, shallow);
  }
  set(target, key2, value, receiver) {
    let oldValue = target[key2];
    if (!this._shallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key2) ? Number(key2) < target.length : hasOwn(target, key2);
    const result = Reflect.set(target, key2, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key2, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key2, value);
      }
    }
    return result;
  }
  deleteProperty(target, key2) {
    const hadKey = hasOwn(target, key2);
    target[key2];
    const result = Reflect.deleteProperty(target, key2);
    if (result && hadKey) {
      trigger(target, "delete", key2, void 0);
    }
    return result;
  }
  has(target, key2) {
    const result = Reflect.has(target, key2);
    if (!isSymbol(key2) || !builtInSymbols.has(key2)) {
      track(target, "has", key2);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(shallow = false) {
    super(true, shallow);
  }
  set(target, key2) {
    return true;
  }
  deleteProperty(target, key2) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get(target, key2, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key2);
  if (!isReadonly2) {
    if (hasChanged(key2, rawKey)) {
      track(rawTarget, "get", key2);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key2)) {
    return wrap2(target.get(key2));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap2(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key2);
  }
}
function has(key2, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key2);
  if (!isReadonly2) {
    if (hasChanged(key2, rawKey)) {
      track(rawTarget, "has", key2);
    }
    track(rawTarget, "has", rawKey);
  }
  return key2 === rawKey ? target.has(key2) : target.has(key2) || target.has(rawKey);
}
function size$2(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add3(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key2, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key2);
  if (!hadKey) {
    key2 = toRaw(key2);
    hadKey = has2.call(target, key2);
  }
  const oldValue = get2.call(target, key2);
  target.set(key2, value);
  if (!hadKey) {
    trigger(target, "add", key2, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key2, value);
  }
  return this;
}
function deleteEntry(key2) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key2);
  if (!hadKey) {
    key2 = toRaw(key2);
    hadKey = has2.call(target, key2);
  }
  get2 ? get2.call(target, key2) : void 0;
  const result = target.delete(key2);
  if (hadKey) {
    trigger(target, "delete", key2, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach4(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key2) => {
      return callback.call(thisArg, wrap2(value), wrap2(key2), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap2(value[0]), wrap2(value[1])] : wrap2(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key2) {
      return get(this, key2);
    },
    get size() {
      return size$2(this);
    },
    has,
    add: add3,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key2) {
      return get(this, key2, false, true);
    },
    get size() {
      return size$2(this);
    },
    has,
    add: add3,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key2) {
      return get(this, key2, true);
    },
    get size() {
      return size$2(this, true);
    },
    has(key2) {
      return has.call(this, key2, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key2) {
      return get(this, key2, true, true);
    },
    get size() {
      return size$2(this, true);
    },
    has(key2) {
      return has.call(this, key2, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
      method,
      false,
      false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      false
    );
    shallowInstrumentations2[method] = createIterableMethod(
      method,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key2, receiver) => {
    if (key2 === "__v_isReactive") {
      return !isReadonly2;
    } else if (key2 === "__v_isReadonly") {
      return isReadonly2;
    } else if (key2 === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key2) && key2 in target ? instrumentations : target,
      key2,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$1(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy2 = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy2);
  return proxy2;
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
let modal$1 = void 0;
function getWeb3Modal(web3modal) {
  if (web3modal) {
    modal$1 = web3modal;
  }
}
function useWeb3Modal() {
  if (!modal$1) {
    throw new Error('Please call "createWeb3Modal" before using "useWeb3Modal" composable');
  }
  async function open(options) {
    await modal$1?.open(options);
  }
  async function close() {
    await modal$1?.close();
  }
  return reactive({
    open,
    close
  });
}
function defineChain(chain, config2 = {}) {
  const { fees = chain.fees, formatters = chain.formatters, serializers = chain.serializers } = config2;
  return {
    ...chain,
    fees,
    formatters,
    serializers
  };
}
const arbitrum = /* @__PURE__ */ defineChain({
  id: 42161,
  name: "Arbitrum One",
  network: "arbitrum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://arb-mainnet.g.alchemy.com/v2"],
      webSocket: ["wss://arb-mainnet.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://arbitrum-mainnet.infura.io/v3"],
      webSocket: ["wss://arbitrum-mainnet.infura.io/ws/v3"]
    },
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    },
    public: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    etherscan: { name: "Arbiscan", url: "https://arbiscan.io" },
    default: { name: "Arbiscan", url: "https://arbiscan.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
});
const version$1 = "1.21.3";
const getContractAddress = (address) => address;
const getUrl = (url) => url;
const getVersion = () => `viem@${version$1}`;
class BaseError extends Error {
  constructor(shortMessage, args = {}) {
    super();
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ViemError"
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: getVersion()
    });
    const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
    const docsPath2 = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
    this.message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsPath2 ? [
        `Docs: https://viem.sh${docsPath2}.html${args.docsSlug ? `#${args.docsSlug}` : ""}`
      ] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: ${this.version}`
    ].join("\n");
    if (args.cause)
      this.cause = args.cause;
    this.details = details;
    this.docsPath = docsPath2;
    this.metaMessages = args.metaMessages;
    this.shortMessage = shortMessage;
  }
  walk(fn2) {
    return walk(this, fn2);
  }
}
function walk(err, fn2) {
  if (fn2?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err)
    return walk(err.cause, fn2);
  return fn2 ? null : err;
}
class IntegerOutOfRangeError extends BaseError {
  constructor({ max, min, signed: signed2, size: size2, value }) {
    super(`Number "${value}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed2 ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "IntegerOutOfRangeError"
    });
  }
}
class InvalidHexBooleanError extends BaseError {
  constructor(hex) {
    super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidHexBooleanError"
    });
  }
}
class SizeOverflowError extends BaseError {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SizeOverflowError"
    });
  }
}
function isHex(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
function size$1(value) {
  if (isHex(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data2 = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i3 = 0; i3 < data2.length - 1; i3++) {
    if (data2[dir === "left" ? i3 : data2.length - i3 - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data2 = dir === "left" ? data2.slice(sliceLength) : data2.slice(0, data2.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data2.length === 1 && dir === "right")
      data2 = `${data2}0`;
    return `0x${data2.length % 2 === 1 ? `0${data2}` : data2}`;
  }
  return data2;
}
class SliceOffsetOutOfBoundsError extends BaseError {
  constructor({ offset, position: position2, size: size2 }) {
    super(`Slice ${position2 === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size2}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SliceOffsetOutOfBoundsError"
    });
  }
}
class SizeExceedsPaddingSizeError extends BaseError {
  constructor({ size: size2, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SizeExceedsPaddingSizeError"
    });
  }
}
function pad2(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size2 });
  return padBytes(hexOrBytes, { dir, size: size2 });
}
function padHex(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
function padBytes(bytes2, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes2;
  if (bytes2.length > size2)
    throw new SizeExceedsPaddingSizeError({
      size: bytes2.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let i3 = 0; i3 < size2; i3++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i3 : size2 - i3 - 1] = bytes2[padEnd ? i3 : bytes2.length - i3 - 1];
  }
  return paddedBytes;
}
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i3) => i3.toString(16).padStart(2, "0"));
function toHex(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad2(hex, { size: opts.size });
  }
  return hex;
}
function bytesToHex(value, opts = {}) {
  let string2 = "";
  for (let i3 = 0; i3 < value.length; i3++) {
    string2 += hexes[value[i3]];
  }
  const hex = `0x${string2}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad2(hex, { dir: "right", size: opts.size });
  }
  return hex;
}
function numberToHex(value_, opts = {}) {
  const { signed: signed2, size: size2 } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size2) {
    if (signed2)
      maxValue = (1n << BigInt(size2) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed2 ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed: signed2,
      size: size2,
      value: `${value_}${suffix}`
    });
  }
  const hex = `0x${(signed2 && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size2)
    return pad2(hex, { size: size2 });
  return hex;
}
const encoder$1 = /* @__PURE__ */ new TextEncoder();
function stringToHex(value_, opts = {}) {
  const value = encoder$1.encode(value_);
  return bytesToHex(value, opts);
}
const encoder = /* @__PURE__ */ new TextEncoder();
function toBytes$1(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex(value))
    return hexToBytes(value, opts);
  return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes2 = new Uint8Array(1);
  bytes2[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes2, { size: opts.size });
    return pad2(bytes2, { size: opts.size });
  }
  return bytes2;
}
const charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(char2) {
  if (char2 >= charCodeMap.zero && char2 <= charCodeMap.nine)
    return char2 - charCodeMap.zero;
  if (char2 >= charCodeMap.A && char2 <= charCodeMap.F)
    return char2 - (charCodeMap.A - 10);
  if (char2 >= charCodeMap.a && char2 <= charCodeMap.f)
    return char2 - (charCodeMap.a - 10);
  return void 0;
}
function hexToBytes(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = pad2(hex, { dir: "right", size: opts.size });
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length2 = hexString.length / 2;
  const bytes2 = new Uint8Array(length2);
  for (let index2 = 0, j2 = 0; index2 < length2; index2++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j2++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j2++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError(`Invalid byte sequence ("${hexString[j2 - 2]}${hexString[j2 - 1]}" in "${hexString}").`);
    }
    bytes2[index2] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes2;
}
function numberToBytes(value, opts) {
  const hex = numberToHex(value, opts);
  return hexToBytes(hex);
}
function stringToBytes(value, opts = {}) {
  const bytes2 = encoder.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes2, { size: opts.size });
    return pad2(bytes2, { dir: "right", size: opts.size });
  }
  return bytes2;
}
function assertSize(hexOrBytes, { size: size2 }) {
  if (size$1(hexOrBytes) > size2)
    throw new SizeOverflowError({
      givenSize: size$1(hexOrBytes),
      maxSize: size2
    });
}
function hexToBigInt(hex, opts = {}) {
  const { signed: signed2 } = opts;
  if (opts.size)
    assertSize(hex, { size: opts.size });
  const value = BigInt(hex);
  if (!signed2)
    return value;
  const size2 = (hex.length - 2) / 2;
  const max = (1n << BigInt(size2) * 8n - 1n) - 1n;
  if (value <= max)
    return value;
  return value - BigInt(`0x${"f".padStart(size2 * 2, "f")}`) - 1n;
}
function hexToBool(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = trim(hex);
  }
  if (trim(hex) === "0x00")
    return false;
  if (trim(hex) === "0x01")
    return true;
  throw new InvalidHexBooleanError(hex);
}
function hexToNumber(hex, opts = {}) {
  return Number(hexToBigInt(hex, opts));
}
function hexToString(hex, opts = {}) {
  let bytes2 = hexToBytes(hex);
  if (opts.size) {
    assertSize(bytes2, { size: opts.size });
    bytes2 = trim(bytes2, { dir: "right" });
  }
  return new TextDecoder().decode(bytes2);
}
const transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  return transaction_;
}
function formatBlock(block2) {
  const transactions = block2.transactions?.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block2,
    baseFeePerGas: block2.baseFeePerGas ? BigInt(block2.baseFeePerGas) : null,
    difficulty: block2.difficulty ? BigInt(block2.difficulty) : void 0,
    gasLimit: block2.gasLimit ? BigInt(block2.gasLimit) : void 0,
    gasUsed: block2.gasUsed ? BigInt(block2.gasUsed) : void 0,
    hash: block2.hash ? block2.hash : null,
    logsBloom: block2.logsBloom ? block2.logsBloom : null,
    nonce: block2.nonce ? block2.nonce : null,
    number: block2.number ? BigInt(block2.number) : null,
    size: block2.size ? BigInt(block2.size) : void 0,
    timestamp: block2.timestamp ? BigInt(block2.timestamp) : void 0,
    transactions,
    totalDifficulty: block2.totalDifficulty ? BigInt(block2.totalDifficulty) : null
  };
}
function formatLog(log3, { args, eventName } = {}) {
  return {
    ...log3,
    blockHash: log3.blockHash ? log3.blockHash : null,
    blockNumber: log3.blockNumber ? BigInt(log3.blockNumber) : null,
    logIndex: log3.logIndex ? Number(log3.logIndex) : null,
    transactionHash: log3.transactionHash ? log3.transactionHash : null,
    transactionIndex: log3.transactionIndex ? Number(log3.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}
const statuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  return {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log3) => formatLog(log3)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? statuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
}
const rpcTransactionType = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2"
};
function formatTransactionRequest(transactionRequest) {
  return {
    ...transactionRequest,
    gas: typeof transactionRequest.gas !== "undefined" ? numberToHex(transactionRequest.gas) : void 0,
    gasPrice: typeof transactionRequest.gasPrice !== "undefined" ? numberToHex(transactionRequest.gasPrice) : void 0,
    maxFeePerGas: typeof transactionRequest.maxFeePerGas !== "undefined" ? numberToHex(transactionRequest.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: typeof transactionRequest.maxPriorityFeePerGas !== "undefined" ? numberToHex(transactionRequest.maxPriorityFeePerGas) : void 0,
    nonce: typeof transactionRequest.nonce !== "undefined" ? numberToHex(transactionRequest.nonce) : void 0,
    type: typeof transactionRequest.type !== "undefined" ? rpcTransactionType[transactionRequest.type] : void 0,
    value: typeof transactionRequest.value !== "undefined" ? numberToHex(transactionRequest.value) : void 0
  };
}
class InvalidAddressError extends BaseError {
  constructor({ address }) {
    super(`Address "${address}" is invalid.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAddressError"
    });
  }
}
class ChainDoesNotSupportContract extends BaseError {
  constructor({ blockNumber, chain, contract }) {
    super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
          `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
        ] : [
          `- The chain does not have the contract "${contract.name}" configured.`
        ]
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainDoesNotSupportContract"
    });
  }
}
class ChainMismatchError extends BaseError {
  constructor({ chain, currentChainId }) {
    super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id}  ${chain.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${currentChainId}`,
        `Expected Chain ID: ${chain.id}  ${chain.name}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainMismatchError"
    });
  }
}
class ChainNotFoundError extends BaseError {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainNotFoundError"
    });
  }
}
class ClientChainNotConfiguredError extends BaseError {
  constructor() {
    super("No chain was provided to the Client.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ClientChainNotConfiguredError"
    });
  }
}
const etherUnits = {
  gwei: 9,
  wei: 18
};
const gweiUnits = {
  ether: -9,
  wei: 9
};
const weiUnits = {
  ether: -18,
  gwei: -9
};
function formatUnits(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}
function formatGwei(wei, unit = "wei") {
  return formatUnits(wei, gweiUnits[unit]);
}
class ExecutionRevertedError extends BaseError {
  constructor({ cause, message } = {}) {
    const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
    super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(ExecutionRevertedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /execution reverted/
});
class FeeCapTooHighError extends BaseError {
  constructor({ cause, maxFeePerGas } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FeeCapTooHigh"
    });
  }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class FeeCapTooLowError extends BaseError {
  constructor({ cause, maxFeePerGas } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FeeCapTooLow"
    });
  }
}
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class NonceTooHighError extends BaseError {
  constructor({ cause, nonce } = {}) {
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NonceTooHighError"
    });
  }
}
Object.defineProperty(NonceTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too high/
});
class NonceTooLowError extends BaseError {
  constructor({ cause, nonce } = {}) {
    super([
      `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join("\n"), { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NonceTooLowError"
    });
  }
}
Object.defineProperty(NonceTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too low|transaction already imported|already known/
});
class NonceMaxValueError extends BaseError {
  constructor({ cause, nonce } = {}) {
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NonceMaxValueError"
    });
  }
}
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce has max value/
});
class InsufficientFundsError extends BaseError {
  constructor({ cause } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join("\n"), {
      cause,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /insufficient funds/
});
class IntrinsicGasTooHighError extends BaseError {
  constructor({ cause, gas } = {}) {
    super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too high|gas limit reached/
});
class IntrinsicGasTooLowError extends BaseError {
  constructor({ cause, gas } = {}) {
    super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too low/
});
class TransactionTypeNotSupportedError extends BaseError {
  constructor({ cause }) {
    super("The transaction type is not supported for this chain.", {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /transaction type not valid/
});
class TipAboveFeeCapError extends BaseError {
  constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
    ].join("\n"), {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class UnknownNodeError extends BaseError {
  constructor({ cause }) {
    super(`An error occurred while executing: ${cause?.shortMessage}`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownNodeError"
    });
  }
}
const addressRegex = /^0x[a-fA-F0-9]{40}$/;
function isAddress(address) {
  return addressRegex.test(address);
}
function concat$1(values2) {
  if (typeof values2[0] === "string")
    return concatHex(values2);
  return concatBytes(values2);
}
function concatBytes(values2) {
  let length2 = 0;
  for (const arr of values2) {
    length2 += arr.length;
  }
  const result = new Uint8Array(length2);
  let offset = 0;
  for (const arr of values2) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
function concatHex(values2) {
  return `0x${values2.reduce((acc, x2) => acc + x2.replace("0x", ""), "")}`;
}
function execTyped(regex2, string2) {
  const match2 = regex2.exec(string2);
  return match2?.groups;
}
const tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(abiParameter) {
  let type = abiParameter.type;
  if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
    type = "(";
    const length2 = abiParameter.components.length;
    for (let i3 = 0; i3 < length2; i3++) {
      const component = abiParameter.components[i3];
      type += formatAbiParameter(component);
      if (i3 < length2 - 1)
        type += ", ";
    }
    const result = execTyped(tupleRegex, abiParameter.type);
    type += `)${result?.array ?? ""}`;
    return formatAbiParameter({
      ...abiParameter,
      type
    });
  }
  if ("indexed" in abiParameter && abiParameter.indexed)
    type = `${type} indexed`;
  if (abiParameter.name)
    return `${type} ${abiParameter.name}`;
  return type;
}
function formatAbiParameters(abiParameters) {
  let params = "";
  const length2 = abiParameters.length;
  for (let i3 = 0; i3 < length2; i3++) {
    const abiParameter = abiParameters[i3];
    params += formatAbiParameter(abiParameter);
    if (i3 !== length2 - 1)
      params += ", ";
  }
  return params;
}
function formatAbiItem$1(abiItem) {
  if (abiItem.type === "function")
    return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs.length ? ` returns (${formatAbiParameters(abiItem.outputs)})` : ""}`;
  else if (abiItem.type === "event")
    return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  else if (abiItem.type === "error")
    return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  else if (abiItem.type === "constructor")
    return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  else if (abiItem.type === "fallback")
    return "fallback()";
  return "receive() external payable";
}
function getAction(client2, action, name2) {
  return (params) => client2[action.name || name2]?.(params) ?? action(client2, params);
}
function formatAbiItem(abiItem, { includeName = false } = {}) {
  if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
    throw new InvalidDefinitionTypeError(abiItem.type);
  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
}
function formatAbiParams(params, { includeName = false } = {}) {
  if (!params)
    return "";
  return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
}
function formatAbiParam(param, { includeName }) {
  if (param.type.startsWith("tuple")) {
    return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
  }
  return param.type + (includeName && param.name ? ` ${param.name}` : "");
}
class AbiConstructorNotFoundError extends BaseError {
  constructor({ docsPath: docsPath2 }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiConstructorNotFoundError"
    });
  }
}
class AbiConstructorParamsNotFoundError extends BaseError {
  constructor({ docsPath: docsPath2 }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiConstructorParamsNotFoundError"
    });
  }
}
class AbiDecodingDataSizeTooSmallError extends BaseError {
  constructor({ data: data2, params, size: size2 }) {
    super([`Data size of ${size2} bytes is too small for given parameters.`].join("\n"), {
      metaMessages: [
        `Params: (${formatAbiParams(params, { includeName: true })})`,
        `Data:   ${data2} (${size2} bytes)`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiDecodingDataSizeTooSmallError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "params", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = data2;
    this.params = params;
    this.size = size2;
  }
}
class AbiDecodingZeroDataError extends BaseError {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.');
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiDecodingZeroDataError"
    });
  }
}
class AbiEncodingArrayLengthMismatchError extends BaseError {
  constructor({ expectedLength, givenLength, type }) {
    super([
      `ABI encoding array length mismatch for type ${type}.`,
      `Expected length: ${expectedLength}`,
      `Given length: ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEncodingArrayLengthMismatchError"
    });
  }
}
class AbiEncodingBytesSizeMismatchError extends BaseError {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size$1(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEncodingBytesSizeMismatchError"
    });
  }
}
class AbiEncodingLengthMismatchError extends BaseError {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEncodingLengthMismatchError"
    });
  }
}
class AbiErrorSignatureNotFoundError extends BaseError {
  constructor(signature2, { docsPath: docsPath2 }) {
    super([
      `Encoded error signature "${signature2}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature2}.`
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiErrorSignatureNotFoundError"
    });
    Object.defineProperty(this, "signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.signature = signature2;
  }
}
class AbiEventSignatureEmptyTopicsError extends BaseError {
  constructor({ docsPath: docsPath2 }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEventSignatureEmptyTopicsError"
    });
  }
}
class AbiEventSignatureNotFoundError extends BaseError {
  constructor(signature2, { docsPath: docsPath2 }) {
    super([
      `Encoded event signature "${signature2}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${signature2}.`
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEventSignatureNotFoundError"
    });
  }
}
class AbiEventNotFoundError extends BaseError {
  constructor(eventName, { docsPath: docsPath2 } = {}) {
    super([
      `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it."
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEventNotFoundError"
    });
  }
}
class AbiFunctionNotFoundError extends BaseError {
  constructor(functionName, { docsPath: docsPath2 } = {}) {
    super([
      `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiFunctionNotFoundError"
    });
  }
}
class AbiFunctionOutputsNotFoundError extends BaseError {
  constructor(functionName, { docsPath: docsPath2 }) {
    super([
      `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiFunctionOutputsNotFoundError"
    });
  }
}
class AbiItemAmbiguityError extends BaseError {
  constructor(x2, y2) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${x2.type}\` in \`${formatAbiItem(x2.abiItem)}\`, and`,
        `\`${y2.type}\` in \`${formatAbiItem(y2.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiItemAmbiguityError"
    });
  }
}
class BytesSizeMismatchError extends BaseError {
  constructor({ expectedSize, givenSize }) {
    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BytesSizeMismatchError"
    });
  }
}
class DecodeLogDataMismatch extends BaseError {
  constructor({ abiItem, data: data2, params, size: size2 }) {
    super([
      `Data size of ${size2} bytes is too small for non-indexed event parameters.`
    ].join("\n"), {
      metaMessages: [
        `Params: (${formatAbiParams(params, { includeName: true })})`,
        `Data:   ${data2} (${size2} bytes)`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "DecodeLogDataMismatch"
    });
    Object.defineProperty(this, "abiItem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "params", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiItem = abiItem;
    this.data = data2;
    this.params = params;
    this.size = size2;
  }
}
class DecodeLogTopicsMismatch extends BaseError {
  constructor({ abiItem, param }) {
    super([
      `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${formatAbiItem(abiItem, { includeName: true })}".`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "DecodeLogTopicsMismatch"
    });
    Object.defineProperty(this, "abiItem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiItem = abiItem;
  }
}
class InvalidAbiEncodingTypeError extends BaseError {
  constructor(type, { docsPath: docsPath2 }) {
    super([
      `Type "${type}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join("\n"), { docsPath: docsPath2 });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiEncodingType"
    });
  }
}
class InvalidAbiDecodingTypeError extends BaseError {
  constructor(type, { docsPath: docsPath2 }) {
    super([
      `Type "${type}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join("\n"), { docsPath: docsPath2 });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiDecodingType"
    });
  }
}
class InvalidArrayError extends BaseError {
  constructor(value) {
    super([`Value "${value}" is not a valid array.`].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidArrayError"
    });
  }
}
class InvalidDefinitionTypeError extends BaseError {
  constructor(type) {
    super([
      `"${type}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidDefinitionTypeError"
    });
  }
}
class FilterTypeNotSupportedError extends BaseError {
  constructor(type) {
    super(`Filter type "${type}" is not supported.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FilterTypeNotSupportedError"
    });
  }
}
function normalizeSignature(signature2) {
  let active = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let i3 = 0; i3 < signature2.length; i3++) {
    const char2 = signature2[i3];
    if (["(", ")", ","].includes(char2))
      active = true;
    if (char2 === "(")
      level++;
    if (char2 === ")")
      level--;
    if (!active)
      continue;
    if (level === 0) {
      if (char2 === " " && ["event", "function", ""].includes(result))
        result = "";
      else {
        result += char2;
        if (char2 === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char2 === " ") {
      if (signature2[i3 - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active = false;
      }
      continue;
    }
    result += char2;
    current += char2;
  }
  if (!valid)
    throw new BaseError("Unable to normalize signature.");
  return result;
}
const getFunctionSignature = (fn_) => {
  const fn2 = (() => {
    if (typeof fn_ === "string")
      return fn_;
    return formatAbiItem$1(fn_);
  })();
  return normalizeSignature(fn2);
};
const getEventSignature = (fn2) => {
  return getFunctionSignature(fn2);
};
function number(n4) {
  if (!Number.isSafeInteger(n4) || n4 < 0)
    throw new Error(`Wrong positive integer: ${n4}`);
}
function bytes(b3, ...lengths) {
  if (!(b3 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b3.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b3.length}`);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n4, le2 = false) {
  if (le2)
    return { h: Number(n4 & U32_MASK64), l: Number(n4 >> _32n & U32_MASK64) };
  return { h: Number(n4 >> _32n & U32_MASK64) | 0, l: Number(n4 & U32_MASK64) | 0 };
}
function split(lst, le2 = false) {
  let Ah2 = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i3 = 0; i3 < lst.length; i3++) {
    const { h: h4, l: l2 } = fromBig(lst[i3], le2);
    [Ah2[i3], Al[i3]] = [h4, l2];
  }
  return [Ah2, Al];
}
const rotlSH = (h4, l2, s4) => h4 << s4 | l2 >>> 32 - s4;
const rotlSL = (h4, l2, s4) => l2 << s4 | h4 >>> 32 - s4;
const rotlBH = (h4, l2, s4) => l2 << s4 - 32 | h4 >>> 64 - s4;
const rotlBL = (h4, l2, s4) => h4 << s4 - 32 | l2 >>> 64 - s4;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a = (a2) => a2 instanceof Uint8Array;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data2) {
  if (typeof data2 === "string")
    data2 = utf8ToBytes(data2);
  if (!u8a(data2))
    throw new Error(`expected Uint8Array, got ${typeof data2}`);
  return data2;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(113);
for (let round2 = 0, R3 = _1n, x2 = 1, y2 = 0; round2 < 24; round2++) {
  [x2, y2] = [y2, (2 * x2 + 3 * y2) % 5];
  SHA3_PI.push(2 * (5 * y2 + x2));
  SHA3_ROTL.push((round2 + 1) * (round2 + 2) / 2 % 64);
  let t2 = _0n;
  for (let j2 = 0; j2 < 7; j2++) {
    R3 = (R3 << _1n ^ (R3 >> _7n) * _0x71n) % _256n;
    if (R3 & _2n)
      t2 ^= _1n << (_1n << /* @__PURE__ */ BigInt(j2)) - _1n;
  }
  _SHA3_IOTA.push(t2);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
const rotlH = (h4, l2, s4) => s4 > 32 ? rotlBH(h4, l2, s4) : rotlSH(h4, l2, s4);
const rotlL = (h4, l2, s4) => s4 > 32 ? rotlBL(h4, l2, s4) : rotlSL(h4, l2, s4);
function keccakP(s4, rounds = 24) {
  const B2 = new Uint32Array(5 * 2);
  for (let round2 = 24 - rounds; round2 < 24; round2++) {
    for (let x2 = 0; x2 < 10; x2++)
      B2[x2] = s4[x2] ^ s4[x2 + 10] ^ s4[x2 + 20] ^ s4[x2 + 30] ^ s4[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B2[idx0];
      const B1 = B2[idx0 + 1];
      const Th2 = rotlH(B0, B1, 1) ^ B2[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B2[idx1 + 1];
      for (let y2 = 0; y2 < 50; y2 += 10) {
        s4[x2 + y2] ^= Th2;
        s4[x2 + y2 + 1] ^= Tl;
      }
    }
    let curH = s4[2];
    let curL = s4[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift = SHA3_ROTL[t2];
      const Th2 = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t2];
      curH = s4[PI];
      curL = s4[PI + 1];
      s4[PI] = Th2;
      s4[PI + 1] = Tl;
    }
    for (let y2 = 0; y2 < 50; y2 += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B2[x2] = s4[y2 + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s4[y2 + x2] ^= ~B2[(x2 + 2) % 10] & B2[(x2 + 4) % 10];
    }
    s4[0] ^= SHA3_IOTA_H[round2];
    s4[1] ^= SHA3_IOTA_L[round2];
  }
  B2.fill(0);
}
class Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data2) {
    exists(this);
    const { blockLen, state: state2 } = this;
    data2 = toBytes(data2);
    const len = data2.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i3 = 0; i3 < take; i3++)
        state2[this.pos++] ^= data2[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state: state2, suffix, pos, blockLen } = this;
    state2[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state2[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
const keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
function keccak256(value, to_) {
  const to = to_ || "hex";
  const bytes2 = keccak_256(isHex(value, { strict: false }) ? toBytes$1(value) : value);
  if (to === "bytes")
    return bytes2;
  return toHex(bytes2);
}
const hash$2 = (value) => keccak256(toBytes$1(value));
const getEventSelector = (fn2) => hash$2(getEventSignature(fn2));
function slice(value, start, end, { strict } = {}) {
  if (isHex(value, { strict: false }))
    return sliceHex(value, start, end, {
      strict
    });
  return sliceBytes(value, start, end, {
    strict
  });
}
function assertStartOffset(value, start) {
  if (typeof start === "number" && start > 0 && start > size$1(value) - 1)
    throw new SliceOffsetOutOfBoundsError({
      offset: start,
      position: "start",
      size: size$1(value)
    });
}
function assertEndOffset(value, start, end) {
  if (typeof start === "number" && typeof end === "number" && size$1(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError({
      offset: end,
      position: "end",
      size: size$1(value)
    });
  }
}
function sliceBytes(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = value_.slice(start, end);
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
function sliceHex(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
function encodeAbiParameters(params, values2) {
  if (params.length !== values2.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: params.length,
      givenLength: values2.length
    });
  const preparedParams = prepareParams({
    params,
    values: values2
  });
  const data2 = encodeParams(preparedParams);
  if (data2.length === 0)
    return "0x";
  return data2;
}
function prepareParams({ params, values: values2 }) {
  const preparedParams = [];
  for (let i3 = 0; i3 < params.length; i3++) {
    preparedParams.push(prepareParam({ param: params[i3], value: values2[i3] }));
  }
  return preparedParams;
}
function prepareParam({ param, value }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length2, type] = arrayComponents;
    return encodeArray(value, { length: length2, param: { ...param, type } });
  }
  if (param.type === "tuple") {
    return encodeTuple(value, {
      param
    });
  }
  if (param.type === "address") {
    return encodeAddress(value);
  }
  if (param.type === "bool") {
    return encodeBool(value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    const signed2 = param.type.startsWith("int");
    return encodeNumber(value, { signed: signed2 });
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(value, { param });
  }
  if (param.type === "string") {
    return encodeString(value);
  }
  throw new InvalidAbiEncodingTypeError(param.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams(preparedParams) {
  let staticSize = 0;
  for (let i3 = 0; i3 < preparedParams.length; i3++) {
    const { dynamic, encoded } = preparedParams[i3];
    if (dynamic)
      staticSize += 32;
    else
      staticSize += size$1(encoded);
  }
  const staticParams = [];
  const dynamicParams = [];
  let dynamicSize = 0;
  for (let i3 = 0; i3 < preparedParams.length; i3++) {
    const { dynamic, encoded } = preparedParams[i3];
    if (dynamic) {
      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
      dynamicParams.push(encoded);
      dynamicSize += size$1(encoded);
    } else {
      staticParams.push(encoded);
    }
  }
  return concat$1([...staticParams, ...dynamicParams]);
}
function encodeAddress(value) {
  if (!isAddress(value))
    throw new InvalidAddressError({ address: value });
  return { dynamic: false, encoded: padHex(value.toLowerCase()) };
}
function encodeArray(value, { length: length2, param }) {
  const dynamic = length2 === null;
  if (!Array.isArray(value))
    throw new InvalidArrayError(value);
  if (!dynamic && value.length !== length2)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: length2,
      givenLength: value.length,
      type: `${param.type}[${length2}]`
    });
  let dynamicChild = false;
  const preparedParams = [];
  for (let i3 = 0; i3 < value.length; i3++) {
    const preparedParam = prepareParam({ param, value: value[i3] });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParams.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data2 = encodeParams(preparedParams);
    if (dynamic) {
      const length3 = numberToHex(preparedParams.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParams.length > 0 ? concat$1([length3, data2]) : length3
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data2 };
  }
  return {
    dynamic: false,
    encoded: concat$1(preparedParams.map(({ encoded }) => encoded))
  };
}
function encodeBytes(value, { param }) {
  const [, paramSize] = param.type.split("bytes");
  const bytesSize = size$1(value);
  if (!paramSize) {
    let value_ = value;
    if (bytesSize % 32 !== 0)
      value_ = padHex(value_, {
        dir: "right",
        size: Math.ceil((value.length - 2) / 2 / 32) * 32
      });
    return {
      dynamic: true,
      encoded: concat$1([padHex(numberToHex(bytesSize, { size: 32 })), value_])
    };
  }
  if (bytesSize !== parseInt(paramSize))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: parseInt(paramSize),
      value
    });
  return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
}
function encodeBool(value) {
  return { dynamic: false, encoded: padHex(boolToHex(value)) };
}
function encodeNumber(value, { signed: signed2 }) {
  return {
    dynamic: false,
    encoded: numberToHex(value, {
      size: 32,
      signed: signed2
    })
  };
}
function encodeString(value) {
  const hexValue2 = stringToHex(value);
  const partsLength = Math.ceil(size$1(hexValue2) / 32);
  const parts = [];
  for (let i3 = 0; i3 < partsLength; i3++) {
    parts.push(padHex(slice(hexValue2, i3 * 32, (i3 + 1) * 32), {
      dir: "right"
    }));
  }
  return {
    dynamic: true,
    encoded: concat$1([
      padHex(numberToHex(size$1(hexValue2), { size: 32 })),
      ...parts
    ])
  };
}
function encodeTuple(value, { param }) {
  let dynamic = false;
  const preparedParams = [];
  for (let i3 = 0; i3 < param.components.length; i3++) {
    const param_ = param.components[i3];
    const index2 = Array.isArray(value) ? i3 : param_.name;
    const preparedParam = prepareParam({
      param: param_,
      value: value[index2]
    });
    preparedParams.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encodeParams(preparedParams) : concat$1(preparedParams.map(({ encoded }) => encoded))
  };
}
function getArrayComponents(type) {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ? (
    // Return `null` if the array is dynamic.
    [matches[2] ? Number(matches[2]) : null, matches[1]]
  ) : void 0;
}
const hash$1 = (value) => keccak256(toBytes$1(value));
const getFunctionSelector = (fn2) => slice(hash$1(getFunctionSignature(fn2)), 0, 4);
function getAbiItem({ abi: abi2, args = [], name: name2 }) {
  const isSelector = isHex(name2, { strict: false });
  const abiItems = abi2.filter((abiItem) => {
    if (isSelector) {
      if (abiItem.type === "function")
        return getFunctionSelector(abiItem) === name2;
      if (abiItem.type === "event")
        return getEventSelector(abiItem) === name2;
      return false;
    }
    return "name" in abiItem && abiItem.name === name2;
  });
  if (abiItems.length === 0)
    return void 0;
  if (abiItems.length === 1)
    return abiItems[0];
  let matchedAbiItem = void 0;
  for (const abiItem of abiItems) {
    if (!("inputs" in abiItem))
      continue;
    if (!args || args.length === 0) {
      if (!abiItem.inputs || abiItem.inputs.length === 0)
        return abiItem;
      continue;
    }
    if (!abiItem.inputs)
      continue;
    if (abiItem.inputs.length === 0)
      continue;
    if (abiItem.inputs.length !== args.length)
      continue;
    const matched = args.every((arg, index2) => {
      const abiParameter = "inputs" in abiItem && abiItem.inputs[index2];
      if (!abiParameter)
        return false;
      return isArgOfType(arg, abiParameter);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
        if (ambiguousTypes)
          throw new AbiItemAmbiguityError({
            abiItem,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem;
    }
  }
  if (matchedAbiItem)
    return matchedAbiItem;
  return abiItems[0];
}
function isArgOfType(arg, abiParameter) {
  const argType = typeof arg;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return isAddress(arg);
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every((component, index2) => {
          return isArgOfType(Object.values(arg)[index2], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every((x2) => isArgOfType(x2, {
          ...abiParameter,
          // Pop off `[]` or `[M]` from end of type
          type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
        }));
      }
      return false;
    }
  }
}
function getAmbiguousTypes(sourceParameters, targetParameters, args) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
    const types2 = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types2.includes("address") && types2.includes("bytes20"))
        return true;
      if (types2.includes("address") && types2.includes("string"))
        return isAddress(args[parameterIndex]);
      if (types2.includes("address") && types2.includes("bytes"))
        return isAddress(args[parameterIndex]);
      return false;
    })();
    if (ambiguous)
      return types2;
  }
  return;
}
function encodeEventTopics({ abi: abi2, eventName, args }) {
  let abiItem = abi2[0];
  if (eventName) {
    abiItem = getAbiItem({
      abi: abi2,
      args,
      name: eventName
    });
    if (!abiItem)
      throw new AbiEventNotFoundError(eventName, {
        docsPath: "/docs/contract/encodeEventTopics"
      });
  }
  if (abiItem.type !== "event")
    throw new AbiEventNotFoundError(void 0, {
      docsPath: "/docs/contract/encodeEventTopics"
    });
  const definition = formatAbiItem(abiItem);
  const signature2 = getEventSelector(definition);
  let topics = [];
  if (args && "inputs" in abiItem) {
    const indexedInputs = abiItem.inputs?.filter((param) => "indexed" in param && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x2) => args[x2.name]) ?? [] : [];
    if (args_.length > 0) {
      topics = indexedInputs?.map((param, i3) => Array.isArray(args_[i3]) ? args_[i3].map((_2, j2) => encodeArg({ param, value: args_[i3][j2] })) : args_[i3] ? encodeArg({ param, value: args_[i3] }) : null) ?? [];
    }
  }
  return [signature2, ...topics];
}
function encodeArg({ param, value }) {
  if (param.type === "string" || param.type === "bytes")
    return keccak256(toBytes$1(value));
  if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(param.type);
  return encodeAbiParameters([param], [value]);
}
function createFilterRequestScope(client2, { method }) {
  const requestMap = {};
  if (client2.transport.type === "fallback")
    client2.transport.onResponse?.(({ method: method_, response: id2, status, transport }) => {
      if (status === "success" && method === method_)
        requestMap[id2] = transport.request;
    });
  return (id2) => requestMap[id2] || client2.request;
}
async function createContractEventFilter(client2, { address, abi: abi2, args, eventName, fromBlock, strict, toBlock }) {
  const getRequest = createFilterRequestScope(client2, {
    method: "eth_newFilter"
  });
  const topics = eventName ? encodeEventTopics({
    abi: abi2,
    args,
    eventName
  }) : void 0;
  const id2 = await client2.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi: abi2,
    args,
    eventName,
    id: id2,
    request: getRequest(id2),
    strict,
    type: "event"
  };
}
function parseAccount(account) {
  if (typeof account === "string")
    return { address: account, type: "json-rpc" };
  return account;
}
function encodeFunctionData({ abi: abi2, args, functionName }) {
  let abiItem = abi2[0];
  if (functionName) {
    abiItem = getAbiItem({
      abi: abi2,
      args,
      name: functionName
    });
    if (!abiItem)
      throw new AbiFunctionNotFoundError(functionName, {
        docsPath: "/docs/contract/encodeFunctionData"
      });
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, {
      docsPath: "/docs/contract/encodeFunctionData"
    });
  const definition = formatAbiItem(abiItem);
  const signature2 = getFunctionSelector(definition);
  const data2 = "inputs" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : void 0;
  return concatHex([signature2, data2 ?? "0x"]);
}
const panicReasons = {
  1: "An `assert` condition failed.",
  17: "Arithmic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
};
const solidityError = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
};
const solidityPanic = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
function checksumAddress(address_, chainId2) {
  const hexAddress = chainId2 ? `${chainId2}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
  const hash2 = keccak256(stringToBytes(hexAddress), "bytes");
  const address = (chainId2 ? hexAddress.substring(`${chainId2}0x`.length) : hexAddress).split("");
  for (let i3 = 0; i3 < 40; i3 += 2) {
    if (hash2[i3 >> 1] >> 4 >= 8 && address[i3]) {
      address[i3] = address[i3].toUpperCase();
    }
    if ((hash2[i3 >> 1] & 15) >= 8 && address[i3 + 1]) {
      address[i3 + 1] = address[i3 + 1].toUpperCase();
    }
  }
  return `0x${address.join("")}`;
}
function getAddress(address, chainId2) {
  if (!isAddress(address))
    throw new InvalidAddressError({ address });
  return checksumAddress(address, chainId2);
}
function decodeAbiParameters(params, data2) {
  if (data2 === "0x" && params.length > 0)
    throw new AbiDecodingZeroDataError();
  if (size$1(data2) && size$1(data2) < 32)
    throw new AbiDecodingDataSizeTooSmallError({
      data: data2,
      params,
      size: size$1(data2)
    });
  return decodeParams({
    data: data2,
    params
  });
}
function decodeParams({ data: data2, params }) {
  const decodedValues = [];
  let position2 = 0;
  for (let i3 = 0; i3 < params.length; i3++) {
    if (position2 >= size$1(data2))
      throw new AbiDecodingDataSizeTooSmallError({
        data: data2,
        params,
        size: size$1(data2)
      });
    const param = params[i3];
    const { consumed, value } = decodeParam({ data: data2, param, position: position2 });
    decodedValues.push(value);
    position2 += consumed;
  }
  return decodedValues;
}
function decodeParam({ data: data2, param, position: position2 }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length2, type] = arrayComponents;
    return decodeArray(data2, {
      length: length2,
      param: { ...param, type },
      position: position2
    });
  }
  if (param.type === "tuple") {
    return decodeTuple(data2, { param, position: position2 });
  }
  if (param.type === "string") {
    return decodeString(data2, { position: position2 });
  }
  if (param.type.startsWith("bytes")) {
    return decodeBytes(data2, { param, position: position2 });
  }
  const value = slice(data2, position2, position2 + 32, { strict: true });
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    return decodeNumber(value, { param });
  }
  if (param.type === "address") {
    return decodeAddress(value);
  }
  if (param.type === "bool") {
    return decodeBool(value);
  }
  throw new InvalidAbiDecodingTypeError(param.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
function decodeAddress(value) {
  return { consumed: 32, value: checksumAddress(slice(value, -20)) };
}
function decodeArray(data2, { param, length: length2, position: position2 }) {
  if (!length2) {
    const offset = hexToNumber(slice(data2, position2, position2 + 32, { strict: true }));
    const length3 = hexToNumber(slice(data2, offset, offset + 32, { strict: true }));
    let consumed2 = 0;
    const value2 = [];
    for (let i3 = 0; i3 < length3; ++i3) {
      const decodedChild = decodeParam({
        data: slice(data2, offset + 32),
        param,
        position: consumed2
      });
      consumed2 += decodedChild.consumed;
      value2.push(decodedChild.value);
    }
    return { value: value2, consumed: 32 };
  }
  if (hasDynamicChild(param)) {
    const arrayComponents = getArrayComponents(param.type);
    const dynamicChild = !arrayComponents?.[0];
    let consumed2 = 0;
    const value2 = [];
    for (let i3 = 0; i3 < length2; ++i3) {
      const offset = hexToNumber(slice(data2, position2, position2 + 32, { strict: true }));
      const decodedChild = decodeParam({
        data: slice(data2, offset),
        param,
        position: dynamicChild ? consumed2 : i3 * 32
      });
      consumed2 += decodedChild.consumed;
      value2.push(decodedChild.value);
    }
    return { value: value2, consumed: 32 };
  }
  let consumed = 0;
  const value = [];
  for (let i3 = 0; i3 < length2; ++i3) {
    const decodedChild = decodeParam({
      data: data2,
      param,
      position: position2 + consumed
    });
    consumed += decodedChild.consumed;
    value.push(decodedChild.value);
  }
  return { value, consumed };
}
function decodeBool(value) {
  return { consumed: 32, value: hexToBool(value) };
}
function decodeBytes(data2, { param, position: position2 }) {
  const [_2, size2] = param.type.split("bytes");
  if (!size2) {
    const offset = hexToNumber(slice(data2, position2, position2 + 32, { strict: true }));
    const length2 = hexToNumber(slice(data2, offset, offset + 32, { strict: true }));
    if (length2 === 0)
      return { consumed: 32, value: "0x" };
    const value2 = slice(data2, offset + 32, offset + 32 + length2, {
      strict: true
    });
    return { consumed: 32, value: value2 };
  }
  const value = slice(data2, position2, position2 + parseInt(size2), {
    strict: true
  });
  return { consumed: 32, value };
}
function decodeNumber(value, { param }) {
  const signed2 = param.type.startsWith("int");
  const size2 = parseInt(param.type.split("int")[1] || "256");
  return {
    consumed: 32,
    value: size2 > 48 ? hexToBigInt(value, { signed: signed2 }) : hexToNumber(value, { signed: signed2 })
  };
}
function decodeString(data2, { position: position2 }) {
  const offset = hexToNumber(slice(data2, position2, position2 + 32, { strict: true }));
  const length2 = hexToNumber(slice(data2, offset, offset + 32, { strict: true }));
  if (length2 === 0)
    return { consumed: 32, value: "" };
  const value = hexToString(trim(slice(data2, offset + 32, offset + 32 + length2, { strict: true })));
  return { consumed: 32, value };
}
function decodeTuple(data2, { param, position: position2 }) {
  const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name: name2 }) => !name2);
  const value = hasUnnamedChild ? [] : {};
  let consumed = 0;
  if (hasDynamicChild(param)) {
    const offset = hexToNumber(slice(data2, position2, position2 + 32, { strict: true }));
    for (let i3 = 0; i3 < param.components.length; ++i3) {
      const component = param.components[i3];
      const decodedChild = decodeParam({
        data: slice(data2, offset),
        param: component,
        position: consumed
      });
      consumed += decodedChild.consumed;
      value[hasUnnamedChild ? i3 : component?.name] = decodedChild.value;
    }
    return { consumed: 32, value };
  }
  for (let i3 = 0; i3 < param.components.length; ++i3) {
    const component = param.components[i3];
    const decodedChild = decodeParam({
      data: data2,
      param: component,
      position: position2 + consumed
    });
    consumed += decodedChild.consumed;
    value[hasUnnamedChild ? i3 : component?.name] = decodedChild.value;
  }
  return { consumed, value };
}
function hasDynamicChild(param) {
  const { type } = param;
  if (type === "string")
    return true;
  if (type === "bytes")
    return true;
  if (type.endsWith("[]"))
    return true;
  if (type === "tuple")
    return param.components?.some(hasDynamicChild);
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
    return true;
  return false;
}
function decodeErrorResult({ abi: abi2, data: data2 }) {
  const signature2 = slice(data2, 0, 4);
  if (signature2 === "0x")
    throw new AbiDecodingZeroDataError();
  const abi_ = [...abi2 || [], solidityError, solidityPanic];
  const abiItem = abi_.find((x2) => x2.type === "error" && signature2 === getFunctionSelector(formatAbiItem(x2)));
  if (!abiItem)
    throw new AbiErrorSignatureNotFoundError(signature2, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem,
    args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice(data2, 4)) : void 0,
    errorName: abiItem.name
  };
}
const stringify = (value, replacer, space) => JSON.stringify(value, (key2, value_) => {
  const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
  return typeof replacer === "function" ? replacer(key2, value2) : value2;
}, space);
function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
  if (!("name" in abiItem))
    return;
  if (!("inputs" in abiItem))
    return;
  if (!abiItem.inputs)
    return;
  return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i3) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i3] === "object" ? stringify(args[i3]) : args[i3]}`).join(", ")})`;
}
function formatEther(wei, unit = "wei") {
  return formatUnits(wei, etherUnits[unit]);
}
function prettyPrint(args) {
  const entries2 = Object.entries(args).map(([key2, value]) => {
    if (value === void 0 || value === false)
      return null;
    return [key2, value];
  }).filter(Boolean);
  const maxLength = entries2.reduce((acc, [key2]) => Math.max(acc, key2.length), 0);
  return entries2.map(([key2, value]) => `  ${`${key2}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
}
class FeeConflictError extends BaseError {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FeeConflictError"
    });
  }
}
class InvalidSerializableTransactionError extends BaseError {
  constructor({ transaction }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        prettyPrint(transaction),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidSerializableTransactionError"
    });
  }
}
class TransactionExecutionError extends BaseError {
  constructor(cause, { account, docsPath: docsPath2, chain, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArgs = prettyPrint({
      chain: chain && `${chain?.name} (id: ${chain?.id})`,
      from: account?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
      data: data2,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Request Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionExecutionError"
    });
    this.cause = cause;
  }
}
class TransactionNotFoundError extends BaseError {
  constructor({ blockHash, blockNumber, blockTag, hash: hash2, index: index2 }) {
    let identifier2 = "Transaction";
    if (blockTag && index2 !== void 0)
      identifier2 = `Transaction at block time "${blockTag}" at index "${index2}"`;
    if (blockHash && index2 !== void 0)
      identifier2 = `Transaction at block hash "${blockHash}" at index "${index2}"`;
    if (blockNumber && index2 !== void 0)
      identifier2 = `Transaction at block number "${blockNumber}" at index "${index2}"`;
    if (hash2)
      identifier2 = `Transaction with hash "${hash2}"`;
    super(`${identifier2} could not be found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionNotFoundError"
    });
  }
}
class TransactionReceiptNotFoundError extends BaseError {
  constructor({ hash: hash2 }) {
    super(`Transaction receipt with hash "${hash2}" could not be found. The Transaction may not be processed on a block yet.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionReceiptNotFoundError"
    });
  }
}
class WaitForTransactionReceiptTimeoutError extends BaseError {
  constructor({ hash: hash2 }) {
    super(`Timed out while waiting for transaction with hash "${hash2}" to be confirmed.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WaitForTransactionReceiptTimeoutError"
    });
  }
}
class CallExecutionError extends BaseError {
  constructor(cause, { account: account_, docsPath: docsPath2, chain, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const account = account_ ? parseAccount(account_) : void 0;
    const prettyArgs = prettyPrint({
      from: account?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
      data: data2,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Raw Call Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "CallExecutionError"
    });
    this.cause = cause;
  }
}
class ContractFunctionExecutionError extends BaseError {
  constructor(cause, { abi: abi2, args, contractAddress, docsPath: docsPath2, functionName, sender }) {
    const abiItem = getAbiItem({ abi: abi2, args, name: functionName });
    const formattedArgs = abiItem ? formatAbiItemWithArgs({
      abiItem,
      args,
      includeFunctionName: false,
      includeName: false
    }) : void 0;
    const functionWithParams = abiItem ? formatAbiItem(abiItem, { includeName: true }) : void 0;
    const prettyArgs = prettyPrint({
      address: contractAddress && getContractAddress(contractAddress),
      function: functionWithParams,
      args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
      sender
    });
    super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Contract Call:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "abi", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "args", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "contractAddress", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "formattedArgs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "functionName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "sender", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ContractFunctionExecutionError"
    });
    this.abi = abi2;
    this.args = args;
    this.cause = cause;
    this.contractAddress = contractAddress;
    this.functionName = functionName;
    this.sender = sender;
  }
}
class ContractFunctionRevertedError extends BaseError {
  constructor({ abi: abi2, data: data2, functionName, message }) {
    let cause;
    let decodedData = void 0;
    let metaMessages;
    let reason;
    if (data2 && data2 !== "0x") {
      try {
        decodedData = decodeErrorResult({ abi: abi2, data: data2 });
        const { abiItem, errorName, args: errorArgs } = decodedData;
        if (errorName === "Error") {
          reason = errorArgs[0];
        } else if (errorName === "Panic") {
          const [firstArg] = errorArgs;
          reason = panicReasons[firstArg];
        } else {
          const errorWithParams = abiItem ? formatAbiItem(abiItem, { includeName: true }) : void 0;
          const formattedArgs = abiItem && errorArgs ? formatAbiItemWithArgs({
            abiItem,
            args: errorArgs,
            includeFunctionName: false,
            includeName: false
          }) : void 0;
          metaMessages = [
            errorWithParams ? `Error: ${errorWithParams}` : "",
            formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
          ];
        }
      } catch (err) {
        cause = err;
      }
    } else if (message)
      reason = message;
    let signature2;
    if (cause instanceof AbiErrorSignatureNotFoundError) {
      signature2 = cause.signature;
      metaMessages = [
        `Unable to decode signature "${signature2}" as it was not found on the provided ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature2}.`
      ];
    }
    super(reason && reason !== "execution reverted" || signature2 ? [
      `The contract function "${functionName}" reverted with the following ${signature2 ? "signature" : "reason"}:`,
      reason || signature2
    ].join("\n") : `The contract function "${functionName}" reverted.`, {
      cause,
      metaMessages
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ContractFunctionRevertedError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "reason", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = decodedData;
    this.reason = reason;
    this.signature = signature2;
  }
}
class ContractFunctionZeroDataError extends BaseError {
  constructor({ functionName }) {
    super(`The contract function "${functionName}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${functionName}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ContractFunctionZeroDataError"
    });
  }
}
class RawContractError extends BaseError {
  constructor({ data: data2, message }) {
    super(message || "");
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RawContractError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = data2;
  }
}
class HttpRequestError extends BaseError {
  constructor({ body: body2, details, headers, status, url }) {
    super("HTTP request failed.", {
      details,
      metaMessages: [
        status && `Status: ${status}`,
        `URL: ${getUrl(url)}`,
        body2 && `Request body: ${stringify(body2)}`
      ].filter(Boolean)
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "HttpRequestError"
    });
    Object.defineProperty(this, "body", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "headers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "status", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "url", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.body = body2;
    this.headers = headers;
    this.status = status;
    this.url = url;
  }
}
class WebSocketRequestError extends BaseError {
  constructor({ body: body2, details, url }) {
    super("WebSocket request failed.", {
      details,
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body2)}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WebSocketRequestError"
    });
  }
}
class RpcRequestError extends BaseError {
  constructor({ body: body2, error, url }) {
    super("RPC Request failed.", {
      cause: error,
      details: error.message,
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body2)}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcRequestError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.code = error.code;
  }
}
class TimeoutError extends BaseError {
  constructor({ body: body2, url }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body2)}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TimeoutError"
    });
  }
}
const unknownErrorCode = -1;
class RpcError extends BaseError {
  constructor(cause, { code: code2, docsPath: docsPath2, metaMessages, shortMessage }) {
    super(shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: metaMessages || cause?.metaMessages
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = cause.name;
    this.code = cause instanceof RpcRequestError ? cause.code : code2 ?? unknownErrorCode;
  }
}
class ProviderRpcError extends RpcError {
  constructor(cause, options) {
    super(cause, options);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderRpcError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = options.data;
  }
}
class ParseRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ParseRpcError.code,
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ParseRpcError"
    });
  }
}
Object.defineProperty(ParseRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32700
});
class InvalidRequestRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidRequestRpcError.code,
      shortMessage: "JSON is not a valid request object."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidRequestRpcError"
    });
  }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32600
});
class MethodNotFoundRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: MethodNotFoundRpcError.code,
      shortMessage: "The method does not exist / is not available."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MethodNotFoundRpcError"
    });
  }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32601
});
class InvalidParamsRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidParamsRpcError.code,
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidParamsRpcError"
    });
  }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32602
});
class InternalRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InternalRpcError.code,
      shortMessage: "An internal error was received."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InternalRpcError"
    });
  }
}
Object.defineProperty(InternalRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32603
});
class InvalidInputRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidInputRpcError.code,
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidInputRpcError"
    });
  }
}
Object.defineProperty(InvalidInputRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32e3
});
class ResourceNotFoundRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ResourceNotFoundRpcError.code,
      shortMessage: "Requested resource not found."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32001
});
class ResourceUnavailableRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ResourceUnavailableRpcError.code,
      shortMessage: "Requested resource not available."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ResourceUnavailableRpcError"
    });
  }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32002
});
class TransactionRejectedRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: TransactionRejectedRpcError.code,
      shortMessage: "Transaction creation failed."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionRejectedRpcError"
    });
  }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32003
});
class MethodNotSupportedRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: MethodNotSupportedRpcError.code,
      shortMessage: "Method is not implemented."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MethodNotSupportedRpcError"
    });
  }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32004
});
class LimitExceededRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: LimitExceededRpcError.code,
      shortMessage: "Request exceeds defined limit."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "LimitExceededRpcError"
    });
  }
}
Object.defineProperty(LimitExceededRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32005
});
class JsonRpcVersionUnsupportedError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: JsonRpcVersionUnsupportedError.code,
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "JsonRpcVersionUnsupportedError"
    });
  }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32006
});
class UserRejectedRequestError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UserRejectedRequestError.code,
      shortMessage: "User rejected the request."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UserRejectedRequestError"
    });
  }
}
Object.defineProperty(UserRejectedRequestError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4001
});
class UnauthorizedProviderError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnauthorizedProviderError.code,
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnauthorizedProviderError"
    });
  }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4100
});
class UnsupportedProviderMethodError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnsupportedProviderMethodError.code,
      shortMessage: "The Provider does not support the requested method."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnsupportedProviderMethodError"
    });
  }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4200
});
class ProviderDisconnectedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: ProviderDisconnectedError.code,
      shortMessage: "The Provider is disconnected from all chains."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderDisconnectedError"
    });
  }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4900
});
class ChainDisconnectedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: ChainDisconnectedError.code,
      shortMessage: "The Provider is not connected to the requested chain."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainDisconnectedError"
    });
  }
}
Object.defineProperty(ChainDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4901
});
class SwitchChainError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: SwitchChainError.code,
      shortMessage: "An error occurred when attempting to switch chain."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SwitchChainError"
    });
  }
}
Object.defineProperty(SwitchChainError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4902
});
class UnknownRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      shortMessage: "An unknown RPC error occurred."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownRpcError"
    });
  }
}
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err, { abi: abi2, address, args, docsPath: docsPath2, functionName, sender }) {
  const { code: code2, data: data2, message, shortMessage } = err instanceof RawContractError ? err : err instanceof BaseError ? err.walk((err2) => "data" in err2) || err.walk() : {};
  const cause = (() => {
    if (err instanceof AbiDecodingZeroDataError)
      return new ContractFunctionZeroDataError({ functionName });
    if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code2) && (data2 || message || shortMessage)) {
      return new ContractFunctionRevertedError({
        abi: abi2,
        data: typeof data2 === "object" ? data2.data : data2,
        functionName,
        message: shortMessage ?? message
      });
    }
    return err;
  })();
  return new ContractFunctionExecutionError(cause, {
    abi: abi2,
    args,
    contractAddress: address,
    docsPath: docsPath2,
    functionName,
    sender
  });
}
class AccountNotFoundError extends BaseError {
  constructor({ docsPath: docsPath2 } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
    ].join("\n"), {
      docsPath: docsPath2,
      docsSlug: "account"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AccountNotFoundError"
    });
  }
}
class EstimateGasExecutionError extends BaseError {
  constructor(cause, { account, docsPath: docsPath2, chain, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArgs = prettyPrint({
      from: account?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
      data: data2,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EstimateGasExecutionError"
    });
    this.cause = cause;
  }
}
function getNodeError(err, args) {
  const message = (err.details || "").toLowerCase();
  const executionRevertedError = err.walk((e2) => e2.code === ExecutionRevertedError.code);
  if (executionRevertedError instanceof BaseError) {
    return new ExecutionRevertedError({
      cause: err,
      message: executionRevertedError.details
    });
  }
  if (ExecutionRevertedError.nodeMessage.test(message))
    return new ExecutionRevertedError({
      cause: err,
      message: err.details
    });
  if (FeeCapTooHighError.nodeMessage.test(message))
    return new FeeCapTooHighError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (FeeCapTooLowError.nodeMessage.test(message))
    return new FeeCapTooLowError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (NonceTooHighError.nodeMessage.test(message))
    return new NonceTooHighError({ cause: err, nonce: args?.nonce });
  if (NonceTooLowError.nodeMessage.test(message))
    return new NonceTooLowError({ cause: err, nonce: args?.nonce });
  if (NonceMaxValueError.nodeMessage.test(message))
    return new NonceMaxValueError({ cause: err, nonce: args?.nonce });
  if (InsufficientFundsError.nodeMessage.test(message))
    return new InsufficientFundsError({ cause: err });
  if (IntrinsicGasTooHighError.nodeMessage.test(message))
    return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
  if (IntrinsicGasTooLowError.nodeMessage.test(message))
    return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
  if (TransactionTypeNotSupportedError.nodeMessage.test(message))
    return new TransactionTypeNotSupportedError({ cause: err });
  if (TipAboveFeeCapError.nodeMessage.test(message))
    return new TipAboveFeeCapError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas,
      maxPriorityFeePerGas: args?.maxPriorityFeePerGas
    });
  return new UnknownNodeError({
    cause: err
  });
}
function getEstimateGasError(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new EstimateGasExecutionError(cause, {
    docsPath: docsPath2,
    ...args
  });
}
function extract(value_, { format }) {
  if (!format)
    return {};
  const value = {};
  function extract_(formatted2) {
    const keys = Object.keys(formatted2);
    for (const key2 of keys) {
      if (key2 in value_)
        value[key2] = value_[key2];
      if (formatted2[key2] && typeof formatted2[key2] === "object" && !Array.isArray(formatted2[key2]))
        extract_(formatted2[key2]);
    }
  }
  const formatted = format(value_ || {});
  extract_(formatted);
  return value;
}
function assertRequest(args) {
  const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
  const account = account_ ? parseAccount(account_) : void 0;
  if (account && !isAddress(account.address))
    throw new InvalidAddressError({ address: account.address });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
    throw new FeeConflictError();
  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
class BaseFeeScalarError extends BaseError {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseFeeScalarError"
    });
  }
}
class Eip1559FeesNotSupportedError extends BaseError {
  constructor() {
    super("Chain does not support EIP-1559 fees.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Eip1559FeesNotSupportedError"
    });
  }
}
class MaxFeePerGasTooLowError extends BaseError {
  constructor({ maxPriorityFeePerGas }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MaxFeePerGasTooLowError"
    });
  }
}
class BlockNotFoundError extends BaseError {
  constructor({ blockHash, blockNumber }) {
    let identifier2 = "Block";
    if (blockHash)
      identifier2 = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier2 = `Block at number "${blockNumber}"`;
    super(`${identifier2} could not be found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BlockNotFoundError"
    });
  }
}
async function getBlock(client2, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
  const blockTag = blockTag_ ?? "latest";
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let block2 = null;
  if (blockHash) {
    block2 = await client2.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    });
  } else {
    block2 = await client2.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    });
  }
  if (!block2)
    throw new BlockNotFoundError({ blockHash, blockNumber });
  const format = client2.chain?.formatters?.block?.format || formatBlock;
  return format(block2);
}
async function getGasPrice(client2) {
  const gasPrice = await client2.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}
async function estimateMaxPriorityFeePerGas(client2, args) {
  return internal_estimateMaxPriorityFeePerGas(client2, args);
}
async function internal_estimateMaxPriorityFeePerGas(client2, args) {
  const { block: block_, chain = client2.chain, request: request2 } = args || {};
  if (typeof chain?.fees?.defaultPriorityFee === "function") {
    const block2 = block_ || await getAction(client2, getBlock, "getBlock")({});
    return chain.fees.defaultPriorityFee({
      block: block2,
      client: client2,
      request: request2
    });
  }
  if (typeof chain?.fees?.defaultPriorityFee !== "undefined")
    return chain?.fees?.defaultPriorityFee;
  try {
    const maxPriorityFeePerGasHex = await client2.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(maxPriorityFeePerGasHex);
  } catch {
    const [block2, gasPrice] = await Promise.all([
      block_ ? Promise.resolve(block_) : getAction(client2, getBlock, "getBlock")({}),
      getAction(client2, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof block2.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = gasPrice - block2.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n)
      return 0n;
    return maxPriorityFeePerGas;
  }
}
async function estimateFeesPerGas(client2, args) {
  return internal_estimateFeesPerGas(client2, args);
}
async function internal_estimateFeesPerGas(client2, args) {
  const { block: block_, chain = client2.chain, request: request2, type = "eip1559" } = args || {};
  const baseFeeMultiplier = await (async () => {
    if (typeof chain?.fees?.baseFeeMultiplier === "function")
      return chain.fees.baseFeeMultiplier({
        block: block_,
        client: client2,
        request: request2
      });
    return chain?.fees?.baseFeeMultiplier ?? 1.2;
  })();
  if (baseFeeMultiplier < 1)
    throw new BaseFeeScalarError();
  const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
  const denominator = 10 ** decimals;
  const multiply = (base3) => base3 * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block2 = block_ ? block_ : await getAction(client2, getBlock, "getBlock")({});
  if (typeof chain?.fees?.estimateFeesPerGas === "function")
    return chain.fees.estimateFeesPerGas({
      block: block_,
      client: client2,
      multiply,
      request: request2,
      type
    });
  if (type === "eip1559") {
    if (typeof block2.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = request2?.maxPriorityFeePerGas ? request2.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client2, {
      block: block2,
      chain,
      request: request2
    });
    const baseFeePerGas = multiply(block2.baseFeePerGas);
    const maxFeePerGas = request2?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = request2?.gasPrice ?? multiply(await getAction(client2, getGasPrice, "getGasPrice")({}));
  return {
    gasPrice
  };
}
async function getTransactionCount(client2, { address, blockTag = "latest", blockNumber }) {
  const count = await client2.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  });
  return hexToNumber(count);
}
function getTransactionType(transaction) {
  if (transaction.type)
    return transaction.type;
  if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined")
    return "eip1559";
  if (typeof transaction.gasPrice !== "undefined") {
    if (typeof transaction.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction });
}
async function prepareTransactionRequest(client2, args) {
  const { account: account_ = client2.account, chain, gas, nonce, type } = args;
  if (!account_)
    throw new AccountNotFoundError();
  const account = parseAccount(account_);
  const block2 = await getAction(client2, getBlock, "getBlock")({ blockTag: "latest" });
  const request2 = { ...args, from: account.address };
  if (typeof nonce === "undefined")
    request2.nonce = await getAction(client2, getTransactionCount, "getTransactionCount")({
      address: account.address,
      blockTag: "pending"
    });
  if (typeof type === "undefined") {
    try {
      request2.type = getTransactionType(request2);
    } catch {
      request2.type = typeof block2.baseFeePerGas === "bigint" ? "eip1559" : "legacy";
    }
  }
  if (request2.type === "eip1559") {
    const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client2, {
      block: block2,
      chain,
      request: request2
    });
    if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
      throw new MaxFeePerGasTooLowError({
        maxPriorityFeePerGas
      });
    request2.maxPriorityFeePerGas = maxPriorityFeePerGas;
    request2.maxFeePerGas = maxFeePerGas;
  } else {
    if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
      throw new Eip1559FeesNotSupportedError();
    const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client2, {
      block: block2,
      chain,
      request: request2,
      type: "legacy"
    });
    request2.gasPrice = gasPrice_;
  }
  if (typeof gas === "undefined")
    request2.gas = await getAction(client2, estimateGas, "estimateGas")({
      ...request2,
      account: { address: account.address, type: "json-rpc" }
    });
  assertRequest(request2);
  return request2;
}
async function estimateGas(client2, args) {
  const account_ = args.account ?? client2.account;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/public/estimateGas"
    });
  const account = parseAccount(account_);
  try {
    const { accessList, blockNumber, blockTag, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = account.type === "local" ? await prepareTransactionRequest(client2, args) : args;
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block2 = blockNumberHex || blockTag;
    assertRequest(args);
    const chainFormat = client2.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request2 = format({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      from: account.address,
      accessList,
      data: data2,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    const balance = await client2.request({
      method: "eth_estimateGas",
      params: block2 ? [request2, block2] : [request2]
    });
    return BigInt(balance);
  } catch (err) {
    throw getEstimateGasError(err, {
      ...args,
      account,
      chain: client2.chain
    });
  }
}
async function estimateContractGas(client2, { abi: abi2, address, args, functionName, ...request2 }) {
  const data2 = encodeFunctionData({
    abi: abi2,
    args,
    functionName
  });
  try {
    const gas = await getAction(client2, estimateGas, "estimateGas")({
      data: data2,
      to: address,
      ...request2
    });
    return gas;
  } catch (err) {
    const account = request2.account ? parseAccount(request2.account) : void 0;
    throw getContractError(err, {
      abi: abi2,
      address,
      args,
      docsPath: "/docs/contract/estimateContractGas",
      functionName,
      sender: account?.address
    });
  }
}
const docsPath$2 = "/docs/contract/decodeEventLog";
function decodeEventLog({ abi: abi2, data: data2, strict: strict_, topics }) {
  const strict = strict_ ?? true;
  const [signature2, ...argTopics] = topics;
  if (!signature2)
    throw new AbiEventSignatureEmptyTopicsError({
      docsPath: docsPath$2
    });
  const abiItem = abi2.find((x2) => x2.type === "event" && signature2 === getEventSelector(formatAbiItem(x2)));
  if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
    throw new AbiEventSignatureNotFoundError(signature2, {
      docsPath: docsPath$2
    });
  const { name: name2, inputs } = abiItem;
  const isUnnamed = inputs?.some((x2) => !("name" in x2 && x2.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x2) => "indexed" in x2 && x2.indexed);
  for (let i3 = 0; i3 < indexedInputs.length; i3++) {
    const param = indexedInputs[i3];
    const topic = argTopics[i3];
    if (!topic)
      throw new DecodeLogTopicsMismatch({
        abiItem,
        param
      });
    args[param.name || i3] = decodeTopic({ param, value: topic });
  }
  const nonIndexedInputs = inputs.filter((x2) => !("indexed" in x2 && x2.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data2 && data2 !== "0x") {
      try {
        const decodedData = decodeAbiParameters(nonIndexedInputs, data2);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i3 = 0; i3 < nonIndexedInputs.length; i3++) {
              args[nonIndexedInputs[i3].name] = decodedData[i3];
            }
          }
        }
      } catch (err) {
        if (strict) {
          if (err instanceof AbiDecodingDataSizeTooSmallError)
            throw new DecodeLogDataMismatch({
              abiItem,
              data: err.data,
              params: err.params,
              size: err.size
            });
          throw err;
        }
      }
    } else if (strict) {
      throw new DecodeLogDataMismatch({
        abiItem,
        data: "0x",
        params: nonIndexedInputs,
        size: 0
      });
    }
  }
  return {
    eventName: name2,
    args: Object.values(args).length > 0 ? args : void 0
  };
}
function decodeTopic({ param, value }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    return value;
  const decodedArg = decodeAbiParameters([param], value) || [];
  return decodedArg[0];
}
async function getLogs(client2, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
  const strict = strict_ ?? false;
  const events2 = events_ ?? (event ? [event] : void 0);
  let topics = [];
  if (events2) {
    topics = [
      events2.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  let logs;
  if (blockHash) {
    logs = await client2.request({
      method: "eth_getLogs",
      params: [{ address, topics, blockHash }]
    });
  } else {
    logs = await client2.request({
      method: "eth_getLogs",
      params: [
        {
          address,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
        }
      ]
    });
  }
  return logs.map((log3) => {
    try {
      const { eventName, args: args2 } = events2 ? decodeEventLog({
        abi: events2,
        data: log3.data,
        topics: log3.topics,
        strict
      }) : { eventName: void 0, args: void 0 };
      return formatLog(log3, { args: args2, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if (strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
      }
      return formatLog(log3, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}
async function getContractEvents(client2, { abi: abi2, address, args, blockHash, eventName, fromBlock, toBlock, strict }) {
  const event = eventName ? getAbiItem({ abi: abi2, name: eventName }) : void 0;
  const events2 = !event ? abi2.filter((x2) => x2.type === "event") : void 0;
  return getAction(client2, getLogs, "getLogs")({
    address,
    args,
    blockHash,
    event,
    events: events2,
    fromBlock,
    toBlock,
    strict
  });
}
const docsPath$1 = "/docs/contract/decodeFunctionResult";
function decodeFunctionResult({ abi: abi2, args, functionName, data: data2 }) {
  let abiItem = abi2[0];
  if (functionName) {
    abiItem = getAbiItem({
      abi: abi2,
      args,
      name: functionName
    });
    if (!abiItem)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath$1 });
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$1 });
  if (!abiItem.outputs)
    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath$1 });
  const values2 = decodeAbiParameters(abiItem.outputs, data2);
  if (values2 && values2.length > 1)
    return values2;
  if (values2 && values2.length === 1)
    return values2[0];
  return void 0;
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    promise = Promise.all(deps.map((dep) => {
      dep = assetsURL(dep);
      if (dep in seen)
        return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      const isBaseRelative = !!importerUrl;
      if (isBaseRelative) {
        for (let i3 = links.length - 1; i3 >= 0; i3--) {
          const link2 = links[i3];
          if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
            return;
          }
        }
      } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
        return;
      }
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) {
        link.as = "script";
        link.crossOrigin = "";
      }
      link.href = dep;
      document.head.appendChild(link);
      if (isCss) {
        return new Promise((res, rej) => {
          link.addEventListener("load", res);
          link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
        });
      }
    }));
  }
  return promise.then(() => baseModule()).catch((err) => {
    const e2 = new Event("vite:preloadError", { cancelable: true });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  });
};
const multicall3Abi = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const universalResolverErrors = [
  {
    inputs: [],
    name: "ResolverNotFound",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverWildcardNotSupported",
    type: "error"
  }
];
const universalResolverResolveAbi = [
  ...universalResolverErrors,
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  }
];
const universalResolverReverseAbi = [
  ...universalResolverErrors,
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "bytes", name: "reverseName" }],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  }
];
const textResolverAbi = [
  {
    name: "text",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "key", type: "string" }
    ],
    outputs: [{ name: "", type: "string" }]
  }
];
const addressResolverAbi = [
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{ name: "name", type: "bytes32" }],
    outputs: [{ name: "", type: "address" }]
  },
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "coinType", type: "uint256" }
    ],
    outputs: [{ name: "", type: "bytes" }]
  }
];
const universalSignatureValidatorAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_signer",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "_hash",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  }
];
const aggregate3Signature = "0x82ad56cb";
function getChainContractAddress({ blockNumber, chain, contract: name2 }) {
  const contract = chain?.contracts?.[name2];
  if (!contract)
    throw new ChainDoesNotSupportContract({
      chain,
      contract: { name: name2 }
    });
  if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
    throw new ChainDoesNotSupportContract({
      blockNumber,
      chain,
      contract: {
        name: name2,
        blockCreated: contract.blockCreated
      }
    });
  return contract.address;
}
function getCallError(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new CallExecutionError(cause, {
    docsPath: docsPath2,
    ...args
  });
}
const schedulerCache = /* @__PURE__ */ new Map();
function createBatchScheduler({ fn: fn2, id: id2, shouldSplitBatch, wait: wait2 = 0, sort }) {
  const exec = async () => {
    const scheduler2 = getScheduler();
    flush();
    const args = scheduler2.map(({ args: args2 }) => args2);
    if (args.length === 0)
      return;
    fn2(args).then((data2) => {
      if (sort && Array.isArray(data2))
        data2.sort(sort);
      for (let i3 = 0; i3 < scheduler2.length; i3++) {
        const { pendingPromise } = scheduler2[i3];
        pendingPromise.resolve?.([data2[i3], data2]);
      }
    }).catch((err) => {
      for (let i3 = 0; i3 < scheduler2.length; i3++) {
        const { pendingPromise } = scheduler2[i3];
        pendingPromise.reject?.(err);
      }
    });
  };
  const flush = () => schedulerCache.delete(id2);
  const getBatchedArgs = () => getScheduler().map(({ args }) => args);
  const getScheduler = () => schedulerCache.get(id2) || [];
  const setScheduler = (item) => schedulerCache.set(id2, [...getScheduler(), item]);
  return {
    flush,
    async schedule(args) {
      const pendingPromise = {};
      const promise = new Promise((resolve, reject) => {
        pendingPromise.resolve = resolve;
        pendingPromise.reject = reject;
      });
      const split2 = shouldSplitBatch?.([...getBatchedArgs(), args]);
      if (split2)
        exec();
      const hasActiveScheduler = getScheduler().length > 0;
      if (hasActiveScheduler) {
        setScheduler({ args, pendingPromise });
        return promise;
      }
      setScheduler({ args, pendingPromise });
      setTimeout(exec, wait2);
      return promise;
    }
  };
}
async function call(client2, args) {
  const { account: account_ = client2.account, batch = Boolean(client2.batch?.multicall), blockNumber, blockTag = "latest", accessList, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
  const account = account_ ? parseAccount(account_) : void 0;
  try {
    assertRequest(args);
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block2 = blockNumberHex || blockTag;
    const chainFormat = client2.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request2 = format({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      accessList,
      data: data2,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    if (batch && shouldPerformMulticall({ request: request2 })) {
      try {
        return await scheduleMulticall(client2, {
          ...request2,
          blockNumber,
          blockTag
        });
      } catch (err) {
        if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract))
          throw err;
      }
    }
    const response = await client2.request({
      method: "eth_call",
      params: block2 ? [request2, block2] : [request2]
    });
    if (response === "0x")
      return { data: void 0 };
    return { data: response };
  } catch (err) {
    const data3 = getRevertErrorData(err);
    const { offchainLookup, offchainLookupSignature } = await __vitePreload(() => import("./ccip-TZwQ8YkJ.js"), true ? __vite__mapDeps([]) : void 0);
    if (data3?.slice(0, 10) === offchainLookupSignature && to) {
      return { data: await offchainLookup(client2, { data: data3, to }) };
    }
    throw getCallError(err, {
      ...args,
      account,
      chain: client2.chain
    });
  }
}
function shouldPerformMulticall({ request: request2 }) {
  const { data: data2, to, ...request_ } = request2;
  if (!data2)
    return false;
  if (data2.startsWith(aggregate3Signature))
    return false;
  if (!to)
    return false;
  if (Object.values(request_).filter((x2) => typeof x2 !== "undefined").length > 0)
    return false;
  return true;
}
async function scheduleMulticall(client2, args) {
  const { batchSize = 1024, wait: wait2 = 0 } = typeof client2.batch?.multicall === "object" ? client2.batch.multicall : {};
  const { blockNumber, blockTag = "latest", data: data2, multicallAddress: multicallAddress_, to } = args;
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client2.chain)
      throw new ClientChainNotConfiguredError();
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "multicall3"
    });
  }
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const block2 = blockNumberHex || blockTag;
  const { schedule } = createBatchScheduler({
    id: `${client2.uid}.${block2}`,
    wait: wait2,
    shouldSplitBatch(args2) {
      const size2 = args2.reduce((size3, { data: data3 }) => size3 + (data3.length - 2), 0);
      return size2 > batchSize * 2;
    },
    fn: async (requests) => {
      const calls = requests.map((request2) => ({
        allowFailure: true,
        callData: request2.data,
        target: request2.to
      }));
      const calldata = encodeFunctionData({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3"
      });
      const data3 = await client2.request({
        method: "eth_call",
        params: [
          {
            data: calldata,
            to: multicallAddress
          },
          block2
        ]
      });
      return decodeFunctionResult({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3",
        data: data3 || "0x"
      });
    }
  });
  const [{ returnData, success }] = await schedule({ data: data2, to });
  if (!success)
    throw new RawContractError({ data: returnData });
  if (returnData === "0x")
    return { data: void 0 };
  return { data: returnData };
}
function getRevertErrorData(err) {
  if (!(err instanceof BaseError))
    return void 0;
  const error = err.walk();
  return typeof error.data === "object" ? error.data.data : error.data;
}
async function readContract$1(client2, { abi: abi2, address, args, functionName, ...callRequest }) {
  const calldata = encodeFunctionData({
    abi: abi2,
    args,
    functionName
  });
  try {
    const { data: data2 } = await getAction(client2, call, "call")({
      data: calldata,
      to: address,
      ...callRequest
    });
    return decodeFunctionResult({
      abi: abi2,
      args,
      functionName,
      data: data2 || "0x"
    });
  } catch (err) {
    throw getContractError(err, {
      abi: abi2,
      address,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}
async function simulateContract(client2, { abi: abi2, address, args, dataSuffix, functionName, ...callRequest }) {
  const account = callRequest.account ? parseAccount(callRequest.account) : void 0;
  const calldata = encodeFunctionData({
    abi: abi2,
    args,
    functionName
  });
  try {
    const { data: data2 } = await getAction(client2, call, "call")({
      batch: false,
      data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...callRequest
    });
    const result = decodeFunctionResult({
      abi: abi2,
      args,
      functionName,
      data: data2 || "0x"
    });
    return {
      result,
      request: {
        abi: abi2,
        address,
        args,
        dataSuffix,
        functionName,
        ...callRequest
      }
    };
  } catch (err) {
    throw getContractError(err, {
      abi: abi2,
      address,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: account?.address
    });
  }
}
const listenersCache = /* @__PURE__ */ new Map();
const cleanupCache = /* @__PURE__ */ new Map();
let callbackCount = 0;
function observe(observerId, callbacks, fn2) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners3 = getListeners();
    listenersCache.set(observerId, listeners3.filter((cb2) => cb2.id !== callbackId));
  };
  const unwatch = () => {
    const cleanup2 = cleanupCache.get(observerId);
    if (getListeners().length === 1 && cleanup2)
      cleanup2();
    unsubscribe();
  };
  const listeners2 = getListeners();
  listenersCache.set(observerId, [
    ...listeners2,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners2 && listeners2.length > 0)
    return unwatch;
  const emit2 = {};
  for (const key2 in callbacks) {
    emit2[key2] = (...args) => {
      const listeners3 = getListeners();
      if (listeners3.length === 0)
        return;
      for (const listener of listeners3)
        listener.fns[key2]?.(...args);
    };
  }
  const cleanup = fn2(emit2);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}
async function wait(time2) {
  return new Promise((res) => setTimeout(res, time2));
}
function poll(fn2, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch2 = async () => {
    let data2 = void 0;
    if (emitOnBegin)
      data2 = await fn2({ unpoll: unwatch });
    const initialWait = await initialWaitTime?.(data2) ?? interval;
    await wait(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await fn2({ unpoll: unwatch });
      await wait(interval);
      poll2();
    };
    poll2();
  };
  watch2();
  return unwatch;
}
const promiseCache = /* @__PURE__ */ new Map();
const responseCache = /* @__PURE__ */ new Map();
function getCache(cacheKey2) {
  const buildCache = (cacheKey3, cache) => ({
    clear: () => cache.delete(cacheKey3),
    get: () => cache.get(cacheKey3),
    set: (data2) => cache.set(cacheKey3, data2)
  });
  const promise = buildCache(cacheKey2, promiseCache);
  const response = buildCache(cacheKey2, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(fn2, { cacheKey: cacheKey2, cacheTime = Infinity }) {
  const cache = getCache(cacheKey2);
  const response = cache.response.get();
  if (response && cacheTime > 0) {
    const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
    if (age < cacheTime)
      return response.data;
  }
  let promise = cache.promise.get();
  if (!promise) {
    promise = fn2();
    cache.promise.set(promise);
  }
  try {
    const data2 = await promise;
    cache.response.set({ created: /* @__PURE__ */ new Date(), data: data2 });
    return data2;
  } finally {
    cache.promise.clear();
  }
}
const cacheKey = (id2) => `blockNumber.${id2}`;
async function getBlockNumber(client2, { cacheTime = client2.cacheTime, maxAge } = {}) {
  const blockNumberHex = await withCache(() => client2.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(client2.uid), cacheTime: maxAge ?? cacheTime });
  return BigInt(blockNumberHex);
}
async function getFilterChanges(_client2, { filter }) {
  const strict = "strict" in filter && filter.strict;
  const logs = await filter.request({
    method: "eth_getFilterChanges",
    params: [filter.id]
  });
  return logs.map((log3) => {
    if (typeof log3 === "string")
      return log3;
    try {
      const { eventName, args } = "abi" in filter && filter.abi ? decodeEventLog({
        abi: filter.abi,
        data: log3.data,
        topics: log3.topics,
        strict
      }) : { eventName: void 0, args: void 0 };
      return formatLog(log3, { args, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if ("strict" in filter && filter.strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
      }
      return formatLog(log3, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}
async function uninstallFilter(_client2, { filter }) {
  return filter.request({
    method: "eth_uninstallFilter",
    params: [filter.id]
  });
}
function watchContractEvent(client2, { abi: abi2, address, args, batch = true, eventName, onError, onLogs, poll: poll_, pollingInterval = client2.pollingInterval, strict: strict_ }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
  const pollContractEvent = () => {
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client2.uid,
      eventName,
      pollingInterval
    ]);
    const strict = strict_ ?? false;
    return observe(observerId, { onLogs, onError }, (emit2) => {
      let previousBlockNumber;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter = await getAction(client2, createContractEventFilter, "createContractEventFilter")({
              abi: abi2,
              address,
              args,
              eventName,
              strict
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getAction(client2, getFilterChanges, "getFilterChanges")({ filter });
          } else {
            const blockNumber = await getAction(client2, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getAction(client2, getContractEvents, "getContractEvents")({
                abi: abi2,
                address,
                args,
                eventName,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                strict
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit2.onLogs(logs);
          else
            for (const log3 of logs)
              emit2.onLogs([log3]);
        } catch (err) {
          if (filter && err instanceof InvalidInputRpcError)
            initialized = false;
          emit2.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client2, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribeContractEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const topics = eventName ? encodeEventTopics({
          abi: abi2,
          eventName,
          args
        }) : [];
        const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
          params: ["logs", { address, topics }],
          onData(data2) {
            if (!active)
              return;
            const log3 = data2.result;
            try {
              const { eventName: eventName2, args: args2 } = decodeEventLog({
                abi: abi2,
                data: log3.data,
                topics: log3.topics,
                strict: strict_
              });
              const formatted = formatLog(log3, {
                args: args2,
                eventName: eventName2
              });
              onLogs([formatted]);
            } catch (err) {
              let eventName2;
              let isUnnamed;
              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName2 = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
              }
              const formatted = formatLog(log3, {
                args: isUnnamed ? [] : {},
                eventName: eventName2
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollContractEvent() : subscribeContractEvent();
}
function assertCurrentChain({ chain, currentChainId }) {
  if (!chain)
    throw new ChainNotFoundError();
  if (currentChainId !== chain.id)
    throw new ChainMismatchError({ chain, currentChainId });
}
function getTransactionError(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new TransactionExecutionError(cause, {
    docsPath: docsPath2,
    ...args
  });
}
async function getChainId(client2) {
  const chainIdHex = await client2.request({
    method: "eth_chainId"
  });
  return hexToNumber(chainIdHex);
}
async function sendRawTransaction(client2, { serializedTransaction }) {
  return client2.request({
    method: "eth_sendRawTransaction",
    params: [serializedTransaction]
  });
}
async function sendTransaction(client2, args) {
  const { account: account_ = client2.account, chain = client2.chain, accessList, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const account = parseAccount(account_);
  try {
    assertRequest(args);
    let chainId2;
    if (chain !== null) {
      chainId2 = await getAction(client2, getChainId, "getChainId")({});
      assertCurrentChain({
        currentChainId: chainId2,
        chain
      });
    }
    if (account.type === "local") {
      const request3 = await getAction(client2, prepareTransactionRequest, "prepareTransactionRequest")({
        account,
        accessList,
        chain,
        data: data2,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value,
        ...rest
      });
      if (!chainId2)
        chainId2 = await getAction(client2, getChainId, "getChainId")({});
      const serializer = chain?.serializers?.transaction;
      const serializedTransaction = await account.signTransaction({
        ...request3,
        chainId: chainId2
      }, { serializer });
      return await getAction(client2, sendRawTransaction, "sendRawTransaction")({
        serializedTransaction
      });
    }
    const chainFormat = client2.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request2 = format({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      accessList,
      data: data2,
      from: account.address,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    return await client2.request({
      method: "eth_sendTransaction",
      params: [request2]
    });
  } catch (err) {
    throw getTransactionError(err, {
      ...args,
      account,
      chain: args.chain || void 0
    });
  }
}
async function writeContract(client2, { abi: abi2, address, args, dataSuffix, functionName, ...request2 }) {
  const data2 = encodeFunctionData({
    abi: abi2,
    args,
    functionName
  });
  const hash2 = await getAction(client2, sendTransaction, "sendTransaction")({
    data: `${data2}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
    to: address,
    ...request2
  });
  return hash2;
}
async function addChain(client2, { chain }) {
  const { id: id2, name: name2, nativeCurrency, rpcUrls, blockExplorers } = chain;
  await client2.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: numberToHex(id2),
        chainName: name2,
        nativeCurrency,
        rpcUrls: rpcUrls.default.http,
        blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
      }
    ]
  });
}
const size = 256;
let index$2 = size;
let buffer$1;
function uid(length2 = 11) {
  if (!buffer$1 || index$2 + length2 > size * 2) {
    buffer$1 = "";
    index$2 = 0;
    for (let i3 = 0; i3 < size; i3++) {
      buffer$1 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer$1.substring(index$2, index$2++ + length2);
}
function createClient(parameters) {
  const { batch, cacheTime = parameters.pollingInterval ?? 4e3, key: key2 = "base", name: name2 = "Base Client", pollingInterval = 4e3, type = "base" } = parameters;
  const chain = parameters.chain;
  const account = parameters.account ? parseAccount(parameters.account) : void 0;
  const { config: config2, request: request2, value } = parameters.transport({
    chain,
    pollingInterval
  });
  const transport = { ...config2, ...value };
  const client2 = {
    account,
    batch,
    cacheTime,
    chain,
    key: key2,
    name: name2,
    pollingInterval,
    request: request2,
    transport,
    type,
    uid: uid()
  };
  function extend2(base3) {
    return (extendFn) => {
      const extended = extendFn(base3);
      for (const key3 in client2)
        delete extended[key3];
      const combined = { ...base3, ...extended };
      return Object.assign(combined, { extend: extend2(combined) });
    };
  }
  return Object.assign(client2, { extend: extend2(client2) });
}
function withRetry(fn2, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry2 = async ({ error }) => {
        const delay2 = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
        if (delay2)
          await wait(delay2);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data2 = await fn2();
        resolve(data2);
      } catch (err) {
        if (count < retryCount && await shouldRetry({ count, error: err }))
          return retry2({ error: err });
        reject(err);
      }
    };
    attemptRetry();
  });
}
const isDeterministicError = (error) => {
  if ("code" in error)
    return error.code !== -1 && error.code !== -32004 && error.code !== -32005 && error.code !== -32042 && error.code !== -32603;
  if (error instanceof HttpRequestError && error.status)
    return error.status !== 403 && error.status !== 408 && error.status !== 413 && error.status !== 429 && error.status !== 500 && error.status !== 502 && error.status !== 503 && error.status !== 504;
  return false;
};
function buildRequest(request2, { retryDelay = 150, retryCount = 3 } = {}) {
  return async (args) => withRetry(async () => {
    try {
      return await request2(args);
    } catch (err_) {
      const err = err_;
      switch (err.code) {
        case ParseRpcError.code:
          throw new ParseRpcError(err);
        case InvalidRequestRpcError.code:
          throw new InvalidRequestRpcError(err);
        case MethodNotFoundRpcError.code:
          throw new MethodNotFoundRpcError(err);
        case InvalidParamsRpcError.code:
          throw new InvalidParamsRpcError(err);
        case InternalRpcError.code:
          throw new InternalRpcError(err);
        case InvalidInputRpcError.code:
          throw new InvalidInputRpcError(err);
        case ResourceNotFoundRpcError.code:
          throw new ResourceNotFoundRpcError(err);
        case ResourceUnavailableRpcError.code:
          throw new ResourceUnavailableRpcError(err);
        case TransactionRejectedRpcError.code:
          throw new TransactionRejectedRpcError(err);
        case MethodNotSupportedRpcError.code:
          throw new MethodNotSupportedRpcError(err);
        case LimitExceededRpcError.code:
          throw new LimitExceededRpcError(err);
        case JsonRpcVersionUnsupportedError.code:
          throw new JsonRpcVersionUnsupportedError(err);
        case UserRejectedRequestError.code:
          throw new UserRejectedRequestError(err);
        case UnauthorizedProviderError.code:
          throw new UnauthorizedProviderError(err);
        case UnsupportedProviderMethodError.code:
          throw new UnsupportedProviderMethodError(err);
        case ProviderDisconnectedError.code:
          throw new ProviderDisconnectedError(err);
        case ChainDisconnectedError.code:
          throw new ChainDisconnectedError(err);
        case SwitchChainError.code:
          throw new SwitchChainError(err);
        case 5e3:
          throw new UserRejectedRequestError(err);
        default:
          if (err_ instanceof BaseError)
            throw err_;
          throw new UnknownRpcError(err);
      }
    }
  }, {
    delay: ({ count, error }) => {
      if (error && error instanceof HttpRequestError) {
        const retryAfter = error?.headers?.get("Retry-After");
        if (retryAfter?.match(/\d/))
          return parseInt(retryAfter) * 1e3;
      }
      return ~~(1 << count) * retryDelay;
    },
    retryCount,
    shouldRetry: ({ error }) => !isDeterministicError(error)
  });
}
function createTransport({ key: key2, name: name2, request: request2, retryCount = 3, retryDelay = 150, timeout, type }, value) {
  return {
    config: { key: key2, name: name2, request: request2, retryCount, retryDelay, timeout, type },
    request: buildRequest(request2, { retryCount, retryDelay }),
    value
  };
}
function custom$1(provider, config2 = {}) {
  const { key: key2 = "custom", name: name2 = "Custom Provider", retryDelay } = config2;
  return ({ retryCount: defaultRetryCount }) => createTransport({
    key: key2,
    name: name2,
    request: provider.request.bind(provider),
    retryCount: config2.retryCount ?? defaultRetryCount,
    retryDelay,
    type: "custom"
  });
}
function fallback(transports_, config2 = {}) {
  const { key: key2 = "fallback", name: name2 = "Fallback", rank = false, retryCount, retryDelay } = config2;
  return ({ chain, pollingInterval = 4e3, timeout }) => {
    let transports = transports_;
    let onResponse = () => {
    };
    const transport = createTransport({
      key: key2,
      name: name2,
      async request({ method, params }) {
        const fetch2 = async (i3 = 0) => {
          const transport2 = transports[i3]({ chain, retryCount: 0, timeout });
          try {
            const response = await transport2.request({
              method,
              params
            });
            onResponse({
              method,
              params,
              response,
              transport: transport2,
              status: "success"
            });
            return response;
          } catch (err) {
            onResponse({
              error: err,
              method,
              params,
              transport: transport2,
              status: "error"
            });
            if (isDeterministicError(err))
              throw err;
            if (i3 === transports.length - 1)
              throw err;
            return fetch2(i3 + 1);
          }
        };
        return fetch2();
      },
      retryCount,
      retryDelay,
      type: "fallback"
    }, {
      onResponse: (fn2) => onResponse = fn2,
      transports: transports.map((fn2) => fn2({ chain, retryCount: 0 }))
    });
    if (rank) {
      const rankOptions = typeof rank === "object" ? rank : {};
      rankTransports({
        chain,
        interval: rankOptions.interval ?? pollingInterval,
        onTransports: (transports_2) => transports = transports_2,
        sampleCount: rankOptions.sampleCount,
        timeout: rankOptions.timeout,
        transports,
        weights: rankOptions.weights
      });
    }
    return transport;
  };
}
function rankTransports({ chain, interval = 4e3, onTransports, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
  const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
  const samples = [];
  const rankTransports_ = async () => {
    const sample = await Promise.all(transports.map(async (transport) => {
      const transport_ = transport({ chain, retryCount: 0, timeout });
      const start = Date.now();
      let end;
      let success;
      try {
        await transport_.request({ method: "net_listening" });
        success = 1;
      } catch {
        success = 0;
      } finally {
        end = Date.now();
      }
      const latency = end - start;
      return { latency, success };
    }));
    samples.push(sample);
    if (samples.length > sampleCount)
      samples.shift();
    const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
    const scores = transports.map((_2, i3) => {
      const latencies = samples.map((sample2) => sample2[i3].latency);
      const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
      const latencyScore = 1 - meanLatency / maxLatency;
      const successes = samples.map((sample2) => sample2[i3].success);
      const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
      if (stabilityScore === 0)
        return [0, i3];
      return [
        latencyWeight * latencyScore + stabilityWeight * stabilityScore,
        i3
      ];
    }).sort((a2, b3) => b3[0] - a2[0]);
    onTransports(scores.map(([, i3]) => transports[i3]));
    await wait(interval);
    rankTransports_();
  };
  rankTransports_();
}
class UrlRequiredError extends BaseError {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro"
    });
  }
}
function getNativeWebSocket() {
  if (typeof WebSocket !== "undefined")
    return WebSocket;
  if (typeof global.WebSocket !== "undefined")
    return global.WebSocket;
  if (typeof window.WebSocket !== "undefined")
    return window.WebSocket;
  if (typeof self.WebSocket !== "undefined")
    return self.WebSocket;
  throw new Error("`WebSocket` is not supported in this environment");
}
const WebSocket$1 = getNativeWebSocket();
function withTimeout(fn2, { errorInstance = new Error("timed out"), timeout, signal }) {
  return new Promise((resolve, reject) => {
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        }
        resolve(await fn2({ signal: controller?.signal }));
      } catch (err) {
        if (err.name === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
let id = 0;
async function http$1(url, { body: body2, fetchOptions = {}, timeout = 1e4 }) {
  const { headers, method, signal: signal_ } = fetchOptions;
  try {
    const response = await withTimeout(async ({ signal }) => {
      const response2 = await fetch(url, {
        ...fetchOptions,
        body: Array.isArray(body2) ? stringify(body2.map((body3) => ({
          jsonrpc: "2.0",
          id: body3.id ?? id++,
          ...body3
        }))) : stringify({ jsonrpc: "2.0", id: body2.id ?? id++, ...body2 }),
        headers: {
          ...headers,
          "Content-Type": "application/json"
        },
        method: method || "POST",
        signal: signal_ || (timeout > 0 ? signal : void 0)
      });
      return response2;
    }, {
      errorInstance: new TimeoutError({ body: body2, url }),
      timeout,
      signal: true
    });
    let data2;
    if (response.headers.get("Content-Type")?.startsWith("application/json")) {
      data2 = await response.json();
    } else {
      data2 = await response.text();
    }
    if (!response.ok) {
      throw new HttpRequestError({
        body: body2,
        details: stringify(data2.error) || response.statusText,
        headers: response.headers,
        status: response.status,
        url
      });
    }
    return data2;
  } catch (err) {
    if (err instanceof HttpRequestError)
      throw err;
    if (err instanceof TimeoutError)
      throw err;
    throw new HttpRequestError({
      body: body2,
      details: err.message,
      url
    });
  }
}
const socketsCache = /* @__PURE__ */ new Map();
async function getSocket(url) {
  let socket = socketsCache.get(url);
  if (socket)
    return socket;
  const { schedule } = createBatchScheduler({
    id: url,
    fn: async () => {
      const webSocket2 = new WebSocket$1(url);
      const requests = /* @__PURE__ */ new Map();
      const subscriptions = /* @__PURE__ */ new Map();
      const onMessage = ({ data: data2 }) => {
        const message = JSON.parse(data2);
        const isSubscription = message.method === "eth_subscription";
        const id2 = isSubscription ? message.params.subscription : message.id;
        const cache = isSubscription ? subscriptions : requests;
        const callback = cache.get(id2);
        if (callback)
          callback({ data: data2 });
        if (!isSubscription)
          cache.delete(id2);
      };
      const onClose = () => {
        socketsCache.delete(url);
        webSocket2.removeEventListener("close", onClose);
        webSocket2.removeEventListener("message", onMessage);
      };
      webSocket2.addEventListener("close", onClose);
      webSocket2.addEventListener("message", onMessage);
      if (webSocket2.readyState === WebSocket$1.CONNECTING) {
        await new Promise((resolve, reject) => {
          if (!webSocket2)
            return;
          webSocket2.onopen = resolve;
          webSocket2.onerror = reject;
        });
      }
      socket = Object.assign(webSocket2, {
        requests,
        subscriptions
      });
      socketsCache.set(url, socket);
      return [socket];
    }
  });
  const [_2, [socket_]] = await schedule();
  return socket_;
}
function webSocket$1(socket, { body: body2, onResponse }) {
  if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING)
    throw new WebSocketRequestError({
      body: body2,
      url: socket.url,
      details: "Socket is closed."
    });
  const id_ = id++;
  const callback = ({ data: data2 }) => {
    const message = JSON.parse(data2);
    if (typeof message.id === "number" && id_ !== message.id)
      return;
    onResponse?.(message);
    if (body2.method === "eth_subscribe" && typeof message.result === "string") {
      socket.subscriptions.set(message.result, callback);
    }
    if (body2.method === "eth_unsubscribe") {
      socket.subscriptions.delete(body2.params?.[0]);
    }
  };
  socket.requests.set(id_, callback);
  socket.send(JSON.stringify({ jsonrpc: "2.0", ...body2, id: id_ }));
  return socket;
}
async function webSocketAsync(socket, { body: body2, timeout = 1e4 }) {
  return withTimeout(() => new Promise((onResponse) => rpc.webSocket(socket, {
    body: body2,
    onResponse
  })), {
    errorInstance: new TimeoutError({ body: body2, url: socket.url }),
    timeout
  });
}
const rpc = {
  http: http$1,
  webSocket: webSocket$1,
  webSocketAsync
};
function http(url, config2 = {}) {
  const { batch, fetchOptions, key: key2 = "http", name: name2 = "HTTP JSON-RPC", retryDelay } = config2;
  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
    const retryCount = config2.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config2.timeout ?? 1e4;
    const url_ = url || chain?.rpcUrls.default.http[0];
    if (!url_)
      throw new UrlRequiredError();
    return createTransport({
      key: key2,
      name: name2,
      async request({ method, params }) {
        const body2 = { method, params };
        const { schedule } = createBatchScheduler({
          id: `${url}`,
          wait: wait2,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body3) => rpc.http(url_, {
            body: body3,
            fetchOptions,
            timeout
          }),
          sort: (a2, b3) => a2.id - b3.id
        });
        const fn2 = async (body3) => batch ? schedule(body3) : [await rpc.http(url_, { body: body3, fetchOptions, timeout })];
        const [{ error, result }] = await fn2(body2);
        if (error)
          throw new RpcRequestError({
            body: body2,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      fetchOptions,
      url
    });
  };
}
function isNullUniversalResolverError(err, callType) {
  if (!(err instanceof BaseError))
    return false;
  const cause = err.walk((e2) => e2 instanceof ContractFunctionRevertedError);
  if (!(cause instanceof ContractFunctionRevertedError))
    return false;
  if (cause.data?.errorName === "ResolverNotFound")
    return true;
  if (cause.data?.errorName === "ResolverWildcardNotSupported")
    return true;
  if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
    return true;
  if (callType === "reverse" && cause.reason === panicReasons[50])
    return true;
  return false;
}
function encodedLabelToLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash2 = `0x${label.slice(1, 65)}`;
  if (!isHex(hash2))
    return null;
  return hash2;
}
function namehash(name2) {
  let result = new Uint8Array(32).fill(0);
  if (!name2)
    return bytesToHex(result);
  const labels = name2.split(".");
  for (let i3 = labels.length - 1; i3 >= 0; i3 -= 1) {
    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i3]);
    const hashed = hashFromEncodedLabel ? toBytes$1(hashFromEncodedLabel) : keccak256(stringToBytes(labels[i3]), "bytes");
    result = keccak256(concat$1([result, hashed]), "bytes");
  }
  return bytesToHex(result);
}
function encodeLabelhash(hash2) {
  return `[${hash2.slice(2)}]`;
}
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return bytesToHex(result);
  return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label));
}
function packetToBytes(packet) {
  const value = packet.replace(/^\.|\.$/gm, "");
  if (value.length === 0)
    return new Uint8Array(1);
  const bytes2 = new Uint8Array(stringToBytes(value).byteLength + 2);
  let offset = 0;
  const list = value.split(".");
  for (let i3 = 0; i3 < list.length; i3++) {
    let encoded = stringToBytes(list[i3]);
    if (encoded.byteLength > 255)
      encoded = stringToBytes(encodeLabelhash(labelhash(list[i3])));
    bytes2[offset] = encoded.length;
    bytes2.set(encoded, offset + 1);
    offset += encoded.length + 1;
  }
  if (bytes2.byteLength !== offset + 1)
    return bytes2.slice(0, offset + 1);
  return bytes2;
}
async function getEnsAddress(client2, { blockNumber, blockTag, coinType, name: name2, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const functionData = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      ...coinType != null ? { args: [namehash(name2), BigInt(coinType)] } : { args: [namehash(name2)] }
    });
    const res = await getAction(client2, readContract$1, "readContract")({
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [toHex(packetToBytes(name2)), functionData],
      blockNumber,
      blockTag
    });
    if (res[0] === "0x")
      return null;
    const address = decodeFunctionResult({
      abi: addressResolverAbi,
      args: coinType != null ? [namehash(name2), BigInt(coinType)] : void 0,
      functionName: "addr",
      data: res[0]
    });
    if (address === "0x")
      return null;
    if (trim(address) === "0x00")
      return null;
    return address;
  } catch (err) {
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}
class EnsAvatarInvalidMetadataError extends BaseError {
  constructor({ data: data2 }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(data2)}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarInvalidMetadataError"
    });
  }
}
class EnsAvatarInvalidNftUriError extends BaseError {
  constructor({ reason }) {
    super(`ENS NFT avatar URI is invalid. ${reason}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarInvalidNftUriError"
    });
  }
}
class EnsAvatarUriResolutionError extends BaseError {
  constructor({ uri }) {
    super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarUriResolutionError"
    });
  }
}
class EnsAvatarUnsupportedNamespaceError extends BaseError {
  constructor({ namespace }) {
    super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarUnsupportedNamespaceError"
    });
  }
}
const networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
const ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
const base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
const dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(uri) {
  try {
    const res = await fetch(uri, { method: "HEAD" });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return contentType?.startsWith("image/");
    }
    return false;
  } catch (error) {
    if (typeof error === "object" && typeof error.response !== "undefined") {
      return false;
    }
    if (!globalThis.hasOwnProperty("Image"))
      return false;
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        resolve(true);
      };
      img.onerror = () => {
        resolve(false);
      };
      img.src = uri;
    });
  }
}
function getGateway(custom2, defaultGateway) {
  if (!custom2)
    return defaultGateway;
  if (custom2.endsWith("/"))
    return custom2.slice(0, -1);
  return custom2;
}
function resolveAvatarUri({ uri, gatewayUrls }) {
  const isEncoded = base64Regex.test(uri);
  if (isEncoded)
    return { uri, isOnChain: true, isEncoded };
  const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
  const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
  const networkRegexMatch = uri.match(networkRegex);
  const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
  const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
  const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
  if (uri.startsWith("http") && !isIPNS && !isIPFS) {
    let replacedUri = uri;
    if (gatewayUrls?.arweave)
      replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
    return { uri: replacedUri, isOnChain: false, isEncoded: false };
  }
  if ((isIPNS || isIPFS) && target) {
    return {
      uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  if (protocol === "ar:/" && target) {
    return {
      uri: `${arweaveGateway}/${target}${subtarget || ""}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  let parsedUri = uri.replace(dataURIRegex, "");
  if (parsedUri.startsWith("<svg")) {
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
  }
  if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
    return {
      uri: parsedUri,
      isOnChain: true,
      isEncoded: false
    };
  }
  throw new EnsAvatarUriResolutionError({ uri });
}
function getJsonImage(data2) {
  if (typeof data2 !== "object" || !("image" in data2) && !("image_url" in data2) && !("image_data" in data2)) {
    throw new EnsAvatarInvalidMetadataError({ data: data2 });
  }
  return data2.image || data2.image_url || data2.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls, uri }) {
  try {
    const res = await fetch(uri).then((res2) => res2.json());
    const image = await parseAvatarUri({
      gatewayUrls,
      uri: getJsonImage(res)
    });
    return image;
  } catch {
    throw new EnsAvatarUriResolutionError({ uri });
  }
}
async function parseAvatarUri({ gatewayUrls, uri }) {
  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
  if (isOnChain)
    return resolvedURI;
  const isImage = await isImageUri(resolvedURI);
  if (isImage)
    return resolvedURI;
  throw new EnsAvatarUriResolutionError({ uri });
}
function parseNftUri(uri_) {
  let uri = uri_;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
  }
  const [reference, asset_namespace, tokenID] = uri.split("/");
  const [eip_namespace, chainID] = reference.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!chainID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!contractAddress)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!tokenID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!erc_namespace)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: parseInt(chainID),
    namespace: erc_namespace.toLowerCase(),
    contractAddress,
    tokenID
  };
}
async function getNftTokenUri(client2, { nft }) {
  if (nft.namespace === "erc721") {
    return readContract$1(client2, {
      address: nft.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(nft.tokenID)]
    });
  }
  if (nft.namespace === "erc1155") {
    return readContract$1(client2, {
      address: nft.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(nft.tokenID)]
    });
  }
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
}
async function parseAvatarRecord(client2, { gatewayUrls, record }) {
  if (/eip155:/i.test(record))
    return parseNftAvatarUri(client2, { gatewayUrls, record });
  return parseAvatarUri({ uri: record, gatewayUrls });
}
async function parseNftAvatarUri(client2, { gatewayUrls, record }) {
  const nft = parseNftUri(record);
  const nftUri = await getNftTokenUri(client2, { nft });
  const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
  if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
    const encodedJson = isEncoded ? (
      // if it is encoded, decode it
      atob(resolvedNftUri.replace("data:application/json;base64,", ""))
    ) : (
      // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
      resolvedNftUri
    );
    const decoded = JSON.parse(encodedJson);
    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
  }
  let uriTokenId = nft.tokenID;
  if (nft.namespace === "erc1155")
    uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
  return getMetadataAvatarUri({
    gatewayUrls,
    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
  });
}
async function getEnsText(client2, { blockNumber, blockTag, name: name2, key: key2, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const res = await getAction(client2, readContract$1, "readContract")({
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(name2)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash(name2), key2]
        })
      ],
      blockNumber,
      blockTag
    });
    if (res[0] === "0x")
      return null;
    const record = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: res[0]
    });
    return record === "" ? null : record;
  } catch (err) {
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}
async function getEnsAvatar(client2, { blockNumber, blockTag, gatewayUrls, name: name2, universalResolverAddress }) {
  const record = await getAction(client2, getEnsText, "getEnsText")({
    blockNumber,
    blockTag,
    key: "avatar",
    name: name2,
    universalResolverAddress
  });
  if (!record)
    return null;
  try {
    return await parseAvatarRecord(client2, { record, gatewayUrls });
  } catch {
    return null;
  }
}
async function getEnsName(client2, { address, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const [name2, resolvedAddress] = await getAction(client2, readContract$1, "readContract")({
      address: universalResolverAddress,
      abi: universalResolverReverseAbi,
      functionName: "reverse",
      args: [toHex(packetToBytes(reverseNode))],
      blockNumber,
      blockTag
    });
    if (address.toLowerCase() !== resolvedAddress.toLowerCase())
      return null;
    return name2;
  } catch (err) {
    if (isNullUniversalResolverError(err, "reverse"))
      return null;
    throw err;
  }
}
async function getEnsResolver(client2, { blockNumber, blockTag, name: name2, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [resolverAddress] = await getAction(client2, readContract$1, "readContract")({
    address: universalResolverAddress,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex(packetToBytes(name2))],
    blockNumber,
    blockTag
  });
  return resolverAddress;
}
async function createBlockFilter(client2) {
  const getRequest = createFilterRequestScope(client2, {
    method: "eth_newBlockFilter"
  });
  const id2 = await client2.request({
    method: "eth_newBlockFilter"
  });
  return { id: id2, request: getRequest(id2), type: "block" };
}
async function createEventFilter(client2, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
  const events2 = events_ ?? (event ? [event] : void 0);
  const getRequest = createFilterRequestScope(client2, {
    method: "eth_newFilter"
  });
  let topics = [];
  if (events2) {
    topics = [
      events2.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  const id2 = await client2.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        ...topics.length ? { topics } : {}
      }
    ]
  });
  return {
    abi: events2,
    args,
    eventName: event ? event.name : void 0,
    fromBlock,
    id: id2,
    request: getRequest(id2),
    strict,
    toBlock,
    type: "event"
  };
}
async function createPendingTransactionFilter(client2) {
  const getRequest = createFilterRequestScope(client2, {
    method: "eth_newPendingTransactionFilter"
  });
  const id2 = await client2.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id: id2, request: getRequest(id2), type: "transaction" };
}
async function getBalance(client2, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const balance = await client2.request({
    method: "eth_getBalance",
    params: [address, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}
async function getBlockTransactionCount(client2, { blockHash, blockNumber, blockTag = "latest" } = {}) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let count;
  if (blockHash) {
    count = await client2.request({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    });
  } else {
    count = await client2.request({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumberHex || blockTag]
    });
  }
  return hexToNumber(count);
}
async function getBytecode(client2, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const hex = await client2.request({
    method: "eth_getCode",
    params: [address, blockNumberHex || blockTag]
  });
  if (hex === "0x")
    return void 0;
  return hex;
}
function formatFeeHistory(feeHistory) {
  return {
    baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
    gasUsedRatio: feeHistory.gasUsedRatio,
    oldestBlock: BigInt(feeHistory.oldestBlock),
    reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
  };
}
async function getFeeHistory(client2, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const feeHistory = await client2.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(blockCount),
      blockNumberHex || blockTag,
      rewardPercentiles
    ]
  });
  return formatFeeHistory(feeHistory);
}
async function getFilterLogs(_client2, { filter }) {
  const strict = filter.strict ?? false;
  const logs = await filter.request({
    method: "eth_getFilterLogs",
    params: [filter.id]
  });
  return logs.map((log3) => {
    try {
      const { eventName, args } = "abi" in filter && filter.abi ? decodeEventLog({
        abi: filter.abi,
        data: log3.data,
        topics: log3.topics,
        strict
      }) : { eventName: void 0, args: void 0 };
      return formatLog(log3, { args, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if ("strict" in filter && filter.strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
      }
      return formatLog(log3, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}
const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
const integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function hashTypedData({ domain: domain_, message, primaryType, types: types_ }) {
  const domain = typeof domain_ === "undefined" ? {} : domain_;
  const types2 = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...types_
  };
  validateTypedData({
    domain,
    message,
    primaryType,
    types: types2
  });
  const parts = ["0x1901"];
  if (domain)
    parts.push(hashDomain({
      domain,
      types: types2
    }));
  if (primaryType !== "EIP712Domain") {
    parts.push(hashStruct({
      data: message,
      primaryType,
      types: types2
    }));
  }
  return keccak256(concat$1(parts));
}
function hashDomain({ domain, types: types2 }) {
  return hashStruct({
    data: domain,
    primaryType: "EIP712Domain",
    types: types2
  });
}
function hashStruct({ data: data2, primaryType, types: types2 }) {
  const encoded = encodeData({
    data: data2,
    primaryType,
    types: types2
  });
  return keccak256(encoded);
}
function encodeData({ data: data2, primaryType, types: types2 }) {
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType({ primaryType, types: types2 })];
  for (const field of types2[primaryType]) {
    const [type, value] = encodeField({
      types: types2,
      name: field.name,
      type: field.type,
      value: data2[field.name]
    });
    encodedTypes.push(type);
    encodedValues.push(value);
  }
  return encodeAbiParameters(encodedTypes, encodedValues);
}
function hashType({ primaryType, types: types2 }) {
  const encodedHashType = toHex(encodeType({ primaryType, types: types2 }));
  return keccak256(encodedHashType);
}
function encodeType({ primaryType, types: types2 }) {
  let result = "";
  const unsortedDeps = findTypeDependencies({ primaryType, types: types2 });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type of deps) {
    result += `${type}(${types2[type].map(({ name: name2, type: t2 }) => `${t2} ${name2}`).join(",")})`;
  }
  return result;
}
function findTypeDependencies({ primaryType: primaryType_, types: types2 }, results = /* @__PURE__ */ new Set()) {
  const match2 = primaryType_.match(/^\w*/u);
  const primaryType = match2?.[0];
  if (results.has(primaryType) || types2[primaryType] === void 0) {
    return results;
  }
  results.add(primaryType);
  for (const field of types2[primaryType]) {
    findTypeDependencies({ primaryType: field.type, types: types2 }, results);
  }
  return results;
}
function encodeField({ types: types2, name: name2, type, value }) {
  if (types2[type] !== void 0) {
    return [
      { type: "bytes32" },
      keccak256(encodeData({ data: value, primaryType: type, types: types2 }))
    ];
  }
  if (type === "bytes") {
    const prepend = value.length % 2 ? "0" : "";
    value = `0x${prepend + value.slice(2)}`;
    return [{ type: "bytes32" }, keccak256(value)];
  }
  if (type === "string")
    return [{ type: "bytes32" }, keccak256(toHex(value))];
  if (type.lastIndexOf("]") === type.length - 1) {
    const parsedType = type.slice(0, type.lastIndexOf("["));
    const typeValuePairs = value.map((item) => encodeField({
      name: name2,
      type: parsedType,
      types: types2,
      value: item
    }));
    return [
      { type: "bytes32" },
      keccak256(encodeAbiParameters(typeValuePairs.map(([t2]) => t2), typeValuePairs.map(([, v2]) => v2)))
    ];
  }
  return [{ type }, value];
}
function validateTypedData({ domain, message, primaryType, types: types_ }) {
  const types2 = types_;
  const validateData = (struct, value_) => {
    for (const param of struct) {
      const { name: name2, type: type_ } = param;
      const type = type_;
      const value = value_[name2];
      const integerMatch = type.match(integerRegex);
      if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
        const [_type, base3, size_] = integerMatch;
        numberToHex(value, {
          signed: base3 === "int",
          size: parseInt(size_) / 8
        });
      }
      if (type === "address" && typeof value === "string" && !isAddress(value))
        throw new InvalidAddressError({ address: value });
      const bytesMatch = type.match(bytesRegex);
      if (bytesMatch) {
        const [_type, size_] = bytesMatch;
        if (size_ && size$1(value) !== parseInt(size_))
          throw new BytesSizeMismatchError({
            expectedSize: parseInt(size_),
            givenSize: size$1(value)
          });
      }
      const struct2 = types2[type];
      if (struct2)
        validateData(struct2, value);
    }
  };
  if (types2.EIP712Domain && domain)
    validateData(types2.EIP712Domain, domain);
  if (primaryType !== "EIP712Domain") {
    const type = types2[primaryType];
    validateData(type, message);
  }
}
function getTypesForEIP712Domain({ domain }) {
  return [
    typeof domain?.name === "string" && { name: "name", type: "string" },
    domain?.version && { name: "version", type: "string" },
    typeof domain?.chainId === "number" && {
      name: "chainId",
      type: "uint256"
    },
    domain?.verifyingContract && {
      name: "verifyingContract",
      type: "address"
    },
    domain?.salt && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
const docsPath = "/docs/contract/encodeDeployData";
function encodeDeployData({ abi: abi2, args, bytecode: bytecode2 }) {
  if (!args || args.length === 0)
    return bytecode2;
  const description2 = abi2.find((x2) => "type" in x2 && x2.type === "constructor");
  if (!description2)
    throw new AbiConstructorNotFoundError({ docsPath });
  if (!("inputs" in description2))
    throw new AbiConstructorParamsNotFoundError({ docsPath });
  if (!description2.inputs || description2.inputs.length === 0)
    throw new AbiConstructorParamsNotFoundError({ docsPath });
  const data2 = encodeAbiParameters(description2.inputs, args);
  return concatHex([bytecode2, data2]);
}
const presignMessagePrefix = "Ethereum Signed Message:\n";
function hashMessage(message, to_) {
  const messageBytes = (() => {
    if (typeof message === "string")
      return stringToBytes(message);
    if (message.raw instanceof Uint8Array)
      return message.raw;
    return toBytes$1(message.raw);
  })();
  const prefixBytes = stringToBytes(`${presignMessagePrefix}${messageBytes.length}`);
  return keccak256(concat$1([prefixBytes, messageBytes]), to_);
}
function formatStorageProof(storageProof) {
  return storageProof.map((proof) => ({
    ...proof,
    value: BigInt(proof.value)
  }));
}
function formatProof(proof) {
  return {
    ...proof,
    balance: proof.balance ? BigInt(proof.balance) : void 0,
    nonce: proof.nonce ? hexToNumber(proof.nonce) : void 0,
    storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : void 0
  };
}
async function getProof(client2, { address, blockNumber, blockTag: blockTag_, storageKeys }) {
  const blockTag = blockTag_ ?? "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const proof = await client2.request({
    method: "eth_getProof",
    params: [address, storageKeys, blockNumberHex || blockTag]
  });
  return formatProof(proof);
}
async function getStorageAt(client2, { address, blockNumber, blockTag = "latest", slot }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const data2 = await client2.request({
    method: "eth_getStorageAt",
    params: [address, slot, blockNumberHex || blockTag]
  });
  return data2;
}
async function getTransaction(client2, { blockHash, blockNumber, blockTag: blockTag_, hash: hash2, index: index2 }) {
  const blockTag = blockTag_ || "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let transaction = null;
  if (hash2) {
    transaction = await client2.request({
      method: "eth_getTransactionByHash",
      params: [hash2]
    });
  } else if (blockHash) {
    transaction = await client2.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, numberToHex(index2)]
    });
  } else if (blockNumberHex || blockTag) {
    transaction = await client2.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumberHex || blockTag, numberToHex(index2)]
    });
  }
  if (!transaction)
    throw new TransactionNotFoundError({
      blockHash,
      blockNumber,
      blockTag,
      hash: hash2,
      index: index2
    });
  const format = client2.chain?.formatters?.transaction?.format || formatTransaction;
  return format(transaction);
}
async function getTransactionConfirmations(client2, { hash: hash2, transactionReceipt }) {
  const [blockNumber, transaction] = await Promise.all([
    getAction(client2, getBlockNumber, "getBlockNumber")({}),
    hash2 ? getAction(client2, getTransaction, "getBlockNumber")({ hash: hash2 }) : void 0
  ]);
  const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
  if (!transactionBlockNumber)
    return 0n;
  return blockNumber - transactionBlockNumber + 1n;
}
async function getTransactionReceipt(client2, { hash: hash2 }) {
  const receipt = await client2.request({
    method: "eth_getTransactionReceipt",
    params: [hash2]
  });
  if (!receipt)
    throw new TransactionReceiptNotFoundError({ hash: hash2 });
  const format = client2.chain?.formatters?.transactionReceipt?.format || formatTransactionReceipt;
  return format(receipt);
}
async function multicall$1(client2, args) {
  const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts, multicallAddress: multicallAddress_ } = args;
  const batchSize = batchSize_ ?? (typeof client2.batch?.multicall === "object" && client2.batch.multicall.batchSize || 1024);
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "multicall3"
    });
  }
  const chunkedCalls = [[]];
  let currentChunk = 0;
  let currentChunkSize = 0;
  for (let i3 = 0; i3 < contracts.length; i3++) {
    const { abi: abi2, address, args: args2, functionName } = contracts[i3];
    try {
      const callData = encodeFunctionData({
        abi: abi2,
        args: args2,
        functionName
      });
      currentChunkSize += (callData.length - 2) / 2;
      if (
        // Check if batching is enabled.
        batchSize > 0 && // Check if the current size of the batch exceeds the size limit.
        currentChunkSize > batchSize && // Check if the current chunk is not already empty.
        chunkedCalls[currentChunk].length > 0
      ) {
        currentChunk++;
        currentChunkSize = (callData.length - 2) / 2;
        chunkedCalls[currentChunk] = [];
      }
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData,
          target: address
        }
      ];
    } catch (err) {
      const error = getContractError(err, {
        abi: abi2,
        address,
        args: args2,
        docsPath: "/docs/contract/multicall",
        functionName
      });
      if (!allowFailure)
        throw error;
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData: "0x",
          target: address
        }
      ];
    }
  }
  const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => getAction(client2, readContract$1, "readContract")({
    abi: multicall3Abi,
    address: multicallAddress,
    args: [calls],
    blockNumber,
    blockTag,
    functionName: "aggregate3"
  })));
  const results = [];
  for (let i3 = 0; i3 < aggregate3Results.length; i3++) {
    const result = aggregate3Results[i3];
    if (result.status === "rejected") {
      if (!allowFailure)
        throw result.reason;
      for (let j2 = 0; j2 < chunkedCalls[i3].length; j2++) {
        results.push({
          status: "failure",
          error: result.reason,
          result: void 0
        });
      }
      continue;
    }
    const aggregate3Result = result.value;
    for (let j2 = 0; j2 < aggregate3Result.length; j2++) {
      const { returnData, success } = aggregate3Result[j2];
      const { callData } = chunkedCalls[i3][j2];
      const { abi: abi2, address, functionName, args: args2 } = contracts[results.length];
      try {
        if (callData === "0x")
          throw new AbiDecodingZeroDataError();
        if (!success)
          throw new RawContractError({ data: returnData });
        const result2 = decodeFunctionResult({
          abi: abi2,
          args: args2,
          data: returnData,
          functionName
        });
        results.push(allowFailure ? { result: result2, status: "success" } : result2);
      } catch (err) {
        const error = getContractError(err, {
          abi: abi2,
          address,
          args: args2,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        results.push({ error, result: void 0, status: "failure" });
      }
    }
  }
  if (results.length !== contracts.length)
    throw new BaseError("multicall results mismatch");
  return results;
}
const universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
BigInt(0);
BigInt(1);
BigInt(2);
function equalBytes(b1, b22) {
  if (b1.length !== b22.length)
    return false;
  for (let i3 = 0; i3 < b1.length; i3++)
    if (b1[i3] !== b22[i3])
      return false;
  return true;
}
function isBytesEqual(a_, b_) {
  const a2 = isHex(a_) ? toBytes$1(a_) : a_;
  const b3 = isHex(b_) ? toBytes$1(b_) : b_;
  return equalBytes(a2, b3);
}
async function verifyHash(client2, { address, hash: hash2, signature: signature2, ...callRequest }) {
  const signatureHex = isHex(signature2) ? signature2 : toHex(signature2);
  try {
    const { data: data2 } = await getAction(client2, call, "call")({
      data: encodeDeployData({
        abi: universalSignatureValidatorAbi,
        args: [address, hash2, signatureHex],
        bytecode: universalSignatureValidatorByteCode
      }),
      ...callRequest
    });
    return isBytesEqual(data2 ?? "0x0", "0x1");
  } catch (error) {
    if (error instanceof CallExecutionError) {
      return false;
    }
    throw error;
  }
}
async function verifyMessage(client2, { address, message, signature: signature2, ...callRequest }) {
  const hash2 = hashMessage(message);
  return verifyHash(client2, {
    address,
    hash: hash2,
    signature: signature2,
    ...callRequest
  });
}
async function verifyTypedData(client2, { address, signature: signature2, message, primaryType, types: types2, domain, ...callRequest }) {
  const hash2 = hashTypedData({ message, primaryType, types: types2, domain });
  return verifyHash(client2, {
    address,
    hash: hash2,
    signature: signature2,
    ...callRequest
  });
}
function watchBlockNumber(client2, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client2.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
  let prevBlockNumber;
  const pollBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client2.uid,
      emitOnBegin,
      emitMissed,
      pollingInterval
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit2) => poll(async () => {
      try {
        const blockNumber = await getAction(client2, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
        if (prevBlockNumber) {
          if (blockNumber === prevBlockNumber)
            return;
          if (blockNumber - prevBlockNumber > 1 && emitMissed) {
            for (let i3 = prevBlockNumber + 1n; i3 < blockNumber; i3++) {
              emit2.onBlockNumber(i3, prevBlockNumber);
              prevBlockNumber = i3;
            }
          }
        }
        if (!prevBlockNumber || blockNumber > prevBlockNumber) {
          emit2.onBlockNumber(blockNumber, prevBlockNumber);
          prevBlockNumber = blockNumber;
        }
      } catch (err) {
        emit2.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlockNumber = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
          params: ["newHeads"],
          onData(data2) {
            if (!active)
              return;
            const blockNumber = hexToBigInt(data2.result?.number);
            onBlockNumber(blockNumber, prevBlockNumber);
            prevBlockNumber = blockNumber;
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}
async function waitForTransactionReceipt(client2, { confirmations = 1, hash: hash2, onReplaced, pollingInterval = client2.pollingInterval, timeout }) {
  const observerId = stringify(["waitForTransactionReceipt", client2.uid, hash2]);
  let transaction;
  let replacedTransaction;
  let receipt;
  let retrying = false;
  return new Promise((resolve, reject) => {
    if (timeout)
      setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({ hash: hash2 })), timeout);
    const _unobserve = observe(observerId, { onReplaced, resolve, reject }, (emit2) => {
      const _unwatch = getAction(client2, watchBlockNumber, "watchBlockNumber")({
        emitMissed: true,
        emitOnBegin: true,
        poll: true,
        pollingInterval,
        async onBlockNumber(blockNumber_) {
          if (retrying)
            return;
          let blockNumber = blockNumber_;
          const done = (fn2) => {
            _unwatch();
            fn2();
            _unobserve();
          };
          try {
            if (receipt) {
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              done(() => emit2.resolve(receipt));
              return;
            }
            if (!transaction) {
              retrying = true;
              await withRetry(async () => {
                transaction = await getAction(client2, getTransaction, "getTransaction")({ hash: hash2 });
                if (transaction.blockNumber)
                  blockNumber = transaction.blockNumber;
              }, {
                // exponential backoff
                delay: ({ count }) => ~~(1 << count) * 200,
                retryCount: 6
              });
              retrying = false;
            }
            receipt = await getAction(client2, getTransactionReceipt, "getTransactionReceipt")({ hash: hash2 });
            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
              return;
            done(() => emit2.resolve(receipt));
          } catch (err) {
            if (transaction && (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError)) {
              try {
                replacedTransaction = transaction;
                retrying = true;
                const block2 = await withRetry(() => getAction(client2, getBlock, "getBlock")({
                  blockNumber,
                  includeTransactions: true
                }), {
                  // exponential backoff
                  delay: ({ count }) => ~~(1 << count) * 200,
                  retryCount: 6,
                  shouldRetry: ({ error }) => error instanceof BlockNotFoundError
                });
                retrying = false;
                const replacementTransaction = block2.transactions.find(({ from: from2, nonce }) => from2 === replacedTransaction.from && nonce === replacedTransaction.nonce);
                if (!replacementTransaction)
                  return;
                receipt = await getAction(client2, getTransactionReceipt, "getTransactionReceipt")({
                  hash: replacementTransaction.hash
                });
                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                  return;
                let reason = "replaced";
                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                  reason = "repriced";
                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                  reason = "cancelled";
                }
                done(() => {
                  emit2.onReplaced?.({
                    reason,
                    replacedTransaction,
                    transaction: replacementTransaction,
                    transactionReceipt: receipt
                  });
                  emit2.resolve(receipt);
                });
              } catch (err_) {
                done(() => emit2.reject(err_));
              }
            } else {
              done(() => emit2.reject(err));
            }
          }
        }
      });
    });
  });
}
function watchBlocks(client2, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client2.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
  const includeTransactions = includeTransactions_ ?? false;
  let prevBlock;
  const pollBlocks = () => {
    const observerId = stringify([
      "watchBlocks",
      client2.uid,
      emitMissed,
      emitOnBegin,
      includeTransactions,
      pollingInterval
    ]);
    return observe(observerId, { onBlock, onError }, (emit2) => poll(async () => {
      try {
        const block2 = await getAction(client2, getBlock, "getBlock")({
          blockTag,
          includeTransactions
        });
        if (block2.number && prevBlock?.number) {
          if (block2.number === prevBlock.number)
            return;
          if (block2.number - prevBlock.number > 1 && emitMissed) {
            for (let i3 = prevBlock?.number + 1n; i3 < block2.number; i3++) {
              const block3 = await getAction(client2, getBlock, "getBlock")({
                blockNumber: i3,
                includeTransactions
              });
              emit2.onBlock(block3, prevBlock);
              prevBlock = block3;
            }
          }
        }
        if (
          // If no previous block exists, emit.
          !prevBlock?.number || // If the block tag is "pending" with no block number, emit.
          blockTag === "pending" && !block2?.number || // If the next block number is greater than the previous block number, emit.
          // We don't want to emit blocks in the past.
          block2.number && block2.number > prevBlock.number
        ) {
          emit2.onBlock(block2, prevBlock);
          prevBlock = block2;
        }
      } catch (err) {
        emit2.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlocks = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
          params: ["newHeads"],
          onData(data2) {
            if (!active)
              return;
            const format = client2.chain?.formatters?.block?.format || formatBlock;
            const block2 = format(data2.result);
            onBlock(block2, prevBlock);
            prevBlock = block2;
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollBlocks() : subscribeBlocks();
}
function watchEvent(client2, { address, args, batch = true, event, events: events2, onError, onLogs, poll: poll_, pollingInterval = client2.pollingInterval, strict: strict_ }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
  const strict = strict_ ?? false;
  const pollEvent = () => {
    const observerId = stringify([
      "watchEvent",
      address,
      args,
      batch,
      client2.uid,
      event,
      pollingInterval
    ]);
    return observe(observerId, { onLogs, onError }, (emit2) => {
      let previousBlockNumber;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter = await getAction(client2, createEventFilter, "createEventFilter")({
              address,
              args,
              event,
              events: events2,
              strict
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getAction(client2, getFilterChanges, "getFilterChanges")({ filter });
          } else {
            const blockNumber = await getAction(client2, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getAction(client2, getLogs, "getLogs")({
                address,
                args,
                event,
                events: events2,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit2.onLogs(logs);
          else
            for (const log3 of logs)
              emit2.onLogs([log3]);
        } catch (err) {
          if (filter && err instanceof InvalidInputRpcError)
            initialized = false;
          emit2.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client2, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribeEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const events_ = events2 ?? (event ? [event] : void 0);
        let topics = [];
        if (events_) {
          topics = [
            events_.flatMap((event2) => encodeEventTopics({
              abi: [event2],
              eventName: event2.name,
              args
            }))
          ];
          if (event)
            topics = topics[0];
        }
        const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
          params: ["logs", { address, topics }],
          onData(data2) {
            if (!active)
              return;
            const log3 = data2.result;
            try {
              const { eventName, args: args2 } = decodeEventLog({
                abi: events_,
                data: log3.data,
                topics: log3.topics,
                strict
              });
              const formatted = formatLog(log3, {
                args: args2,
                eventName
              });
              onLogs([formatted]);
            } catch (err) {
              let eventName;
              let isUnnamed;
              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
              }
              const formatted = formatLog(log3, {
                args: isUnnamed ? [] : {},
                eventName
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollEvent() : subscribeEvent();
}
function watchPendingTransactions(client2, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client2.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
  const pollPendingTransactions = () => {
    const observerId = stringify([
      "watchPendingTransactions",
      client2.uid,
      batch,
      pollingInterval
    ]);
    return observe(observerId, { onTransactions, onError }, (emit2) => {
      let filter;
      const unwatch = poll(async () => {
        try {
          if (!filter) {
            try {
              filter = await getAction(client2, createPendingTransactionFilter, "createPendingTransactionFilter")({});
              return;
            } catch (err) {
              unwatch();
              throw err;
            }
          }
          const hashes = await getAction(client2, getFilterChanges, "getFilterChanges")({ filter });
          if (hashes.length === 0)
            return;
          if (batch)
            emit2.onTransactions(hashes);
          else
            for (const hash2 of hashes)
              emit2.onTransactions([hash2]);
        } catch (err) {
          emit2.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client2, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribePendingTransactions = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(data2) {
            if (!active)
              return;
            const transaction = data2.result;
            onTransactions([transaction]);
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
}
function publicActions(client2) {
  return {
    call: (args) => call(client2, args),
    createBlockFilter: () => createBlockFilter(client2),
    createContractEventFilter: (args) => createContractEventFilter(client2, args),
    createEventFilter: (args) => createEventFilter(client2, args),
    createPendingTransactionFilter: () => createPendingTransactionFilter(client2),
    estimateContractGas: (args) => estimateContractGas(client2, args),
    estimateGas: (args) => estimateGas(client2, args),
    getBalance: (args) => getBalance(client2, args),
    getBlock: (args) => getBlock(client2, args),
    getBlockNumber: (args) => getBlockNumber(client2, args),
    getBlockTransactionCount: (args) => getBlockTransactionCount(client2, args),
    getBytecode: (args) => getBytecode(client2, args),
    getChainId: () => getChainId(client2),
    getContractEvents: (args) => getContractEvents(client2, args),
    getEnsAddress: (args) => getEnsAddress(client2, args),
    getEnsAvatar: (args) => getEnsAvatar(client2, args),
    getEnsName: (args) => getEnsName(client2, args),
    getEnsResolver: (args) => getEnsResolver(client2, args),
    getEnsText: (args) => getEnsText(client2, args),
    getFeeHistory: (args) => getFeeHistory(client2, args),
    estimateFeesPerGas: (args) => estimateFeesPerGas(client2, args),
    getFilterChanges: (args) => getFilterChanges(client2, args),
    getFilterLogs: (args) => getFilterLogs(client2, args),
    getGasPrice: () => getGasPrice(client2),
    getLogs: (args) => getLogs(client2, args),
    getProof: (args) => getProof(client2, args),
    estimateMaxPriorityFeePerGas: (args) => estimateMaxPriorityFeePerGas(client2, args),
    getStorageAt: (args) => getStorageAt(client2, args),
    getTransaction: (args) => getTransaction(client2, args),
    getTransactionConfirmations: (args) => getTransactionConfirmations(client2, args),
    getTransactionCount: (args) => getTransactionCount(client2, args),
    getTransactionReceipt: (args) => getTransactionReceipt(client2, args),
    multicall: (args) => multicall$1(client2, args),
    prepareTransactionRequest: (args) => prepareTransactionRequest(client2, args),
    readContract: (args) => readContract$1(client2, args),
    sendRawTransaction: (args) => sendRawTransaction(client2, args),
    simulateContract: (args) => simulateContract(client2, args),
    verifyMessage: (args) => verifyMessage(client2, args),
    verifyTypedData: (args) => verifyTypedData(client2, args),
    uninstallFilter: (args) => uninstallFilter(client2, args),
    waitForTransactionReceipt: (args) => waitForTransactionReceipt(client2, args),
    watchBlocks: (args) => watchBlocks(client2, args),
    watchBlockNumber: (args) => watchBlockNumber(client2, args),
    watchContractEvent: (args) => watchContractEvent(client2, args),
    watchEvent: (args) => watchEvent(client2, args),
    watchPendingTransactions: (args) => watchPendingTransactions(client2, args)
  };
}
function createPublicClient(parameters) {
  const { key: key2 = "public", name: name2 = "Public Client" } = parameters;
  const client2 = createClient({
    ...parameters,
    key: key2,
    name: name2,
    type: "publicClient"
  });
  return client2.extend(publicActions);
}
function deployContract(walletClient, { abi: abi2, args, bytecode: bytecode2, ...request2 }) {
  const calldata = encodeDeployData({
    abi: abi2,
    args,
    bytecode: bytecode2
  });
  return sendTransaction(walletClient, {
    ...request2,
    data: calldata
  });
}
async function getAddresses(client2) {
  if (client2.account?.type === "local")
    return [client2.account.address];
  const addresses = await client2.request({ method: "eth_accounts" });
  return addresses.map((address) => checksumAddress(address));
}
async function getPermissions(client2) {
  const permissions = await client2.request({ method: "wallet_getPermissions" });
  return permissions;
}
async function requestAddresses(client2) {
  const addresses = await client2.request({ method: "eth_requestAccounts" });
  return addresses.map((address) => getAddress(address));
}
async function requestPermissions(client2, permissions) {
  return client2.request({
    method: "wallet_requestPermissions",
    params: [permissions]
  });
}
async function signMessage$1(client2, { account: account_ = client2.account, message }) {
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const account = parseAccount(account_);
  if (account.type === "local")
    return account.signMessage({ message });
  const message_ = (() => {
    if (typeof message === "string")
      return stringToHex(message);
    if (message.raw instanceof Uint8Array)
      return toHex(message.raw);
    return message.raw;
  })();
  return client2.request({
    method: "personal_sign",
    params: [message_, account.address]
  });
}
async function signTransaction(client2, args) {
  const { account: account_ = client2.account, chain = client2.chain, ...transaction } = args;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const account = parseAccount(account_);
  assertRequest({
    account,
    ...args
  });
  const chainId2 = await getAction(client2, getChainId, "getChainId")({});
  if (chain !== null)
    assertCurrentChain({
      currentChainId: chainId2,
      chain
    });
  const formatters = chain?.formatters || client2.chain?.formatters;
  const format = formatters?.transactionRequest?.format || formatTransactionRequest;
  if (account.type === "local")
    return account.signTransaction({
      ...transaction,
      chainId: chainId2
    }, { serializer: client2.chain?.serializers?.transaction });
  return await client2.request({
    method: "eth_signTransaction",
    params: [
      {
        ...format(transaction),
        chainId: numberToHex(chainId2),
        from: account.address
      }
    ]
  });
}
async function signTypedData(client2, { account: account_ = client2.account, domain, message, primaryType, types: types_ }) {
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const account = parseAccount(account_);
  const types2 = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...types_
  };
  validateTypedData({
    domain,
    message,
    primaryType,
    types: types2
  });
  if (account.type === "local")
    return account.signTypedData({
      domain,
      primaryType,
      types: types2,
      message
    });
  const typedData = stringify({ domain: domain ?? {}, primaryType, types: types2, message }, (_2, value) => isHex(value) ? value.toLowerCase() : value);
  return client2.request({
    method: "eth_signTypedData_v4",
    params: [account.address, typedData]
  });
}
async function switchChain(client2, { id: id2 }) {
  await client2.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: numberToHex(id2)
      }
    ]
  });
}
async function watchAsset(client2, params) {
  const added = await client2.request({
    method: "wallet_watchAsset",
    params
  });
  return added;
}
function walletActions(client2) {
  return {
    addChain: (args) => addChain(client2, args),
    deployContract: (args) => deployContract(client2, args),
    getAddresses: () => getAddresses(client2),
    getChainId: () => getChainId(client2),
    getPermissions: () => getPermissions(client2),
    prepareTransactionRequest: (args) => prepareTransactionRequest(client2, args),
    requestAddresses: () => requestAddresses(client2),
    requestPermissions: (args) => requestPermissions(client2, args),
    sendRawTransaction: (args) => sendRawTransaction(client2, args),
    sendTransaction: (args) => sendTransaction(client2, args),
    signMessage: (args) => signMessage$1(client2, args),
    signTransaction: (args) => signTransaction(client2, args),
    signTypedData: (args) => signTypedData(client2, args),
    switchChain: (args) => switchChain(client2, args),
    watchAsset: (args) => watchAsset(client2, args),
    writeContract: (args) => writeContract(client2, args)
  };
}
function createWalletClient(parameters) {
  const { key: key2 = "wallet", name: name2 = "Wallet Client", transport } = parameters;
  const client2 = createClient({
    ...parameters,
    key: key2,
    name: name2,
    transport: (opts) => transport({ ...opts, retryCount: 0 }),
    type: "walletClient"
  });
  return client2.extend(walletActions);
}
function webSocket(url, config2 = {}) {
  const { key: key2 = "webSocket", name: name2 = "WebSocket JSON-RPC", retryDelay } = config2;
  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
    const retryCount = config2.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config2.timeout ?? 1e4;
    const url_ = url || chain?.rpcUrls.default.webSocket?.[0];
    if (!url_)
      throw new UrlRequiredError();
    return createTransport({
      key: key2,
      name: name2,
      async request({ method, params }) {
        const body2 = { method, params };
        const socket = await getSocket(url_);
        const { error, result } = await rpc.webSocketAsync(socket, {
          body: body2,
          timeout
        });
        if (error)
          throw new RpcRequestError({
            body: body2,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "webSocket"
    }, {
      getSocket() {
        return getSocket(url_);
      },
      async subscribe({ params, onData, onError }) {
        const socket = await getSocket(url_);
        const { result: subscriptionId } = await new Promise((resolve, reject) => rpc.webSocket(socket, {
          body: {
            method: "eth_subscribe",
            params
          },
          onResponse(response) {
            if (response.error) {
              reject(response.error);
              onError?.(response.error);
              return;
            }
            if (typeof response.id === "number") {
              resolve(response);
              return;
            }
            if (response.method !== "eth_subscription")
              return;
            onData(response.params);
          }
        }));
        return {
          subscriptionId,
          async unsubscribe() {
            return new Promise((resolve) => rpc.webSocket(socket, {
              body: {
                method: "eth_unsubscribe",
                params: [subscriptionId]
              },
              onResponse: resolve
            }));
          }
        };
      }
    });
  };
}
const goerli = /* @__PURE__ */ defineChain({
  id: 5,
  network: "goerli",
  name: "Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://eth-goerli.g.alchemy.com/v2"],
      webSocket: ["wss://eth-goerli.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://goerli.infura.io/v3"],
      webSocket: ["wss://goerli.infura.io/ws/v3"]
    },
    default: {
      http: ["https://rpc.ankr.com/eth_goerli"]
    },
    public: {
      http: ["https://rpc.ankr.com/eth_goerli"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io"
    },
    default: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0x56522D00C410a43BFfDF00a9A569489297385790",
      blockCreated: 8765204
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6507670
    }
  },
  testnet: true
});
const mainnet = /* @__PURE__ */ defineChain({
  id: 1,
  network: "homestead",
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    alchemy: {
      http: ["https://eth-mainnet.g.alchemy.com/v2"],
      webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"]
    },
    infura: {
      http: ["https://mainnet.infura.io/v3"],
      webSocket: ["wss://mainnet.infura.io/ws/v3"]
    },
    default: {
      http: ["https://cloudflare-eth.com"]
    },
    public: {
      http: ["https://cloudflare-eth.com"]
    }
  },
  blockExplorers: {
    etherscan: {
      name: "Etherscan",
      url: "https://etherscan.io"
    },
    default: {
      name: "Etherscan",
      url: "https://etherscan.io"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xc0497E381f536Be9ce14B0dD3817cBcAe57d2F62",
      blockCreated: 16966585
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});
var ChainNotConfiguredForConnectorError = class extends Error {
  constructor({
    chainId: chainId2,
    connectorId
  }) {
    super(`Chain "${chainId2}" not configured for connector "${connectorId}".`);
    this.name = "ChainNotConfiguredForConnectorError";
  }
};
var ConnectorNotFoundError = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "ConnectorNotFoundError";
    this.message = "Connector not found";
  }
};
function normalizeChainId(chainId2) {
  if (typeof chainId2 === "string")
    return Number.parseInt(
      chainId2,
      chainId2.trim().substring(0, 2) === "0x" ? 16 : 10
    );
  if (typeof chainId2 === "bigint")
    return Number(chainId2);
  return chainId2;
}
var eventemitter3 = { exports: {} };
(function(module) {
  var has2 = Object.prototype.hasOwnProperty, prefix2 = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix2 = false;
  }
  function EE(fn2, context, once3) {
    this.fn = fn2;
    this.context = context;
    this.once = once3 || false;
  }
  function addListener2(emitter, event, fn2, context, once3) {
    if (typeof fn2 !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn2, context || emitter, once3), evt = prefix2 ? prefix2 + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames2() {
    var names2 = [], events2, name2;
    if (this._eventsCount === 0)
      return names2;
    for (name2 in events2 = this._events) {
      if (has2.call(events2, name2))
        names2.push(prefix2 ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events2));
    }
    return names2;
  };
  EventEmitter2.prototype.listeners = function listeners2(event) {
    var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i3 = 0, l2 = handlers.length, ee2 = new Array(l2); i3 < l2; i3++) {
      ee2[i3] = handlers[i3].fn;
    }
    return ee2;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount2(event) {
    var evt = prefix2 ? prefix2 + event : event, listeners2 = this._events[evt];
    if (!listeners2)
      return 0;
    if (listeners2.fn)
      return 1;
    return listeners2.length;
  };
  EventEmitter2.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt])
      return false;
    var listeners2 = this._events[evt], len = arguments.length, args, i3;
    if (listeners2.fn) {
      if (listeners2.once)
        this.removeListener(event, listeners2.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i3 = 1, args = new Array(len - 1); i3 < len; i3++) {
        args[i3 - 1] = arguments[i3];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length2 = listeners2.length, j2;
      for (i3 = 0; i3 < length2; i3++) {
        if (listeners2[i3].once)
          this.removeListener(event, listeners2[i3].fn, void 0, true);
        switch (len) {
          case 1:
            listeners2[i3].fn.call(listeners2[i3].context);
            break;
          case 2:
            listeners2[i3].fn.call(listeners2[i3].context, a1);
            break;
          case 3:
            listeners2[i3].fn.call(listeners2[i3].context, a1, a2);
            break;
          case 4:
            listeners2[i3].fn.call(listeners2[i3].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
            listeners2[i3].fn.apply(listeners2[i3].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on2(event, fn2, context) {
    return addListener2(this, event, fn2, context, false);
  };
  EventEmitter2.prototype.once = function once3(event, fn2, context) {
    return addListener2(this, event, fn2, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener2(event, fn2, context, once3) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt])
      return this;
    if (!fn2) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn2 && (!once3 || listeners2.once) && (!context || listeners2.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i3 = 0, events2 = [], length2 = listeners2.length; i3 < length2; i3++) {
        if (listeners2[i3].fn !== fn2 || once3 && !listeners2[i3].once || context && listeners2[i3].context !== context) {
          events2.push(listeners2[i3]);
        }
      }
      if (events2.length)
        this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners2(event) {
    var evt;
    if (event) {
      evt = prefix2 ? prefix2 + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix2;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
var __accessCheck$1 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$1 = (obj, member, getter) => {
  __accessCheck$1(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$1 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$1 = (obj, member, value, setter) => {
  __accessCheck$1(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$1 = (obj, member, method) => {
  __accessCheck$1(obj, member, "access private method");
  return method;
};
var Connector = class extends EventEmitter {
  constructor({
    chains: chains2 = [mainnet, goerli],
    options
  }) {
    super();
    this.chains = chains2;
    this.options = options;
  }
  getBlockExplorerUrls(chain) {
    const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};
    if (blockExplorer)
      return [
        blockExplorer.url,
        ...Object.values(blockExplorers).map((x2) => x2.url)
      ];
  }
  isChainUnsupported(chainId2) {
    return !this.chains.some((x2) => x2.id === chainId2);
  }
  setStorage(storage) {
    this.storage = storage;
  }
};
function getInjectedName(ethereum) {
  if (!ethereum)
    return "Injected";
  const getName = (provider) => {
    if (provider.isApexWallet)
      return "Apex Wallet";
    if (provider.isAvalanche)
      return "Core Wallet";
    if (provider.isBackpack)
      return "Backpack";
    if (provider.isBifrost)
      return "Bifrost Wallet";
    if (provider.isBitKeep)
      return "BitKeep";
    if (provider.isBitski)
      return "Bitski";
    if (provider.isBlockWallet)
      return "BlockWallet";
    if (provider.isBraveWallet)
      return "Brave Wallet";
    if (provider.isCoin98)
      return "Coin98 Wallet";
    if (provider.isCoinbaseWallet)
      return "Coinbase Wallet";
    if (provider.isDawn)
      return "Dawn Wallet";
    if (provider.isDefiant)
      return "Defiant";
    if (provider.isDesig)
      return "Desig Wallet";
    if (provider.isEnkrypt)
      return "Enkrypt";
    if (provider.isExodus)
      return "Exodus";
    if (provider.isFordefi)
      return "Fordefi";
    if (provider.isFrame)
      return "Frame";
    if (provider.isFrontier)
      return "Frontier Wallet";
    if (provider.isGamestop)
      return "GameStop Wallet";
    if (provider.isHaqqWallet)
      return "HAQQ Wallet";
    if (provider.isHyperPay)
      return "HyperPay Wallet";
    if (provider.isImToken)
      return "ImToken";
    if (provider.isHaloWallet)
      return "Halo Wallet";
    if (provider.isKuCoinWallet)
      return "KuCoin Wallet";
    if (provider.isMathWallet)
      return "MathWallet";
    if (provider.isNovaWallet)
      return "Nova Wallet";
    if (provider.isOkxWallet || provider.isOKExWallet)
      return "OKX Wallet";
    if (provider.isOktoWallet)
      return "Okto Wallet";
    if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet)
      return "1inch Wallet";
    if (provider.isOneKey)
      return "OneKey Wallet";
    if (provider.isOpera)
      return "Opera";
    if (provider.isPhantom)
      return "Phantom";
    if (provider.isPortal)
      return "Ripio Portal";
    if (provider.isRabby)
      return "Rabby Wallet";
    if (provider.isRainbow)
      return "Rainbow";
    if (provider.isSafePal)
      return "SafePal Wallet";
    if (provider.isStatus)
      return "Status";
    if (provider.isSubWallet)
      return "SubWallet";
    if (provider.isTalisman)
      return "Talisman";
    if (provider.isTally)
      return "Taho";
    if (provider.isTokenPocket)
      return "TokenPocket";
    if (provider.isTokenary)
      return "Tokenary";
    if (provider.isTrust || provider.isTrustWallet)
      return "Trust Wallet";
    if (provider.isTTWallet)
      return "TTWallet";
    if (provider.isXDEFI)
      return "XDEFI Wallet";
    if (provider.isZeal)
      return "Zeal";
    if (provider.isZerion)
      return "Zerion";
    if (provider.isMetaMask)
      return "MetaMask";
  };
  if (ethereum.providers?.length) {
    const nameSet = /* @__PURE__ */ new Set();
    let unknownCount = 1;
    for (const provider of ethereum.providers) {
      let name2 = getName(provider);
      if (!name2) {
        name2 = `Unknown Wallet #${unknownCount}`;
        unknownCount += 1;
      }
      nameSet.add(name2);
    }
    const names2 = [...nameSet];
    if (names2.length)
      return names2;
    return names2[0] ?? "Injected";
  }
  return getName(ethereum) ?? "Injected";
}
var _provider$2;
var InjectedConnector = class extends Connector {
  constructor({
    chains: chains2,
    options: options_
  } = {}) {
    const options = {
      shimDisconnect: true,
      getProvider() {
        if (typeof window === "undefined")
          return;
        const ethereum = window.ethereum;
        if (ethereum?.providers && ethereum.providers.length > 0)
          return ethereum.providers[0];
        return ethereum;
      },
      ...options_
    };
    super({ chains: chains2, options });
    this.id = "injected";
    __privateAdd$1(this, _provider$2, void 0);
    this.shimDisconnectKey = `${this.id}.shimDisconnect`;
    this.onAccountsChanged = (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", {
          account: getAddress(accounts[0])
        });
    };
    this.onChainChanged = (chainId2) => {
      const id2 = normalizeChainId(chainId2);
      const unsupported = this.isChainUnsupported(id2);
      this.emit("change", { chain: { id: id2, unsupported } });
    };
    this.onDisconnect = async (error) => {
      if (error.code === 1013) {
        const provider2 = await this.getProvider();
        if (provider2) {
          const isAuthorized = await this.getAccount();
          if (isAuthorized)
            return;
        }
      }
      this.emit("disconnect");
      if (this.options.shimDisconnect)
        this.storage?.removeItem(this.shimDisconnectKey);
    };
    const provider = options.getProvider();
    if (typeof options.name === "string")
      this.name = options.name;
    else if (provider) {
      const detectedName = getInjectedName(provider);
      if (options.name)
        this.name = options.name(detectedName);
      else {
        if (typeof detectedName === "string")
          this.name = detectedName;
        else
          this.name = detectedName[0];
      }
    } else
      this.name = "Injected";
    this.ready = !!provider;
  }
  async connect({ chainId: chainId2 } = {}) {
    try {
      const provider = await this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      if (provider.on) {
        provider.on("accountsChanged", this.onAccountsChanged);
        provider.on("chainChanged", this.onChainChanged);
        provider.on("disconnect", this.onDisconnect);
      }
      this.emit("message", { type: "connecting" });
      const accounts = await provider.request({
        method: "eth_requestAccounts"
      });
      const account = getAddress(accounts[0]);
      let id2 = await this.getChainId();
      let unsupported = this.isChainUnsupported(id2);
      if (chainId2 && id2 !== chainId2) {
        const chain = await this.switchChain(chainId2);
        id2 = chain.id;
        unsupported = this.isChainUnsupported(id2);
      }
      if (this.options.shimDisconnect)
        this.storage?.setItem(this.shimDisconnectKey, true);
      return { account, chain: { id: id2, unsupported } };
    } catch (error) {
      if (this.isUserRejectedRequestError(error))
        throw new UserRejectedRequestError(error);
      if (error.code === -32002)
        throw new ResourceUnavailableRpcError(error);
      throw error;
    }
  }
  async disconnect() {
    const provider = await this.getProvider();
    if (!provider?.removeListener)
      return;
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    if (this.options.shimDisconnect)
      this.storage?.removeItem(this.shimDisconnectKey);
  }
  async getAccount() {
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    const accounts = await provider.request({
      method: "eth_accounts"
    });
    return getAddress(accounts[0]);
  }
  async getChainId() {
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    return provider.request({ method: "eth_chainId" }).then(normalizeChainId);
  }
  async getProvider() {
    const provider = this.options.getProvider();
    if (provider)
      __privateSet$1(this, _provider$2, provider);
    return __privateGet$1(this, _provider$2);
  }
  async getWalletClient({
    chainId: chainId2
  } = {}) {
    const [provider, account] = await Promise.all([
      this.getProvider(),
      this.getAccount()
    ]);
    const chain = this.chains.find((x2) => x2.id === chainId2);
    if (!provider)
      throw new Error("provider is required.");
    return createWalletClient({
      account,
      chain,
      transport: custom$1(provider)
    });
  }
  async isAuthorized() {
    try {
      if (this.options.shimDisconnect && !this.storage?.getItem(this.shimDisconnectKey))
        return false;
      const provider = await this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      const account = await this.getAccount();
      return !!account;
    } catch {
      return false;
    }
  }
  async switchChain(chainId2) {
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    const id2 = numberToHex(chainId2);
    try {
      await Promise.all([
        provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: id2 }]
        }),
        new Promise(
          (res) => this.on("change", ({ chain }) => {
            if (chain?.id === chainId2)
              res();
          })
        )
      ]);
      return this.chains.find((x2) => x2.id === chainId2) ?? {
        id: chainId2,
        name: `Chain ${id2}`,
        network: `${id2}`,
        nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
        rpcUrls: { default: { http: [""] }, public: { http: [""] } }
      };
    } catch (error) {
      const chain = this.chains.find((x2) => x2.id === chainId2);
      if (!chain)
        throw new ChainNotConfiguredForConnectorError({
          chainId: chainId2,
          connectorId: this.id
        });
      if (error.code === 4902 || error?.data?.originalError?.code === 4902) {
        try {
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [
              {
                chainId: id2,
                chainName: chain.name,
                nativeCurrency: chain.nativeCurrency,
                rpcUrls: [chain.rpcUrls.public?.http[0] ?? ""],
                blockExplorerUrls: this.getBlockExplorerUrls(chain)
              }
            ]
          });
          const currentChainId = await this.getChainId();
          if (currentChainId !== chainId2)
            throw new UserRejectedRequestError(
              new Error("User rejected switch after adding network.")
            );
          return chain;
        } catch (error2) {
          throw new UserRejectedRequestError(error2);
        }
      }
      if (this.isUserRejectedRequestError(error))
        throw new UserRejectedRequestError(error);
      throw new SwitchChainError(error);
    }
  }
  async watchAsset({
    address,
    decimals = 18,
    image,
    symbol
  }) {
    const provider = await this.getProvider();
    if (!provider)
      throw new ConnectorNotFoundError();
    return provider.request({
      method: "wallet_watchAsset",
      params: {
        type: "ERC20",
        options: {
          address,
          decimals,
          image,
          symbol
        }
      }
    });
  }
  isUserRejectedRequestError(error) {
    return error.code === 4001;
  }
};
_provider$2 = /* @__PURE__ */ new WeakMap();
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var define_import_meta_env_default$2 = { VITE_REACT_PROJECTID: "05c6fd6b3708f60c6c5dcdd31968eeef", VITE_REACT_STAKING_CONTRACT_ADDRESS: "0xfB528B5905C8f9398fb625Ab4155C567A75cCC9F", VITE_REACT_STAKE_TOKEN_CONTRACT_ADDRESS: "0x5263fdc29e84891ded4e0fb8be4084398d9a6e84", VITE_REACT_V3_SWAP_ROUTER_ADDRESS: "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45", VITE_REACT_TESTNET_URL: "https://holesky-fullnode-testnet.rpc.grove.city/v1/e62fd814", VITE_REACT_CHAIN_ID: "3", VITE_REACT_ADDRESS0: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", VITE_REACT_ADDRESS1: "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984", BASE_URL: "/", MODE: "production", DEV: false, PROD: true, SSR: false };
const subscribeWithSelectorImpl = (fn2) => (set2, get2, api2) => {
  const origSubscribe = api2.subscribe;
  api2.subscribe = (selector, optListener, options) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector(api2.getState());
      listener = (state2) => {
        const nextSlice = selector(state2);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState = fn2(set2, get2, api2);
  return initialState;
};
const subscribeWithSelector = subscribeWithSelectorImpl;
function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e2) {
    return;
  }
  const persistStorage = {
    getItem: (name2) => {
      var _a;
      const parse2 = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, options == null ? void 0 : options.reviver);
      };
      const str = (_a = storage.getItem(name2)) != null ? _a : null;
      if (str instanceof Promise) {
        return str.then(parse2);
      }
      return parse2(str);
    },
    setItem: (name2, newValue) => storage.setItem(
      name2,
      JSON.stringify(newValue, options == null ? void 0 : options.replacer)
    ),
    removeItem: (name2) => storage.removeItem(name2)
  };
  return persistStorage;
}
const toThenable = (fn2) => (input) => {
  try {
    const result = fn2(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e2) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e2);
      }
    };
  }
};
const oldImpl = (config2, baseOptions) => (set2, get2, api2) => {
  let options = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (state2) => state2,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage;
  try {
    storage = options.getStorage();
  } catch (e2) {
  }
  if (!storage) {
    return config2(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set2(...args);
      },
      get2,
      api2
    );
  }
  const thenableSerialize = toThenable(options.serialize);
  const setItem = () => {
    const state2 = options.partialize({ ...get2() });
    let errorInSync;
    const thenable = thenableSerialize({ state: state2, version: options.version }).then(
      (serializedValue) => storage.setItem(options.name, serializedValue)
    ).catch((e2) => {
      errorInSync = e2;
    });
    if (errorInSync) {
      throw errorInSync;
    }
    return thenable;
  };
  const savedSetState = api2.setState;
  api2.setState = (state2, replace2) => {
    savedSetState(state2, replace2);
    void setItem();
  };
  const configResult = config2(
    (...args) => {
      set2(...args);
      void setItem();
    },
    get2,
    api2
  );
  let stateFromStorage;
  const hydrate = () => {
    var _a;
    if (!storage)
      return;
    hasHydrated = false;
    hydrationListeners.forEach((cb2) => cb2(get2()));
    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get2())) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
      if (storageValue) {
        return options.deserialize(storageValue);
      }
    }).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a2;
      stateFromStorage = options.merge(
        migratedState,
        (_a2 = get2()) != null ? _a2 : configResult
      );
      set2(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      hasHydrated = true;
      finishHydrationListeners.forEach((cb2) => cb2(stateFromStorage));
    }).catch((e2) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e2);
    });
  };
  api2.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.getStorage) {
        storage = newOptions.getStorage();
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb2) => {
      hydrationListeners.add(cb2);
      return () => {
        hydrationListeners.delete(cb2);
      };
    },
    onFinishHydration: (cb2) => {
      finishHydrationListeners.add(cb2);
      return () => {
        finishHydrationListeners.delete(cb2);
      };
    }
  };
  hydrate();
  return stateFromStorage || configResult;
};
const newImpl = (config2, baseOptions) => (set2, get2, api2) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state2) => state2,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config2(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set2(...args);
      },
      get2,
      api2
    );
  }
  const setItem = () => {
    const state2 = options.partialize({ ...get2() });
    return storage.setItem(options.name, {
      state: state2,
      version: options.version
    });
  };
  const savedSetState = api2.setState;
  api2.setState = (state2, replace2) => {
    savedSetState(state2, replace2);
    void setItem();
  };
  const configResult = config2(
    (...args) => {
      set2(...args);
      void setItem();
    },
    get2,
    api2
  );
  api2.getInitialState = () => configResult;
  let stateFromStorage;
  const hydrate = () => {
    var _a, _b;
    if (!storage)
      return;
    hasHydrated = false;
    hydrationListeners.forEach((cb2) => {
      var _a2;
      return cb2((_a2 = get2()) != null ? _a2 : configResult);
    });
    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get2()) != null ? _a : configResult)) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a2;
      stateFromStorage = options.merge(
        migratedState,
        (_a2 = get2()) != null ? _a2 : configResult
      );
      set2(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get2();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb2) => cb2(stateFromStorage));
    }).catch((e2) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e2);
    });
  };
  api2.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb2) => {
      hydrationListeners.add(cb2);
      return () => {
        hydrationListeners.delete(cb2);
      };
    },
    onFinishHydration: (cb2) => {
      finishHydrationListeners.add(cb2);
      return () => {
        finishHydrationListeners.delete(cb2);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate();
  }
  return stateFromStorage || configResult;
};
const persistImpl = (config2, baseOptions) => {
  if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
    if ((define_import_meta_env_default$2 ? "production" : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
      );
    }
    return oldImpl(config2, baseOptions);
  }
  return newImpl(config2, baseOptions);
};
const persist = persistImpl;
var define_import_meta_env_default$1 = { VITE_REACT_PROJECTID: "05c6fd6b3708f60c6c5dcdd31968eeef", VITE_REACT_STAKING_CONTRACT_ADDRESS: "0xfB528B5905C8f9398fb625Ab4155C567A75cCC9F", VITE_REACT_STAKE_TOKEN_CONTRACT_ADDRESS: "0x5263fdc29e84891ded4e0fb8be4084398d9a6e84", VITE_REACT_V3_SWAP_ROUTER_ADDRESS: "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45", VITE_REACT_TESTNET_URL: "https://holesky-fullnode-testnet.rpc.grove.city/v1/e62fd814", VITE_REACT_CHAIN_ID: "3", VITE_REACT_ADDRESS0: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", VITE_REACT_ADDRESS1: "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984", BASE_URL: "/", MODE: "production", DEV: false, PROD: true, SSR: false };
const createStoreImpl = (createState) => {
  let state2;
  const listeners2 = /* @__PURE__ */ new Set();
  const setState = (partial, replace2) => {
    const nextState = typeof partial === "function" ? partial(state2) : partial;
    if (!Object.is(nextState, state2)) {
      const previousState = state2;
      state2 = (replace2 != null ? replace2 : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state2, nextState);
      listeners2.forEach((listener) => listener(state2, previousState));
    }
  };
  const getState = () => state2;
  const getInitialState = () => initialState;
  const subscribe2 = (listener) => {
    listeners2.add(listener);
    return () => listeners2.delete(listener);
  };
  const destroy = () => {
    if ((define_import_meta_env_default$1 ? "production" : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners2.clear();
  };
  const api2 = { setState, getState, getInitialState, subscribe: subscribe2, destroy };
  const initialState = state2 = createState(setState, getState, api2);
  return api2;
};
const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
function shallow$1(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size)
      return false;
    for (const [key2, value] of objA) {
      if (!Object.is(value, objB.get(key2))) {
        return false;
      }
    }
    return true;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size)
      return false;
    for (const value of objA) {
      if (!objB.has(value)) {
        return false;
      }
    }
    return true;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i3 = 0; i3 < keysA.length; i3++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i3]) || !Object.is(objA[keysA[i3]], objB[keysA[i3]])) {
      return false;
    }
  }
  return true;
}
function configureChains(defaultChains, providers, {
  batch = { multicall: { wait: 32 } },
  pollingInterval = 4e3,
  rank,
  retryCount,
  retryDelay,
  stallTimeout
} = {}) {
  if (!defaultChains.length)
    throw new Error("must have at least one chain");
  let chains2 = [];
  const httpUrls = {};
  const wsUrls = {};
  for (const chain of defaultChains) {
    let configExists = false;
    for (const provider of providers) {
      const apiConfig = provider(chain);
      if (!apiConfig)
        continue;
      configExists = true;
      if (!chains2.some(({ id: id2 }) => id2 === chain.id)) {
        chains2 = [...chains2, apiConfig.chain];
      }
      httpUrls[chain.id] = [
        ...httpUrls[chain.id] || [],
        ...apiConfig.rpcUrls.http
      ];
      if (apiConfig.rpcUrls.webSocket) {
        wsUrls[chain.id] = [
          ...wsUrls[chain.id] || [],
          ...apiConfig.rpcUrls.webSocket
        ];
      }
    }
    if (!configExists) {
      throw new Error(
        [
          `Could not find valid provider configuration for chain "${chain.name}".
`,
          "You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.",
          "Read more: https://wagmi.sh/core/providers/jsonRpc"
        ].join("\n")
      );
    }
  }
  return {
    chains: chains2,
    publicClient: ({ chainId: chainId2 }) => {
      const activeChain = chains2.find((x2) => x2.id === chainId2) ?? defaultChains[0];
      const chainHttpUrls = httpUrls[activeChain.id];
      if (!chainHttpUrls || !chainHttpUrls[0])
        throw new Error(`No providers configured for chain "${activeChain.id}"`);
      const publicClient = createPublicClient({
        batch,
        chain: activeChain,
        transport: fallback(
          chainHttpUrls.map((url) => http(url, { timeout: stallTimeout })),
          { rank, retryCount, retryDelay }
        ),
        pollingInterval
      });
      return Object.assign(publicClient, {
        chains: chains2
      });
    },
    webSocketPublicClient: ({ chainId: chainId2 }) => {
      const activeChain = chains2.find((x2) => x2.id === chainId2) ?? defaultChains[0];
      const chainWsUrls = wsUrls[activeChain.id];
      if (!chainWsUrls || !chainWsUrls[0])
        return void 0;
      const publicClient = createPublicClient({
        batch,
        chain: activeChain,
        transport: fallback(
          chainWsUrls.map((url) => webSocket(url, { timeout: stallTimeout })),
          { rank, retryCount, retryDelay }
        ),
        pollingInterval
      });
      return Object.assign(publicClient, {
        chains: chains2
      });
    }
  };
}
var ChainNotConfiguredError = class extends Error {
  constructor({
    chainId: chainId2,
    connectorId
  }) {
    super(
      `Chain "${chainId2}" not configured${connectorId ? ` for connector "${connectorId}"` : ""}.`
    );
    this.name = "ChainNotConfigured";
  }
};
var ConnectorAlreadyConnectedError = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "ConnectorAlreadyConnectedError";
    this.message = "Connector already connected";
  }
};
var ConfigChainsNotFound = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "ConfigChainsNotFound";
    this.message = "No chains were found on the wagmi config. Some functions that require a chain may not work.";
  }
};
var SwitchChainNotSupportedError = class extends Error {
  constructor({ connector }) {
    super(`"${connector.name}" does not support programmatic chain switching.`);
    this.name = "SwitchChainNotSupportedError";
  }
};
var findAndReplace = (cacheRef, {
  find,
  replace: replace2
}) => {
  if (cacheRef && find(cacheRef)) {
    return replace2(cacheRef);
  }
  if (typeof cacheRef !== "object") {
    return cacheRef;
  }
  if (Array.isArray(cacheRef)) {
    return cacheRef.map((item) => findAndReplace(item, { find, replace: replace2 }));
  }
  if (cacheRef instanceof Object) {
    return Object.entries(cacheRef).reduce(
      (curr, [key2, value]) => ({
        ...curr,
        [key2]: findAndReplace(value, { find, replace: replace2 })
      }),
      {}
    );
  }
  return cacheRef;
};
function deserialize(cachedString) {
  const cache = JSON.parse(cachedString);
  const deserializedCacheWithBigInts = findAndReplace(cache, {
    find: (data2) => typeof data2 === "string" && data2.startsWith("#bigint."),
    replace: (data2) => BigInt(data2.replace("#bigint.", ""))
  });
  return deserializedCacheWithBigInts;
}
function getUnit(unit) {
  if (typeof unit === "number")
    return unit;
  if (unit === "wei")
    return 0;
  return Math.abs(weiUnits[unit]);
}
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join(".") || ".";
}
function getCutoff(array, value) {
  const { length: length2 } = array;
  for (let index2 = 0; index2 < length2; ++index2) {
    if (array[index2] === value) {
      return index2 + 1;
    }
  }
  return 0;
}
function createReplacer(replacer, circularReplacer) {
  const hasReplacer = typeof replacer === "function";
  const hasCircularReplacer = typeof circularReplacer === "function";
  const cache = [];
  const keys = [];
  return function replace2(key2, value) {
    if (typeof value === "object") {
      if (cache.length) {
        const thisCutoff = getCutoff(cache, this);
        if (thisCutoff === 0) {
          cache[cache.length] = this;
        } else {
          cache.splice(thisCutoff);
          keys.splice(thisCutoff);
        }
        keys[keys.length] = key2;
        const valueCutoff = getCutoff(cache, value);
        if (valueCutoff !== 0) {
          return hasCircularReplacer ? circularReplacer.call(
            this,
            key2,
            value,
            getReferenceKey(keys, valueCutoff)
          ) : `[ref=${getReferenceKey(keys, valueCutoff)}]`;
        }
      } else {
        cache[0] = value;
        keys[0] = key2;
      }
    }
    return hasReplacer ? replacer.call(this, key2, value) : value;
  };
}
function serialize(value, replacer, indent2, circularReplacer) {
  return JSON.stringify(
    value,
    createReplacer((key2, value_) => {
      const value2 = typeof value_ === "bigint" ? `#bigint.${value_.toString()}` : value_;
      return replacer?.(key2, value2) || value2;
    }, circularReplacer),
    indent2 ?? void 0
  );
}
var noopStorage = {
  getItem: (_key) => "",
  setItem: (_key, _value) => null,
  removeItem: (_key) => null
};
function createStorage({
  deserialize: deserialize2 = deserialize,
  key: prefix2 = "wagmi",
  serialize: serialize2 = serialize,
  storage
}) {
  return {
    ...storage,
    getItem: (key2, defaultState = null) => {
      const value = storage.getItem(`${prefix2}.${key2}`);
      try {
        return value ? deserialize2(value) : defaultState;
      } catch (error) {
        console.warn(error);
        return defaultState;
      }
    },
    setItem: (key2, value) => {
      if (value === null) {
        storage.removeItem(`${prefix2}.${key2}`);
      } else {
        try {
          storage.setItem(`${prefix2}.${key2}`, serialize2(value));
        } catch (err) {
          console.error(err);
        }
      }
    },
    removeItem: (key2) => storage.removeItem(`${prefix2}.${key2}`)
  };
}
var storeKey = "store";
var _isAutoConnecting, _lastUsedConnector, _addEffects, addEffects_fn;
var Config = class {
  constructor({
    autoConnect = false,
    connectors = [new InjectedConnector()],
    publicClient,
    storage = createStorage({
      storage: typeof window !== "undefined" ? window.localStorage : noopStorage
    }),
    logger: logger2 = {
      warn: console.warn
    },
    webSocketPublicClient
  }) {
    __privateAdd(this, _addEffects);
    this.publicClients = /* @__PURE__ */ new Map();
    this.webSocketPublicClients = /* @__PURE__ */ new Map();
    __privateAdd(this, _isAutoConnecting, void 0);
    __privateAdd(this, _lastUsedConnector, void 0);
    this.args = {
      autoConnect,
      connectors,
      logger: logger2,
      publicClient,
      storage,
      webSocketPublicClient
    };
    let status = "disconnected";
    let chainId2;
    if (autoConnect) {
      try {
        const rawState = storage.getItem(storeKey);
        const data2 = rawState?.state?.data;
        status = data2?.account ? "reconnecting" : "connecting";
        chainId2 = data2?.chain?.id;
      } catch (_error) {
      }
    }
    const connectors_ = typeof connectors === "function" ? connectors() : connectors;
    connectors_.forEach((connector) => connector.setStorage(storage));
    this.store = createStore(
      subscribeWithSelector(
        persist(
          () => ({
            connectors: connectors_,
            publicClient: this.getPublicClient({ chainId: chainId2 }),
            status,
            webSocketPublicClient: this.getWebSocketPublicClient({ chainId: chainId2 })
          }),
          {
            name: storeKey,
            storage,
            partialize: (state2) => ({
              ...autoConnect && {
                data: {
                  account: state2?.data?.account,
                  chain: state2?.data?.chain
                }
              },
              chains: state2?.chains
            }),
            version: 2
          }
        )
      )
    );
    this.storage = storage;
    __privateSet(this, _lastUsedConnector, storage?.getItem("wallet"));
    __privateMethod(this, _addEffects, addEffects_fn).call(this);
    if (autoConnect && typeof window !== "undefined")
      setTimeout(async () => await this.autoConnect(), 0);
  }
  get chains() {
    return this.store.getState().chains;
  }
  get connectors() {
    return this.store.getState().connectors;
  }
  get connector() {
    return this.store.getState().connector;
  }
  get data() {
    return this.store.getState().data;
  }
  get error() {
    return this.store.getState().error;
  }
  get lastUsedChainId() {
    return this.data?.chain?.id;
  }
  get publicClient() {
    return this.store.getState().publicClient;
  }
  get status() {
    return this.store.getState().status;
  }
  get subscribe() {
    return this.store.subscribe;
  }
  get webSocketPublicClient() {
    return this.store.getState().webSocketPublicClient;
  }
  setState(updater) {
    const newState = typeof updater === "function" ? updater(this.store.getState()) : updater;
    this.store.setState(newState, true);
  }
  clearState() {
    this.setState((x2) => ({
      ...x2,
      chains: void 0,
      connector: void 0,
      data: void 0,
      error: void 0,
      status: "disconnected"
    }));
  }
  async destroy() {
    if (this.connector)
      await this.connector.disconnect?.();
    __privateSet(this, _isAutoConnecting, false);
    this.clearState();
    this.store.destroy();
  }
  async autoConnect() {
    if (__privateGet(this, _isAutoConnecting))
      return;
    __privateSet(this, _isAutoConnecting, true);
    this.setState((x2) => ({
      ...x2,
      status: x2.data?.account ? "reconnecting" : "connecting"
    }));
    const sorted = __privateGet(this, _lastUsedConnector) ? [...this.connectors].sort(
      (x2) => x2.id === __privateGet(this, _lastUsedConnector) ? -1 : 1
    ) : this.connectors;
    let connected = false;
    for (const connector of sorted) {
      if (!connector.ready || !connector.isAuthorized)
        continue;
      const isAuthorized = await connector.isAuthorized();
      if (!isAuthorized)
        continue;
      const data2 = await connector.connect();
      this.setState((x2) => ({
        ...x2,
        connector,
        chains: connector?.chains,
        data: data2,
        status: "connected"
      }));
      connected = true;
      break;
    }
    if (!connected)
      this.setState((x2) => ({
        ...x2,
        data: void 0,
        status: "disconnected"
      }));
    __privateSet(this, _isAutoConnecting, false);
    return this.data;
  }
  setConnectors(connectors) {
    this.args = {
      ...this.args,
      connectors
    };
    const connectors_ = typeof connectors === "function" ? connectors() : connectors;
    connectors_.forEach((connector) => connector.setStorage(this.args.storage));
    this.setState((x2) => ({
      ...x2,
      connectors: connectors_
    }));
  }
  getPublicClient({ chainId: chainId2 } = {}) {
    let publicClient_ = this.publicClients.get(-1);
    if (publicClient_ && publicClient_?.chain.id === chainId2)
      return publicClient_;
    publicClient_ = this.publicClients.get(chainId2 ?? -1);
    if (publicClient_)
      return publicClient_;
    const { publicClient } = this.args;
    publicClient_ = typeof publicClient === "function" ? publicClient({ chainId: chainId2 }) : publicClient;
    this.publicClients.set(chainId2 ?? -1, publicClient_);
    return publicClient_;
  }
  setPublicClient(publicClient) {
    const chainId2 = this.data?.chain?.id;
    this.args = {
      ...this.args,
      publicClient
    };
    this.publicClients.clear();
    this.setState((x2) => ({
      ...x2,
      publicClient: this.getPublicClient({ chainId: chainId2 })
    }));
  }
  getWebSocketPublicClient({ chainId: chainId2 } = {}) {
    let webSocketPublicClient_ = this.webSocketPublicClients.get(-1);
    if (webSocketPublicClient_ && webSocketPublicClient_?.chain.id === chainId2)
      return webSocketPublicClient_;
    webSocketPublicClient_ = this.webSocketPublicClients.get(chainId2 ?? -1);
    if (webSocketPublicClient_)
      return webSocketPublicClient_;
    const { webSocketPublicClient } = this.args;
    webSocketPublicClient_ = typeof webSocketPublicClient === "function" ? webSocketPublicClient({ chainId: chainId2 }) : webSocketPublicClient;
    if (webSocketPublicClient_)
      this.webSocketPublicClients.set(chainId2 ?? -1, webSocketPublicClient_);
    return webSocketPublicClient_;
  }
  setWebSocketPublicClient(webSocketPublicClient) {
    const chainId2 = this.data?.chain?.id;
    this.args = {
      ...this.args,
      webSocketPublicClient
    };
    this.webSocketPublicClients.clear();
    this.setState((x2) => ({
      ...x2,
      webSocketPublicClient: this.getWebSocketPublicClient({
        chainId: chainId2
      })
    }));
  }
  setLastUsedConnector(lastUsedConnector = null) {
    this.storage?.setItem("wallet", lastUsedConnector);
  }
};
_isAutoConnecting = /* @__PURE__ */ new WeakMap();
_lastUsedConnector = /* @__PURE__ */ new WeakMap();
_addEffects = /* @__PURE__ */ new WeakSet();
addEffects_fn = function() {
  const onChange = (data2) => {
    this.setState((x2) => ({
      ...x2,
      data: { ...x2.data, ...data2 }
    }));
  };
  const onDisconnect = () => {
    this.clearState();
  };
  const onError = (error) => {
    this.setState((x2) => ({ ...x2, error }));
  };
  this.store.subscribe(
    ({ connector }) => connector,
    (connector, prevConnector) => {
      prevConnector?.off?.("change", onChange);
      prevConnector?.off?.("disconnect", onDisconnect);
      prevConnector?.off?.("error", onError);
      if (!connector)
        return;
      connector.on?.("change", onChange);
      connector.on?.("disconnect", onDisconnect);
      connector.on?.("error", onError);
    }
  );
  const { publicClient, webSocketPublicClient } = this.args;
  const subscribePublicClient = typeof publicClient === "function";
  const subscribeWebSocketPublicClient = typeof webSocketPublicClient === "function";
  if (subscribePublicClient || subscribeWebSocketPublicClient)
    this.store.subscribe(
      ({ data: data2 }) => data2?.chain?.id,
      (chainId2) => {
        this.setState((x2) => ({
          ...x2,
          publicClient: this.getPublicClient({ chainId: chainId2 }),
          webSocketPublicClient: this.getWebSocketPublicClient({
            chainId: chainId2
          })
        }));
      }
    );
};
var config;
function createConfig(args) {
  const config_ = new Config(args);
  config = config_;
  return config_;
}
function getConfig() {
  if (!config) {
    throw new Error(
      "No wagmi config found. Ensure you have set up a config: https://wagmi.sh/react/config"
    );
  }
  return config;
}
async function connect({ chainId: chainId2, connector }) {
  const config2 = getConfig();
  const activeConnector = config2.connector;
  if (activeConnector && connector.id === activeConnector.id)
    throw new ConnectorAlreadyConnectedError();
  try {
    config2.setState((x2) => ({ ...x2, status: "connecting" }));
    const data2 = await connector.connect({ chainId: chainId2 });
    config2.setLastUsedConnector(connector.id);
    config2.setState((x2) => ({
      ...x2,
      connector,
      chains: connector?.chains,
      data: data2,
      status: "connected"
    }));
    config2.storage.setItem("connected", true);
    return { ...data2, connector };
  } catch (err) {
    config2.setState((x2) => {
      return {
        ...x2,
        status: x2.connector ? "connected" : "disconnected"
      };
    });
    throw err;
  }
}
async function disconnect() {
  const config2 = getConfig();
  if (config2.connector)
    await config2.connector.disconnect();
  config2.clearState();
  config2.storage.removeItem("connected");
}
var erc20ABI = [
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "allowance",
    stateMutability: "view",
    inputs: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "spender",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "spender",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [
      {
        name: "account",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "decimals",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ]
  },
  {
    type: "function",
    name: "name",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "string"
      }
    ]
  },
  {
    type: "function",
    name: "symbol",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "string"
      }
    ]
  },
  {
    type: "function",
    name: "totalSupply",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  }
];
var erc20ABI_bytes32 = [
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "allowance",
    stateMutability: "view",
    inputs: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "spender",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "spender",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [
      {
        name: "account",
        type: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "decimals",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ]
  },
  {
    type: "function",
    name: "name",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32"
      }
    ]
  },
  {
    type: "function",
    name: "symbol",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32"
      }
    ]
  },
  {
    type: "function",
    name: "totalSupply",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  }
];
function getPublicClient({ chainId: chainId2 } = {}) {
  const config2 = getConfig();
  if (chainId2)
    return config2.getPublicClient({ chainId: chainId2 }) || config2.publicClient;
  return config2.publicClient;
}
async function getWalletClient({
  chainId: chainId2
} = {}) {
  const config2 = getConfig();
  const walletClient = await config2.connector?.getWalletClient?.({ chainId: chainId2 }) || null;
  return walletClient;
}
async function multicall({
  chainId: chainId2,
  contracts,
  blockNumber,
  blockTag,
  ...args
}) {
  const publicClient = getPublicClient({ chainId: chainId2 });
  if (!publicClient.chains)
    throw new ConfigChainsNotFound();
  if (chainId2 && publicClient.chain.id !== chainId2)
    throw new ChainNotConfiguredError({ chainId: chainId2 });
  return publicClient.multicall({
    allowFailure: args.allowFailure ?? true,
    blockNumber,
    blockTag,
    contracts
  });
}
async function readContract({
  address,
  account,
  chainId: chainId2,
  abi: abi2,
  args,
  functionName,
  blockNumber,
  blockTag
}) {
  const publicClient = getPublicClient({ chainId: chainId2 });
  return publicClient.readContract({
    abi: abi2,
    address,
    account,
    functionName,
    args,
    blockNumber,
    blockTag
  });
}
async function readContracts({
  contracts,
  blockNumber,
  blockTag,
  ...args
}) {
  const { allowFailure = true } = args;
  try {
    const publicClient = getPublicClient();
    const contractsByChainId = contracts.reduce((contracts2, contract, index2) => {
      const chainId2 = contract.chainId ?? publicClient.chain.id;
      return {
        ...contracts2,
        [chainId2]: [...contracts2[chainId2] || [], { contract, index: index2 }]
      };
    }, {});
    const promises = () => Object.entries(contractsByChainId).map(
      ([chainId2, contracts2]) => multicall({
        allowFailure,
        chainId: parseInt(chainId2),
        contracts: contracts2.map(
          ({ contract }) => contract
        ),
        blockNumber,
        blockTag
      })
    );
    const multicallResults = (await Promise.all(promises())).flat();
    const resultIndexes = Object.values(contractsByChainId).flatMap(
      (contracts2) => contracts2.map(({ index: index2 }) => index2)
    );
    return multicallResults.reduce((results, result, index2) => {
      if (results)
        results[resultIndexes[index2]] = result;
      return results;
    }, []);
  } catch (err) {
    if (err instanceof ContractFunctionExecutionError)
      throw err;
    const promises = () => contracts.map(
      (contract) => readContract({ ...contract, blockNumber, blockTag })
    );
    if (allowFailure)
      return (await Promise.allSettled(promises())).map((result) => {
        if (result.status === "fulfilled")
          return { result: result.value, status: "success" };
        return { error: result.reason, result: void 0, status: "failure" };
      });
    return await Promise.all(promises());
  }
}
async function fetchBalance({
  address,
  chainId: chainId2,
  formatUnits: unit,
  token: token2
}) {
  const config2 = getConfig();
  const publicClient = getPublicClient({ chainId: chainId2 });
  if (token2) {
    const fetchContractBalance = async ({ abi: abi2 }) => {
      const erc20Config = { abi: abi2, address: token2, chainId: chainId2 };
      const [value2, decimals, symbol] = await readContracts({
        allowFailure: false,
        contracts: [
          {
            ...erc20Config,
            functionName: "balanceOf",
            args: [address]
          },
          { ...erc20Config, functionName: "decimals" },
          { ...erc20Config, functionName: "symbol" }
        ]
      });
      return {
        decimals,
        formatted: formatUnits(value2 ?? "0", getUnit(unit ?? decimals)),
        symbol,
        value: value2
      };
    };
    try {
      return await fetchContractBalance({ abi: erc20ABI });
    } catch (err) {
      if (err instanceof ContractFunctionExecutionError) {
        const { symbol, ...rest } = await fetchContractBalance({
          abi: erc20ABI_bytes32
        });
        return {
          symbol: hexToString(trim(symbol, { dir: "right" })),
          ...rest
        };
      }
      throw err;
    }
  }
  const chains2 = [
    ...config2.publicClient.chains || [],
    ...config2.chains ?? []
  ];
  const value = await publicClient.getBalance({ address });
  const chain = chains2.find((x2) => x2.id === publicClient.chain.id);
  return {
    decimals: chain?.nativeCurrency.decimals ?? 18,
    formatted: formatUnits(value ?? "0", getUnit(unit ?? 18)),
    symbol: chain?.nativeCurrency.symbol ?? "ETH",
    value
  };
}
function getAccount() {
  const { data: data2, connector, status } = getConfig();
  switch (status) {
    case "connected":
      return {
        address: data2?.account,
        connector,
        isConnected: true,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "reconnecting":
      return {
        address: data2?.account,
        connector,
        isConnected: !!data2?.account,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: true,
        status
      };
    case "connecting":
      return {
        address: data2?.account,
        connector,
        isConnected: false,
        isConnecting: true,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "disconnected":
      return {
        address: void 0,
        connector: void 0,
        isConnected: false,
        isConnecting: false,
        isDisconnected: true,
        isReconnecting: false,
        status
      };
  }
}
function getNetwork() {
  const config2 = getConfig();
  const chainId2 = config2.data?.chain?.id;
  const activeChains = config2.chains ?? [];
  const activeChain = [
    ...config2.publicClient?.chains || [],
    ...activeChains
  ].find((x2) => x2.id === chainId2) ?? {
    id: chainId2,
    name: `Chain ${chainId2}`,
    network: `${chainId2}`,
    nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
    rpcUrls: {
      default: { http: [""] },
      public: { http: [""] }
    }
  };
  return {
    chain: chainId2 ? {
      ...activeChain,
      ...config2.data?.chain,
      id: chainId2
    } : void 0,
    chains: activeChains
  };
}
async function signMessage(args) {
  const walletClient = await getWalletClient();
  if (!walletClient)
    throw new ConnectorNotFoundError();
  return await walletClient.signMessage({
    message: args.message
  });
}
async function switchNetwork({
  chainId: chainId2
}) {
  const { connector } = getConfig();
  if (!connector)
    throw new ConnectorNotFoundError();
  if (!connector.switchChain)
    throw new SwitchChainNotSupportedError({
      connector
    });
  return connector.switchChain(chainId2);
}
function watchAccount(callback, { selector = (x2) => x2 } = {}) {
  const config2 = getConfig();
  const handleChange = () => callback(getAccount());
  const unsubscribe = config2.subscribe(
    ({ data: data2, connector, status }) => selector({
      address: data2?.account,
      connector,
      status
    }),
    handleChange,
    {
      equalityFn: shallow$1
    }
  );
  return unsubscribe;
}
function watchNetwork(callback, { selector = (x2) => x2 } = {}) {
  const config2 = getConfig();
  const handleChange = () => callback(getNetwork());
  const unsubscribe = config2.subscribe(
    ({ data: data2, chains: chains2 }) => selector({ chainId: data2?.chain?.id, chains: chains2 }),
    handleChange,
    {
      equalityFn: shallow$1
    }
  );
  return unsubscribe;
}
async function fetchEnsAvatar({
  name: name2,
  chainId: chainId2
}) {
  const { normalize: normalize2 } = await __vitePreload(() => import("./index--JK178hv.js"), true ? __vite__mapDeps([]) : void 0);
  const publicClient = getPublicClient({ chainId: chainId2 });
  const avatar = await publicClient.getEnsAvatar({ name: normalize2(name2) });
  return avatar;
}
async function fetchEnsName({
  address,
  chainId: chainId2
}) {
  const publicClient = getPublicClient({ chainId: chainId2 });
  return publicClient.getEnsName({
    address: getAddress(address)
  });
}
const t$6 = Symbol();
const s$8 = Object.getPrototypeOf, c$8 = /* @__PURE__ */ new WeakMap(), l$4 = (e2) => e2 && (c$8.has(e2) ? c$8.get(e2) : s$8(e2) === Object.prototype || s$8(e2) === Array.prototype), y$4 = (e2) => l$4(e2) && e2[t$6] || null, h$9 = (e2, t2 = true) => {
  c$8.set(e2, t2);
};
var define_import_meta_env_default = { VITE_REACT_PROJECTID: "05c6fd6b3708f60c6c5dcdd31968eeef", VITE_REACT_STAKING_CONTRACT_ADDRESS: "0xfB528B5905C8f9398fb625Ab4155C567A75cCC9F", VITE_REACT_STAKE_TOKEN_CONTRACT_ADDRESS: "0x5263fdc29e84891ded4e0fb8be4084398d9a6e84", VITE_REACT_V3_SWAP_ROUTER_ADDRESS: "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45", VITE_REACT_TESTNET_URL: "https://holesky-fullnode-testnet.rpc.grove.city/v1/e62fd814", VITE_REACT_CHAIN_ID: "3", VITE_REACT_ADDRESS0: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", VITE_REACT_ADDRESS1: "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984", BASE_URL: "/", MODE: "production", DEV: false, PROD: true, SSR: false };
const isObject = (x2) => typeof x2 === "object" && x2 !== null;
const proxyStateMap = /* @__PURE__ */ new WeakMap();
const refSet = /* @__PURE__ */ new WeakSet();
const buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x2) => isObject(x2) && !refSet.has(x2) && (Array.isArray(x2) || !(Symbol.iterator in x2)) && !(x2 instanceof WeakMap) && !(x2 instanceof WeakSet) && !(x2 instanceof Error) && !(x2 instanceof Number) && !(x2 instanceof Date) && !(x2 instanceof String) && !(x2 instanceof RegExp) && !(x2 instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version2, handlePromise = defaultHandlePromise) => {
  const cache = snapCache.get(target);
  if ((cache == null ? void 0 : cache[0]) === version2) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  h$9(snap, true);
  snapCache.set(target, [version2, snap]);
  Reflect.ownKeys(target).forEach((key2) => {
    if (Object.getOwnPropertyDescriptor(snap, key2)) {
      return;
    }
    const value = Reflect.get(target, key2);
    const desc = {
      value,
      enumerable: true,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: true
    };
    if (refSet.has(value)) {
      h$9(value, false);
    } else if (value instanceof Promise) {
      delete desc.value;
      desc.get = () => handlePromise(value);
    } else if (proxyStateMap.has(value)) {
      const [target2, ensureVersion] = proxyStateMap.get(
        value
      );
      desc.value = createSnapshot(
        target2,
        ensureVersion(),
        handlePromise
      );
    }
    Object.defineProperty(snap, key2, desc);
  });
  return Object.preventExtensions(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction = (initialObject) => {
  if (!isObject(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version2 = versionHolder[0];
  const listeners2 = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version2 !== nextVersion) {
      version2 = nextVersion;
      listeners2.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners2.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version2) {
          version2 = propVersion;
        }
      });
    }
    return version2;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if ((define_import_meta_env_default ? "production" : void 0) !== "production" && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners2.size) {
      const remove = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a = entry[1]) == null ? void 0 : _a.call(entry);
    }
  };
  const addListener2 = (listener) => {
    listeners2.add(listener);
    if (listeners2.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if ((define_import_meta_env_default ? "production" : void 0) !== "production" && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      });
    }
    const removeListener2 = () => {
      listeners2.delete(listener);
      if (listeners2.size === 0) {
        propProxyStates.forEach(([propProxyState, remove], prop) => {
          if (remove) {
            remove();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener2;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject(value)) {
        value = y$4(value) || value;
      }
      let nextValue = value;
      if (value instanceof Promise) {
        value.then((v2) => {
          value.status = "fulfilled";
          value.value = v2;
          notifyUpdate(["resolve", [prop], v2]);
        }).catch((e2) => {
          value.status = "rejected";
          value.reason = e2;
          notifyUpdate(["reject", [prop], e2]);
        });
      } else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxyFunction(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [
    baseObject,
    ensureVersion,
    createSnapshot,
    addListener2
  ];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key2) => {
    const desc = Object.getOwnPropertyDescriptor(
      initialObject,
      key2
    );
    if ("value" in desc) {
      proxyObject[key2] = initialObject[key2];
      delete desc.value;
      delete desc.writable;
    }
    Object.defineProperty(baseObject, key2, desc);
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
const [defaultProxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return defaultProxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((define_import_meta_env_default ? "production" : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener2 = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener2 = addListener2(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener2();
  };
}
function snapshot(proxyObject, handlePromise) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((define_import_meta_env_default ? "production" : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}
function subscribeKey(proxyObject, key2, callback, notifyInSync) {
  let prevValue = proxyObject[key2];
  return subscribe(
    proxyObject,
    () => {
      const nextValue = proxyObject[key2];
      if (!Object.is(prevValue, nextValue)) {
        callback(prevValue = nextValue);
      }
    },
    notifyInSync
  );
}
const SECURE_SITE = "https://secure.web3modal.com";
const ConstantsUtil$1 = {
  FOUR_MINUTES_MS: 24e4,
  TEN_SEC_MS: 1e4,
  ONE_SEC_MS: 1e3,
  SECURE_SITE,
  SECURE_SITE_DASHBOARD: `${SECURE_SITE}/dashboard`,
  SECURE_SITE_FAVICON: `${SECURE_SITE}/images/favicon.png`,
  RESTRICTED_TIMEZONES: [
    "ASIA/SHANGHAI",
    "ASIA/URUMQI",
    "ASIA/CHONGQING",
    "ASIA/HARBIN",
    "ASIA/KASHGAR",
    "ASIA/MACAU",
    "ASIA/HONG_KONG",
    "ASIA/MACAO",
    "ASIA/BEIJING",
    "ASIA/HARBIN"
  ],
  CONNECTOR_RDNS_MAP: {
    coinbaseWallet: "com.coinbase.wallet"
  }
};
const CoreHelperUtil = {
  isMobile() {
    if (typeof window !== "undefined") {
      return Boolean(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent));
    }
    return false;
  },
  isAndroid() {
    const ua2 = window.navigator.userAgent.toLowerCase();
    return CoreHelperUtil.isMobile() && ua2.includes("android");
  },
  isIos() {
    const ua2 = window.navigator.userAgent.toLowerCase();
    return CoreHelperUtil.isMobile() && (ua2.includes("iphone") || ua2.includes("ipad"));
  },
  isClient() {
    return typeof window !== "undefined";
  },
  isPairingExpired(expiry) {
    return expiry ? expiry - Date.now() <= ConstantsUtil$1.TEN_SEC_MS : true;
  },
  isAllowedRetry(lastRetry) {
    return Date.now() - lastRetry >= ConstantsUtil$1.ONE_SEC_MS;
  },
  copyToClopboard(text) {
    navigator.clipboard.writeText(text);
  },
  getPairingExpiry() {
    return Date.now() + ConstantsUtil$1.FOUR_MINUTES_MS;
  },
  getPlainAddress(caipAddress) {
    return caipAddress.split(":")[2];
  },
  async wait(milliseconds) {
    return new Promise((resolve) => {
      setTimeout(resolve, milliseconds);
    });
  },
  debounce(func, timeout = 500) {
    let timer2 = void 0;
    return (...args) => {
      function next2() {
        func(...args);
      }
      if (timer2) {
        clearTimeout(timer2);
      }
      timer2 = setTimeout(next2, timeout);
    };
  },
  isHttpUrl(url) {
    return url.startsWith("http://") || url.startsWith("https://");
  },
  formatNativeUrl(appUrl, wcUri) {
    if (CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatUniversalUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.includes("://")) {
      safeAppUrl = appUrl.replaceAll("/", "").replaceAll(":", "");
      safeAppUrl = `${safeAppUrl}://`;
    }
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  formatUniversalUrl(appUrl, wcUri) {
    if (!CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatNativeUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  openHref(href, target) {
    window.open(href, target, "noreferrer noopener");
  },
  async preloadImage(src2) {
    const imagePromise = new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = resolve;
      image.onerror = reject;
      image.crossOrigin = "anonymous";
      image.src = src2;
    });
    return Promise.race([imagePromise, CoreHelperUtil.wait(2e3)]);
  },
  formatBalance(balance, symbol) {
    let formattedBalance = void 0;
    if (balance === "0") {
      formattedBalance = "0.000";
    } else if (typeof balance === "string") {
      const number2 = Number(balance);
      if (number2) {
        formattedBalance = number2.toString().match(/^-?\d+(?:\.\d{0,3})?/u)?.[0];
      }
    }
    return formattedBalance ? `${formattedBalance} ${symbol}` : `0.000 ${symbol}`;
  },
  isRestrictedRegion() {
    try {
      const { timeZone } = new Intl.DateTimeFormat().resolvedOptions();
      const capTimeZone = timeZone.toUpperCase();
      return ConstantsUtil$1.RESTRICTED_TIMEZONES.includes(capTimeZone);
    } catch {
      return false;
    }
  },
  getApiUrl() {
    return CoreHelperUtil.isRestrictedRegion() ? "https://api.web3modal.org" : "https://api.web3modal.com";
  },
  getBlockchainApiUrl() {
    return CoreHelperUtil.isRestrictedRegion() ? "https://rpc.walletconnect.org" : "https://rpc.walletconnect.com";
  },
  getAnalyticsUrl() {
    return CoreHelperUtil.isRestrictedRegion() ? "https://pulse.walletconnect.org" : "https://pulse.walletconnect.com";
  },
  getUUID() {
    if (crypto?.randomUUID) {
      return crypto.randomUUID();
    }
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (c2) => {
      const r2 = Math.random() * 16 | 0;
      const v2 = c2 === "x" ? r2 : r2 & 3 | 8;
      return v2.toString(16);
    });
  },
  parseError(error) {
    if (typeof error === "string") {
      return error;
    } else if (typeof error?.issues?.[0]?.message === "string") {
      return error.issues[0].message;
    } else if (error instanceof Error) {
      return error.message;
    }
    return "Unknown error";
  }
};
const state$e = proxy({
  isConnected: false
});
const AccountController = {
  state: state$e,
  subscribe(callback) {
    return subscribe(state$e, () => callback(state$e));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$e, key2, callback);
  },
  setIsConnected(isConnected) {
    state$e.isConnected = isConnected;
  },
  setCaipAddress(caipAddress) {
    state$e.caipAddress = caipAddress;
    state$e.address = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
  },
  setBalance(balance, balanceSymbol) {
    state$e.balance = balance;
    state$e.balanceSymbol = balanceSymbol;
  },
  setProfileName(profileName) {
    state$e.profileName = profileName;
  },
  setProfileImage(profileImage) {
    state$e.profileImage = profileImage;
  },
  setAddressExplorerUrl(explorerUrl) {
    state$e.addressExplorerUrl = explorerUrl;
  },
  resetAccount() {
    state$e.isConnected = false;
    state$e.caipAddress = void 0;
    state$e.address = void 0;
    state$e.balance = void 0;
    state$e.balanceSymbol = void 0;
    state$e.profileName = void 0;
    state$e.profileImage = void 0;
    state$e.addressExplorerUrl = void 0;
  }
};
class FetchUtil {
  constructor({ baseUrl: baseUrl2 }) {
    this.baseUrl = baseUrl2;
  }
  async get({ headers, ...args }) {
    const url = this.createUrl(args);
    const response = await fetch(url, { method: "GET", headers });
    return response.json();
  }
  async getBlob({ headers, ...args }) {
    const url = this.createUrl(args);
    const response = await fetch(url, { method: "GET", headers });
    return response.blob();
  }
  async post({ body: body2, headers, ...args }) {
    const url = this.createUrl(args);
    const response = await fetch(url, {
      method: "POST",
      headers,
      body: body2 ? JSON.stringify(body2) : void 0
    });
    return response.json();
  }
  async put({ body: body2, headers, ...args }) {
    const url = this.createUrl(args);
    const response = await fetch(url, {
      method: "PUT",
      headers,
      body: body2 ? JSON.stringify(body2) : void 0
    });
    return response.json();
  }
  async delete({ body: body2, headers, ...args }) {
    const url = this.createUrl(args);
    const response = await fetch(url, {
      method: "DELETE",
      headers,
      body: body2 ? JSON.stringify(body2) : void 0
    });
    return response.json();
  }
  createUrl({ path, params }) {
    const url = new URL(path, this.baseUrl);
    if (params) {
      Object.entries(params).forEach(([key2, value]) => {
        if (value) {
          url.searchParams.append(key2, value);
        }
      });
    }
    return url;
  }
}
const WC_DEEPLINK = "WALLETCONNECT_DEEPLINK_CHOICE";
const W3M_RECENT = "@w3m/recent";
const W3M_CONNECTED_WALLET_IMAGE_URL = "@w3m/connected_wallet_image_url";
const W3M_CONNECTED_CONNECTOR = "@w3m/connected_connector";
const StorageUtil = {
  setWalletConnectDeepLink({ href, name: name2 }) {
    try {
      localStorage.setItem(WC_DEEPLINK, JSON.stringify({ href, name: name2 }));
    } catch {
      console.info("Unable to set WalletConnect deep link");
    }
  },
  getWalletConnectDeepLink() {
    try {
      const deepLink = localStorage.getItem(WC_DEEPLINK);
      if (deepLink) {
        return JSON.parse(deepLink);
      }
    } catch {
      console.info("Unable to get WalletConnect deep link");
    }
    return void 0;
  },
  deleteWalletConnectDeepLink() {
    try {
      localStorage.removeItem(WC_DEEPLINK);
    } catch {
      console.info("Unable to delete WalletConnect deep link");
    }
  },
  setWeb3ModalRecent(wallet) {
    try {
      const recentWallets = StorageUtil.getRecentWallets();
      const exists2 = recentWallets.find((w2) => w2.id === wallet.id);
      if (!exists2) {
        recentWallets.unshift(wallet);
        if (recentWallets.length > 2) {
          recentWallets.pop();
        }
        localStorage.setItem(W3M_RECENT, JSON.stringify(recentWallets));
      }
    } catch {
      console.info("Unable to set Web3Modal recent");
    }
  },
  getRecentWallets() {
    try {
      const recent = localStorage.getItem(W3M_RECENT);
      return recent ? JSON.parse(recent) : [];
    } catch {
      console.info("Unable to get Web3Modal recent");
    }
    return [];
  },
  setConnectedWalletImageUrl(imageUrl) {
    try {
      localStorage.setItem(W3M_CONNECTED_WALLET_IMAGE_URL, imageUrl);
    } catch {
      console.info("Unable to set Connected Wallet Image Url");
    }
  },
  getConnectedWalletImageUrl() {
    try {
      return localStorage.getItem(W3M_CONNECTED_WALLET_IMAGE_URL);
    } catch {
      console.info("Unable to set Connected Wallet Image Url");
    }
    return void 0;
  },
  setConnectedConnector(connectorType) {
    try {
      localStorage.setItem(W3M_CONNECTED_CONNECTOR, connectorType);
    } catch {
      console.info("Unable to set Connected Connector");
    }
  },
  getConnectedConnector() {
    try {
      return localStorage.getItem(W3M_CONNECTED_CONNECTOR);
    } catch {
      console.info("Unable to get Connected Connector");
    }
    return void 0;
  }
};
const state$d = proxy({
  walletImages: {},
  networkImages: {},
  connectorImages: {},
  tokenImages: {}
});
const AssetController = {
  state: state$d,
  subscribeNetworkImages(callback) {
    return subscribe(state$d.networkImages, () => callback(state$d.networkImages));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$d, key2, callback);
  },
  setWalletImage(key2, value) {
    state$d.walletImages[key2] = value;
  },
  setNetworkImage(key2, value) {
    state$d.networkImages[key2] = value;
  },
  setConnectorImage(key2, value) {
    state$d.connectorImages[key2] = value;
  },
  setTokenImage(key2, value) {
    state$d.tokenImages[key2] = value;
  }
};
const state$c = proxy({
  projectId: "",
  sdkType: "w3m",
  sdkVersion: "html-wagmi-undefined"
});
const OptionsController = {
  state: state$c,
  subscribeKey(key2, callback) {
    return subscribeKey(state$c, key2, callback);
  },
  setProjectId(projectId2) {
    state$c.projectId = projectId2;
  },
  setIncludeWalletIds(includeWalletIds) {
    state$c.includeWalletIds = includeWalletIds;
  },
  setExcludeWalletIds(excludeWalletIds) {
    state$c.excludeWalletIds = excludeWalletIds;
  },
  setFeaturedWalletIds(featuredWalletIds) {
    state$c.featuredWalletIds = featuredWalletIds;
  },
  setTokens(tokens2) {
    state$c.tokens = tokens2;
  },
  setTermsConditionsUrl(termsConditionsUrl) {
    state$c.termsConditionsUrl = termsConditionsUrl;
  },
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    state$c.privacyPolicyUrl = privacyPolicyUrl;
  },
  setCustomWallets(customWallets) {
    state$c.customWallets = customWallets;
  },
  setEnableAnalytics(enableAnalytics) {
    state$c.enableAnalytics = enableAnalytics;
  },
  setSdkVersion(sdkVersion) {
    state$c.sdkVersion = sdkVersion;
  },
  setMetadata(metadata2) {
    state$c.metadata = metadata2;
  }
};
const state$b = proxy({
  connectors: []
});
const ConnectorController = {
  state: state$b,
  subscribeKey(key2, callback) {
    return subscribeKey(state$b, key2, callback);
  },
  setConnectors(connectors) {
    state$b.connectors = connectors.map((c2) => ref(c2));
  },
  addConnector(connector) {
    state$b.connectors.push(ref(connector));
    if (connector.id === "w3mEmail") {
      const emailConnector = connector;
      const optionsState = snapshot(OptionsController.state);
      emailConnector?.provider?.syncDappData?.({
        metadata: optionsState.metadata,
        sdkVersion: optionsState.sdkVersion,
        projectId: optionsState.projectId
      });
    }
  },
  getEmailConnector() {
    return state$b.connectors.find((c2) => c2.type === "EMAIL");
  },
  getAnnouncedConnectorRdns() {
    return state$b.connectors.filter((c2) => c2.type === "ANNOUNCED").map((c2) => c2.info?.rdns);
  },
  getConnectors() {
    return state$b.connectors;
  }
};
const state$a = proxy({
  open: false,
  selectedNetworkId: void 0
});
const PublicStateController = {
  state: state$a,
  subscribe(callback) {
    return subscribe(state$a, () => callback(state$a));
  },
  set(newState) {
    Object.assign(state$a, { ...state$a, ...newState });
  }
};
const state$9 = proxy({
  supportsAllNetworks: true,
  isDefaultCaipNetwork: false
});
const NetworkController = {
  state: state$9,
  subscribeKey(key2, callback) {
    return subscribeKey(state$9, key2, callback);
  },
  _getClient() {
    if (!state$9._client) {
      throw new Error("NetworkController client not set");
    }
    return state$9._client;
  },
  setClient(client2) {
    state$9._client = ref(client2);
  },
  setCaipNetwork(caipNetwork) {
    state$9.caipNetwork = caipNetwork;
    PublicStateController.set({ selectedNetworkId: caipNetwork?.id });
  },
  setDefaultCaipNetwork(caipNetwork) {
    state$9.caipNetwork = caipNetwork;
    PublicStateController.set({ selectedNetworkId: caipNetwork?.id });
    state$9.isDefaultCaipNetwork = true;
  },
  setRequestedCaipNetworks(requestedNetworks) {
    state$9.requestedCaipNetworks = requestedNetworks;
  },
  async getApprovedCaipNetworksData() {
    const data2 = await this._getClient().getApprovedCaipNetworksData();
    state$9.supportsAllNetworks = data2.supportsAllNetworks;
    state$9.approvedCaipNetworkIds = data2.approvedCaipNetworkIds;
  },
  async switchActiveNetwork(network) {
    await this._getClient().switchCaipNetwork(network);
    state$9.caipNetwork = network;
  },
  resetNetwork() {
    if (!state$9.isDefaultCaipNetwork) {
      state$9.caipNetwork = void 0;
    }
    state$9.approvedCaipNetworkIds = void 0;
    state$9.supportsAllNetworks = true;
  }
};
const baseUrl$2 = CoreHelperUtil.getApiUrl();
const api$2 = new FetchUtil({ baseUrl: baseUrl$2 });
const entries = "40";
const recommendedEntries = "4";
const state$8 = proxy({
  page: 1,
  count: 0,
  featured: [],
  recommended: [],
  wallets: [],
  search: []
});
const ApiController = {
  state: state$8,
  subscribeKey(key2, callback) {
    return subscribeKey(state$8, key2, callback);
  },
  _getApiHeaders() {
    const { projectId: projectId2, sdkType, sdkVersion } = OptionsController.state;
    return {
      "x-project-id": projectId2,
      "x-sdk-type": sdkType,
      "x-sdk-version": sdkVersion
    };
  },
  async _fetchWalletImage(imageId) {
    const imageUrl = `${api$2.baseUrl}/getWalletImage/${imageId}`;
    const blob = await api$2.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setWalletImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchNetworkImage(imageId) {
    const imageUrl = `${api$2.baseUrl}/public/getAssetImage/${imageId}`;
    const blob = await api$2.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setNetworkImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchConnectorImage(imageId) {
    const imageUrl = `${api$2.baseUrl}/public/getAssetImage/${imageId}`;
    const blob = await api$2.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setConnectorImage(imageId, URL.createObjectURL(blob));
  },
  async fetchNetworkImages() {
    const { requestedCaipNetworks } = NetworkController.state;
    const ids = requestedCaipNetworks?.map(({ imageId }) => imageId).filter(Boolean);
    if (ids) {
      await Promise.allSettled(ids.map((id2) => ApiController._fetchNetworkImage(id2)));
    }
  },
  async fetchConnectorImages() {
    const { connectors } = ConnectorController.state;
    const ids = connectors.map(({ imageId }) => imageId).filter(Boolean);
    await Promise.allSettled(ids.map((id2) => ApiController._fetchConnectorImage(id2)));
  },
  async fetchFeaturedWallets() {
    const { featuredWalletIds } = OptionsController.state;
    if (featuredWalletIds?.length) {
      const { data: data2 } = await api$2.get({
        path: "/getWallets",
        headers: ApiController._getApiHeaders(),
        params: {
          page: "1",
          entries: featuredWalletIds?.length ? String(featuredWalletIds.length) : recommendedEntries,
          include: featuredWalletIds?.join(",")
        }
      });
      data2.sort((a2, b3) => featuredWalletIds.indexOf(a2.id) - featuredWalletIds.indexOf(b3.id));
      const images = data2.map((d2) => d2.image_id).filter(Boolean);
      await Promise.allSettled(images.map((id2) => ApiController._fetchWalletImage(id2)));
      state$8.featured = data2;
    }
  },
  async fetchRecommendedWallets() {
    const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
    const exclude = [...excludeWalletIds ?? [], ...featuredWalletIds ?? []].filter(Boolean);
    const { data: data2, count } = await api$2.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: "1",
        entries: recommendedEntries,
        include: includeWalletIds?.join(","),
        exclude: exclude?.join(",")
      }
    });
    const recent = StorageUtil.getRecentWallets();
    const recommendedImages = data2.map((d2) => d2.image_id).filter(Boolean);
    const recentImages = recent.map((r2) => r2.image_id).filter(Boolean);
    await Promise.allSettled([...recommendedImages, ...recentImages].map((id2) => ApiController._fetchWalletImage(id2)));
    state$8.recommended = data2;
    state$8.count = count ?? 0;
  },
  async fetchWallets({ page }) {
    const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
    const exclude = [
      ...state$8.recommended.map(({ id: id2 }) => id2),
      ...excludeWalletIds ?? [],
      ...featuredWalletIds ?? []
    ].filter(Boolean);
    const { data: data2, count } = await api$2.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: String(page),
        entries,
        include: includeWalletIds?.join(","),
        exclude: exclude.join(",")
      }
    });
    const images = data2.map((w2) => w2.image_id).filter(Boolean);
    await Promise.allSettled([
      ...images.map((id2) => ApiController._fetchWalletImage(id2)),
      CoreHelperUtil.wait(300)
    ]);
    state$8.wallets = [...state$8.wallets, ...data2];
    state$8.count = count > state$8.count ? count : state$8.count;
    state$8.page = page;
  },
  async searchWallet({ search }) {
    const { includeWalletIds, excludeWalletIds } = OptionsController.state;
    state$8.search = [];
    const { data: data2 } = await api$2.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: "1",
        entries: "100",
        search,
        include: includeWalletIds?.join(","),
        exclude: excludeWalletIds?.join(",")
      }
    });
    const images = data2.map((w2) => w2.image_id).filter(Boolean);
    await Promise.allSettled([
      ...images.map((id2) => ApiController._fetchWalletImage(id2)),
      CoreHelperUtil.wait(300)
    ]);
    state$8.search = data2;
  },
  prefetch() {
    state$8.prefetchPromise = Promise.race([
      Promise.allSettled([
        ApiController.fetchFeaturedWallets(),
        ApiController.fetchRecommendedWallets(),
        ApiController.fetchNetworkImages(),
        ApiController.fetchConnectorImages()
      ]),
      CoreHelperUtil.wait(3e3)
    ]);
  }
};
const baseUrl$1 = CoreHelperUtil.getAnalyticsUrl();
const api$1 = new FetchUtil({ baseUrl: baseUrl$1 });
const excluded = ["MODAL_CREATED"];
const state$7 = proxy({
  timestamp: Date.now(),
  data: {
    type: "track",
    event: "MODAL_CREATED"
  }
});
const EventsController = {
  state: state$7,
  subscribe(callback) {
    return subscribe(state$7, () => callback(state$7));
  },
  _getApiHeaders() {
    const { projectId: projectId2, sdkType, sdkVersion } = OptionsController.state;
    return {
      "x-project-id": projectId2,
      "x-sdk-type": sdkType,
      "x-sdk-version": sdkVersion
    };
  },
  async _sendAnalyticsEvent(payload) {
    try {
      if (excluded.includes(payload.data.event) || typeof window === "undefined") {
        return;
      }
      await api$1.post({
        path: "/e",
        headers: EventsController._getApiHeaders(),
        body: {
          eventId: CoreHelperUtil.getUUID(),
          url: window.location.href,
          domain: window.location.hostname,
          timestamp: payload.timestamp,
          props: payload.data
        }
      });
    } catch {
    }
  },
  sendEvent(data2) {
    state$7.timestamp = Date.now();
    state$7.data = data2;
    if (OptionsController.state.enableAnalytics) {
      EventsController._sendAnalyticsEvent(state$7);
    }
  }
};
const state$6 = proxy({
  view: "Connect",
  history: ["Connect"]
});
const RouterController = {
  state: state$6,
  subscribeKey(key2, callback) {
    return subscribeKey(state$6, key2, callback);
  },
  push(view, data2) {
    if (view !== state$6.view) {
      state$6.view = view;
      state$6.history.push(view);
      state$6.data = data2;
    }
  },
  reset(view) {
    state$6.view = view;
    state$6.history = [view];
  },
  replace(view, data2) {
    if (state$6.history.length > 1 && state$6.history.at(-1) !== view) {
      state$6.view = view;
      state$6.history[state$6.history.length - 1] = view;
      state$6.data = data2;
    }
  },
  goBack() {
    if (state$6.history.length > 1) {
      state$6.history.pop();
      const [last] = state$6.history.slice(-1);
      if (last) {
        state$6.view = last;
      }
    }
  },
  goBackToIndex(historyIndex) {
    if (state$6.history.length > 1) {
      state$6.history = state$6.history.slice(0, historyIndex + 1);
      const [last] = state$6.history.slice(-1);
      if (last) {
        state$6.view = last;
      }
    }
  }
};
const state$5 = proxy({
  loading: false,
  open: false
});
const ModalController = {
  state: state$5,
  subscribe(callback) {
    return subscribe(state$5, () => callback(state$5));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$5, key2, callback);
  },
  async open(options) {
    await ApiController.state.prefetchPromise;
    if (options?.view) {
      RouterController.reset(options.view);
    } else if (AccountController.state.isConnected) {
      RouterController.reset("Account");
    } else {
      RouterController.reset("Connect");
    }
    state$5.open = true;
    PublicStateController.set({ open: true });
    EventsController.sendEvent({ type: "track", event: "MODAL_OPEN" });
  },
  close() {
    state$5.open = false;
    PublicStateController.set({ open: false });
    EventsController.sendEvent({ type: "track", event: "MODAL_CLOSE" });
  },
  setLoading(loading) {
    state$5.loading = loading;
  }
};
const baseUrl = CoreHelperUtil.getBlockchainApiUrl();
const api = new FetchUtil({ baseUrl });
const BlockchainApiController = {
  fetchIdentity({ caipChainId, address }) {
    return api.get({
      path: `/v1/identity/${address}`,
      params: {
        chainId: caipChainId,
        projectId: OptionsController.state.projectId
      }
    });
  },
  fetchTransactions({ account, projectId: projectId2, cursor: cursor2 }) {
    const queryParams = cursor2 ? { cursor: cursor2 } : {};
    return api.get({
      path: `/v1/account/${account}/history?projectId=${projectId2}`,
      params: queryParams
    });
  }
};
const state$4 = proxy({
  message: "",
  variant: "success",
  open: false
});
const SnackController = {
  state: state$4,
  subscribeKey(key2, callback) {
    return subscribeKey(state$4, key2, callback);
  },
  showSuccess(message) {
    state$4.message = message;
    state$4.variant = "success";
    state$4.open = true;
  },
  showError(message) {
    const errorMessage = CoreHelperUtil.parseError(message);
    state$4.message = errorMessage;
    state$4.variant = "error";
    state$4.open = true;
  },
  hide() {
    state$4.open = false;
  }
};
const state$3 = proxy({
  transactions: [],
  transactionsByYear: {},
  loading: false,
  empty: false,
  next: void 0
});
const TransactionsController = {
  state: state$3,
  subscribe(callback) {
    return subscribe(state$3, () => callback(state$3));
  },
  async fetchTransactions(accountAddress) {
    const { projectId: projectId2 } = OptionsController.state;
    if (!projectId2 || !accountAddress) {
      throw new Error("Transactions can't be fetched without a projectId and an accountAddress");
    }
    state$3.loading = true;
    try {
      const response = await BlockchainApiController.fetchTransactions({
        account: accountAddress,
        projectId: projectId2,
        cursor: state$3.next
      });
      const nonSpamTransactions = this.filterSpamTransactions(response.data);
      const filteredTransactions = [...state$3.transactions, ...nonSpamTransactions];
      state$3.loading = false;
      state$3.transactions = filteredTransactions;
      state$3.transactionsByYear = this.groupTransactionsByYear(state$3.transactionsByYear, nonSpamTransactions);
      state$3.empty = filteredTransactions.length === 0;
      state$3.next = response.next ? response.next : void 0;
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "ERROR_FETCH_TRANSACTIONS",
        properties: {
          address: accountAddress,
          projectId: projectId2,
          cursor: state$3.next
        }
      });
      SnackController.showError("Failed to fetch transactions");
      state$3.loading = false;
      state$3.empty = true;
    }
  },
  groupTransactionsByYear(transactionsMap = {}, transactions = []) {
    const grouped = transactionsMap;
    transactions.forEach((transaction) => {
      const year = new Date(transaction.metadata.minedAt).getFullYear();
      if (!grouped[year]) {
        grouped[year] = [];
      }
      grouped[year]?.push(transaction);
    });
    return grouped;
  },
  filterSpamTransactions(transactions) {
    return transactions.filter((transaction) => {
      const isAllSpam = transaction.transfers.every((transfer) => transfer.nft_info?.flags.is_spam === true);
      return !isAllSpam;
    });
  },
  resetTransactions() {
    state$3.transactions = [];
    state$3.transactionsByYear = {};
    state$3.loading = false;
    state$3.empty = false;
    state$3.next = void 0;
  }
};
const state$2 = proxy({
  wcError: false,
  buffering: false
});
const ConnectionController = {
  state: state$2,
  subscribeKey(key2, callback) {
    return subscribeKey(state$2, key2, callback);
  },
  _getClient() {
    if (!state$2._client) {
      throw new Error("ConnectionController client not set");
    }
    return state$2._client;
  },
  setClient(client2) {
    state$2._client = ref(client2);
  },
  connectWalletConnect() {
    state$2.wcPromise = this._getClient().connectWalletConnect((uri) => {
      state$2.wcUri = uri;
      state$2.wcPairingExpiry = CoreHelperUtil.getPairingExpiry();
    });
  },
  async connectExternal(options) {
    await this._getClient().connectExternal?.(options);
    StorageUtil.setConnectedConnector(options.type);
  },
  async signMessage(message) {
    return this._getClient().signMessage(message);
  },
  checkInstalled(ids) {
    return this._getClient().checkInstalled?.(ids);
  },
  resetWcConnection() {
    state$2.wcUri = void 0;
    state$2.wcPairingExpiry = void 0;
    state$2.wcPromise = void 0;
    state$2.wcLinking = void 0;
    state$2.recentWallet = void 0;
    TransactionsController.resetTransactions();
    StorageUtil.deleteWalletConnectDeepLink();
  },
  setWcLinking(wcLinking) {
    state$2.wcLinking = wcLinking;
  },
  setWcError(wcError) {
    state$2.wcError = wcError;
    state$2.buffering = false;
  },
  setRecentWallet(wallet) {
    state$2.recentWallet = wallet;
  },
  setBuffering(buffering) {
    state$2.buffering = buffering;
  },
  async disconnect() {
    await this._getClient().disconnect();
    this.resetWcConnection();
  }
};
const state$1 = proxy({
  status: "uninitialized",
  isSiweEnabled: false
});
const SIWEController = {
  state: state$1,
  subscribeKey(key2, callback) {
    return subscribeKey(state$1, key2, callback);
  },
  subscribe(callback) {
    return subscribe(state$1, () => callback(state$1));
  },
  _getClient() {
    if (!state$1._client) {
      throw new Error("SIWEController client not set");
    }
    return state$1._client;
  },
  async getNonce() {
    const client2 = this._getClient();
    const nonce = await client2.getNonce();
    this.setNonce(nonce);
    return nonce;
  },
  async getSession() {
    const client2 = this._getClient();
    const session = await client2.getSession();
    if (session) {
      this.setSession(session);
      this.setStatus("success");
    }
    return session;
  },
  createMessage(args) {
    const client2 = this._getClient();
    const message = client2.createMessage(args);
    this.setMessage(message);
    return message;
  },
  async verifyMessage(args) {
    const client2 = this._getClient();
    const isValid3 = await client2.verifyMessage(args);
    return isValid3;
  },
  async signIn() {
    const client2 = this._getClient();
    const session = await client2.signIn();
    return session;
  },
  async signOut() {
    const client2 = this._getClient();
    await client2.signOut();
    this.setStatus("ready");
    client2.onSignOut?.();
  },
  onSignIn(args) {
    const client2 = this._getClient();
    client2.onSignIn?.(args);
  },
  onSignOut() {
    const client2 = this._getClient();
    client2.onSignOut?.();
  },
  setSIWEClient(client2) {
    state$1._client = ref(client2);
    state$1.status = "ready";
    state$1.isSiweEnabled = client2.options.enabled;
  },
  setNonce(nonce) {
    state$1.nonce = nonce;
  },
  setStatus(status) {
    state$1.status = status;
  },
  setMessage(message) {
    state$1.message = message;
  },
  setSession(session) {
    state$1.session = session;
  }
};
const state = proxy({
  themeMode: "dark",
  themeVariables: {}
});
const ThemeController = {
  state,
  subscribe(callback) {
    return subscribe(state, () => callback(state));
  },
  setThemeMode(themeMode) {
    state.themeMode = themeMode;
  },
  setThemeVariables(themeVariables) {
    state.themeVariables = { ...state.themeVariables, ...themeVariables };
  },
  getSnapshot() {
    return snapshot(state);
  }
};
const AssetUtil = {
  getWalletImage(wallet) {
    if (wallet?.image_url) {
      return wallet?.image_url;
    }
    if (wallet?.image_id) {
      return AssetController.state.walletImages[wallet.image_id];
    }
    return void 0;
  },
  getNetworkImage(network) {
    if (network?.imageUrl) {
      return network?.imageUrl;
    }
    if (network?.imageId) {
      return AssetController.state.networkImages[network.imageId];
    }
    return void 0;
  },
  getConnectorImage(connector) {
    if (connector?.imageUrl) {
      return connector.imageUrl;
    }
    if (connector?.imageId) {
      return AssetController.state.connectorImages[connector.imageId];
    }
    return void 0;
  }
};
const RouterUtil = {
  goBackOrCloseModal() {
    if (RouterController.state.history.length > 1) {
      RouterController.goBack();
    } else {
      ModalController.close();
    }
  },
  navigateAfterNetworkSwitch() {
    const { history } = RouterController.state;
    const networkSelectIndex = history.findIndex((name2) => name2 === "Networks");
    if (networkSelectIndex >= 1) {
      RouterController.goBackToIndex(networkSelectIndex - 1);
    } else {
      ModalController.close();
    }
  }
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$5 = globalThis, e$a = t$5.ShadowRoot && (void 0 === t$5.ShadyCSS || t$5.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s$7 = Symbol(), o$d = /* @__PURE__ */ new WeakMap();
let n$b = class n {
  constructor(t2, e2, o2) {
    if (this._$cssResult$ = true, o2 !== s$7)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t2, this.t = e2;
  }
  get styleSheet() {
    let t2 = this.o;
    const s4 = this.t;
    if (e$a && void 0 === t2) {
      const e2 = void 0 !== s4 && 1 === s4.length;
      e2 && (t2 = o$d.get(s4)), void 0 === t2 && ((this.o = t2 = new CSSStyleSheet()).replaceSync(this.cssText), e2 && o$d.set(s4, t2));
    }
    return t2;
  }
  toString() {
    return this.cssText;
  }
};
const r$d = (t2) => new n$b("string" == typeof t2 ? t2 : t2 + "", void 0, s$7), i$8 = (t2, ...e2) => {
  const o2 = 1 === t2.length ? t2[0] : e2.reduce((e3, s4, o3) => e3 + ((t3) => {
    if (true === t3._$cssResult$)
      return t3.cssText;
    if ("number" == typeof t3)
      return t3;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t3 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s4) + t2[o3 + 1], t2[0]);
  return new n$b(o2, t2, s$7);
}, S$4 = (s4, o2) => {
  if (e$a)
    s4.adoptedStyleSheets = o2.map((t2) => t2 instanceof CSSStyleSheet ? t2 : t2.styleSheet);
  else
    for (const e2 of o2) {
      const o3 = document.createElement("style"), n4 = t$5.litNonce;
      void 0 !== n4 && o3.setAttribute("nonce", n4), o3.textContent = e2.cssText, s4.appendChild(o3);
    }
}, c$7 = e$a ? (t2) => t2 : (t2) => t2 instanceof CSSStyleSheet ? ((t3) => {
  let e2 = "";
  for (const s4 of t3.cssRules)
    e2 += s4.cssText;
  return r$d(e2);
})(t2) : t2;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: i$7, defineProperty: e$9, getOwnPropertyDescriptor: r$c, getOwnPropertyNames: h$8, getOwnPropertySymbols: o$c, getPrototypeOf: n$a } = Object, a$3 = globalThis, c$6 = a$3.trustedTypes, l$3 = c$6 ? c$6.emptyScript : "", p$4 = a$3.reactiveElementPolyfillSupport, d$3 = (t2, s4) => t2, u$3 = { toAttribute(t2, s4) {
  switch (s4) {
    case Boolean:
      t2 = t2 ? l$3 : null;
      break;
    case Object:
    case Array:
      t2 = null == t2 ? t2 : JSON.stringify(t2);
  }
  return t2;
}, fromAttribute(t2, s4) {
  let i3 = t2;
  switch (s4) {
    case Boolean:
      i3 = null !== t2;
      break;
    case Number:
      i3 = null === t2 ? null : Number(t2);
      break;
    case Object:
    case Array:
      try {
        i3 = JSON.parse(t2);
      } catch (t3) {
        i3 = null;
      }
  }
  return i3;
} }, f$7 = (t2, s4) => !i$7(t2, s4), y$3 = { attribute: true, type: String, converter: u$3, reflect: false, hasChanged: f$7 };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), a$3.litPropertyMetadata ?? (a$3.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let b$2 = class b extends HTMLElement {
  static addInitializer(t2) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t2);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t2, s4 = y$3) {
    if (s4.state && (s4.attribute = false), this._$Ei(), this.elementProperties.set(t2, s4), !s4.noAccessor) {
      const i3 = Symbol(), r2 = this.getPropertyDescriptor(t2, i3, s4);
      void 0 !== r2 && e$9(this.prototype, t2, r2);
    }
  }
  static getPropertyDescriptor(t2, s4, i3) {
    const { get: e2, set: h4 } = r$c(this.prototype, t2) ?? { get() {
      return this[s4];
    }, set(t3) {
      this[s4] = t3;
    } };
    return { get() {
      return e2?.call(this);
    }, set(s5) {
      const r2 = e2?.call(this);
      h4.call(this, s5), this.requestUpdate(t2, r2, i3);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t2) {
    return this.elementProperties.get(t2) ?? y$3;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d$3("elementProperties")))
      return;
    const t2 = n$a(this);
    t2.finalize(), void 0 !== t2.l && (this.l = [...t2.l]), this.elementProperties = new Map(t2.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d$3("finalized")))
      return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d$3("properties"))) {
      const t3 = this.properties, s4 = [...h$8(t3), ...o$c(t3)];
      for (const i3 of s4)
        this.createProperty(i3, t3[i3]);
    }
    const t2 = this[Symbol.metadata];
    if (null !== t2) {
      const s4 = litPropertyMetadata.get(t2);
      if (void 0 !== s4)
        for (const [t3, i3] of s4)
          this.elementProperties.set(t3, i3);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t3, s4] of this.elementProperties) {
      const i3 = this._$Eu(t3, s4);
      void 0 !== i3 && this._$Eh.set(i3, t3);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s4) {
    const i3 = [];
    if (Array.isArray(s4)) {
      const e2 = new Set(s4.flat(1 / 0).reverse());
      for (const s5 of e2)
        i3.unshift(c$7(s5));
    } else
      void 0 !== s4 && i3.push(c$7(s4));
    return i3;
  }
  static _$Eu(t2, s4) {
    const i3 = s4.attribute;
    return false === i3 ? void 0 : "string" == typeof i3 ? i3 : "string" == typeof t2 ? t2.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$Eg = new Promise((t2) => this.enableUpdating = t2), this._$AL = /* @__PURE__ */ new Map(), this._$ES(), this.requestUpdate(), this.constructor.l?.forEach((t2) => t2(this));
  }
  addController(t2) {
    (this._$E_ ?? (this._$E_ = /* @__PURE__ */ new Set())).add(t2), void 0 !== this.renderRoot && this.isConnected && t2.hostConnected?.();
  }
  removeController(t2) {
    this._$E_?.delete(t2);
  }
  _$ES() {
    const t2 = /* @__PURE__ */ new Map(), s4 = this.constructor.elementProperties;
    for (const i3 of s4.keys())
      this.hasOwnProperty(i3) && (t2.set(i3, this[i3]), delete this[i3]);
    t2.size > 0 && (this._$Ep = t2);
  }
  createRenderRoot() {
    const t2 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S$4(t2, this.constructor.elementStyles), t2;
  }
  connectedCallback() {
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), this._$E_?.forEach((t2) => t2.hostConnected?.());
  }
  enableUpdating(t2) {
  }
  disconnectedCallback() {
    this._$E_?.forEach((t2) => t2.hostDisconnected?.());
  }
  attributeChangedCallback(t2, s4, i3) {
    this._$AK(t2, i3);
  }
  _$EO(t2, s4) {
    const i3 = this.constructor.elementProperties.get(t2), e2 = this.constructor._$Eu(t2, i3);
    if (void 0 !== e2 && true === i3.reflect) {
      const r2 = (void 0 !== i3.converter?.toAttribute ? i3.converter : u$3).toAttribute(s4, i3.type);
      this._$Em = t2, null == r2 ? this.removeAttribute(e2) : this.setAttribute(e2, r2), this._$Em = null;
    }
  }
  _$AK(t2, s4) {
    const i3 = this.constructor, e2 = i3._$Eh.get(t2);
    if (void 0 !== e2 && this._$Em !== e2) {
      const t3 = i3.getPropertyOptions(e2), r2 = "function" == typeof t3.converter ? { fromAttribute: t3.converter } : void 0 !== t3.converter?.fromAttribute ? t3.converter : u$3;
      this._$Em = e2, this[e2] = r2.fromAttribute(s4, t3.type), this._$Em = null;
    }
  }
  requestUpdate(t2, s4, i3) {
    if (void 0 !== t2) {
      if (i3 ?? (i3 = this.constructor.getPropertyOptions(t2)), !(i3.hasChanged ?? f$7)(this[t2], s4))
        return;
      this.C(t2, s4, i3);
    }
    false === this.isUpdatePending && (this._$Eg = this._$EP());
  }
  C(t2, s4, i3) {
    this._$AL.has(t2) || this._$AL.set(t2, s4), true === i3.reflect && this._$Em !== t2 && (this._$ET ?? (this._$ET = /* @__PURE__ */ new Set())).add(t2);
  }
  async _$EP() {
    this.isUpdatePending = true;
    try {
      await this._$Eg;
    } catch (t3) {
      Promise.reject(t3);
    }
    const t2 = this.scheduleUpdate();
    return null != t2 && await t2, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [t4, s5] of this._$Ep)
          this[t4] = s5;
        this._$Ep = void 0;
      }
      const t3 = this.constructor.elementProperties;
      if (t3.size > 0)
        for (const [s5, i3] of t3)
          true !== i3.wrapped || this._$AL.has(s5) || void 0 === this[s5] || this.C(s5, this[s5], i3);
    }
    let t2 = false;
    const s4 = this._$AL;
    try {
      t2 = this.shouldUpdate(s4), t2 ? (this.willUpdate(s4), this._$E_?.forEach((t3) => t3.hostUpdate?.()), this.update(s4)) : this._$Ej();
    } catch (s5) {
      throw t2 = false, this._$Ej(), s5;
    }
    t2 && this._$AE(s4);
  }
  willUpdate(t2) {
  }
  _$AE(t2) {
    this._$E_?.forEach((t3) => t3.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t2)), this.updated(t2);
  }
  _$Ej() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$Eg;
  }
  shouldUpdate(t2) {
    return true;
  }
  update(t2) {
    this._$ET && (this._$ET = this._$ET.forEach((t3) => this._$EO(t3, this[t3]))), this._$Ej();
  }
  updated(t2) {
  }
  firstUpdated(t2) {
  }
};
b$2.elementStyles = [], b$2.shadowRootOptions = { mode: "open" }, b$2[d$3("elementProperties")] = /* @__PURE__ */ new Map(), b$2[d$3("finalized")] = /* @__PURE__ */ new Map(), p$4?.({ ReactiveElement: b$2 }), (a$3.reactiveElementVersions ?? (a$3.reactiveElementVersions = [])).push("2.0.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$4 = globalThis, i$6 = t$4.trustedTypes, s$6 = i$6 ? i$6.createPolicy("lit-html", { createHTML: (t2) => t2 }) : void 0, e$8 = "$lit$", h$7 = `lit$${(Math.random() + "").slice(9)}$`, o$b = "?" + h$7, n$9 = `<${o$b}>`, r$b = document, l$2 = () => r$b.createComment(""), c$5 = (t2) => null === t2 || "object" != typeof t2 && "function" != typeof t2, a$2 = Array.isArray, u$2 = (t2) => a$2(t2) || "function" == typeof t2?.[Symbol.iterator], d$2 = "[ 	\n\f\r]", f$6 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, v$1 = /-->/g, _$2 = />/g, m$2 = RegExp(`>|${d$2}(?:([^\\s"'>=/]+)(${d$2}*=${d$2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), p$3 = /'/g, g$1 = /"/g, $$2 = /^(?:script|style|textarea|title)$/i, y$2 = (t2) => (i3, ...s4) => ({ _$litType$: t2, strings: i3, values: s4 }), x$1 = y$2(1), b$1 = y$2(2), w$2 = Symbol.for("lit-noChange"), T$2 = Symbol.for("lit-nothing"), A$2 = /* @__PURE__ */ new WeakMap(), E$1 = r$b.createTreeWalker(r$b, 129);
function C$2(t2, i3) {
  if (!Array.isArray(t2) || !t2.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return void 0 !== s$6 ? s$6.createHTML(i3) : i3;
}
const P$1 = (t2, i3) => {
  const s4 = t2.length - 1, o2 = [];
  let r2, l2 = 2 === i3 ? "<svg>" : "", c2 = f$6;
  for (let i4 = 0; i4 < s4; i4++) {
    const s5 = t2[i4];
    let a2, u2, d2 = -1, y2 = 0;
    for (; y2 < s5.length && (c2.lastIndex = y2, u2 = c2.exec(s5), null !== u2); )
      y2 = c2.lastIndex, c2 === f$6 ? "!--" === u2[1] ? c2 = v$1 : void 0 !== u2[1] ? c2 = _$2 : void 0 !== u2[2] ? ($$2.test(u2[2]) && (r2 = RegExp("</" + u2[2], "g")), c2 = m$2) : void 0 !== u2[3] && (c2 = m$2) : c2 === m$2 ? ">" === u2[0] ? (c2 = r2 ?? f$6, d2 = -1) : void 0 === u2[1] ? d2 = -2 : (d2 = c2.lastIndex - u2[2].length, a2 = u2[1], c2 = void 0 === u2[3] ? m$2 : '"' === u2[3] ? g$1 : p$3) : c2 === g$1 || c2 === p$3 ? c2 = m$2 : c2 === v$1 || c2 === _$2 ? c2 = f$6 : (c2 = m$2, r2 = void 0);
    const x2 = c2 === m$2 && t2[i4 + 1].startsWith("/>") ? " " : "";
    l2 += c2 === f$6 ? s5 + n$9 : d2 >= 0 ? (o2.push(a2), s5.slice(0, d2) + e$8 + s5.slice(d2) + h$7 + x2) : s5 + h$7 + (-2 === d2 ? i4 : x2);
  }
  return [C$2(t2, l2 + (t2[s4] || "<?>") + (2 === i3 ? "</svg>" : "")), o2];
};
let V$2 = class V {
  constructor({ strings: t2, _$litType$: s4 }, n4) {
    let r2;
    this.parts = [];
    let c2 = 0, a2 = 0;
    const u2 = t2.length - 1, d2 = this.parts, [f3, v2] = P$1(t2, s4);
    if (this.el = V.createElement(f3, n4), E$1.currentNode = this.el.content, 2 === s4) {
      const t3 = this.el.content.firstChild;
      t3.replaceWith(...t3.childNodes);
    }
    for (; null !== (r2 = E$1.nextNode()) && d2.length < u2; ) {
      if (1 === r2.nodeType) {
        if (r2.hasAttributes())
          for (const t3 of r2.getAttributeNames())
            if (t3.endsWith(e$8)) {
              const i3 = v2[a2++], s5 = r2.getAttribute(t3).split(h$7), e2 = /([.?@])?(.*)/.exec(i3);
              d2.push({ type: 1, index: c2, name: e2[2], strings: s5, ctor: "." === e2[1] ? k$2 : "?" === e2[1] ? H$2 : "@" === e2[1] ? I$1 : R$1 }), r2.removeAttribute(t3);
            } else
              t3.startsWith(h$7) && (d2.push({ type: 6, index: c2 }), r2.removeAttribute(t3));
        if ($$2.test(r2.tagName)) {
          const t3 = r2.textContent.split(h$7), s5 = t3.length - 1;
          if (s5 > 0) {
            r2.textContent = i$6 ? i$6.emptyScript : "";
            for (let i3 = 0; i3 < s5; i3++)
              r2.append(t3[i3], l$2()), E$1.nextNode(), d2.push({ type: 2, index: ++c2 });
            r2.append(t3[s5], l$2());
          }
        }
      } else if (8 === r2.nodeType)
        if (r2.data === o$b)
          d2.push({ type: 2, index: c2 });
        else {
          let t3 = -1;
          for (; -1 !== (t3 = r2.data.indexOf(h$7, t3 + 1)); )
            d2.push({ type: 7, index: c2 }), t3 += h$7.length - 1;
        }
      c2++;
    }
  }
  static createElement(t2, i3) {
    const s4 = r$b.createElement("template");
    return s4.innerHTML = t2, s4;
  }
};
function N$2(t2, i3, s4 = t2, e2) {
  if (i3 === w$2)
    return i3;
  let h4 = void 0 !== e2 ? s4._$Co?.[e2] : s4._$Cl;
  const o2 = c$5(i3) ? void 0 : i3._$litDirective$;
  return h4?.constructor !== o2 && (h4?._$AO?.(false), void 0 === o2 ? h4 = void 0 : (h4 = new o2(t2), h4._$AT(t2, s4, e2)), void 0 !== e2 ? (s4._$Co ?? (s4._$Co = []))[e2] = h4 : s4._$Cl = h4), void 0 !== h4 && (i3 = N$2(t2, h4._$AS(t2, i3.values), h4, e2)), i3;
}
let S$3 = class S {
  constructor(t2, i3) {
    this._$AV = [], this._$AN = void 0, this._$AD = t2, this._$AM = i3;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t2) {
    const { el: { content: i3 }, parts: s4 } = this._$AD, e2 = (t2?.creationScope ?? r$b).importNode(i3, true);
    E$1.currentNode = e2;
    let h4 = E$1.nextNode(), o2 = 0, n4 = 0, l2 = s4[0];
    for (; void 0 !== l2; ) {
      if (o2 === l2.index) {
        let i4;
        2 === l2.type ? i4 = new M$1(h4, h4.nextSibling, this, t2) : 1 === l2.type ? i4 = new l2.ctor(h4, l2.name, l2.strings, this, t2) : 6 === l2.type && (i4 = new L$2(h4, this, t2)), this._$AV.push(i4), l2 = s4[++n4];
      }
      o2 !== l2?.index && (h4 = E$1.nextNode(), o2++);
    }
    return E$1.currentNode = r$b, e2;
  }
  p(t2) {
    let i3 = 0;
    for (const s4 of this._$AV)
      void 0 !== s4 && (void 0 !== s4.strings ? (s4._$AI(t2, s4, i3), i3 += s4.strings.length - 2) : s4._$AI(t2[i3])), i3++;
  }
};
let M$1 = class M {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t2, i3, s4, e2) {
    this.type = 2, this._$AH = T$2, this._$AN = void 0, this._$AA = t2, this._$AB = i3, this._$AM = s4, this.options = e2, this._$Cv = e2?.isConnected ?? true;
  }
  get parentNode() {
    let t2 = this._$AA.parentNode;
    const i3 = this._$AM;
    return void 0 !== i3 && 11 === t2?.nodeType && (t2 = i3.parentNode), t2;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t2, i3 = this) {
    t2 = N$2(this, t2, i3), c$5(t2) ? t2 === T$2 || null == t2 || "" === t2 ? (this._$AH !== T$2 && this._$AR(), this._$AH = T$2) : t2 !== this._$AH && t2 !== w$2 && this._(t2) : void 0 !== t2._$litType$ ? this.g(t2) : void 0 !== t2.nodeType ? this.$(t2) : u$2(t2) ? this.T(t2) : this._(t2);
  }
  k(t2) {
    return this._$AA.parentNode.insertBefore(t2, this._$AB);
  }
  $(t2) {
    this._$AH !== t2 && (this._$AR(), this._$AH = this.k(t2));
  }
  _(t2) {
    this._$AH !== T$2 && c$5(this._$AH) ? this._$AA.nextSibling.data = t2 : this.$(r$b.createTextNode(t2)), this._$AH = t2;
  }
  g(t2) {
    const { values: i3, _$litType$: s4 } = t2, e2 = "number" == typeof s4 ? this._$AC(t2) : (void 0 === s4.el && (s4.el = V$2.createElement(C$2(s4.h, s4.h[0]), this.options)), s4);
    if (this._$AH?._$AD === e2)
      this._$AH.p(i3);
    else {
      const t3 = new S$3(e2, this), s5 = t3.u(this.options);
      t3.p(i3), this.$(s5), this._$AH = t3;
    }
  }
  _$AC(t2) {
    let i3 = A$2.get(t2.strings);
    return void 0 === i3 && A$2.set(t2.strings, i3 = new V$2(t2)), i3;
  }
  T(t2) {
    a$2(this._$AH) || (this._$AH = [], this._$AR());
    const i3 = this._$AH;
    let s4, e2 = 0;
    for (const h4 of t2)
      e2 === i3.length ? i3.push(s4 = new M(this.k(l$2()), this.k(l$2()), this, this.options)) : s4 = i3[e2], s4._$AI(h4), e2++;
    e2 < i3.length && (this._$AR(s4 && s4._$AB.nextSibling, e2), i3.length = e2);
  }
  _$AR(t2 = this._$AA.nextSibling, i3) {
    for (this._$AP?.(false, true, i3); t2 && t2 !== this._$AB; ) {
      const i4 = t2.nextSibling;
      t2.remove(), t2 = i4;
    }
  }
  setConnected(t2) {
    void 0 === this._$AM && (this._$Cv = t2, this._$AP?.(t2));
  }
};
let R$1 = class R {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t2, i3, s4, e2, h4) {
    this.type = 1, this._$AH = T$2, this._$AN = void 0, this.element = t2, this.name = i3, this._$AM = e2, this.options = h4, s4.length > 2 || "" !== s4[0] || "" !== s4[1] ? (this._$AH = Array(s4.length - 1).fill(new String()), this.strings = s4) : this._$AH = T$2;
  }
  _$AI(t2, i3 = this, s4, e2) {
    const h4 = this.strings;
    let o2 = false;
    if (void 0 === h4)
      t2 = N$2(this, t2, i3, 0), o2 = !c$5(t2) || t2 !== this._$AH && t2 !== w$2, o2 && (this._$AH = t2);
    else {
      const e3 = t2;
      let n4, r2;
      for (t2 = h4[0], n4 = 0; n4 < h4.length - 1; n4++)
        r2 = N$2(this, e3[s4 + n4], i3, n4), r2 === w$2 && (r2 = this._$AH[n4]), o2 || (o2 = !c$5(r2) || r2 !== this._$AH[n4]), r2 === T$2 ? t2 = T$2 : t2 !== T$2 && (t2 += (r2 ?? "") + h4[n4 + 1]), this._$AH[n4] = r2;
    }
    o2 && !e2 && this.O(t2);
  }
  O(t2) {
    t2 === T$2 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t2 ?? "");
  }
};
let k$2 = class k extends R$1 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  O(t2) {
    this.element[this.name] = t2 === T$2 ? void 0 : t2;
  }
};
let H$2 = class H extends R$1 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  O(t2) {
    this.element.toggleAttribute(this.name, !!t2 && t2 !== T$2);
  }
};
let I$1 = class I extends R$1 {
  constructor(t2, i3, s4, e2, h4) {
    super(t2, i3, s4, e2, h4), this.type = 5;
  }
  _$AI(t2, i3 = this) {
    if ((t2 = N$2(this, t2, i3, 0) ?? T$2) === w$2)
      return;
    const s4 = this._$AH, e2 = t2 === T$2 && s4 !== T$2 || t2.capture !== s4.capture || t2.once !== s4.once || t2.passive !== s4.passive, h4 = t2 !== T$2 && (s4 === T$2 || e2);
    e2 && this.element.removeEventListener(this.name, this, s4), h4 && this.element.addEventListener(this.name, this, t2), this._$AH = t2;
  }
  handleEvent(t2) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t2) : this._$AH.handleEvent(t2);
  }
};
let L$2 = class L {
  constructor(t2, i3, s4) {
    this.element = t2, this.type = 6, this._$AN = void 0, this._$AM = i3, this.options = s4;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t2) {
    N$2(this, t2);
  }
};
const Z$2 = t$4.litHtmlPolyfillSupport;
Z$2?.(V$2, M$1), (t$4.litHtmlVersions ?? (t$4.litHtmlVersions = [])).push("3.1.1");
const j$1 = (t2, i3, s4) => {
  const e2 = s4?.renderBefore ?? i3;
  let h4 = e2._$litPart$;
  if (void 0 === h4) {
    const t3 = s4?.renderBefore ?? null;
    e2._$litPart$ = h4 = new M$1(i3.insertBefore(l$2(), t3), t3, void 0, s4 ?? {});
  }
  return h4._$AI(t2), h4;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$5 = class s extends b$2 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var _a;
    const t2 = super.createRenderRoot();
    return (_a = this.renderOptions).renderBefore ?? (_a.renderBefore = t2.firstChild), t2;
  }
  update(t2) {
    const i3 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t2), this._$Do = j$1(i3, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(false);
  }
  render() {
    return w$2;
  }
};
s$5._$litElement$ = true, s$5["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: s$5 });
const r$a = globalThis.litElementPolyfillSupport;
r$a?.({ LitElement: s$5 });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.3");
let themeTag = void 0;
let darkModeTag = void 0;
let lightModeTag = void 0;
function initializeTheming(themeVariables, themeMode) {
  themeTag = document.createElement("style");
  darkModeTag = document.createElement("style");
  lightModeTag = document.createElement("style");
  themeTag.textContent = createRootStyles(themeVariables).core.cssText;
  darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
  lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
  document.head.appendChild(themeTag);
  document.head.appendChild(darkModeTag);
  document.head.appendChild(lightModeTag);
  setColorTheme(themeMode);
}
function setColorTheme(themeMode) {
  if (darkModeTag && lightModeTag) {
    if (themeMode === "light") {
      darkModeTag.removeAttribute("media");
      lightModeTag.media = "enabled";
    } else {
      lightModeTag.removeAttribute("media");
      darkModeTag.media = "enabled";
    }
  }
}
function setThemeVariables(themeVariables) {
  if (themeTag && darkModeTag && lightModeTag) {
    themeTag.textContent = createRootStyles(themeVariables).core.cssText;
    darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
    lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
  }
}
function createRootStyles(themeVariables) {
  return {
    core: i$8`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      :root {
        --w3m-color-mix-strength: ${r$d(themeVariables?.["--w3m-color-mix-strength"] ? `${themeVariables["--w3m-color-mix-strength"]}%` : "0%")};
        --w3m-font-family: ${r$d(themeVariables?.["--w3m-font-family"] || "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;")};
        --w3m-font-size-master: ${r$d(themeVariables?.["--w3m-font-size-master"] || "10px")};
        --w3m-border-radius-master: ${r$d(themeVariables?.["--w3m-border-radius-master"] || "4px")};
        --w3m-z-index: ${r$d(themeVariables?.["--w3m-z-index"] || 100)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-blue-100: var(--wui-color-blue-base-100);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-accent-glass-090: var(--wui-accent-glass-base-090);
        --wui-accent-glass-080: var(--wui-accent-glass-base-080);
        --wui-accent-glass-020: var(--wui-accent-glass-base-020);
        --wui-accent-glass-015: var(--wui-accent-glass-base-015);
        --wui-accent-glass-010: var(--wui-accent-glass-base-010);
        --wui-accent-glass-005: var(--wui-accent-glass-base-005);
        --wui-accent-glass-002: var(--wui-accent-glass-base-002);

        --wui-color-fg-100: var(--wui-color-fg-base-100);
        --wui-color-fg-125: var(--wui-color-fg-base-125);
        --wui-color-fg-150: var(--wui-color-fg-base-150);
        --wui-color-fg-175: var(--wui-color-fg-base-175);
        --wui-color-fg-200: var(--wui-color-fg-base-200);
        --wui-color-fg-225: var(--wui-color-fg-base-225);
        --wui-color-fg-250: var(--wui-color-fg-base-250);
        --wui-color-fg-275: var(--wui-color-fg-base-275);
        --wui-color-fg-300: var(--wui-color-fg-base-300);

        --wui-color-bg-100: var(--wui-color-bg-base-100);
        --wui-color-bg-125: var(--wui-color-bg-base-125);
        --wui-color-bg-150: var(--wui-color-bg-base-150);
        --wui-color-bg-175: var(--wui-color-bg-base-175);
        --wui-color-bg-200: var(--wui-color-bg-base-200);
        --wui-color-bg-225: var(--wui-color-bg-base-225);
        --wui-color-bg-250: var(--wui-color-bg-base-250);
        --wui-color-bg-275: var(--wui-color-bg-base-275);
        --wui-color-bg-300: var(--wui-color-bg-base-300);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-error-100: var(--wui-color-error-base-100);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-base-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-box-shadow-blue: rgba(71, 161, 255, 0.16);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 16%, transparent);

          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            var(--w3m-default)
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            var(--w3m-default)
          );

          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );

          --wui-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-300)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-300)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-base-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );
        }
      }
    `,
    light: i$8`
      :root {
        --w3m-color-mix: ${r$d(themeVariables?.["--w3m-color-mix"] || "#fff")};
        --w3m-accent: ${r$d(themeVariables?.["--w3m-accent"] || "#47a1ff")};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: #191a1a;

        --wui-color-blue-base-100: #47a1ff;

        --wui-color-accent-base-100: var(--w3m-accent);
        --wui-color-accent-base-090: #59aaff;
        --wui-color-accent-base-080: #6cb4ff;

        --wui-accent-glass-base-090: rgba(71, 161, 255, 0.9);
        --wui-accent-glass-base-080: rgba(71, 161, 255, 0.8);
        --wui-accent-glass-base-020: rgba(71, 161, 255, 0.2);
        --wui-accent-glass-base-015: rgba(71, 161, 255, 0.15);
        --wui-accent-glass-base-010: rgba(71, 161, 255, 0.1);
        --wui-accent-glass-base-005: rgba(71, 161, 255, 0.05);
        --wui-accent-glass-base-002: rgba(71, 161, 255, 0.02);

        --wui-color-fg-base-100: #e4e7e7;
        --wui-color-fg-base-125: #d0d5d5;
        --wui-color-fg-base-150: #a8b1b1;
        --wui-color-fg-base-175: #a8b0b0;
        --wui-color-fg-base-200: #949e9e;
        --wui-color-fg-base-225: #868f8f;
        --wui-color-fg-base-250: #788080;
        --wui-color-fg-base-275: #788181;
        --wui-color-fg-base-300: #6e7777;

        --wui-color-bg-base-100: #141414;
        --wui-color-bg-base-125: #191a1a;
        --wui-color-bg-base-150: #1e1f1f;
        --wui-color-bg-base-175: #222525;
        --wui-color-bg-base-200: #272a2a;
        --wui-color-bg-base-225: #2c3030;
        --wui-color-bg-base-250: #313535;
        --wui-color-bg-base-275: #363b3b;
        --wui-color-bg-base-300: #3b4040;

        --wui-color-success-base-100: #26d962;
        --wui-color-error-base-100: #f25a67;

        --wui-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-base-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-gray-glass-080: rgba(255, 255, 255, 0.8);
      }
    `,
    dark: i$8`
      :root {
        --w3m-color-mix: ${r$d(themeVariables?.["--w3m-color-mix"] || "#000")};
        --w3m-accent: ${r$d(themeVariables?.["--w3m-accent"] || "#3396ff")};
        --w3m-default: #000;

        --wui-color-modal-bg-base: #fff;

        --wui-color-blue-base-100: #3396ff;

        --wui-color-accent-base-100: var(--w3m-accent);
        --wui-color-accent-base-090: #2d7dd2;
        --wui-color-accent-base-080: #2978cc;

        --wui-accent-glass-base-090: rgba(51, 150, 255, 0.9);
        --wui-accent-glass-base-080: rgba(51, 150, 255, 0.8);
        --wui-accent-glass-base-020: rgba(51, 150, 255, 0.2);
        --wui-accent-glass-base-015: rgba(51, 150, 255, 0.15);
        --wui-accent-glass-base-010: rgba(51, 150, 255, 0.1);
        --wui-accent-glass-base-005: rgba(51, 150, 255, 0.05);
        --wui-accent-glass-base-002: rgba(51, 150, 255, 0.02);

        --wui-color-fg-base-100: #141414;
        --wui-color-fg-base-125: #2d3131;
        --wui-color-fg-base-150: #474d4d;
        --wui-color-fg-base-175: #636d6d;
        --wui-color-fg-base-200: #798686;
        --wui-color-fg-base-225: #828f8f;
        --wui-color-fg-base-250: #8b9797;
        --wui-color-fg-base-275: #95a0a0;
        --wui-color-fg-base-300: #9ea9a9;

        --wui-color-bg-base-100: #ffffff;
        --wui-color-bg-base-125: #f5fafa;
        --wui-color-bg-base-150: #f3f8f8;
        --wui-color-bg-base-175: #eef4f4;
        --wui-color-bg-base-200: #eaf1f1;
        --wui-color-bg-base-225: #e5eded;
        --wui-color-bg-base-250: #e1e9e9;
        --wui-color-bg-base-275: #dce7e7;
        --wui-color-bg-base-300: #d8e3e3;

        --wui-color-success-base-100: #26b562;
        --wui-color-error-base-100: #f05142;

        --wui-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-base-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-gray-glass-080: rgba(0, 0, 0, 0.8);
      }
    `
  };
}
const resetStyles = i$8`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`;
const elementStyles = i$8`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
    outline: none;
    border: 1px solid transparent;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-gray-glass-005);
    }

    button:active:enabled {
      transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
      background-color: var(--wui-gray-glass-010);
    }

    button[data-variant='fill']:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='accentBg']:hover:enabled {
      background: var(--wui-accent-glass-015);
    }

    button[data-variant='accentBg']:active:enabled {
      background: var(--wui-accent-glass-020);
    }
  }

  button:disabled {
    cursor: not-allowed;
    background-color: var(--wui-gray-glass-005);
  }

  button[data-variant='shade']:disabled,
  button[data-variant='accent']:disabled,
  button[data-variant='accentBg']:disabled {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-gray-glass-015);
    filter: grayscale(1);
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-icon-box,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  button:focus-visible,
  a:focus-visible {
    border: 1px solid var(--wui-color-accent-100);
    background-color: var(--wui-gray-glass-005);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  button[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  button[data-variant='fill']:disabled {
    color: var(--wui-gray-glass-015);
    background-color: var(--wui-gray-glass-015);
  }

  button[data-variant='fill']:disabled > wui-icon {
    color: var(--wui-gray-glass-015);
  }

  button[data-variant='shade'] {
    color: var(--wui-color-fg-200);
  }

  button[data-variant='accent'],
  button[data-variant='accentBg'] {
    color: var(--wui-color-accent-100);
  }

  button[data-variant='accentBg'] {
    background: var(--wui-accent-glass-010);
    border: 1px solid var(--wui-accent-glass-010);
  }

  button[data-variant='fullWidth'] {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    height: 56px;
    border: none;
    background-color: var(--wui-gray-glass-002);
    color: var(--wui-color-fg-200);
    gap: var(--wui-spacing-xs);
  }

  button:active:enabled {
    background-color: var(--wui-gray-glass-010);
  }

  button[data-variant='fill']:active:enabled {
    background-color: var(--wui-color-accent-080);
    border: 1px solid var(--wui-gray-glass-010);
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`;
const colorStyles = i$8`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }
`;
function standardCustomElement(tagName, descriptor) {
  const { kind, elements } = descriptor;
  return {
    kind,
    elements,
    finisher(clazz) {
      if (!customElements.get(tagName)) {
        customElements.define(tagName, clazz);
      }
    }
  };
}
function legacyCustomElement(tagName, clazz) {
  if (!customElements.get(tagName)) {
    customElements.define(tagName, clazz);
  }
  return clazz;
}
function customElement(tagName) {
  return function create3(classOrDescriptor) {
    return typeof classOrDescriptor === "function" ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
  };
}
const styles$19 = i$8`
  :host {
    display: block;
    border-radius: clamp(0px, var(--wui-border-radius-l), 44px);
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-color-modal-bg);
    overflow: hidden;
  }
`;
var __decorate$1s = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiCard = class WuiCard2 extends s$5 {
  render() {
    return x$1`<slot></slot>`;
  }
};
WuiCard.styles = [resetStyles, styles$19];
WuiCard = __decorate$1s([
  customElement("wui-card")
], WuiCard);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$a = { attribute: true, type: String, converter: u$3, reflect: false, hasChanged: f$7 }, r$9 = (t2 = o$a, e2, r2) => {
  const { kind: n4, metadata: i3 } = r2;
  let s4 = globalThis.litPropertyMetadata.get(i3);
  if (void 0 === s4 && globalThis.litPropertyMetadata.set(i3, s4 = /* @__PURE__ */ new Map()), s4.set(r2.name, t2), "accessor" === n4) {
    const { name: o2 } = r2;
    return { set(r3) {
      const n5 = e2.get.call(this);
      e2.set.call(this, r3), this.requestUpdate(o2, n5, t2);
    }, init(e3) {
      return void 0 !== e3 && this.C(o2, void 0, t2), e3;
    } };
  }
  if ("setter" === n4) {
    const { name: o2 } = r2;
    return function(r3) {
      const n5 = this[o2];
      e2.call(this, r3), this.requestUpdate(o2, n5, t2);
    };
  }
  throw Error("Unsupported decorator location: " + n4);
};
function n$8(t2) {
  return (e2, o2) => "object" == typeof o2 ? r$9(t2, e2, o2) : ((t3, e3, o3) => {
    const r2 = e3.hasOwnProperty(o3);
    return e3.constructor.createProperty(o3, r2 ? { ...t3, wrapped: true } : t3), r2 ? Object.getOwnPropertyDescriptor(e3, o3) : void 0;
  })(t2, e2, o2);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$8(r2) {
  return n$8({ ...r2, state: true, attribute: false });
}
const styles$18 = i$8`
  :host {
    display: flex;
    aspect-ratio: 1 / 1;
    color: var(--local-color);
    width: var(--local-width);
  }

  svg {
    width: inherit;
    height: inherit;
    object-fit: contain;
    object-position: center;
  }
`;
const allWalletsSvg = b$1`<svg fill="none" viewBox="0 0 24 24">
  <path
    style="fill: var(--wui-color-accent-100);"
    d="M10.2 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM10.2 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0Z"
  />
</svg>`;
const appStoreSvg = b$1`
<svg width="36" height="36">
  <path
    d="M28.724 0H7.271A7.269 7.269 0 0 0 0 7.272v21.46A7.268 7.268 0 0 0 7.271 36H28.73A7.272 7.272 0 0 0 36 28.728V7.272A7.275 7.275 0 0 0 28.724 0Z"
    fill="url(#a)"
  />
  <path
    d="m17.845 8.271.729-1.26a1.64 1.64 0 1 1 2.843 1.638l-7.023 12.159h5.08c1.646 0 2.569 1.935 1.853 3.276H6.434a1.632 1.632 0 0 1-1.638-1.638c0-.909.73-1.638 1.638-1.638h4.176l5.345-9.265-1.67-2.898a1.642 1.642 0 0 1 2.844-1.638l.716 1.264Zm-6.317 17.5-1.575 2.732a1.64 1.64 0 1 1-2.844-1.638l1.17-2.025c1.323-.41 2.398-.095 3.249.931Zm13.56-4.954h4.262c.909 0 1.638.729 1.638 1.638 0 .909-.73 1.638-1.638 1.638h-2.367l1.597 2.772c.45.788.185 1.782-.602 2.241a1.642 1.642 0 0 1-2.241-.603c-2.69-4.666-4.711-8.159-6.052-10.485-1.372-2.367-.391-4.743.576-5.549 1.075 1.846 2.682 4.631 4.828 8.348Z"
    fill="#fff"
  />
  <defs>
    <linearGradient id="a" x1="18" y1="0" x2="18" y2="36" gradientUnits="userSpaceOnUse">
      <stop stop-color="#18BFFB" />
      <stop offset="1" stop-color="#2072F3" />
    </linearGradient>
  </defs>
</svg>`;
const appleSvg = b$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#000" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M28.77 23.3c-.69 1.99-2.75 5.52-4.87 5.56-1.4.03-1.86-.84-3.46-.84-1.61 0-2.12.81-3.45.86-2.25.1-5.72-5.1-5.72-9.62 0-4.15 2.9-6.2 5.42-6.25 1.36-.02 2.64.92 3.47.92.83 0 2.38-1.13 4.02-.97.68.03 2.6.28 3.84 2.08-3.27 2.14-2.76 6.61.75 8.25ZM24.2 7.88c-2.47.1-4.49 2.69-4.2 4.84 2.28.17 4.47-2.39 4.2-4.84Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const arrowBottomSvg = b$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 1.99a1 1 0 0 1 1 1v7.58l2.46-2.46a1 1 0 0 1 1.41 1.42L7.7 13.69a1 1 0 0 1-1.41 0L2.12 9.53A1 1 0 0 1 3.54 8.1L6 10.57V3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const arrowLeftSvg = b$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13 7.99a1 1 0 0 1-1 1H4.4l2.46 2.46a1 1 0 1 1-1.41 1.41L1.29 8.7a1 1 0 0 1 0-1.41L5.46 3.1a1 1 0 0 1 1.41 1.42L4.41 6.99H12a1 1 0 0 1 1 1Z"
    clip-rule="evenodd"
  />
</svg>`;
const arrowRightSvg = b$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1 7.99a1 1 0 0 1 1-1h7.58L7.12 4.53A1 1 0 1 1 8.54 3.1l4.16 4.17a1 1 0 0 1 0 1.41l-4.16 4.17a1 1 0 1 1-1.42-1.41l2.46-2.46H2a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const arrowTopSvg = b$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 13.99a1 1 0 0 1-1-1V5.4L3.54 7.86a1 1 0 0 1-1.42-1.41L6.3 2.28a1 1 0 0 1 1.41 0l4.17 4.17a1 1 0 1 1-1.41 1.41L8 5.4v7.59a1 1 0 0 1-1 1Z"
    clip-rule="evenodd"
  />
</svg>`;
const browserSvg$1 = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4 6.4a1 1 0 0 1-.46.89 6.98 6.98 0 0 0 .38 6.18A7 7 0 0 0 16.46 7.3a1 1 0 0 1-.47-.92 7 7 0 0 0-12 .03Zm-2.02-.5a9 9 0 1 1 16.03 8.2A9 9 0 0 1 1.98 5.9Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.03 8.63c-1.46-.3-2.72-.75-3.6-1.35l-.02-.01-.14-.11a1 1 0 0 1 1.2-1.6l.1.08c.6.4 1.52.74 2.69 1 .16-.99.39-1.88.67-2.65.3-.79.68-1.5 1.15-2.02A2.58 2.58 0 0 1 9.99 1c.8 0 1.45.44 1.92.97.47.52.84 1.23 1.14 2.02.29.77.52 1.66.68 2.64a8 8 0 0 0 2.7-1l.26-.18h.48a1 1 0 0 1 .12 2c-.86.51-2.01.91-3.34 1.18a22.24 22.24 0 0 1-.03 3.19c1.45.29 2.7.73 3.58 1.31a1 1 0 0 1-1.1 1.68c-.6-.4-1.56-.76-2.75-1-.15.8-.36 1.55-.6 2.2-.3.79-.67 1.5-1.14 2.02-.47.53-1.12.97-1.92.97-.8 0-1.45-.44-1.91-.97a6.51 6.51 0 0 1-1.15-2.02c-.24-.65-.44-1.4-.6-2.2-1.18.24-2.13.6-2.73.99a1 1 0 1 1-1.1-1.67c.88-.58 2.12-1.03 3.57-1.31a22.03 22.03 0 0 1-.04-3.2Zm2.2-1.7c.15-.86.34-1.61.58-2.24.24-.65.51-1.12.76-1.4.25-.28.4-.29.42-.29.03 0 .17.01.42.3.25.27.52.74.77 1.4.23.62.43 1.37.57 2.22a19.96 19.96 0 0 1-3.52 0Zm-.18 4.6a20.1 20.1 0 0 1-.03-2.62 21.95 21.95 0 0 0 3.94 0 20.4 20.4 0 0 1-.03 2.63 21.97 21.97 0 0 0-3.88 0Zm.27 2c.13.66.3 1.26.49 1.78.24.65.51 1.12.76 1.4.25.28.4.29.42.29.03 0 .17-.01.42-.3.25-.27.52-.74.77-1.4.19-.5.36-1.1.49-1.78a20.03 20.03 0 0 0-3.35 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const checkmarkSvg = b$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M12.04 2.65c.47.3.6.91.3 1.38l-5.78 9a1 1 0 0 1-1.61.1L1.73 9.27A1 1 0 1 1 3.27 8L5.6 10.8l5.05-7.85a1 1 0 0 1 1.38-.3Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronBottomSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1.46 4.96a1 1 0 0 1 1.41 0L8 10.09l5.13-5.13a1 1 0 1 1 1.41 1.41l-5.83 5.84a1 1 0 0 1-1.42 0L1.46 6.37a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronLeftSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M11.04 1.46a1 1 0 0 1 0 1.41L5.91 8l5.13 5.13a1 1 0 1 1-1.41 1.41L3.79 8.71a1 1 0 0 1 0-1.42l5.84-5.83a1 1 0 0 1 1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronRightSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.96 14.54a1 1 0 0 1 0-1.41L10.09 8 4.96 2.87a1 1 0 0 1 1.41-1.41l5.84 5.83a1 1 0 0 1 0 1.42l-5.84 5.83a1 1 0 0 1-1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronTopSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.54 11.04a1 1 0 0 1-1.41 0L8 5.92l-5.13 5.12a1 1 0 1 1-1.41-1.41l5.83-5.84a1 1 0 0 1 1.42 0l5.83 5.84a1 1 0 0 1 0 1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
const chromeStoreSvg = b$1`<svg width="36" height="36" fill="none">
  <path
    fill="#fff"
    fill-opacity=".05"
    d="M0 14.94c0-5.55 0-8.326 1.182-10.4a9 9 0 0 1 3.359-3.358C6.614 0 9.389 0 14.94 0h6.12c5.55 0 8.326 0 10.4 1.182a9 9 0 0 1 3.358 3.359C36 6.614 36 9.389 36 14.94v6.12c0 5.55 0 8.326-1.182 10.4a9 9 0 0 1-3.359 3.358C29.386 36 26.611 36 21.06 36h-6.12c-5.55 0-8.326 0-10.4-1.182a9 9 0 0 1-3.358-3.359C0 29.386 0 26.611 0 21.06v-6.12Z"
  />
  <path
    stroke="#fff"
    stroke-opacity=".05"
    d="M14.94.5h6.12c2.785 0 4.84 0 6.46.146 1.612.144 2.743.43 3.691.97a8.5 8.5 0 0 1 3.172 3.173c.541.948.826 2.08.971 3.692.145 1.62.146 3.675.146 6.459v6.12c0 2.785 0 4.84-.146 6.46-.145 1.612-.43 2.743-.97 3.691a8.5 8.5 0 0 1-3.173 3.172c-.948.541-2.08.826-3.692.971-1.62.145-3.674.146-6.459.146h-6.12c-2.784 0-4.84 0-6.46-.146-1.612-.145-2.743-.43-3.691-.97a8.5 8.5 0 0 1-3.172-3.173c-.541-.948-.827-2.08-.971-3.692C.5 25.9.5 23.845.5 21.06v-6.12c0-2.784 0-4.84.146-6.46.144-1.612.43-2.743.97-3.691A8.5 8.5 0 0 1 4.79 1.617C5.737 1.076 6.869.79 8.48.646 10.1.5 12.156.5 14.94.5Z"
  />
  <path
    fill="url(#a)"
    d="M17.998 10.8h12.469a14.397 14.397 0 0 0-24.938.001l6.234 10.798.006-.001a7.19 7.19 0 0 1 6.23-10.799Z"
  />
  <path
    fill="url(#b)"
    d="m24.237 21.598-6.234 10.798A14.397 14.397 0 0 0 30.47 10.798H18.002l-.002.006a7.191 7.191 0 0 1 6.237 10.794Z"
  />
  <path
    fill="url(#c)"
    d="M11.765 21.601 5.531 10.803A14.396 14.396 0 0 0 18.001 32.4l6.235-10.798-.004-.004a7.19 7.19 0 0 1-12.466.004Z"
  />
  <path fill="#fff" d="M18 25.2a7.2 7.2 0 1 0 0-14.4 7.2 7.2 0 0 0 0 14.4Z" />
  <path fill="#1A73E8" d="M18 23.7a5.7 5.7 0 1 0 0-11.4 5.7 5.7 0 0 0 0 11.4Z" />
  <defs>
    <linearGradient
      id="a"
      x1="6.294"
      x2="41.1"
      y1="5.995"
      y2="5.995"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#D93025" />
      <stop offset="1" stop-color="#EA4335" />
    </linearGradient>
    <linearGradient
      id="b"
      x1="20.953"
      x2="37.194"
      y1="32.143"
      y2="2.701"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#FCC934" />
      <stop offset="1" stop-color="#FBBC04" />
    </linearGradient>
    <linearGradient
      id="c"
      x1="25.873"
      x2="9.632"
      y1="31.2"
      y2="1.759"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#1E8E3E" />
      <stop offset="1" stop-color="#34A853" />
    </linearGradient>
  </defs>
</svg>`;
const clockSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 2.99a5 5 0 1 0 0 10 5 5 0 0 0 0-10Zm-7 5a7 7 0 1 1 14 0 7 7 0 0 1-14 0Zm7-4a1 1 0 0 1 1 1v2.58l1.85 1.85a1 1 0 0 1-1.41 1.42L6.29 8.69A1 1 0 0 1 6 8v-3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const closeSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M2.54 2.54a1 1 0 0 1 1.42 0L8 6.6l4.04-4.05a1 1 0 1 1 1.42 1.42L9.4 8l4.05 4.04a1 1 0 0 1-1.42 1.42L8 9.4l-4.04 4.05a1 1 0 0 1-1.42-1.42L6.6 8 2.54 3.96a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`;
const coinPlaceholderSvg = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 3a7 7 0 0 0-6.85 8.44l8.29-8.3C10.97 3.06 10.49 3 10 3Zm3.49.93-9.56 9.56c.32.55.71 1.06 1.16 1.5L15 5.1a7.03 7.03 0 0 0-1.5-1.16Zm2.7 2.8-9.46 9.46a7 7 0 0 0 9.46-9.46ZM1.99 5.9A9 9 0 1 1 18 14.09 9 9 0 0 1 1.98 5.91Z"
    clip-rule="evenodd"
  />
</svg>`;
const compassSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm10.66-2.65a1 1 0 0 1 .23 1.06L9.83 9.24a1 1 0 0 1-.59.58l-2.83 1.06A1 1 0 0 1 5.13 9.6l1.06-2.82a1 1 0 0 1 .58-.59L9.6 5.12a1 1 0 0 1 1.06.23ZM7.9 7.89l-.13.35.35-.13.12-.35-.34.13Z"
    clip-rule="evenodd"
  />
</svg>`;
const copySvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.5 0h1.67c.68 0 1.26 0 1.73.04.5.05.97.14 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73V6.5c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.43.03-.95.03-1.57.03 0 .62 0 1.14-.04 1.57-.04.5-.14.97-.4 1.42-.29.52-.72.95-1.24 1.24-.44.26-.92.35-1.41.4-.48.04-1.05.04-1.74.04H4.83c-.68 0-1.26 0-1.73-.04-.5-.05-.97-.14-1.42-.4-.52-.3-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.42A20.9 20.9 0 0 1 0 11.17V9.5c0-.69 0-1.26.04-1.74.05-.5.14-.97.4-1.41.3-.52.72-.95 1.24-1.25.45-.25.92-.35 1.42-.4.43-.03.95-.03 1.57-.03 0-.62 0-1.14.04-1.57.04-.5.14-.97.4-1.42.29-.52.72-.95 1.24-1.24.44-.26.92-.35 1.41-.4A20.9 20.9 0 0 1 9.5 0ZM4.67 6.67c-.63 0-1.06 0-1.4.03-.35.03-.5.09-.6.14-.2.12-.38.3-.5.5-.05.1-.1.24-.14.6C2 8.32 2 8.8 2 9.54v1.59c0 .73 0 1.22.03 1.6.04.35.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h1.58c.74 0 1.22 0 1.6-.03.36-.04.5-.1.6-.15.2-.11.38-.29.5-.5.05-.09.1-.24.14-.6.03-.33.03-.76.03-1.39-.6 0-1.13 0-1.57-.04-.5-.04-.97-.14-1.41-.4-.52-.29-.95-.72-1.25-1.24a3.39 3.39 0 0 1-.4-1.41c-.03-.44-.03-.96-.03-1.57Zm3.27-4.64c-.36.04-.5.1-.6.15-.2.11-.38.29-.5.5-.05.09-.1.24-.14.6-.03.37-.03.86-.03 1.6v1.58c0 .74 0 1.22.03 1.6.03.36.09.5.14.6.12.2.3.38.5.5.1.05.24.1.6.14.38.03.86.03 1.6.03h1.59c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6V4.87c0-.73 0-1.22-.03-1.6a1.46 1.46 0 0 0-.15-.6c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.14-.37-.03-.86-.03-1.6-.03H9.55c-.74 0-1.22 0-1.6.03Z"
    clip-rule="evenodd"
  />
</svg>`;
const cursorSvg = b$1` <svg fill="none" viewBox="0 0 13 4">
  <path fill="currentColor" d="M.5 0h12L8.9 3.13a3.76 3.76 0 0 1-4.8 0L.5 0Z" />
</svg>`;
const desktopSvg = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13.66 2H6.34c-1.07 0-1.96 0-2.68.08-.74.08-1.42.25-2.01.68a4 4 0 0 0-.89.89c-.43.6-.6 1.27-.68 2.01C0 6.38 0 7.26 0 8.34v.89c0 1.07 0 1.96.08 2.68.08.74.25 1.42.68 2.01a4 4 0 0 0 .89.89c.6.43 1.27.6 2.01.68a27 27 0 0 0 2.68.08h7.32a27 27 0 0 0 2.68-.08 4.03 4.03 0 0 0 2.01-.68 4 4 0 0 0 .89-.89c.43-.6.6-1.27.68-2.01.08-.72.08-1.6.08-2.68v-.89c0-1.07 0-1.96-.08-2.68a4.04 4.04 0 0 0-.68-2.01 4 4 0 0 0-.89-.89c-.6-.43-1.27-.6-2.01-.68C15.62 2 14.74 2 13.66 2ZM2.82 4.38c.2-.14.48-.25 1.06-.31C4.48 4 5.25 4 6.4 4h7.2c1.15 0 1.93 0 2.52.07.58.06.86.17 1.06.31a2 2 0 0 1 .44.44c.14.2.25.48.31 1.06.07.6.07 1.37.07 2.52v.77c0 1.15 0 1.93-.07 2.52-.06.58-.17.86-.31 1.06a2 2 0 0 1-.44.44c-.2.14-.48.25-1.06.32-.6.06-1.37.06-2.52.06H6.4c-1.15 0-1.93 0-2.52-.06-.58-.07-.86-.18-1.06-.32a2 2 0 0 1-.44-.44c-.14-.2-.25-.48-.31-1.06C2 11.1 2 10.32 2 9.17V8.4c0-1.15 0-1.93.07-2.52.06-.58.17-.86.31-1.06a2 2 0 0 1 .44-.44Z"
    clip-rule="evenodd"
  />
  <path fill="currentColor" d="M6.14 17.57a1 1 0 1 0 0 2h7.72a1 1 0 1 0 0-2H6.14Z" />
</svg>`;
const disconnectSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.07 1h.57a1 1 0 0 1 0 2h-.52c-.98 0-1.64 0-2.14.06-.48.05-.7.14-.84.24-.13.1-.25.22-.34.35-.1.14-.2.35-.25.83-.05.5-.05 1.16-.05 2.15v2.74c0 .99 0 1.65.05 2.15.05.48.14.7.25.83.1.14.2.25.34.35.14.1.36.2.84.25.5.05 1.16.05 2.14.05h.52a1 1 0 0 1 0 2h-.57c-.92 0-1.69 0-2.3-.07a3.6 3.6 0 0 1-1.8-.61c-.3-.22-.57-.49-.8-.8a3.6 3.6 0 0 1-.6-1.79C.5 11.11.5 10.35.5 9.43V6.58c0-.92 0-1.7.06-2.31a3.6 3.6 0 0 1 .62-1.8c.22-.3.48-.57.79-.79a3.6 3.6 0 0 1 1.8-.61C4.37 1 5.14 1 6.06 1ZM9.5 3a1 1 0 0 1 1.42 0l4.28 4.3a1 1 0 0 1 0 1.4L10.93 13a1 1 0 0 1-1.42-1.42L12.1 9H6.8a1 1 0 1 1 0-2h5.3L9.51 4.42a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
const discordSvg = b$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`;
const etherscanSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M4.25 7a.63.63 0 0 0-.63.63v3.97c0 .28-.2.51-.47.54l-.75.07a.93.93 0 0 1-.9-.47A7.51 7.51 0 0 1 5.54.92a7.5 7.5 0 0 1 9.54 4.62c.12.35.06.72-.16 1-.74.97-1.68 1.78-2.6 2.44V4.44a.64.64 0 0 0-.63-.64h-1.06c-.35 0-.63.3-.63.64v5.5c0 .23-.12.42-.32.5l-.52.23V6.05c0-.36-.3-.64-.64-.64H7.45c-.35 0-.64.3-.64.64v4.97c0 .25-.17.46-.4.52a5.8 5.8 0 0 0-.45.11v-4c0-.36-.3-.65-.64-.65H4.25ZM14.07 12.4A7.49 7.49 0 0 1 3.6 14.08c4.09-.58 9.14-2.5 11.87-6.6v.03a7.56 7.56 0 0 1-1.41 4.91Z"
  />
</svg>`;
const extensionSvg = b$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.71 2.99a.57.57 0 0 0-.57.57 1 1 0 0 1-1 1c-.58 0-.96 0-1.24.03-.27.03-.37.07-.42.1a.97.97 0 0 0-.36.35c-.04.08-.09.21-.11.67a2.57 2.57 0 0 1 0 5.13c.02.45.07.6.11.66.09.15.21.28.36.36.07.04.21.1.67.12a2.57 2.57 0 0 1 5.12 0c.46-.03.6-.08.67-.12a.97.97 0 0 0 .36-.36c.03-.04.07-.14.1-.41.02-.29.03-.66.03-1.24a1 1 0 0 1 1-1 .57.57 0 0 0 0-1.15 1 1 0 0 1-1-1c0-.58 0-.95-.03-1.24a1.04 1.04 0 0 0-.1-.42.97.97 0 0 0-.36-.36 1.04 1.04 0 0 0-.42-.1c-.28-.02-.65-.02-1.24-.02a1 1 0 0 1-1-1 .57.57 0 0 0-.57-.57ZM5.15 13.98a1 1 0 0 0 .99-1v-.78a.57.57 0 0 1 1.14 0v.78a1 1 0 0 0 .99 1H8.36a66.26 66.26 0 0 0 .73 0 3.78 3.78 0 0 0 1.84-.38c.46-.26.85-.64 1.1-1.1.23-.4.32-.8.36-1.22.02-.2.03-.4.03-.63a2.57 2.57 0 0 0 0-4.75c0-.23-.01-.44-.03-.63a2.96 2.96 0 0 0-.35-1.22 2.97 2.97 0 0 0-1.1-1.1c-.4-.22-.8-.31-1.22-.35a8.7 8.7 0 0 0-.64-.04 2.57 2.57 0 0 0-4.74 0c-.23 0-.44.02-.63.04-.42.04-.83.13-1.22.35-.46.26-.84.64-1.1 1.1-.33.57-.37 1.2-.39 1.84a21.39 21.39 0 0 0 0 .72v.1a1 1 0 0 0 1 .99h.78a.57.57 0 0 1 0 1.15h-.77a1 1 0 0 0-1 .98v.1a63.87 63.87 0 0 0 0 .73c0 .64.05 1.27.38 1.83.26.47.64.85 1.1 1.11.56.32 1.2.37 1.84.38a20.93 20.93 0 0 0 .72 0h.1Z"
    clip-rule="evenodd"
  />
</svg>`;
const externalLinkSvg = b$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.74 3.99a1 1 0 0 1 1-1H11a1 1 0 0 1 1 1v6.26a1 1 0 0 1-2 0V6.4l-6.3 6.3a1 1 0 0 1-1.4-1.42l6.29-6.3H4.74a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const facebookSvg = b$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1877F2" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M26 12.38h-2.89c-.92 0-1.61.38-1.61 1.34v1.66H26l-.36 4.5H21.5v12H17v-12h-3v-4.5h3V12.5c0-3.03 1.6-4.62 5.2-4.62H26v4.5Z"
        />
      </g>
    </g>
    <path
      fill="#1877F2"
      d="M40 20a20 20 0 1 0-23.13 19.76V25.78H11.8V20h5.07v-4.4c0-5.02 3-7.79 7.56-7.79 2.19 0 4.48.4 4.48.4v4.91h-2.53c-2.48 0-3.25 1.55-3.25 3.13V20h5.54l-.88 5.78h-4.66v13.98A20 20 0 0 0 40 20Z"
    />
    <path
      fill="#fff"
      d="m27.79 25.78.88-5.78h-5.55v-3.75c0-1.58.78-3.13 3.26-3.13h2.53V8.2s-2.3-.39-4.48-.39c-4.57 0-7.55 2.77-7.55 7.78V20H11.8v5.78h5.07v13.98a20.15 20.15 0 0 0 6.25 0V25.78h4.67Z"
    />
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const filtersSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 3a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1Zm2.63 5.25a1 1 0 0 1 1-1h8.75a1 1 0 1 1 0 2H3.63a1 1 0 0 1-1-1Zm2.62 5.25a1 1 0 0 1 1-1h3.5a1 1 0 0 1 0 2h-3.5a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const githubSvg = b$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1B1F23" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M8 19.89a12 12 0 1 1 15.8 11.38c-.6.12-.8-.26-.8-.57v-3.3c0-1.12-.4-1.85-.82-2.22 2.67-.3 5.48-1.31 5.48-5.92 0-1.31-.47-2.38-1.24-3.22.13-.3.54-1.52-.12-3.18 0 0-1-.32-3.3 1.23a11.54 11.54 0 0 0-6 0c-2.3-1.55-3.3-1.23-3.3-1.23a4.32 4.32 0 0 0-.12 3.18 4.64 4.64 0 0 0-1.24 3.22c0 4.6 2.8 5.63 5.47 5.93-.34.3-.65.83-.76 1.6-.69.31-2.42.84-3.5-1 0 0-.63-1.15-1.83-1.23 0 0-1.18-.02-.09.73 0 0 .8.37 1.34 1.76 0 0 .7 2.14 4.03 1.41v2.24c0 .31-.2.68-.8.57A12 12 0 0 1 8 19.9Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const googleSvg = b$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#fff" fill-opacity=".05" />
      <g clip-path="url(#c)">
        <path
          fill="#4285F4"
          d="M20 17.7v4.65h6.46a5.53 5.53 0 0 1-2.41 3.61l3.9 3.02c2.26-2.09 3.57-5.17 3.57-8.82 0-.85-.08-1.67-.22-2.46H20Z"
        />
        <path
          fill="#34A853"
          d="m13.27 22.17-.87.67-3.11 2.42A12 12 0 0 0 20 31.9c3.24 0 5.96-1.07 7.94-2.9l-3.9-3.03A7.15 7.15 0 0 1 20 27.12a7.16 7.16 0 0 1-6.72-4.94v-.01Z"
        />
        <path
          fill="#FBBC05"
          d="M9.29 14.5a11.85 11.85 0 0 0 0 10.76l3.99-3.1a7.19 7.19 0 0 1 0-4.55l-4-3.1Z"
        />
        <path
          fill="#EA4335"
          d="M20 12.66c1.77 0 3.34.61 4.6 1.8l3.43-3.44A11.51 11.51 0 0 0 20 7.89c-4.7 0-8.74 2.69-10.71 6.62l3.99 3.1A7.16 7.16 0 0 1 20 12.66Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const helpCircleSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M8.51 5.66a.83.83 0 0 0-.57-.2.83.83 0 0 0-.52.28.8.8 0 0 0-.25.52 1 1 0 0 1-2 0c0-.75.34-1.43.81-1.91a2.75 2.75 0 0 1 4.78 1.92c0 1.24-.8 1.86-1.25 2.2l-.04.03c-.47.36-.5.43-.5.65a1 1 0 1 1-2 0c0-1.25.8-1.86 1.24-2.2l.04-.04c.47-.36.5-.43.5-.65 0-.3-.1-.49-.24-.6ZM9.12 11.87a1.13 1.13 0 1 1-2.25 0 1.13 1.13 0 0 1 2.25 0Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"
    clip-rule="evenodd"
  />
</svg>`;
const infoCircleSvg = b$1`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    d="M6 10.49a1 1 0 1 0 2 0v-2a1 1 0 0 0-2 0v2ZM7 4.49a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 14.99a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm5-7a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const mailSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.83 1.34h6.34c.68 0 1.26 0 1.73.04.5.05.97.15 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73v3.71c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.47.03-1.05.03-1.73.03H4.83c-.68 0-1.26 0-1.73-.04-.5-.04-.97-.14-1.42-.4-.52-.29-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.41A20.9 20.9 0 0 1 0 9.88v-3.7c0-.7 0-1.27.04-1.74.05-.5.14-.97.4-1.42.3-.52.72-.95 1.24-1.24.45-.25.92-.35 1.42-.4.47-.04 1.05-.04 1.73-.04ZM3.28 3.38c-.36.03-.51.08-.6.14-.21.11-.39.29-.5.5a.8.8 0 0 0-.08.19l5.16 3.44c.45.3 1.03.3 1.48 0L13.9 4.2a.79.79 0 0 0-.08-.2c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.13-.37-.04-.86-.04-1.6-.04H4.88c-.73 0-1.22 0-1.6.04ZM14 6.54 9.85 9.31a3.33 3.33 0 0 1-3.7 0L2 6.54v3.3c0 .74 0 1.22.03 1.6.04.36.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h6.25c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6v-3.3Z"
    clip-rule="evenodd"
  />
</svg>`;
const mobileSvg = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path fill="currentColor" d="M10.81 5.81a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z" />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3 4.75A4.75 4.75 0 0 1 7.75 0h4.5A4.75 4.75 0 0 1 17 4.75v10.5A4.75 4.75 0 0 1 12.25 20h-4.5A4.75 4.75 0 0 1 3 15.25V4.75ZM7.75 2A2.75 2.75 0 0 0 5 4.75v10.5A2.75 2.75 0 0 0 7.75 18h4.5A2.75 2.75 0 0 0 15 15.25V4.75A2.75 2.75 0 0 0 12.25 2h-4.5Z"
    clip-rule="evenodd"
  />
</svg>`;
const networkPlaceholderSvg = b$1`<svg fill="none" viewBox="0 0 22 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M16.32 13.62a3.14 3.14 0 1 1-.99 1.72l-1.6-.93a3.83 3.83 0 0 1-3.71 1 3.66 3.66 0 0 1-1.74-1l-1.6.94a3.14 3.14 0 1 1-1-1.73l1.6-.94a3.7 3.7 0 0 1 0-2 3.81 3.81 0 0 1 1.8-2.33c.29-.17.6-.3.92-.38V6.1a3.14 3.14 0 1 1 2 0l-.01.02v1.85H12a3.82 3.82 0 0 1 2.33 1.8 3.7 3.7 0 0 1 .39 2.91l1.6.93ZM2.6 16.54a1.14 1.14 0 0 0 1.98-1.14 1.14 1.14 0 0 0-1.98 1.14ZM11 2.01a1.14 1.14 0 1 0 0 2.28 1.14 1.14 0 0 0 0-2.28Zm1.68 10.45c.08-.19.14-.38.16-.58v-.05l.02-.13v-.13a1.92 1.92 0 0 0-.24-.8l-.11-.15a1.89 1.89 0 0 0-.74-.6 1.86 1.86 0 0 0-.77-.17h-.19a1.97 1.97 0 0 0-.89.34 1.98 1.98 0 0 0-.61.74 1.99 1.99 0 0 0-.16.9v.05a1.87 1.87 0 0 0 .24.74l.1.15c.12.16.26.3.42.42l.16.1.13.07.04.02a1.84 1.84 0 0 0 .76.17h.17a2 2 0 0 0 .91-.35 1.78 1.78 0 0 0 .52-.58l.03-.05a.84.84 0 0 0 .05-.11Zm5.15 4.5a1.14 1.14 0 0 0 1.14-1.97 1.13 1.13 0 0 0-1.55.41c-.32.55-.13 1.25.41 1.56Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.63 9.43a1.5 1.5 0 1 0 1.5-2.6 1.5 1.5 0 0 0-1.5 2.6Zm.32-1.55a.5.5 0 0 1 .68-.19.5.5 0 0 1 .18.68.5.5 0 0 1-.68.19.5.5 0 0 1-.18-.68ZM17.94 8.88a1.5 1.5 0 1 1-2.6-1.5 1.5 1.5 0 1 1 2.6 1.5ZM16.9 7.69a.5.5 0 0 0-.68.19.5.5 0 0 0 .18.68.5.5 0 0 0 .68-.19.5.5 0 0 0-.18-.68ZM9.75 17.75a1.5 1.5 0 1 1 2.6 1.5 1.5 1.5 0 1 1-2.6-1.5Zm1.05 1.18a.5.5 0 0 0 .68-.18.5.5 0 0 0-.18-.68.5.5 0 0 0-.68.18.5.5 0 0 0 .18.68Z"
    clip-rule="evenodd"
  />
</svg>`;
const nftPlaceholderSvg = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.13 1h1.71c1.46 0 2.63 0 3.56.1.97.1 1.8.33 2.53.85a5 5 0 0 1 1.1 1.11c.53.73.75 1.56.86 2.53.1.93.1 2.1.1 3.55v1.72c0 1.45 0 2.62-.1 3.55-.1.97-.33 1.8-.86 2.53a5 5 0 0 1-1.1 1.1c-.73.53-1.56.75-2.53.86-.93.1-2.1.1-3.55.1H9.13c-1.45 0-2.62 0-3.56-.1-.96-.1-1.8-.33-2.52-.85a5 5 0 0 1-1.1-1.11 5.05 5.05 0 0 1-.86-2.53c-.1-.93-.1-2.1-.1-3.55V9.14c0-1.45 0-2.62.1-3.55.1-.97.33-1.8.85-2.53a5 5 0 0 1 1.1-1.1 5.05 5.05 0 0 1 2.53-.86C6.51 1 7.67 1 9.13 1ZM5.79 3.09a3.1 3.1 0 0 0-1.57.48 3 3 0 0 0-.66.67c-.24.32-.4.77-.48 1.56-.1.82-.1 1.88-.1 3.4v1.6c0 1.15 0 2.04.05 2.76l.41-.42c.5-.5.93-.92 1.32-1.24.41-.33.86-.6 1.43-.7a3 3 0 0 1 .94 0c.35.06.66.2.95.37a17.11 17.11 0 0 0 .8.45c.1-.08.2-.2.41-.4l.04-.03a27 27 0 0 1 1.95-1.84 4.03 4.03 0 0 1 1.91-.94 4 4 0 0 1 1.25 0c.73.11 1.33.46 1.91.94l.64.55V9.2c0-1.52 0-2.58-.1-3.4a3.1 3.1 0 0 0-.48-1.56 3 3 0 0 0-.66-.67 3.1 3.1 0 0 0-1.56-.48C13.37 3 12.3 3 10.79 3h-1.6c-1.52 0-2.59 0-3.4.09Zm11.18 10-.04-.05a26.24 26.24 0 0 0-1.83-1.74c-.45-.36-.73-.48-.97-.52a2 2 0 0 0-.63 0c-.24.04-.51.16-.97.52-.46.38-1.01.93-1.83 1.74l-.02.02c-.17.18-.34.34-.49.47a2.04 2.04 0 0 1-1.08.5 1.97 1.97 0 0 1-1.25-.27l-.79-.46-.02-.02a.65.65 0 0 0-.24-.1 1 1 0 0 0-.31 0c-.08.02-.21.06-.49.28-.3.24-.65.59-1.2 1.14l-.56.56-.65.66a3 3 0 0 0 .62.6c.33.24.77.4 1.57.49.81.09 1.88.09 3.4.09h1.6c1.52 0 2.58 0 3.4-.09a3.1 3.1 0 0 0 1.56-.48 3 3 0 0 0 .66-.67c.24-.32.4-.77.49-1.56l.07-1.12Zm-8.02-1.03ZM4.99 7a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const offSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 0a1 1 0 0 1 1 1v5.38a1 1 0 0 1-2 0V1a1 1 0 0 1 1-1ZM5.26 2.6a1 1 0 0 1-.28 1.39 5.46 5.46 0 1 0 6.04 0 1 1 0 1 1 1.1-1.67 7.46 7.46 0 1 1-8.25 0 1 1 0 0 1 1.4.28Z"
    clip-rule="evenodd"
  />
</svg>`;
const playStoreSvg = b$1` <svg
  width="36"
  height="36"
  fill="none"
>
  <path
    d="M0 8a8 8 0 0 1 8-8h20a8 8 0 0 1 8 8v20a8 8 0 0 1-8 8H8a8 8 0 0 1-8-8V8Z"
    fill="#fff"
    fill-opacity=".05"
  />
  <path
    d="m18.262 17.513-8.944 9.49v.01a2.417 2.417 0 0 0 3.56 1.452l.026-.017 10.061-5.803-4.703-5.132Z"
    fill="#EA4335"
  />
  <path
    d="m27.307 15.9-.008-.008-4.342-2.52-4.896 4.36 4.913 4.912 4.325-2.494a2.42 2.42 0 0 0 .008-4.25Z"
    fill="#FBBC04"
  />
  <path
    d="M9.318 8.997c-.05.202-.084.403-.084.622V26.39c0 .218.025.42.084.621l9.246-9.247-9.246-8.768Z"
    fill="#4285F4"
  />
  <path
    d="m18.33 18 4.627-4.628-10.053-5.828a2.427 2.427 0 0 0-3.586 1.444L18.329 18Z"
    fill="#34A853"
  />
  <path
    d="M8 .5h20A7.5 7.5 0 0 1 35.5 8v20a7.5 7.5 0 0 1-7.5 7.5H8A7.5 7.5 0 0 1 .5 28V8A7.5 7.5 0 0 1 8 .5Z"
    stroke="#fff"
    stroke-opacity=".05"
  />
</svg>`;
const qrCodeIcon = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M3 6a3 3 0 0 1 3-3h1a1 1 0 1 0 0-2H6a5 5 0 0 0-5 5v1a1 1 0 0 0 2 0V6ZM13 1a1 1 0 1 0 0 2h1a3 3 0 0 1 3 3v1a1 1 0 1 0 2 0V6a5 5 0 0 0-5-5h-1ZM3 13a1 1 0 1 0-2 0v1a5 5 0 0 0 5 5h1a1 1 0 1 0 0-2H6a3 3 0 0 1-3-3v-1ZM19 13a1 1 0 1 0-2 0v1a3 3 0 0 1-3 3h-1a1 1 0 1 0 0 2h1.01a5 5 0 0 0 5-5v-1ZM5.3 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05A1.5 1.5 0 0 0 9.2 8.14c.06-.2.06-.43.06-.89s0-.7-.06-.89A1.5 1.5 0 0 0 8.14 5.3c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM10.8 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM5.26 12.75c0-.46 0-.7.05-.89a1.5 1.5 0 0 1 1.06-1.06c.19-.05.42-.05.89-.05.46 0 .7 0 .88.05.52.14.93.54 1.06 1.06.06.2.06.43.06.89s0 .7-.06.89a1.5 1.5 0 0 1-1.06 1.06c-.19.05-.42.05-.88.05-.47 0-.7 0-.9-.05a1.5 1.5 0 0 1-1.05-1.06c-.05-.2-.05-.43-.05-.89ZM10.8 11.86c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06Z"
  />
</svg>`;
const refreshSvg = b$1`<svg fill="none" viewBox="0 0 14 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.94 1.04a1 1 0 0 1 .7 1.23l-.48 1.68a5.85 5.85 0 0 1 8.53 4.32 5.86 5.86 0 0 1-11.4 2.56 1 1 0 0 1 1.9-.57 3.86 3.86 0 1 0 1.83-4.5l1.87.53a1 1 0 0 1-.55 1.92l-4.1-1.15a1 1 0 0 1-.69-1.23l1.16-4.1a1 1 0 0 1 1.23-.7Z"
    clip-rule="evenodd"
  />
</svg>`;
const searchSvg = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.36 4.21a5.14 5.14 0 1 0 0 10.29 5.14 5.14 0 0 0 0-10.29ZM1.64 9.36a7.71 7.71 0 1 1 14 4.47l2.52 2.5a1.29 1.29 0 1 1-1.82 1.83l-2.51-2.51A7.71 7.71 0 0 1 1.65 9.36Z"
    clip-rule="evenodd"
  />
</svg>`;
const swapHorizontalSvg = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.76.3a1 1 0 0 1 0 1.4L4.07 4.4h9a1 1 0 1 1 0 2h-9l2.69 2.68a1 1 0 1 1-1.42 1.42L.95 6.09a1 1 0 0 1 0-1.4l4.4-4.4a1 1 0 0 1 1.4 0Zm6.49 9.21a1 1 0 0 1 1.41 0l4.39 4.4a1 1 0 0 1 0 1.4l-4.39 4.4a1 1 0 0 1-1.41-1.42l2.68-2.68h-9a1 1 0 0 1 0-2h9l-2.68-2.68a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`;
const swapHorizontalBoldSvg = b$1`<svg width="10" height="10" viewBox="0 0 10 10">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.77986 0.566631C4.0589 0.845577 4.0589 1.29784 3.77986 1.57678L3.08261 2.2738H6.34184C6.73647 2.2738 7.05637 2.5936 7.05637 2.98808C7.05637 3.38257 6.73647 3.70237 6.34184 3.70237H3.08261L3.77986 4.39938C4.0589 4.67833 4.0589 5.13059 3.77986 5.40954C3.50082 5.68848 3.04841 5.68848 2.76937 5.40954L0.852346 3.49316C0.573306 3.21421 0.573306 2.76195 0.852346 2.48301L2.76937 0.566631C3.04841 0.287685 3.50082 0.287685 3.77986 0.566631ZM6.22 4.59102C6.49904 4.31208 6.95145 4.31208 7.23049 4.59102L9.14751 6.5074C9.42655 6.78634 9.42655 7.23861 9.14751 7.51755L7.23049 9.43393C6.95145 9.71287 6.49904 9.71287 6.22 9.43393C5.94096 9.15498 5.94096 8.70272 6.22 8.42377L6.91725 7.72676L3.65802 7.72676C3.26339 7.72676 2.94349 7.40696 2.94349 7.01247C2.94349 6.61798 3.26339 6.29819 3.65802 6.29819L6.91725 6.29819L6.22 5.60117C5.94096 5.32223 5.94096 4.86997 6.22 4.59102Z"
    clip-rule="evenodd"
  />
</svg>`;
const swapVerticalSvg = b$1`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.48 2.18a1 1 0 0 1 1.41 0l2.68 2.68a1 1 0 1 1-1.41 1.42l-.98-.98v4.56a1 1 0 0 1-2 0V5.3l-.97.98A1 1 0 0 1 .79 4.86l2.69-2.68Zm6.34 2.93a1 1 0 0 1 1 1v4.56l.97-.98a1 1 0 1 1 1.42 1.42l-2.69 2.68a1 1 0 0 1-1.41 0l-2.68-2.68a1 1 0 0 1 1.41-1.42l.98.98V6.1a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const telegramSvg = b$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg> `;
const twitchSvg = b$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5A3E85" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M18.22 25.7 20 23.91h3.34l2.1-2.1v-6.68H15.4v8.78h2.82v1.77Zm3.87-8.16h1.25v3.66H22.1v-3.66Zm-3.34 0H20v3.66h-1.25v-3.66ZM20 7.9a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm6.69 14.56-3.66 3.66h-2.72l-1.77 1.78h-1.88V26.1H13.3v-9.82l.94-2.4H26.7v8.56Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const twitterSvg = b$1`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1D9BF0" />
      <path
        fill="#fff"
        d="M30 13.81c-.74.33-1.53.55-2.36.65.85-.51 1.5-1.32 1.8-2.27-.79.47-1.66.8-2.6 1a4.1 4.1 0 0 0-7 3.73c-3.4-.17-6.42-1.8-8.45-4.28a4.1 4.1 0 0 0 1.27 5.47c-.67-.02-1.3-.2-1.86-.5a4.1 4.1 0 0 0 3.3 4.07c-.58.15-1.21.19-1.86.07a4.1 4.1 0 0 0 3.83 2.85A8.25 8.25 0 0 1 10 26.3a11.62 11.62 0 0 0 6.29 1.84c7.62 0 11.92-6.44 11.66-12.2.8-.59 1.5-1.3 2.05-2.13Z"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`;
const twitterIconSvg = b$1`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="m14.36 4.74.01.42c0 4.34-3.3 9.34-9.34 9.34A9.3 9.3 0 0 1 0 13.03a6.6 6.6 0 0 0 4.86-1.36 3.29 3.29 0 0 1-3.07-2.28c.5.1 1 .07 1.48-.06A3.28 3.28 0 0 1 .64 6.11v-.04c.46.26.97.4 1.49.41A3.29 3.29 0 0 1 1.11 2.1a9.32 9.32 0 0 0 6.77 3.43 3.28 3.28 0 0 1 5.6-3 6.59 6.59 0 0 0 2.08-.8 3.3 3.3 0 0 1-1.45 1.82A6.53 6.53 0 0 0 16 3.04c-.44.66-1 1.23-1.64 1.7Z"
  />
</svg>`;
const verifySvg = b$1`<svg fill="none" viewBox="0 0 28 28">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M18.1 4.76c-.42-.73-1.33-1.01-2.09-.66l-1.42.66c-.37.18-.8.18-1.18 0l-1.4-.65a1.63 1.63 0 0 0-2.1.66l-.84 1.45c-.2.34-.53.59-.92.67l-1.7.35c-.83.17-1.39.94-1.3 1.78l.19 1.56c.04.39-.08.78-.33 1.07l-1.12 1.3c-.52.6-.52 1.5 0 2.11L5 16.38c.25.3.37.68.33 1.06l-.18 1.57c-.1.83.46 1.6 1.28 1.78l1.7.35c.4.08.73.32.93.66l.84 1.43a1.63 1.63 0 0 0 2.09.66l1.41-.66c.37-.17.8-.17 1.18 0l1.43.67c.76.35 1.66.07 2.08-.65l.86-1.45c.2-.34.54-.58.92-.66l1.68-.35A1.63 1.63 0 0 0 22.84 19l-.18-1.57a1.4 1.4 0 0 1 .33-1.06l1.12-1.32c.52-.6.52-1.5 0-2.11l-1.12-1.3a1.4 1.4 0 0 1-.33-1.07l.18-1.57c.1-.83-.46-1.6-1.28-1.77l-1.68-.35a1.4 1.4 0 0 1-.92-.66l-.86-1.47Zm-3.27-3.2a4.43 4.43 0 0 1 5.69 1.78l.54.93 1.07.22a4.43 4.43 0 0 1 3.5 4.84l-.11.96.7.83a4.43 4.43 0 0 1 .02 5.76l-.72.85.1.96a4.43 4.43 0 0 1-3.5 4.84l-1.06.22-.54.92a4.43 4.43 0 0 1-5.68 1.77l-.84-.4-.82.39a4.43 4.43 0 0 1-5.7-1.79l-.51-.89-1.09-.22a4.43 4.43 0 0 1-3.5-4.84l.1-.96-.72-.85a4.43 4.43 0 0 1 .01-5.76l.71-.83-.1-.95a4.43 4.43 0 0 1 3.5-4.84l1.08-.23.53-.9a4.43 4.43 0 0 1 5.7-1.8l.81.38.83-.39ZM18.2 9.4c.65.42.84 1.28.42 1.93l-4.4 6.87a1.4 1.4 0 0 1-2.26.14L9.5 15.39a1.4 1.4 0 0 1 2.15-1.8l1.23 1.48 3.38-5.26a1.4 1.4 0 0 1 1.93-.42Z"
    clip-rule="evenodd"
  />
</svg>`;
const verifyFilledSvg = b$1`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="m4.1 12.43-.45-.78-.93-.2a1.65 1.65 0 0 1-1.31-1.8l.1-.86-.61-.71a1.65 1.65 0 0 1 0-2.16l.6-.7-.09-.85c-.1-.86.47-1.64 1.3-1.81l.94-.2.45-.78A1.65 1.65 0 0 1 6.23.9l.77.36.78-.36c.77-.36 1.69-.07 2.12.66l.47.8.91.2c.84.17 1.4.95 1.31 1.8l-.1.86.6.7c.54.62.54 1.54.01 2.16l-.6.71.09.86c.1.85-.47 1.63-1.3 1.8l-.92.2-.47.79a1.65 1.65 0 0 1-2.12.66L7 12.74l-.77.36c-.78.35-1.7.07-2.13-.67Zm5.74-6.9a1 1 0 1 0-1.68-1.07L6.32 7.3l-.55-.66a1 1 0 0 0-1.54 1.28l1.43 1.71a1 1 0 0 0 1.61-.1l2.57-4Z"
    clip-rule="evenodd"
  />
</svg>`;
const walletPlaceholderSvg = b$1`
  <svg fill="none" viewBox="0 0 48 44">
    <path
      style="fill: var(--wui-color-bg-300);"
      d="M4.56 8.64c-1.23 1.68-1.23 4.08-1.23 8.88v8.96c0 4.8 0 7.2 1.23 8.88.39.55.87 1.02 1.41 1.42C7.65 38 10.05 38 14.85 38h14.3c4.8 0 7.2 0 8.88-1.22a6.4 6.4 0 0 0 1.41-1.42c.83-1.14 1.1-2.6 1.19-4.92a6.4 6.4 0 0 0 5.16-4.65c.21-.81.21-1.8.21-3.79 0-1.98 0-2.98-.22-3.79a6.4 6.4 0 0 0-5.15-4.65c-.1-2.32-.36-3.78-1.19-4.92a6.4 6.4 0 0 0-1.41-1.42C36.35 6 33.95 6 29.15 6h-14.3c-4.8 0-7.2 0-8.88 1.22a6.4 6.4 0 0 0-1.41 1.42Z"
    />
    <path
      style="fill: var(--wui-color-fg-200);"
      fill-rule="evenodd"
      d="M2.27 11.33a6.4 6.4 0 0 1 6.4-6.4h26.66a6.4 6.4 0 0 1 6.4 6.4v1.7a6.4 6.4 0 0 1 5.34 6.3v5.34a6.4 6.4 0 0 1-5.34 6.3v1.7a6.4 6.4 0 0 1-6.4 6.4H8.67a6.4 6.4 0 0 1-6.4-6.4V11.33ZM39.6 31.07h-6.93a9.07 9.07 0 1 1 0-18.14h6.93v-1.6a4.27 4.27 0 0 0-4.27-4.26H8.67a4.27 4.27 0 0 0-4.27 4.26v21.34a4.27 4.27 0 0 0 4.27 4.26h26.66a4.27 4.27 0 0 0 4.27-4.26v-1.6Zm-6.93-16a6.93 6.93 0 0 0 0 13.86h8a4.27 4.27 0 0 0 4.26-4.26v-5.34a4.27 4.27 0 0 0-4.26-4.26h-8Z"
      clip-rule="evenodd"
    />
  </svg>
`;
const walletSvg = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 5.5c0-1.8 1.46-3.25 3.25-3.25H14.5c1.8 0 3.25 1.46 3.25 3.25v.28A3.25 3.25 0 0 1 20 8.88v2.24c0 1.45-.94 2.68-2.25 3.1v.28c0 1.8-1.46 3.25-3.25 3.25H3.25A3.25 3.25 0 0 1 0 14.5v-9Zm15.75 8.88h-2.38a4.38 4.38 0 0 1 0-8.76h2.38V5.5c0-.69-.56-1.25-1.25-1.25H3.25C2.56 4.25 2 4.81 2 5.5v9c0 .69.56 1.25 1.25 1.25H14.5c.69 0 1.25-.56 1.25-1.25v-.13Zm-2.38-6.76a2.37 2.37 0 1 0 0 4.75h3.38c.69 0 1.25-.55 1.25-1.24V8.87c0-.69-.56-1.24-1.25-1.24h-3.38Z"
    clip-rule="evenodd"
  />
</svg>`;
const walletConnectSvg = b$1`<svg fill="none" viewBox="0 0 96 67">
  <path
    fill="currentColor"
    d="M25.32 18.8a32.56 32.56 0 0 1 45.36 0l1.5 1.47c.63.62.63 1.61 0 2.22l-5.15 5.05c-.31.3-.82.3-1.14 0l-2.07-2.03a22.71 22.71 0 0 0-31.64 0l-2.22 2.18c-.31.3-.82.3-1.14 0l-5.15-5.05a1.55 1.55 0 0 1 0-2.22l1.65-1.62Zm56.02 10.44 4.59 4.5c.63.6.63 1.6 0 2.21l-20.7 20.26c-.62.61-1.63.61-2.26 0L48.28 41.83a.4.4 0 0 0-.56 0L33.03 56.21c-.63.61-1.64.61-2.27 0L10.07 35.95a1.55 1.55 0 0 1 0-2.22l4.59-4.5a1.63 1.63 0 0 1 2.27 0L31.6 43.63a.4.4 0 0 0 .57 0l14.69-14.38a1.63 1.63 0 0 1 2.26 0l14.69 14.38a.4.4 0 0 0 .57 0l14.68-14.38a1.63 1.63 0 0 1 2.27 0Z"
  />
  <path
    stroke="#000"
    stroke-opacity=".1"
    d="M25.67 19.15a32.06 32.06 0 0 1 44.66 0l1.5 1.48c.43.42.43 1.09 0 1.5l-5.15 5.05a.31.31 0 0 1-.44 0l-2.07-2.03a23.21 23.21 0 0 0-32.34 0l-2.22 2.18a.31.31 0 0 1-.44 0l-5.15-5.05a1.05 1.05 0 0 1 0-1.5l1.65-1.63ZM81 29.6l4.6 4.5c.42.41.42 1.09 0 1.5l-20.7 20.26c-.43.43-1.14.43-1.57 0L48.63 41.47a.9.9 0 0 0-1.26 0L32.68 55.85c-.43.43-1.14.43-1.57 0L10.42 35.6a1.05 1.05 0 0 1 0-1.5l4.59-4.5a1.13 1.13 0 0 1 1.57 0l14.68 14.38a.9.9 0 0 0 1.27 0l-.35-.35.35.35L47.22 29.6a1.13 1.13 0 0 1 1.56 0l14.7 14.38a.9.9 0 0 0 1.26 0L79.42 29.6a1.13 1.13 0 0 1 1.57 0Z"
  />
</svg>`;
const warningCircleSvg = b$1`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M11 6.67a1 1 0 1 0-2 0v2.66a1 1 0 0 0 2 0V6.67ZM10 14.5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 1a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm-7 9a7 7 0 1 1 14 0 7 7 0 0 1-14 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const alphaSvg = b$1`<svg xmlns="http://www.w3.org/2000/svg" width="14" height="12" viewBox="0 0 14 12" fill="none">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10.687 0.557043C11.1462 0.671832 11.4254 1.13706 11.3106 1.59615C11.2044 2.02082 11.0975 2.51184 10.9822 3.04102C10.7176 4.25623 10.4091 5.6727 9.96482 6.94907C10.1435 7.58939 10.3065 8.16905 10.4935 8.68429C10.6447 9.10072 10.7858 9.39487 10.9179 9.58289C11.0055 9.70747 11.0597 9.74443 11.0748 9.75277C11.096 9.75724 11.1075 9.75764 11.1531 9.71916C11.2342 9.65067 11.3386 9.50891 11.4426 9.28357C11.5416 9.06892 11.614 8.8366 11.662 8.6497C11.6854 8.55831 11.7019 8.48242 11.7122 8.43111C11.7174 8.40555 11.7209 8.38638 11.723 8.37476L11.725 8.36363C11.8 7.89659 12.2395 7.57864 12.7068 7.65342C13.1742 7.72822 13.4925 8.16766 13.4177 8.63494C13.4153 8.64924 13.42 8.62063 13.4177 8.63494L13.4175 8.63596L13.4173 8.63721L13.4168 8.64037L13.4153 8.64924L13.4105 8.67692C13.4064 8.69961 13.4006 8.73069 13.3929 8.76891C13.3776 8.84516 13.3545 8.95091 13.3224 9.07586C13.2593 9.32166 13.1564 9.66085 12.9992 10.0015C12.8469 10.3315 12.6139 10.7288 12.2595 11.0282C11.8757 11.3523 11.35 11.5553 10.7293 11.4312C10.1645 11.3183 9.77597 10.939 9.51527 10.5681C9.2535 10.1957 9.05129 9.7349 8.88212 9.26898C8.87877 9.25975 8.87542 9.25049 8.87208 9.2412C8.03954 10.4941 6.83375 11.4479 5.03926 11.4479C3.48049 11.4479 2.31021 10.7159 1.56788 9.63945C0.846767 8.5938 0.544023 7.25403 0.573206 5.9702C0.60242 4.68505 0.966023 3.36073 1.69055 2.33272C2.42915 1.28475 3.5614 0.531453 5.03927 0.531453C6.44937 0.531453 7.4408 1.29593 8.1276 2.27567C8.48261 2.7821 8.77248 3.36668 9.0177 3.97383C9.1059 3.59106 9.18901 3.20908 9.27086 2.83294C9.39492 2.26277 9.51606 1.70605 9.64752 1.18046C9.76235 0.721369 10.2277 0.442254 10.687 0.557043ZM8.16354 6.87693C8.08689 6.60534 8.01003 6.33741 7.93241 6.08076C7.59522 4.96581 7.22132 3.969 6.72371 3.25914C6.24674 2.57873 5.72135 2.24516 5.03927 2.24516C4.21565 2.24516 3.56947 2.6422 3.09195 3.31975C2.60035 4.01725 2.31013 4.99361 2.28705 6.00913C2.26393 7.02599 2.51041 7.9869 2.97927 8.66676C3.42691 9.31586 4.08734 9.73417 5.03926 9.73417C6.48097 9.73417 7.4216 8.72164 8.14437 6.9249C8.15079 6.90893 8.15718 6.89294 8.16354 6.87693Z" fill="#47A1FF"/>
</svg>`;
var __decorate$1r = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const svgOptions$1 = {
  allWallets: allWalletsSvg,
  alpha: alphaSvg,
  appStore: appStoreSvg,
  chromeStore: chromeStoreSvg,
  apple: appleSvg,
  arrowBottom: arrowBottomSvg,
  arrowLeft: arrowLeftSvg,
  arrowRight: arrowRightSvg,
  arrowTop: arrowTopSvg,
  browser: browserSvg$1,
  checkmark: checkmarkSvg,
  chevronBottom: chevronBottomSvg,
  chevronLeft: chevronLeftSvg,
  chevronRight: chevronRightSvg,
  chevronTop: chevronTopSvg,
  clock: clockSvg,
  close: closeSvg,
  compass: compassSvg,
  coinPlaceholder: coinPlaceholderSvg,
  copy: copySvg,
  cursor: cursorSvg,
  desktop: desktopSvg,
  disconnect: disconnectSvg,
  discord: discordSvg,
  etherscan: etherscanSvg,
  extension: extensionSvg,
  externalLink: externalLinkSvg,
  facebook: facebookSvg,
  filters: filtersSvg,
  github: githubSvg,
  google: googleSvg,
  helpCircle: helpCircleSvg,
  infoCircle: infoCircleSvg,
  mail: mailSvg,
  mobile: mobileSvg,
  networkPlaceholder: networkPlaceholderSvg,
  nftPlaceholder: nftPlaceholderSvg,
  off: offSvg,
  playStore: playStoreSvg,
  qrCode: qrCodeIcon,
  refresh: refreshSvg,
  search: searchSvg,
  swapHorizontal: swapHorizontalSvg,
  swapHorizontalBold: swapHorizontalBoldSvg,
  swapVertical: swapVerticalSvg,
  telegram: telegramSvg,
  twitch: twitchSvg,
  twitter: twitterSvg,
  twitterIcon: twitterIconSvg,
  verify: verifySvg,
  verifyFilled: verifyFilledSvg,
  wallet: walletSvg,
  walletConnect: walletConnectSvg,
  walletPlaceholder: walletPlaceholderSvg,
  warningCircle: warningCircleSvg
};
let WuiIcon = class WuiIcon2 extends s$5 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.name = "copy";
    this.color = "fg-300";
  }
  render() {
    this.style.cssText = `
      --local-color: ${`var(--wui-color-${this.color});`}
      --local-width: ${`var(--wui-icon-size-${this.size});`}
    `;
    return x$1`${svgOptions$1[this.name]}`;
  }
};
WuiIcon.styles = [resetStyles, colorStyles, styles$18];
__decorate$1r([
  n$8()
], WuiIcon.prototype, "size", void 0);
__decorate$1r([
  n$8()
], WuiIcon.prototype, "name", void 0);
__decorate$1r([
  n$8()
], WuiIcon.prototype, "color", void 0);
WuiIcon = __decorate$1r([
  customElement("wui-icon")
], WuiIcon);
const styles$17 = i$8`
  :host {
    display: block;
    width: 100%;
    height: 100%;
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center center;
    border-radius: inherit;
  }
`;
var __decorate$1q = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiImage = class WuiImage2 extends s$5 {
  constructor() {
    super(...arguments);
    this.src = "./path/to/image.jpg";
    this.alt = "Image";
  }
  render() {
    return x$1`<img src=${this.src} alt=${this.alt} />`;
  }
};
WuiImage.styles = [resetStyles, colorStyles, styles$17];
__decorate$1q([
  n$8()
], WuiImage.prototype, "src", void 0);
__decorate$1q([
  n$8()
], WuiImage.prototype, "alt", void 0);
WuiImage = __decorate$1q([
  customElement("wui-image")
], WuiImage);
const styles$16 = i$8`
  :host {
    display: block;
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
  }

  svg {
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
    fill: none;
    stroke: transparent;
    stroke-linecap: round;
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  use {
    stroke: var(--wui-color-accent-100);
    stroke-width: 2px;
    stroke-dasharray: 54, 118;
    stroke-dashoffset: 172;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var __decorate$1p = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLoadingHexagon = class WuiLoadingHexagon2 extends s$5 {
  render() {
    return x$1`
      <svg viewBox="0 0 54 59">
        <path
          id="wui-loader-path"
          d="M17.22 5.295c3.877-2.277 5.737-3.363 7.72-3.726a11.44 11.44 0 0 1 4.12 0c1.983.363 3.844 1.45 7.72 3.726l6.065 3.562c3.876 2.276 5.731 3.372 7.032 4.938a11.896 11.896 0 0 1 2.06 3.63c.683 1.928.688 4.11.688 8.663v7.124c0 4.553-.005 6.735-.688 8.664a11.896 11.896 0 0 1-2.06 3.63c-1.3 1.565-3.156 2.66-7.032 4.937l-6.065 3.563c-3.877 2.276-5.737 3.362-7.72 3.725a11.46 11.46 0 0 1-4.12 0c-1.983-.363-3.844-1.449-7.72-3.726l-6.065-3.562c-3.876-2.276-5.731-3.372-7.032-4.938a11.885 11.885 0 0 1-2.06-3.63c-.682-1.928-.688-4.11-.688-8.663v-7.124c0-4.553.006-6.735.688-8.664a11.885 11.885 0 0 1 2.06-3.63c1.3-1.565 3.156-2.66 7.032-4.937l6.065-3.562Z"
        />
        <use xlink:href="#wui-loader-path"></use>
      </svg>
    `;
  }
};
WuiLoadingHexagon.styles = [resetStyles, styles$16];
WuiLoadingHexagon = __decorate$1p([
  customElement("wui-loading-hexagon")
], WuiLoadingHexagon);
const styles$15 = i$8`
  :host {
    display: flex;
  }

  :host([data-size='sm']) > svg {
    width: 12px;
    height: 12px;
  }

  :host([data-size='md']) > svg {
    width: 16px;
    height: 16px;
  }

  :host([data-size='lg']) > svg {
    width: 24px;
    height: 24px;
  }

  :host([data-size='xl']) > svg {
    width: 32px;
    height: 32px;
  }

  svg {
    animation: rotate 2s linear infinite;
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  circle {
    fill: none;
    stroke: var(--local-color);
    stroke-width: 4px;
    stroke-dasharray: 1, 124;
    stroke-dashoffset: 0;
    stroke-linecap: round;
    animation: dash 1.5s ease-in-out infinite;
  }

  :host([data-size='md']) > svg > circle {
    stroke-width: 6px;
  }

  :host([data-size='sm']) > svg > circle {
    stroke-width: 8px;
  }

  @keyframes rotate {
    100% {
      transform: rotate(360deg);
    }
  }

  @keyframes dash {
    0% {
      stroke-dasharray: 1, 124;
      stroke-dashoffset: 0;
    }

    50% {
      stroke-dasharray: 90, 124;
      stroke-dashoffset: -35;
    }

    100% {
      stroke-dashoffset: -125;
    }
  }
`;
var __decorate$1o = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLoadingSpinner = class WuiLoadingSpinner2 extends s$5 {
  constructor() {
    super(...arguments);
    this.color = "accent-100";
    this.size = "lg";
  }
  render() {
    this.style.cssText = `--local-color: var(--wui-color-${this.color});`;
    this.dataset["size"] = this.size;
    return x$1`<svg viewBox="25 25 50 50">
      <circle r="20" cy="50" cx="50"></circle>
    </svg>`;
  }
};
WuiLoadingSpinner.styles = [resetStyles, styles$15];
__decorate$1o([
  n$8()
], WuiLoadingSpinner.prototype, "color", void 0);
__decorate$1o([
  n$8()
], WuiLoadingSpinner.prototype, "size", void 0);
WuiLoadingSpinner = __decorate$1o([
  customElement("wui-loading-spinner")
], WuiLoadingSpinner);
const styles$14 = i$8`
  :host {
    display: block;
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  svg {
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  rect {
    fill: none;
    stroke: var(--wui-color-accent-100);
    stroke-width: 4px;
    stroke-linecap: round;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var __decorate$1n = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLoadingThumbnail = class WuiLoadingThumbnail2 extends s$5 {
  constructor() {
    super(...arguments);
    this.radius = 36;
  }
  render() {
    return this.svgLoaderTemplate();
  }
  svgLoaderTemplate() {
    const radius = this.radius > 50 ? 50 : this.radius;
    const standardValue = 36;
    const radiusFactor = standardValue - radius;
    const dashArrayStart = 116 + radiusFactor;
    const dashArrayEnd = 245 + radiusFactor;
    const dashOffset = 360 + radiusFactor * 1.75;
    return x$1`
      <svg viewBox="0 0 110 110" width="110" height="110">
        <rect
          x="2"
          y="2"
          width="106"
          height="106"
          rx=${radius}
          stroke-dasharray="${dashArrayStart} ${dashArrayEnd}"
          stroke-dashoffset=${dashOffset}
        />
      </svg>
    `;
  }
};
WuiLoadingThumbnail.styles = [resetStyles, styles$14];
__decorate$1n([
  n$8({ type: Number })
], WuiLoadingThumbnail.prototype, "radius", void 0);
WuiLoadingThumbnail = __decorate$1n([
  customElement("wui-loading-thumbnail")
], WuiLoadingThumbnail);
const styles$13 = i$8`
  :host {
    display: block;
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-200) 5%,
      var(--wui-color-bg-200) 48%,
      var(--wui-color-bg-300) 55%,
      var(--wui-color-bg-300) 60%,
      var(--wui-color-bg-300) calc(60% + 10px),
      var(--wui-color-bg-200) calc(60% + 12px),
      var(--wui-color-bg-200) 100%
    );
    background-size: 250%;
    animation: shimmer 3s linear infinite reverse;
  }

  @keyframes shimmer {
    from {
      background-position: -250% 0;
    }
    to {
      background-position: 250% 0;
    }
  }
`;
var __decorate$1m = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiShimmer = class WuiShimmer2 extends s$5 {
  constructor() {
    super(...arguments);
    this.width = "";
    this.height = "";
    this.borderRadius = "m";
  }
  render() {
    this.style.cssText = `
      width: ${this.width};
      height: ${this.height};
      border-radius: ${`clamp(0px,var(--wui-border-radius-${this.borderRadius}), 40px)`};
    `;
    return x$1`<slot></slot>`;
  }
};
WuiShimmer.styles = [styles$13];
__decorate$1m([
  n$8()
], WuiShimmer.prototype, "width", void 0);
__decorate$1m([
  n$8()
], WuiShimmer.prototype, "height", void 0);
__decorate$1m([
  n$8()
], WuiShimmer.prototype, "borderRadius", void 0);
WuiShimmer = __decorate$1m([
  customElement("wui-shimmer")
], WuiShimmer);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$3 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, e$7 = (t2) => (...e2) => ({ _$litDirective$: t2, values: e2 });
let i$5 = class i {
  constructor(t2) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t2, e2, i3) {
    this._$Ct = t2, this._$AM = e2, this._$Ci = i3;
  }
  _$AS(t2, e2) {
    return this.update(t2, e2);
  }
  update(t2, e2) {
    return this.render(...e2);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$6 = e$7(class extends i$5 {
  constructor(t2) {
    if (super(t2), t2.type !== t$3.ATTRIBUTE || "class" !== t2.name || t2.strings?.length > 2)
      throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t2) {
    return " " + Object.keys(t2).filter((s4) => t2[s4]).join(" ") + " ";
  }
  update(s4, [i3]) {
    if (void 0 === this.it) {
      this.it = /* @__PURE__ */ new Set(), void 0 !== s4.strings && (this.st = new Set(s4.strings.join(" ").split(/\s/).filter((t2) => "" !== t2)));
      for (const t2 in i3)
        i3[t2] && !this.st?.has(t2) && this.it.add(t2);
      return this.render(i3);
    }
    const r2 = s4.element.classList;
    for (const t2 of this.it)
      t2 in i3 || (r2.remove(t2), this.it.delete(t2));
    for (const t2 in i3) {
      const s5 = !!i3[t2];
      s5 === this.it.has(t2) || this.st?.has(t2) || (s5 ? (r2.add(t2), this.it.add(t2)) : (r2.remove(t2), this.it.delete(t2)));
    }
    return w$2;
  }
});
const styles$12 = i$8`
  :host {
    display: flex !important;
  }

  slot {
    display: inline-block;
    font-style: normal;
    font-family: var(--wui-font-family);
    font-feature-settings:
      'tnum' on,
      'lnum' on,
      'case' on;
    line-height: 130%;
    font-weight: var(--wui-font-weight-regular);
    overflow: inherit;
    text-overflow: inherit;
    text-align: var(--local-align);
    color: var(--local-color);
  }

  .wui-font-large-500,
  .wui-font-large-600,
  .wui-font-large-700 {
    font-size: var(--wui-font-size-large);
    letter-spacing: var(--wui-letter-spacing-large);
  }

  .wui-font-paragraph-500,
  .wui-font-paragraph-600,
  .wui-font-paragraph-700 {
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
  }

  .wui-font-small-400,
  .wui-font-small-500,
  .wui-font-small-600 {
    font-size: var(--wui-font-size-small);
    letter-spacing: var(--wui-letter-spacing-small);
  }

  .wui-font-tiny-500,
  .wui-font-tiny-600 {
    font-size: var(--wui-font-size-tiny);
    letter-spacing: var(--wui-letter-spacing-tiny);
  }

  .wui-font-micro-700,
  .wui-font-micro-600 {
    font-size: var(--wui-font-size-micro);
    letter-spacing: var(--wui-letter-spacing-micro);
    text-transform: uppercase;
  }

  .wui-font-small-400,
  .wui-font-paragraph-400 {
    font-weight: var(--wui-font-weight-light);
  }

  .wui-font-large-700,
  .wui-font-paragraph-700,
  .wui-font-micro-700 {
    font-weight: var(--wui-font-weight-bold);
  }

  .wui-font-large-600,
  .wui-font-paragraph-600,
  .wui-font-small-600,
  .wui-font-tiny-600,
  .wui-font-micro-600 {
    font-weight: var(--wui-font-weight-medium);
  }
`;
var __decorate$1l = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiText = class WuiText2 extends s$5 {
  constructor() {
    super(...arguments);
    this.variant = "paragraph-500";
    this.color = "fg-300";
    this.align = "left";
  }
  render() {
    const classes = {
      [`wui-font-${this.variant}`]: true,
      [`wui-color-${this.color}`]: true
    };
    this.style.cssText = `
      --local-align: ${this.align};
      --local-color: var(--wui-color-${this.color});
    `;
    return x$1`<slot class=${e$6(classes)}></slot>`;
  }
};
WuiText.styles = [resetStyles, styles$12];
__decorate$1l([
  n$8()
], WuiText.prototype, "variant", void 0);
__decorate$1l([
  n$8()
], WuiText.prototype, "color", void 0);
__decorate$1l([
  n$8()
], WuiText.prototype, "align", void 0);
WuiText = __decorate$1l([
  customElement("wui-text")
], WuiText);
const browserSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="30" />
  <circle cx="30" cy="30" r="3" fill="#fff" />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m45.32 17.9-.88-.42.88.42.02-.05c.1-.2.21-.44.26-.7l-.82-.15.82.16a2 2 0 0 0-.24-1.4c-.13-.23-.32-.42-.47-.57a8.42 8.42 0 0 1-.04-.04l-.04-.04a2.9 2.9 0 0 0-.56-.47l-.51.86.5-.86a2 2 0 0 0-1.4-.24c-.26.05-.5.16-.69.26l-.05.02-15.05 7.25-.1.05c-1.14.55-1.85.89-2.46 1.37a7 7 0 0 0-1.13 1.14c-.5.6-.83 1.32-1.38 2.45l-.05.11-7.25 15.05-.02.05c-.1.2-.21.43-.26.69a2 2 0 0 0 .24 1.4l.85-.5-.85.5c.13.23.32.42.47.57l.04.04.04.04c.15.15.34.34.56.47a2 2 0 0 0 1.41.24l-.2-.98.2.98c.25-.05.5-.17.69-.26l.05-.02-.42-.87.42.87 15.05-7.25.1-.05c1.14-.55 1.85-.89 2.46-1.38a7 7 0 0 0 1.13-1.13 12.87 12.87 0 0 0 1.43-2.56l7.25-15.05Z"
  />
  <path
    fill="#1DC956"
    d="M33.38 32.72 30.7 29.3 15.86 44.14l.2.2a1 1 0 0 0 1.14.2l15.1-7.27a3 3 0 0 0 1.08-4.55Z"
  />
  <path
    fill="#86F999"
    d="m26.62 27.28 2.67 3.43 14.85-14.85-.2-.2a1 1 0 0 0-1.14-.2l-15.1 7.27a3 3 0 0 0-1.08 4.55Z"
  />
  <circle cx="30" cy="30" r="3" fill="#fff" transform="rotate(45 30 30)" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
</svg> `;
const daoSvg = b$1`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#clip0_7734_50402)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#EB8B47"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M19 52C24.5228 52 29 47.5228 29 42C29 36.4772 24.5228 32 19 32C13.4772 32 9 36.4772 9 42C9 47.5228 13.4772 52 19 52Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.8437 8.3264C42.4507 7.70891 41.5493 7.70891 41.1564 8.32641L28.978 27.4638C28.5544 28.1295 29.0326 29.0007 29.8217 29.0007H54.1783C54.9674 29.0007 55.4456 28.1295 55.022 27.4638L42.8437 8.3264Z"
      fill="white"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.3348 11.6456C42.659 11.7608 42.9061 12.1492 43.4005 12.926L50.7332 24.4488C51.2952 25.332 51.5763 25.7737 51.5254 26.1382C51.4915 26.3808 51.3698 26.6026 51.1833 26.7614C50.9031 27 50.3796 27 49.3327 27H34.6673C33.6204 27 33.0969 27 32.8167 26.7614C32.6302 26.6026 32.5085 26.3808 32.4746 26.1382C32.4237 25.7737 32.7048 25.332 33.2669 24.4488L40.5995 12.926C41.0939 12.1492 41.341 11.7608 41.6652 11.6456C41.8818 11.5687 42.1182 11.5687 42.3348 11.6456ZM35.0001 26.999C38.8661 26.999 42.0001 23.865 42.0001 19.999C42.0001 23.865 45.1341 26.999 49.0001 26.999H35.0001Z"
      fill="#FF974C"
    />
    <path
      d="M10.1061 9.35712C9.9973 9.67775 9.99867 10.0388 9.99978 10.3323C9.99989 10.3611 10 10.3893 10 10.4167V25.5833C10 25.6107 9.99989 25.6389 9.99978 25.6677C9.99867 25.9612 9.9973 26.3222 10.1061 26.6429C10.306 27.2317 10.7683 27.694 11.3571 27.8939C11.6777 28.0027 12.0388 28.0013 12.3323 28.0002C12.3611 28.0001 12.3893 28 12.4167 28H19C24.5228 28 29 23.5228 29 18C29 12.4772 24.5228 8 19 8H12.4167C12.3893 8 12.3611 7.99989 12.3323 7.99978C12.0388 7.99867 11.6778 7.9973 11.3571 8.10614C10.7683 8.306 10.306 8.76834 10.1061 9.35712Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="19" cy="18" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
    <circle cx="19" cy="42" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="clip0_7734_50402">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `;
const defiSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#1DC956"
      d="M0 25.01c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02.11 15.65.11 24.9.11h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.13 60 15.76 60 25v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-3.45 1.97-8.08 1.97-17.33 1.97H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 49.1 0 44.46 0 35.21v-10.2Z"
    />
    <path
      fill="#2BEE6C"
      d="M16.1 60c-3.82-.18-6.4-.64-8.53-1.86a15 15 0 0 1-5.6-5.6C.55 50.06.16 46.97.04 41.98L4.2 40.6a4 4 0 0 0 2.48-2.39l4.65-12.4a2 2 0 0 1 2.5-1.2l2.53.84a2 2 0 0 0 2.43-1l2.96-5.94a2 2 0 0 1 3.7.32l3.78 12.58a2 2 0 0 0 3.03 1.09l3.34-2.23a2 2 0 0 0 .65-.7l5.3-9.72a2 2 0 0 1 1.42-1.01l4.14-.69a2 2 0 0 1 1.6.44l3.9 3.24a2 2 0 0 0 2.7-.12l4.62-4.63c.08 2.2.08 4.8.08 7.93v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-2.13 1.22-4.7 1.68-8.54 1.86H16.11Z"
    />
    <path
      fill="#fff"
      d="m.07 43.03-.05-2.1 3.85-1.28a3 3 0 0 0 1.86-1.79l4.66-12.4a3 3 0 0 1 3.75-1.8l2.53.84a1 1 0 0 0 1.21-.5l2.97-5.94a3 3 0 0 1 5.56.48l3.77 12.58a1 1 0 0 0 1.51.55l3.34-2.23a1 1 0 0 0 .33-.35l5.3-9.71a3 3 0 0 1 2.14-1.53l4.13-.69a3 3 0 0 1 2.41.66l3.9 3.24a1 1 0 0 0 1.34-.06l5.28-5.28c.05.85.08 1.75.1 2.73L56 22.41a3 3 0 0 1-4.04.19l-3.9-3.25a1 1 0 0 0-.8-.21l-4.13.69a1 1 0 0 0-.72.5l-5.3 9.72a3 3 0 0 1-.97 1.05l-3.34 2.23a3 3 0 0 1-4.53-1.63l-3.78-12.58a1 1 0 0 0-1.85-.16l-2.97 5.94a3 3 0 0 1-3.63 1.5l-2.53-.84a1 1 0 0 0-1.25.6l-4.65 12.4a5 5 0 0 1-3.1 3L.07 43.02Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M49.5 19a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M45 .28v59.66l-2 .1V.19c.7.02 1.37.05 2 .1Z" />
    <path fill="#2BEE6C" d="M47.5 19a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
    <path
      stroke="#fff"
      stroke-opacity=".1"
      d="M.5 25.01c0-4.63 0-8.08.24-10.8.25-2.7.73-4.64 1.66-6.28a14.5 14.5 0 0 1 5.42-5.41C9.46 1.58 11.39 1.1 14.1.85A133 133 0 0 1 24.9.61h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.67a14.5 14.5 0 0 1 5.42 5.4c.93 1.65 1.41 3.58 1.66 6.3.24 2.71.24 6.16.24 10.79v10.2c0 4.64 0 8.08-.24 10.8-.25 2.7-.73 4.65-1.66 6.28a14.5 14.5 0 0 1-5.42 5.42c-1.63.93-3.57 1.41-6.28 1.66-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.66a14.5 14.5 0 0 1-5.42-5.42C1.47 50.66 1 48.72.74 46.01A133 133 0 0 1 .5 35.2v-10.2Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg>`;
const defiAltSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="30" />
    <path
      fill="#E87DE8"
      d="M57.98.01v19.5a4.09 4.09 0 0 0-2.63 2.29L50.7 34.2a2 2 0 0 1-2.5 1.2l-2.53-.84a2 2 0 0 0-2.42 1l-2.97 5.94a2 2 0 0 1-3.7-.32L32.8 28.6a2 2 0 0 0-3.02-1.09l-3.35 2.23a2 2 0 0 0-.64.7l-5.3 9.72a2 2 0 0 1-1.43 1.01l-4.13.69a2 2 0 0 1-1.61-.44l-3.9-3.24a2 2 0 0 0-2.69.12L2.1 42.93.02 43V.01h57.96Z"
    />
    <path
      fill="#fff"
      d="m61.95 16.94.05 2.1-3.85 1.28a3 3 0 0 0-1.86 1.79l-4.65 12.4a3 3 0 0 1-3.76 1.8l-2.53-.84a1 1 0 0 0-1.2.5l-2.98 5.94a3 3 0 0 1-5.55-.48l-3.78-12.58a1 1 0 0 0-1.5-.55l-3.35 2.23a1 1 0 0 0-.32.35l-5.3 9.72a3 3 0 0 1-2.14 1.52l-4.14.69a3 3 0 0 1-2.41-.66l-3.9-3.24a1 1 0 0 0-1.34.06l-5.28 5.28c-.05-.84-.08-1.75-.1-2.73l3.97-3.96a3 3 0 0 1 4.04-.19l3.89 3.25a1 1 0 0 0 .8.21l4.14-.68a1 1 0 0 0 .71-.51l5.3-9.71a3 3 0 0 1 .97-1.06l3.34-2.23a3 3 0 0 1 4.54 1.63l3.77 12.58a1 1 0 0 0 1.86.16l2.96-5.93a3 3 0 0 1 3.64-1.5l2.52.83a1 1 0 0 0 1.25-.6l4.66-12.4a5 5 0 0 1 3.1-2.99l4.43-1.48Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M35.5 27a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M31 0v60h-2V0h2Z" />
    <path fill="#E87DE8" d="M33.5 27a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `;
const ethSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#987DE8" rx="30" />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="m15.48 28.37 11.97-19.3a3 3 0 0 1 5.1 0l11.97 19.3a6 6 0 0 1 .9 3.14v.03a6 6 0 0 1-1.16 3.56L33.23 50.2a4 4 0 0 1-6.46 0L15.73 35.1a6 6 0 0 1-1.15-3.54v-.03a6 6 0 0 1 .9-3.16Z"
      clip-rule="evenodd"
    />
    <path
      fill="#643CDD"
      d="M30.84 10.11a1 1 0 0 0-.84-.46V24.5l12.6 5.53a2 2 0 0 0-.28-1.4L30.84 10.11Z"
    />
    <path
      fill="#BDADEB"
      d="M30 9.65a1 1 0 0 0-.85.46L17.66 28.64a2 2 0 0 0-.26 1.39L30 24.5V9.65Z"
    />
    <path
      fill="#643CDD"
      d="M30 50.54a1 1 0 0 0 .8-.4l11.24-15.38c.3-.44-.2-1-.66-.73l-9.89 5.68a3 3 0 0 1-1.5.4v10.43Z"
    />
    <path
      fill="#BDADEB"
      d="m17.97 34.76 11.22 15.37c.2.28.5.41.8.41V40.11a3 3 0 0 1-1.49-.4l-9.88-5.68c-.47-.27-.97.3-.65.73Z"
    />
    <path
      fill="#401AB3"
      d="M42.6 30.03 30 24.5v13.14a3 3 0 0 0 1.5-.4l10.14-5.83a2 2 0 0 0 .95-1.38Z"
    />
    <path
      fill="#7C5AE2"
      d="M30 37.64V24.46l-12.6 5.57a2 2 0 0 0 .97 1.39l10.13 5.82a3 3 0 0 0 1.5.4Z"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `;
const layersSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="3" />
  <path
    fill="#1FAD7E"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 29.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 19.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#86F999"
    stroke="#fff"
    stroke-width="2"
    d="m46.69 21.06-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-6.32-3.51-.18-.1c-2.33-1.3-3.72-2.06-5.22-2.33a9 9 0 0 0-3.08 0c-1.5.27-2.9 1.04-5.22 2.33l-.17.1-6.33 3.51-.05.03c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45Z"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;
const lockSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#C653C6" rx="3" />
  <path
    fill="#fff"
    d="M20.03 15.22C20 15.6 20 16.07 20 17v2.8c0 1.14 0 1.7-.2 2.12-.15.31-.3.5-.58.71-.37.28-1.06.42-2.43.7-.59.12-1.11.29-1.6.51a9 9 0 0 0-4.35 4.36C10 30 10 32.34 10 37c0 4.66 0 7 .84 8.8a9 9 0 0 0 4.36 4.36C17 51 19.34 51 24 51h12c4.66 0 7 0 8.8-.84a9 9 0 0 0 4.36-4.36C50 44 50 41.66 50 37c0-4.66 0-7-.84-8.8a9 9 0 0 0-4.36-4.36c-.48-.22-1-.39-1.6-.5-1.36-.29-2.05-.43-2.42-.7-.27-.22-.43-.4-.58-.72-.2-.42-.2-.98-.2-2.11V17c0-.93 0-1.4-.03-1.78a9 9 0 0 0-8.19-8.19C31.4 7 30.93 7 30 7s-1.4 0-1.78.03a9 9 0 0 0-8.19 8.19Z"
  />
  <path
    fill="#E87DE8"
    d="M22 17c0-.93 0-1.4.04-1.78a7 7 0 0 1 6.18-6.18C28.6 9 29.07 9 30 9s1.4 0 1.78.04a7 7 0 0 1 6.18 6.18c.04.39.04.85.04 1.78v4.5a1.5 1.5 0 0 1-3 0V17c0-.93 0-1.4-.08-1.78a4 4 0 0 0-3.14-3.14C31.39 12 30.93 12 30 12s-1.4 0-1.78.08a4 4 0 0 0-3.14 3.14c-.08.39-.08.85-.08 1.78v4.5a1.5 1.5 0 0 1-3 0V17Z"
  />
  <path
    fill="#E87DE8"
    fill-rule="evenodd"
    d="M12 36.62c0-4.32 0-6.48.92-8.09a7 7 0 0 1 2.61-2.61C17.14 25 19.3 25 23.62 25h6.86c.46 0 .7 0 .9.02 2.73.22 4.37 2.43 4.62 4.98.27-2.7 2.11-5 5.02-5A6.98 6.98 0 0 1 48 31.98v5.4c0 4.32 0 6.48-.92 8.09a7 7 0 0 1-2.61 2.61c-1.61.92-3.77.92-8.09.92h-5.86c-.46 0-.7 0-.9-.02-2.73-.22-4.37-2.43-4.62-4.98-.26 2.58-1.94 4.82-4.71 4.99l-.7.01c-.55 0-.82 0-1.05-.02a7 7 0 0 1-6.52-6.52c-.02-.23-.02-.5-.02-1.05v-4.79Zm21.24-.27a4 4 0 1 0-6.48 0 31.28 31.28 0 0 1 1.57 2.23c.17.4.17.81.17 1.24V42.5a1.5 1.5 0 0 0 3 0V39.82c0-.43 0-.85.17-1.24.09-.2.58-.87 1.57-2.23Z"
    clip-rule="evenodd"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;
const loginSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#EB8B47"
      d="M0 24.9c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02 0 15.65 0 24.9 0h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.02 60 15.65 60 24.9v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6C48.98 60 44.35 60 35.1 60H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 48.98 0 44.35 0 35.1V24.9Z"
    />
    <path
      stroke="#062B2B"
      stroke-opacity=".1"
      d="M.5 24.9c0-4.64 0-8.08.24-10.8.25-2.7.73-4.65 1.66-6.28A14.5 14.5 0 0 1 7.82 2.4C9.46 1.47 11.39 1 14.1.74A133 133 0 0 1 24.9.5h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.66a14.5 14.5 0 0 1 5.42 5.42c.93 1.63 1.41 3.57 1.66 6.28.24 2.72.24 6.16.24 10.8v10.2c0 4.63 0 8.08-.24 10.8-.25 2.7-.73 4.64-1.66 6.28a14.5 14.5 0 0 1-5.42 5.41c-1.63.94-3.57 1.42-6.28 1.67-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.67a14.5 14.5 0 0 1-5.42-5.4C1.47 50.53 1 48.6.74 45.88A133 133 0 0 1 .5 35.1V24.9Z"
    />
    <path
      fill="#FF974C"
      stroke="#fff"
      stroke-width="2"
      d="M39.2 29.2a13 13 0 1 0-18.4 0l1.3 1.28a12.82 12.82 0 0 1 2.1 2.39 6 6 0 0 1 .6 1.47c.2.76.2 1.56.2 3.17v11.24c0 1.08 0 1.61.13 2.12a4 4 0 0 0 .41.98c.26.45.64.83 1.4 1.6l.3.29c.65.65.98.98 1.36 1.09.26.07.54.07.8 0 .38-.11.7-.44 1.36-1.1l3.48-3.47c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.47-.48c-.65-.65-.98-.98-1.09-1.36a1.5 1.5 0 0 1 0-.8c.1-.38.44-.7 1.1-1.36l.47-.48c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.48-.5c-.65-.64-.98-.97-1.08-1.35a1.5 1.5 0 0 1 0-.79c.1-.38.42-.7 1.06-1.36l5.46-5.55Z"
    />
    <circle cx="30" cy="17" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg> `;
const networkSvg$1 = b$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#00ACE6" rx="30" />
    <circle cx="64" cy="39" r="50" fill="#1AC6FF" stroke="#fff" stroke-width="2" />
    <circle cx="78" cy="30" r="50" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="72" cy="15" r="35" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-17" r="45" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-5" r="50" stroke="#fff" stroke-width="2" />
    <circle cx="30" cy="45" r="4" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="39.5" cy="27.5" r="4" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="16" cy="24" r="4" fill="#19C6FF" stroke="#fff" stroke-width="2" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg>`;
const nftSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="3" />
    <path
      fill="#E87DE8"
      stroke="#fff"
      stroke-width="2"
      d="M52.1 47.34c0-4.24-1.44-9.55-5.9-12.4a2.86 2.86 0 0 0-1.6-3.89v-.82c0-1.19-.52-2.26-1.35-3a4.74 4.74 0 0 0-2.4-6.26v-5.5a11.31 11.31 0 1 0-22.63 0v2.15a3.34 3.34 0 0 0-1.18 5.05 4.74 4.74 0 0 0-.68 6.44A5.22 5.22 0 0 0 14 35.92c-3.06 4.13-6.1 8.3-6.1 15.64 0 2.67.37 4.86.74 6.39a20.3 20.3 0 0 0 .73 2.39l.02.04v.01l.92-.39-.92.4.26.6h38.26l.3-.49-.87-.51.86.5.02-.01.03-.07a16.32 16.32 0 0 0 .57-1.05c.36-.72.85-1.74 1.33-2.96a25.51 25.51 0 0 0 1.94-9.07Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M26.5 29.5c-3-.5-5.5-3-5.5-7v-7c0-.47 0-.7.03-.9a3 3 0 0 1 2.58-2.57c.2-.03.42-.03.89-.03 2 0 2.5-2.5 2.5-2.5s0 2.5 2.5 2.5c1.4 0 2.1 0 2.65.23a3 3 0 0 1 1.62 1.62c.23.55.23 1.25.23 2.65v6c0 4-3 7-6.5 7 1.35.23 4 0 6.5-2v9.53C34 38.5 31.5 40 28 40s-6-1.5-6-2.97L24 34l2.5 1.5v-6ZM26 47h4.5c2.5 0 3 4 3 5.5h-3l-1-1.5H26v-4Zm-6.25 5.5H24V57h-8c0-1 1-4.5 3.75-4.5Z"
      clip-rule="evenodd"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="3" /></clipPath>
  </defs>
</svg> `;
const nounSvg = b$1`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#794CFF" rx="3" />
  <path
    fill="#987DE8"
    stroke="#fff"
    stroke-width="2"
    d="M33 22.5v-1H16v5H8.5V36H13v-5h3v7.5h17V31h1v7.5h17v-17H34v5h-1v-4Z"
  />
  <path fill="#fff" d="M37.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M42.5 25h5v10h-5z" />
  <path fill="#fff" d="M19.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M24.5 25h5v10h-5z" />
  <path fill="#fff" d="M12 30.5h4V37h-4v-6.5Z" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;
const profileSvg = b$1`<svg
  viewBox="0 0 60 60"
  fill="none"
>
  <g clip-path="url(#1)">
    <rect width="60" height="60" rx="30" fill="#00ACE6" />
    <path
      d="M59 73C59 89.0163 46.0163 102 30 102C13.9837 102 1 89.0163 1 73C1 56.9837 12 44 30 44C48 44 59 56.9837 59 73Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M18.6904 19.9015C19.6264 15.3286 23.3466 11.8445 27.9708 11.2096C29.3231 11.024 30.6751 11.0238 32.0289 11.2096C36.6532 11.8445 40.3733 15.3286 41.3094 19.9015C41.4868 20.7681 41.6309 21.6509 41.7492 22.5271C41.8811 23.5041 41.8811 24.4944 41.7492 25.4715C41.6309 26.3476 41.4868 27.2304 41.3094 28.097C40.3733 32.6699 36.6532 36.154 32.0289 36.7889C30.6772 36.9744 29.3216 36.9743 27.9708 36.7889C23.3466 36.154 19.6264 32.6699 18.6904 28.097C18.513 27.2304 18.3689 26.3476 18.2506 25.4715C18.1186 24.4944 18.1186 23.5041 18.2506 22.5271C18.3689 21.6509 18.513 20.7681 18.6904 19.9015Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="24.5" cy="23.5" r="1.5" fill="white" />
    <circle cx="35.5" cy="23.5" r="1.5" fill="white" />
    <path
      d="M31 20L28 28H32"
      stroke="white"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    />
  </g>
  <rect x="0.5" y="0.5" width="59" height="59" rx="29.5" stroke="white" stroke-opacity="0.1" />
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" rx="30" fill="white" />
    </clipPath>
  </defs>
</svg> `;
const systemSvg = b$1`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#1)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#794CFF"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M35.1403 31.5016C35.1193 30.9637 35.388 30.4558 35.8446 30.1707C36.1207 29.9982 36.4761 29.8473 36.7921 29.7685C37.3143 29.6382 37.8664 29.7977 38.2386 30.1864C38.8507 30.8257 39.3004 31.6836 39.8033 32.408C40.2796 33.0942 41.4695 33.2512 41.9687 32.5047C42.4839 31.7341 42.9405 30.8229 43.572 30.1399C43.9375 29.7447 44.4866 29.5756 45.0111 29.6967C45.3283 29.7701 45.6863 29.9147 45.9655 30.0823C46.4269 30.3595 46.7045 30.8626 46.6928 31.4008C46.6731 32.3083 46.3764 33.2571 46.2158 34.1473C46.061 35.0048 46.9045 35.8337 47.7592 35.664C48.6464 35.4878 49.5899 35.1747 50.497 35.1391C51.0348 35.1181 51.5427 35.3868 51.8279 35.8433C52.0004 36.1195 52.1513 36.4749 52.2301 36.7908C52.3604 37.3131 52.2009 37.8651 51.8121 38.2374C51.1729 38.8495 50.3151 39.2991 49.5908 39.8019C48.9046 40.2782 48.7473 41.4683 49.4939 41.9675C50.2644 42.4827 51.1757 42.9393 51.8587 43.5708C52.2539 43.9362 52.423 44.4854 52.3018 45.0099C52.2285 45.3271 52.0839 45.6851 51.9162 45.9642C51.6391 46.4257 51.1359 46.7032 50.5978 46.6916C49.6903 46.6719 48.7417 46.3753 47.8516 46.2146C46.9939 46.0598 46.1648 46.9035 46.3346 47.7583C46.5108 48.6454 46.8239 49.5888 46.8594 50.4958C46.8805 51.0336 46.6117 51.5415 46.1552 51.8267C45.879 51.9992 45.5236 52.15 45.2077 52.2289C44.6854 52.3592 44.1334 52.1997 43.7611 51.8109C43.1491 51.1718 42.6996 50.314 42.1968 49.5897C41.7203 48.9034 40.5301 48.7463 40.0309 49.493C39.5157 50.2634 39.0592 51.1746 38.4278 51.8574C38.0623 52.2527 37.5132 52.4218 36.9887 52.3006C36.6715 52.2273 36.3135 52.0826 36.0343 51.915C35.5729 51.6379 35.2953 51.1347 35.307 50.5966C35.3267 49.6891 35.6233 48.7405 35.7839 47.8505C35.9388 46.9928 35.0951 46.1636 34.2402 46.3334C33.3531 46.5096 32.4098 46.8227 31.5028 46.8582C30.9649 46.8793 30.457 46.6105 30.1719 46.154C29.9994 45.8778 29.8485 45.5224 29.7697 45.2065C29.6394 44.6842 29.7989 44.1322 30.1877 43.7599C30.8269 43.1479 31.6847 42.6982 32.4091 42.1954C33.0954 41.7189 33.2522 40.5289 32.5056 40.0297C31.7351 39.5145 30.824 39.058 30.1411 38.4265C29.7459 38.0611 29.5768 37.5119 29.698 36.9875C29.7713 36.6702 29.9159 36.3122 30.0836 36.0331C30.3607 35.5717 30.8638 35.2941 31.402 35.3058C32.3095 35.3255 33.2583 35.6221 34.1485 35.7828C35.006 35.9376 35.8349 35.094 35.6652 34.2393C35.489 33.3521 35.1759 32.4087 35.1403 31.5016Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M20.7706 8.22357C20.9036 7.51411 21.5231 7 22.2449 7H23.7551C24.4769 7 25.0964 7.51411 25.2294 8.22357C25.5051 9.69403 25.4829 11.6321 27.1202 12.2606C27.3092 12.3331 27.4958 12.4105 27.6798 12.4926C29.2818 13.2072 30.6374 11.8199 31.8721 10.9752C32.4678 10.5676 33.2694 10.6421 33.7798 11.1525L34.8477 12.2204C35.3581 12.7308 35.4326 13.5323 35.025 14.128C34.1802 15.3627 32.7931 16.7183 33.5077 18.3202C33.5898 18.5043 33.6672 18.6909 33.7398 18.88C34.3683 20.5171 36.3061 20.4949 37.7764 20.7706C38.4859 20.9036 39 21.5231 39 22.2449V23.7551C39 24.4769 38.4859 25.0964 37.7764 25.2294C36.3061 25.5051 34.3685 25.483 33.7401 27.1201C33.6675 27.3093 33.59 27.4961 33.5079 27.6803C32.7934 29.282 34.1803 30.6374 35.025 31.8719C35.4326 32.4677 35.3581 33.2692 34.8477 33.7796L33.7798 34.8475C33.2694 35.3579 32.4678 35.4324 31.8721 35.0248C30.6376 34.1801 29.2823 32.7934 27.6806 33.508C27.4962 33.5903 27.3093 33.6678 27.12 33.7405C25.483 34.3688 25.5051 36.3062 25.2294 37.7764C25.0964 38.4859 24.4769 39 23.7551 39H22.2449C21.5231 39 20.9036 38.4859 20.7706 37.7764C20.4949 36.3062 20.517 34.3688 18.88 33.7405C18.6908 33.6678 18.5039 33.5903 18.3196 33.5081C16.7179 32.7936 15.3625 34.1804 14.1279 35.0251C13.5322 35.4327 12.7307 35.3582 12.2203 34.8478L11.1524 33.7799C10.642 33.2695 10.5675 32.4679 10.9751 31.8722C11.8198 30.6376 13.2067 29.2822 12.4922 27.6804C12.41 27.4962 12.3325 27.3093 12.2599 27.1201C11.6315 25.483 9.69392 25.5051 8.22357 25.2294C7.51411 25.0964 7 24.4769 7 23.7551V22.2449C7 21.5231 7.51411 20.9036 8.22357 20.7706C9.69394 20.4949 11.6317 20.5171 12.2602 18.88C12.3328 18.6909 12.4103 18.5042 12.4924 18.3201C13.207 16.7181 11.8198 15.3625 10.975 14.1278C10.5674 13.5321 10.6419 12.7305 11.1523 12.2201L12.2202 11.1522C12.7306 10.6418 13.5322 10.5673 14.1279 10.9749C15.3626 11.8197 16.7184 13.2071 18.3204 12.4925C18.5044 12.4105 18.6909 12.3331 18.8799 12.2606C20.5171 11.6321 20.4949 9.69403 20.7706 8.22357Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="23" cy="23" r="6" fill="#794CFF" stroke="white" stroke-width="2" />
    <circle cx="41" cy="41" r="4" fill="#794CFF" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `;
const styles$11 = i$8`
  :host {
    display: block;
    width: 55px;
    height: 55px;
  }
`;
var __decorate$1k = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const svgOptions = {
  browser: browserSvg,
  dao: daoSvg,
  defi: defiSvg,
  defiAlt: defiAltSvg,
  eth: ethSvg,
  layers: layersSvg,
  lock: lockSvg,
  login: loginSvg,
  network: networkSvg$1,
  nft: nftSvg,
  noun: nounSvg,
  profile: profileSvg,
  system: systemSvg
};
let WuiVisual = class WuiVisual2 extends s$5 {
  constructor() {
    super(...arguments);
    this.name = "browser";
  }
  render() {
    return x$1`${svgOptions[this.name]}`;
  }
};
WuiVisual.styles = [resetStyles, styles$11];
__decorate$1k([
  n$8()
], WuiVisual.prototype, "name", void 0);
WuiVisual = __decorate$1k([
  customElement("wui-visual")
], WuiVisual);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$9 = (o2) => o2 ?? T$2;
const UiHelperUtil = {
  getSpacingStyles(spacing, index2) {
    if (Array.isArray(spacing)) {
      return spacing[index2] ? `var(--wui-spacing-${spacing[index2]})` : void 0;
    } else if (typeof spacing === "string") {
      return `var(--wui-spacing-${spacing})`;
    }
    return void 0;
  },
  getFormattedDate(date) {
    return new Intl.DateTimeFormat("en-US", { month: "short", day: "numeric" }).format(date);
  },
  getHostName(url) {
    const newUrl = new URL(url);
    return newUrl.hostname;
  },
  getTruncateString({ string: string2, charsStart, charsEnd, truncate: truncate2 }) {
    if (string2.length <= charsStart + charsEnd) {
      return string2;
    }
    if (truncate2 === "end") {
      return `${string2.substring(0, charsStart)}...`;
    } else if (truncate2 === "start") {
      return `...${string2.substring(string2.length - charsEnd)}`;
    }
    return `${string2.substring(0, Math.floor(charsStart))}...${string2.substring(string2.length - Math.floor(charsEnd))}`;
  },
  generateAvatarColors(address) {
    const hash2 = address.toLowerCase().replace(/^0x/iu, "");
    const baseColor = hash2.substring(0, 6);
    const rgbColor = this.hexToRgb(baseColor);
    const masterBorderRadius = getComputedStyle(document.documentElement).getPropertyValue("--w3m-border-radius-master");
    const radius = Number(masterBorderRadius?.replace("px", ""));
    const edge = 100 - 3 * radius;
    const gradientCircle = `${edge}% ${edge}% at 65% 40%`;
    const colors2 = [];
    for (let i3 = 0; i3 < 5; i3 += 1) {
      const tintedColor = this.tintColor(rgbColor, 0.15 * i3);
      colors2.push(`rgb(${tintedColor[0]}, ${tintedColor[1]}, ${tintedColor[2]})`);
    }
    return `
    --local-color-1: ${colors2[0]};
    --local-color-2: ${colors2[1]};
    --local-color-3: ${colors2[2]};
    --local-color-4: ${colors2[3]};
    --local-color-5: ${colors2[4]};
    --local-radial-circle: ${gradientCircle}
   `;
  },
  hexToRgb(hex) {
    const bigint = parseInt(hex, 16);
    const r2 = bigint >> 16 & 255;
    const g2 = bigint >> 8 & 255;
    const b3 = bigint & 255;
    return [r2, g2, b3];
  },
  tintColor(rgb, tint) {
    const [r2, g2, b3] = rgb;
    const tintedR = Math.round(r2 + (255 - r2) * tint);
    const tintedG = Math.round(g2 + (255 - g2) * tint);
    const tintedB = Math.round(b3 + (255 - b3) * tint);
    return [tintedR, tintedG, tintedB];
  },
  isNumber(character2) {
    const regex2 = {
      number: /^[0-9]+$/u
    };
    return regex2.number.test(character2);
  },
  getColorTheme(theme2) {
    if (theme2) {
      return theme2;
    } else if (typeof window !== "undefined" && window.matchMedia) {
      if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
        return "dark";
      }
      return "light";
    }
    return "dark";
  }
};
const styles$10 = i$8`
  :host {
    display: flex;
    width: inherit;
    height: inherit;
  }
`;
var __decorate$1j = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiFlex = class WuiFlex2 extends s$5 {
  render() {
    this.style.cssText = `
      flex-direction: ${this.flexDirection};
      flex-wrap: ${this.flexWrap};
      flex-basis: ${this.flexBasis};
      flex-grow: ${this.flexGrow};
      flex-shrink: ${this.flexShrink};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `;
    return x$1`<slot></slot>`;
  }
};
WuiFlex.styles = [resetStyles, styles$10];
__decorate$1j([
  n$8()
], WuiFlex.prototype, "flexDirection", void 0);
__decorate$1j([
  n$8()
], WuiFlex.prototype, "flexWrap", void 0);
__decorate$1j([
  n$8()
], WuiFlex.prototype, "flexBasis", void 0);
__decorate$1j([
  n$8()
], WuiFlex.prototype, "flexGrow", void 0);
__decorate$1j([
  n$8()
], WuiFlex.prototype, "flexShrink", void 0);
__decorate$1j([
  n$8()
], WuiFlex.prototype, "alignItems", void 0);
__decorate$1j([
  n$8()
], WuiFlex.prototype, "justifyContent", void 0);
__decorate$1j([
  n$8()
], WuiFlex.prototype, "columnGap", void 0);
__decorate$1j([
  n$8()
], WuiFlex.prototype, "rowGap", void 0);
__decorate$1j([
  n$8()
], WuiFlex.prototype, "gap", void 0);
__decorate$1j([
  n$8()
], WuiFlex.prototype, "padding", void 0);
__decorate$1j([
  n$8()
], WuiFlex.prototype, "margin", void 0);
WuiFlex = __decorate$1j([
  customElement("wui-flex")
], WuiFlex);
const styles$$ = i$8`
  :host {
    display: block;
    width: var(--wui-icon-box-size-xl);
    height: var(--wui-icon-box-size-xl);
    border-radius: var(--wui-border-radius-3xl);
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    overflow: hidden;
    position: relative;
  }

  :host([data-variant='generated']) {
    --mixed-local-color-1: var(--local-color-1);
    --mixed-local-color-2: var(--local-color-2);
    --mixed-local-color-3: var(--local-color-3);
    --mixed-local-color-4: var(--local-color-4);
    --mixed-local-color-5: var(--local-color-5);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host([data-variant='generated']) {
      --mixed-local-color-1: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-1)
      );
      --mixed-local-color-2: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-2)
      );
      --mixed-local-color-3: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-3)
      );
      --mixed-local-color-4: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-4)
      );
      --mixed-local-color-5: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-5)
      );
    }
  }

  :host([data-variant='generated']) {
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    background: radial-gradient(
      var(--local-radial-circle),
      #fff 0.52%,
      var(--mixed-local-color-5) 31.25%,
      var(--mixed-local-color-3) 51.56%,
      var(--mixed-local-color-2) 65.63%,
      var(--mixed-local-color-1) 82.29%,
      var(--mixed-local-color-4) 100%
    );
  }

  :host([data-variant='default']) {
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    background: radial-gradient(
      75.29% 75.29% at 64.96% 24.36%,
      #fff 0.52%,
      #f5ccfc 31.25%,
      #dba4f5 51.56%,
      #9a8ee8 65.63%,
      #6493da 82.29%,
      #6ebdea 100%
    );
  }
`;
var __decorate$1i = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiAvatar = class WuiAvatar2 extends s$5 {
  constructor() {
    super(...arguments);
    this.imageSrc = void 0;
    this.alt = void 0;
    this.address = void 0;
  }
  render() {
    return x$1`${this.visualTemplate()}`;
  }
  visualTemplate() {
    if (this.imageSrc) {
      this.dataset["variant"] = "image";
      return x$1`<wui-image src=${this.imageSrc} alt=${this.alt ?? "avatar"}></wui-image>`;
    } else if (this.address) {
      this.dataset["variant"] = "generated";
      const cssColors = UiHelperUtil.generateAvatarColors(this.address);
      this.style.cssText = cssColors;
      return null;
    }
    this.dataset["variant"] = "default";
    return null;
  }
};
WuiAvatar.styles = [resetStyles, styles$$];
__decorate$1i([
  n$8()
], WuiAvatar.prototype, "imageSrc", void 0);
__decorate$1i([
  n$8()
], WuiAvatar.prototype, "alt", void 0);
__decorate$1i([
  n$8()
], WuiAvatar.prototype, "address", void 0);
WuiAvatar = __decorate$1i([
  customElement("wui-avatar")
], WuiAvatar);
const styles$_ = i$8`
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden;
    background-color: var(--wui-gray-glass-020);
    border-radius: var(--local-border-radius);
    box-shadow: 0 0 0 1px var(--local-border);
    width: var(--local-size);
    height: var(--local-size);
    min-height: var(--local-size);
    min-width: var(--local-size);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host {
      background-color: color-mix(in srgb, var(--local-bg-value) var(--local-bg-mix), transparent);
    }
  }
`;
var __decorate$1h = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiIconBox = class WuiIconBox2 extends s$5 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.backgroundColor = "accent-100";
    this.iconColor = "accent-100";
    this.background = "transparent";
    this.border = false;
    this.borderColor = "wui-color-bg-125";
    this.icon = "copy";
  }
  render() {
    const iconSize = this.iconSize || this.size;
    const isLg = this.size === "lg";
    const isXl = this.size === "xl";
    const bgMix = isLg ? "12%" : "16%";
    const borderRadius2 = isLg ? "xxs" : isXl ? "s" : "3xl";
    const isGray = this.background === "gray";
    const isOpaque = this.background === "opaque";
    const isColorChange = this.backgroundColor === "accent-100" && isOpaque || this.backgroundColor === "success-100" && isOpaque || this.backgroundColor === "error-100" && isOpaque || this.backgroundColor === "inverse-100" && isOpaque;
    let bgValueVariable = `var(--wui-color-${this.backgroundColor})`;
    if (isColorChange) {
      bgValueVariable = `var(--wui-icon-box-bg-${this.backgroundColor})`;
    } else if (isGray) {
      bgValueVariable = `var(--wui-gray-${this.backgroundColor})`;
    }
    this.style.cssText = `
       --local-bg-value: ${bgValueVariable};
       --local-bg-mix: ${isColorChange || isGray ? `100%` : bgMix};
       --local-border-radius: var(--wui-border-radius-${borderRadius2});
       --local-size: var(--wui-icon-box-size-${this.size});
       --local-border: ${this.borderColor === "wui-color-bg-125" ? `2px` : `1px`} solid ${this.border ? `var(--${this.borderColor})` : `transparent`}
   `;
    return x$1` <wui-icon color=${this.iconColor} size=${iconSize} name=${this.icon}></wui-icon> `;
  }
};
WuiIconBox.styles = [resetStyles, elementStyles, styles$_];
__decorate$1h([
  n$8()
], WuiIconBox.prototype, "size", void 0);
__decorate$1h([
  n$8()
], WuiIconBox.prototype, "backgroundColor", void 0);
__decorate$1h([
  n$8()
], WuiIconBox.prototype, "iconColor", void 0);
__decorate$1h([
  n$8()
], WuiIconBox.prototype, "iconSize", void 0);
__decorate$1h([
  n$8()
], WuiIconBox.prototype, "background", void 0);
__decorate$1h([
  n$8({ type: Boolean })
], WuiIconBox.prototype, "border", void 0);
__decorate$1h([
  n$8()
], WuiIconBox.prototype, "borderColor", void 0);
__decorate$1h([
  n$8()
], WuiIconBox.prototype, "icon", void 0);
WuiIconBox = __decorate$1h([
  customElement("wui-icon-box")
], WuiIconBox);
const styles$Z = i$8`
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    background: var(--wui-gray-glass-002);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-gray-glass-005);
  }

  button:disabled {
    background: var(--wui-gray-glass-015);
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-flex > wui-text {
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-image,
  button:disabled > wui-icon-box,
  button:disabled > wui-flex > wui-avatar {
    filter: grayscale(1);
  }

  button:has(wui-image) {
    padding: var(--wui-spacing-3xs) var(--wui-spacing-3xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
  }

  wui-text {
    color: var(--wui-color-fg-100);
  }

  wui-flex > wui-text {
    color: var(--wui-color-fg-200);
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  wui-flex {
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-005);
    background: var(--wui-gray-glass-005);
    padding: 4px var(--wui-spacing-m) 4px var(--wui-spacing-xxs);
  }

  button.local-no-balance {
    border-radius: 0px;
    border: none;
    background: transparent;
  }

  wui-avatar {
    width: 20px;
    height: 20px;
    box-shadow: 0 0 0 2px var(--wui-accent-glass-010);
  }

  @media (max-width: 500px) {
    button {
      gap: 0px;
      padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) !important;
      height: 32px;
    }
    wui-image,
    wui-icon-box,
    button > wui-text {
      visibility: hidden;
      width: 0px;
      height: 0px;
    }
    button {
      border-radius: 0px;
      border: none;
      background: transparent;
      padding: 0px;
    }
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }

    button:active:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }
  }
`;
var __decorate$1g = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiAccountButton = class WuiAccountButton2 extends s$5 {
  constructor() {
    super(...arguments);
    this.networkSrc = void 0;
    this.avatarSrc = void 0;
    this.balance = void 0;
    this.disabled = false;
    this.isProfileName = false;
    this.address = "";
    this.charsStart = 4;
    this.charsEnd = 6;
  }
  render() {
    return x$1`
      <button
        ?disabled=${this.disabled}
        class=${o$9(this.balance ? void 0 : "local-no-balance")}
      >
        ${this.balanceTemplate()}
        <wui-flex gap="xxs" alignItems="center">
          <wui-avatar
            .imageSrc=${this.avatarSrc}
            alt=${this.address}
            address=${this.address}
          ></wui-avatar>
          <wui-text variant="paragraph-600" color="inherit">
            ${UiHelperUtil.getTruncateString({
      string: this.address,
      charsStart: this.isProfileName ? 18 : this.charsStart,
      charsEnd: this.isProfileName ? 0 : this.charsEnd,
      truncate: this.isProfileName ? "end" : "middle"
    })}
          </wui-text>
        </wui-flex>
      </button>
    `;
  }
  balanceTemplate() {
    if (this.balance) {
      const networkElement = this.networkSrc ? x$1`<wui-image src=${this.networkSrc}></wui-image>` : x$1`
            <wui-icon-box
              size="sm"
              iconColor="fg-200"
              backgroundColor="fg-300"
              icon="networkPlaceholder"
            ></wui-icon-box>
          `;
      return x$1`
        ${networkElement}
        <wui-text variant="paragraph-600" color="inherit"> ${this.balance} </wui-text>
      `;
    }
    return null;
  }
};
WuiAccountButton.styles = [resetStyles, elementStyles, styles$Z];
__decorate$1g([
  n$8()
], WuiAccountButton.prototype, "networkSrc", void 0);
__decorate$1g([
  n$8()
], WuiAccountButton.prototype, "avatarSrc", void 0);
__decorate$1g([
  n$8()
], WuiAccountButton.prototype, "balance", void 0);
__decorate$1g([
  n$8({ type: Boolean })
], WuiAccountButton.prototype, "disabled", void 0);
__decorate$1g([
  n$8({ type: Boolean })
], WuiAccountButton.prototype, "isProfileName", void 0);
__decorate$1g([
  n$8()
], WuiAccountButton.prototype, "address", void 0);
__decorate$1g([
  n$8()
], WuiAccountButton.prototype, "charsStart", void 0);
__decorate$1g([
  n$8()
], WuiAccountButton.prototype, "charsEnd", void 0);
WuiAccountButton = __decorate$1g([
  customElement("wui-account-button")
], WuiAccountButton);
const styles$Y = i$8`
  :host {
    position: relative;
    background-color: var(--wui-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-size);
    height: var(--local-size);
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host > wui-flex {
    overflow: hidden;
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  :host([name='Extension'])::after {
    border: 1px solid var(--wui-accent-glass-010);
  }

  :host([data-wallet-icon='allWallets']) {
    background-color: var(--wui-all-wallets-bg-100);
  }

  :host([data-wallet-icon='allWallets'])::after {
    border: 1px solid var(--wui-accent-glass-010);
  }

  wui-icon[data-parent-size='inherit'] {
    width: 75%;
    height: 75%;
    align-items: center;
  }

  wui-icon[data-parent-size='sm'] {
    width: 18px;
    height: 18px;
  }

  wui-icon[data-parent-size='md'] {
    width: 24px;
    height: 24px;
  }

  wui-icon[data-parent-size='lg'] {
    width: 42px;
    height: 42px;
  }

  wui-icon[data-parent-size='full'] {
    width: 100%;
    height: 100%;
  }

  :host > wui-icon-box {
    position: absolute;
    overflow: hidden;
    right: -1px;
    bottom: -2px;
    z-index: 1;
    border: 2px solid var(--wui-color-bg-base-150, #1e1f1f);
    padding: 1px;
  }
`;
var __decorate$1f = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiWalletImage = class WuiWalletImage2 extends s$5 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.name = "";
    this.installed = false;
    this.badgeSize = "xs";
  }
  render() {
    let borderRadius2 = "xxs";
    if (this.size === "lg") {
      borderRadius2 = "m";
    } else if (this.size === "md") {
      borderRadius2 = "xs";
    } else {
      borderRadius2 = "xxs";
    }
    this.style.cssText = `
       --local-border-radius: var(--wui-border-radius-${borderRadius2});
       --local-size: var(--wui-wallet-image-size-${this.size});
   `;
    if (this.walletIcon) {
      this.dataset["walletIcon"] = this.walletIcon;
    }
    return x$1`
      <wui-flex justifyContent="center" alignItems="center"> ${this.templateVisual()} </wui-flex>
    `;
  }
  templateVisual() {
    if (this.imageSrc) {
      return x$1`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>`;
    } else if (this.walletIcon) {
      return x$1`<wui-icon
        data-parent-size="md"
        size="md"
        color="inherit"
        name=${this.walletIcon}
      ></wui-icon>`;
    }
    return x$1`<wui-icon
      data-parent-size=${this.size}
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`;
  }
};
WuiWalletImage.styles = [resetStyles, styles$Y];
__decorate$1f([
  n$8()
], WuiWalletImage.prototype, "size", void 0);
__decorate$1f([
  n$8()
], WuiWalletImage.prototype, "name", void 0);
__decorate$1f([
  n$8()
], WuiWalletImage.prototype, "imageSrc", void 0);
__decorate$1f([
  n$8()
], WuiWalletImage.prototype, "walletIcon", void 0);
__decorate$1f([
  n$8({ type: Boolean })
], WuiWalletImage.prototype, "installed", void 0);
__decorate$1f([
  n$8()
], WuiWalletImage.prototype, "badgeSize", void 0);
WuiWalletImage = __decorate$1f([
  customElement("wui-wallet-image")
], WuiWalletImage);
const styles$X = i$8`
  :host {
    position: relative;
    border-radius: var(--wui-border-radius-xxs);
    width: 40px;
    height: 40px;
    overflow: hidden;
    background: var(--wui-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--wui-spacing-4xs);
    padding: 3.75px !important;
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  :host > wui-wallet-image {
    width: 14px;
    height: 14px;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host > wui-flex {
    padding: 2px;
    position: fixed;
    overflow: hidden;
    left: 34px;
    bottom: 8px;
    background: var(--dark-background-150, #1e1f1f);
    border-radius: 50%;
    z-index: 2;
    display: flex;
  }
`;
var __decorate$1e = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const TOTAL_IMAGES = 4;
let WuiAllWalletsImage = class WuiAllWalletsImage2 extends s$5 {
  constructor() {
    super(...arguments);
    this.walletImages = [];
  }
  render() {
    const isPlaceholders = this.walletImages.length < TOTAL_IMAGES;
    return x$1`${this.walletImages.slice(0, TOTAL_IMAGES).map(({ src: src2, walletName }) => x$1`
            <wui-wallet-image
              size="inherit"
              imageSrc=${src2}
              name=${o$9(walletName)}
            ></wui-wallet-image>
          `)}
      ${isPlaceholders ? [...Array(TOTAL_IMAGES - this.walletImages.length)].map(() => x$1` <wui-wallet-image size="inherit" name=""></wui-wallet-image>`) : null}
      <wui-flex>
        <wui-icon-box
          size="xxs"
          iconSize="xxs"
          iconcolor="success-100"
          backgroundcolor="success-100"
          icon="checkmark"
          background="opaque"
        ></wui-icon-box>
      </wui-flex>`;
  }
};
WuiAllWalletsImage.styles = [resetStyles, styles$X];
__decorate$1e([
  n$8({ type: Array })
], WuiAllWalletsImage.prototype, "walletImages", void 0);
WuiAllWalletsImage = __decorate$1e([
  customElement("wui-all-wallets-image")
], WuiAllWalletsImage);
const styles$W = i$8`
  :host {
    width: var(--local-width);
    position: relative;
  }

  button {
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-m);
    width: var(--local-width);
  }

  button:disabled {
    border: 1px solid var(--wui-gray-glass-010);
  }

  button[data-size='sm'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-s);
  }

  button[data-size='sm'][data-icon-left='true'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-s) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  button[data-size='sm'][data-icon-right='true'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-xs) var(--wui-spacing-xxs)
      var(--wui-spacing-s);
  }

  ::slotted(*) {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button > wui-text {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button[data-size='md'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  button[data-size='md'][data-icon-left='true'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-s);
  }

  button[data-size='md'][data-icon-right='true'] {
    padding: 8.2px var(--wui-spacing-s) 9px var(--wui-spacing-l);
  }

  wui-loading-spinner {
    position: absolute;
    left: 50%;
    top: 50%;
    transition: all 200ms ease-in-out;
    transform: translate(-50%, -50%);
    opacity: var(--local-opacity-000);
  }
`;
var __decorate$1d = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiButton = class WuiButton2 extends s$5 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.disabled = false;
    this.fullWidth = false;
    this.loading = false;
    this.variant = "fill";
    this.hasIconLeft = false;
    this.hasIconRight = false;
  }
  render() {
    this.style.cssText = `
    --local-width: ${this.fullWidth ? "100%" : "auto"};
    --local-opacity-100: ${this.loading ? 0 : 1};
    --local-opacity-000: ${this.loading ? 1 : 0};`;
    const textVariant = this.size === "md" ? "paragraph-600" : "small-600";
    return x$1`
      <button
        data-variant=${this.variant}
        data-icon-left=${this.hasIconLeft}
        data-icon-right=${this.hasIconRight}
        data-size=${this.size}
        ?disabled=${this.disabled || this.loading}
        ontouchstart
      >
        ${this.loadingTemplate()}
        <slot name="iconLeft" @slotchange=${() => this.handleSlotLeftChange()}></slot>
        <wui-text variant=${textVariant} color="inherit">
          <slot></slot>
        </wui-text>
        <slot name="iconRight" @slotchange=${() => this.handleSlotRightChange()}></slot>
      </button>
    `;
  }
  handleSlotLeftChange() {
    this.hasIconLeft = true;
  }
  handleSlotRightChange() {
    this.hasIconRight = true;
  }
  loadingTemplate() {
    if (this.loading) {
      return x$1`<wui-loading-spinner color="fg-300"></wui-loading-spinner>`;
    }
    return x$1``;
  }
};
WuiButton.styles = [resetStyles, elementStyles, styles$W];
__decorate$1d([
  n$8()
], WuiButton.prototype, "size", void 0);
__decorate$1d([
  n$8({ type: Boolean })
], WuiButton.prototype, "disabled", void 0);
__decorate$1d([
  n$8({ type: Boolean })
], WuiButton.prototype, "fullWidth", void 0);
__decorate$1d([
  n$8({ type: Boolean })
], WuiButton.prototype, "loading", void 0);
__decorate$1d([
  n$8()
], WuiButton.prototype, "variant", void 0);
__decorate$1d([
  n$8({ type: Boolean })
], WuiButton.prototype, "hasIconLeft", void 0);
__decorate$1d([
  n$8({ type: Boolean })
], WuiButton.prototype, "hasIconRight", void 0);
WuiButton = __decorate$1d([
  customElement("wui-button")
], WuiButton);
const networkSvg = b$1`<svg  viewBox="0 0 48 54" fill="none">
  <path
    d="M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z"
  />
</svg>`;
const styles$V = i$8`
  :host {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) 10px;
    background-color: var(--wui-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    position: relative;
  }

  wui-shimmer[data-type='network'] {
    border: none;
    -webkit-clip-path: var(--wui-path-network);
    clip-path: var(--wui-path-network);
  }

  svg {
    position: absolute;
    width: 48px;
    height: 54px;
    z-index: 1;
  }

  svg > path {
    stroke: var(--wui-gray-glass-010);
    stroke-width: 1px;
  }
`;
var __decorate$1c = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiCardSelectLoader = class WuiCardSelectLoader2 extends s$5 {
  constructor() {
    super(...arguments);
    this.type = "wallet";
  }
  render() {
    return x$1`
      ${this.shimmerTemplate()}
      <wui-shimmer width="56px" height="20px" borderRadius="xs"></wui-shimmer>
    `;
  }
  shimmerTemplate() {
    if (this.type === "network") {
      return x$1` <wui-shimmer
          data-type=${this.type}
          width="48px"
          height="54px"
          borderRadius="xs"
        ></wui-shimmer>
        ${networkSvg}`;
    }
    return x$1`<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`;
  }
};
WuiCardSelectLoader.styles = [resetStyles, elementStyles, styles$V];
__decorate$1c([
  n$8()
], WuiCardSelectLoader.prototype, "type", void 0);
WuiCardSelectLoader = __decorate$1c([
  customElement("wui-card-select-loader")
], WuiCardSelectLoader);
const networkLgSvg = b$1`<svg width="86" height="96" fill="none">
  <path
    d="M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z"
  />
</svg>`;
const styles$U = i$8`
  :host {
    position: relative;
    border-radius: inherit;
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-width);
    height: var(--local-height);
  }

  svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    fill: var(--wui-gray-glass-002);
  }

  svg > path {
    stroke: var(--local-stroke);
    transition: stroke var(--wui-ease-out-power-1) var(--wui-duration-lg);
  }

  wui-image {
    width: 100%;
    height: 100%;
    -webkit-clip-path: var(--local-path);
    clip-path: var(--local-path);
    background: var(--wui-gray-glass-002);
  }

  wui-icon {
    transform: translateY(-5%);
    width: var(--local-icon-size);
    height: var(--local-icon-size);
  }
`;
var __decorate$1b = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiNetworkImage = class WuiNetworkImage2 extends s$5 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.name = "uknown";
    this.selected = false;
  }
  render() {
    const isLg = this.size === "lg";
    this.style.cssText = `
      --local-stroke: ${this.selected ? "var(--wui-color-accent-100)" : "var(--wui-gray-glass-010)"};
      --local-path: ${isLg ? "var(--wui-path-network-lg)" : "var(--wui-path-network)"};
      --local-width: ${isLg ? "86px" : "48px"};
      --local-height: ${isLg ? "96px" : "54px"};
      --local-icon-size: ${isLg ? "42px" : "24px"};
    `;
    return x$1`${this.templateVisual()} ${isLg ? networkLgSvg : networkSvg}`;
  }
  templateVisual() {
    if (this.imageSrc) {
      return x$1`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>`;
    }
    return x$1`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
WuiNetworkImage.styles = [resetStyles, styles$U];
__decorate$1b([
  n$8()
], WuiNetworkImage.prototype, "size", void 0);
__decorate$1b([
  n$8()
], WuiNetworkImage.prototype, "name", void 0);
__decorate$1b([
  n$8()
], WuiNetworkImage.prototype, "imageSrc", void 0);
__decorate$1b([
  n$8({ type: Boolean })
], WuiNetworkImage.prototype, "selected", void 0);
WuiNetworkImage = __decorate$1b([
  customElement("wui-network-image")
], WuiNetworkImage);
const styles$T = i$8`
  button {
    flex-direction: column;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) var(--wui-spacing-0);
    background-color: var(--wui-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
  }

  button > wui-text {
    color: var(--wui-color-fg-100);
    max-width: var(--wui-icon-box-size-xl);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  [data-selected='true'] {
    background-color: var(--wui-accent-glass-020);
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: var(--wui-accent-glass-015);
    }
  }

  [data-selected='true']:active:enabled {
    background-color: var(--wui-accent-glass-010);
  }
`;
var __decorate$1a = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiCardSelect = class WuiCardSelect2 extends s$5 {
  constructor() {
    super(...arguments);
    this.name = "Unknown";
    this.type = "wallet";
    this.imageSrc = void 0;
    this.disabled = false;
    this.selected = false;
    this.installed = false;
  }
  render() {
    return x$1`
      <button data-selected=${o$9(this.selected)} ?disabled=${this.disabled} ontouchstart>
        ${this.imageTemplate()}
        <wui-text variant="tiny-500" color=${this.selected ? "accent-100" : "inherit"}>
          ${this.name}
        </wui-text>
      </button>
    `;
  }
  imageTemplate() {
    if (this.type === "network") {
      return x$1`
        <wui-network-image
          .selected=${this.selected}
          imageSrc=${o$9(this.imageSrc)}
          name=${this.name}
        >
        </wui-network-image>
      `;
    }
    return x$1`
      <wui-wallet-image
        size="md"
        imageSrc=${o$9(this.imageSrc)}
        name=${this.name}
        .installed=${this.installed}
        badgeSize="sm"
      >
      </wui-wallet-image>
    `;
  }
};
WuiCardSelect.styles = [resetStyles, elementStyles, styles$T];
__decorate$1a([
  n$8()
], WuiCardSelect.prototype, "name", void 0);
__decorate$1a([
  n$8()
], WuiCardSelect.prototype, "type", void 0);
__decorate$1a([
  n$8()
], WuiCardSelect.prototype, "imageSrc", void 0);
__decorate$1a([
  n$8({ type: Boolean })
], WuiCardSelect.prototype, "disabled", void 0);
__decorate$1a([
  n$8({ type: Boolean })
], WuiCardSelect.prototype, "selected", void 0);
__decorate$1a([
  n$8({ type: Boolean })
], WuiCardSelect.prototype, "installed", void 0);
WuiCardSelect = __decorate$1a([
  customElement("wui-card-select")
], WuiCardSelect);
const styles$S = i$8`
  a {
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-image {
    border-radius: var(--wui-border-radius-3xl);
    overflow: hidden;
  }

  a.disabled > wui-icon,
  a.disabled > wui-image {
    filter: grayscale(1);
  }

  a[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  a[data-variant='shade'],
  a[data-variant='shadeSmall'] {
    background-color: transparent;
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  a[data-variant='success'] {
    column-gap: var(--wui-spacing-xxs);
    border: 1px solid var(--wui-success-glass-010);
    background-color: var(--wui-success-glass-010);
    color: var(--wui-color-success-100);
  }

  a[data-variant='transparent'] {
    column-gap: var(--wui-spacing-xxs);
    background-color: transparent;
    color: var(--wui-color-fg-150);
  }

  a[data-variant='transparent'],
  a[data-variant='success'],
  a[data-variant='shadeSmall'] {
    padding: 7px var(--wui-spacing-s) 7px 10px;
  }

  a[data-variant='transparent']:has(wui-text:first-child),
  a[data-variant='success']:has(wui-text:first-child),
  a[data-variant='shadeSmall']:has(wui-text:first-child) {
    padding: 7px var(--wui-spacing-s);
  }

  a[data-variant='fill'],
  a[data-variant='shade'] {
    column-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  a[data-variant='fill']:has(wui-text:first-child),
  a[data-variant='shade']:has(wui-text:first-child) {
    padding: 9px var(--wui-spacing-m) 9px var(--wui-spacing-m);
  }

  a[data-variant='fill'] > wui-image,
  a[data-variant='shade'] > wui-image {
    width: 24px;
    height: 24px;
  }

  a[data-variant='fill'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-accent-090);
  }

  a[data-variant='shade'] > wui-image,
  a[data-variant='shadeSmall'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-010);
  }

  a[data-variant='fill'] > wui-icon,
  a[data-variant='shade'] > wui-icon {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-image,
  a[data-variant='success'] > wui-image,
  a[data-variant='shadeSmall'] > wui-image {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-icon,
  a[data-variant='success'] > wui-icon,
  a[data-variant='shadeSmall'] > wui-icon {
    width: 12px;
    height: 12px;
  }

  a[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  a[data-variant='shade']:focus-visible,
  a[data-variant='shadeSmall']:focus-visible {
    background-color: var(--wui-gray-glass-015);
  }

  a[data-variant='transparent']:focus-visible {
    background-color: var(--wui-gray-glass-005);
  }

  a[data-variant='success']:focus-visible {
    background-color: var(--wui-success-glass-015);
  }

  a.disabled {
    color: var(--wui-gray-glass-015);
    background-color: var(--wui-gray-glass-015);
    pointer-events: none;
  }

  @media (hover: hover) and (pointer: fine) {
    a[data-variant='fill']:hover {
      background-color: var(--wui-color-accent-090);
    }

    a[data-variant='shade']:hover,
    a[data-variant='shadeSmall']:hover {
      background-color: var(--wui-gray-glass-015);
    }

    a[data-variant='transparent']:hover {
      background-color: var(--wui-gray-glass-005);
    }

    a[data-variant='success']:hover {
      background-color: var(--wui-success-glass-015);
    }
  }

  a[data-variant='fill']:active {
    background-color: var(--wui-color-accent-080);
  }

  a[data-variant='shade']:active,
  a[data-variant='shadeSmall']:active {
    background-color: var(--wui-gray-glass-020);
  }

  a[data-variant='transparent']:active {
    background-color: var(--wui-gray-glass-010);
  }

  a[data-variant='success']:active {
    background-color: var(--wui-success-glass-020);
  }
`;
var __decorate$19 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiChip = class WuiChip2 extends s$5 {
  constructor() {
    super(...arguments);
    this.variant = "fill";
    this.imageSrc = void 0;
    this.disabled = false;
    this.icon = "externalLink";
    this.href = "";
    this.text = void 0;
  }
  render() {
    const isSmall = this.variant === "success" || this.variant === "transparent" || this.variant === "shadeSmall";
    const textVariant = isSmall ? "small-600" : "paragraph-600";
    return x$1`
      <a
        rel="noreferrer"
        target="_blank"
        href=${this.href}
        class=${this.disabled ? "disabled" : ""}
        data-variant=${this.variant}
      >
        ${this.imageTemplate()}
        <wui-text variant=${textVariant} color="inherit">
          ${this.title ? this.title : UiHelperUtil.getHostName(this.href)}
        </wui-text>
        <wui-icon name=${this.icon} color="inherit" size="inherit"></wui-icon>
      </a>
    `;
  }
  imageTemplate() {
    if (this.imageSrc) {
      return x$1`<wui-image src=${this.imageSrc}></wui-image>`;
    }
    return null;
  }
};
WuiChip.styles = [resetStyles, elementStyles, styles$S];
__decorate$19([
  n$8()
], WuiChip.prototype, "variant", void 0);
__decorate$19([
  n$8()
], WuiChip.prototype, "imageSrc", void 0);
__decorate$19([
  n$8({ type: Boolean })
], WuiChip.prototype, "disabled", void 0);
__decorate$19([
  n$8()
], WuiChip.prototype, "icon", void 0);
__decorate$19([
  n$8()
], WuiChip.prototype, "href", void 0);
__decorate$19([
  n$8()
], WuiChip.prototype, "text", void 0);
WuiChip = __decorate$19([
  customElement("wui-chip")
], WuiChip);
const styles$R = i$8`
  :host {
    position: relative;
    display: block;
  }

  button {
    background: var(--wui-color-accent-100);
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-m);
    gap: var(--wui-spacing-xs);
  }

  button.loading {
    background: var(--wui-gray-glass-010);
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    border: 1px solid var(--wui-gray-glass-010);
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button:active:enabled {
      background-color: var(--wui-color-accent-080);
    }
  }

  button:focus-visible {
    border: 1px solid var(--wui-gray-glass-010);
    background-color: var(--wui-color-accent-090);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-size='sm'] {
    padding: 6.75px 10px 7.25px;
  }

  ::slotted(*) {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button > wui-text {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
    color: var(--wui-color-inverse-100);
  }

  button[data-size='md'] {
    padding: 9px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  button[data-size='md'] + wui-text {
    padding-left: var(--wui-spacing-3xs);
  }

  @media (max-width: 500px) {
    button[data-size='md'] {
      height: 32px;
      padding: 5px 12px;
    }

    button[data-size='md'] > wui-text > slot {
      font-size: 14px !important;
    }
  }

  wui-loading-spinner {
    width: 14px;
    height: 14px;
  }

  wui-loading-spinner::slotted(svg) {
    width: 10px !important;
    height: 10px !important;
  }

  button[data-size='sm'] > wui-loading-spinner {
    width: 12px;
    height: 12px;
  }
`;
var __decorate$18 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiConnectButton = class WuiConnectButton2 extends s$5 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.loading = false;
  }
  render() {
    const textVariant = this.size === "md" ? "paragraph-600" : "small-600";
    return x$1`
      <button data-size=${this.size} ?disabled=${this.loading} ontouchstart>
        ${this.loadingTemplate()}
        <wui-text variant=${textVariant} color=${this.loading ? "accent-100" : "inherit"}>
          <slot></slot>
        </wui-text>
      </button>
    `;
  }
  loadingTemplate() {
    if (!this.loading) {
      return null;
    }
    return x$1`<wui-loading-spinner size=${this.size} color="accent-100"></wui-loading-spinner>`;
  }
};
WuiConnectButton.styles = [resetStyles, elementStyles, styles$R];
__decorate$18([
  n$8()
], WuiConnectButton.prototype, "size", void 0);
__decorate$18([
  n$8({ type: Boolean })
], WuiConnectButton.prototype, "loading", void 0);
WuiConnectButton = __decorate$18([
  customElement("wui-connect-button")
], WuiConnectButton);
const styles$Q = i$8`
  wui-flex {
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$17 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiCtaButton = class WuiCtaButton2 extends s$5 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.label = "";
    this.buttonLabel = "";
  }
  render() {
    return x$1`
      <wui-flex
        justifyContent="space-between"
        alignItems="center"
        .padding=${["1xs", "2l", "1xs", "2l"]}
      >
        <wui-text variant="paragraph-500" color="fg-200">${this.label}</wui-text>
        <wui-button size="sm" variant="accent">
          ${this.buttonLabel}
          <wui-icon size="xs" color="inherit" slot="iconRight" name="chevronRight"></wui-icon>
        </wui-button>
      </wui-flex>
    `;
  }
};
WuiCtaButton.styles = [resetStyles, elementStyles, styles$Q];
__decorate$17([
  n$8({ type: Boolean })
], WuiCtaButton.prototype, "disabled", void 0);
__decorate$17([
  n$8()
], WuiCtaButton.prototype, "label", void 0);
__decorate$17([
  n$8()
], WuiCtaButton.prototype, "buttonLabel", void 0);
WuiCtaButton = __decorate$17([
  customElement("wui-cta-button")
], WuiCtaButton);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const f$5 = (o2) => void 0 === o2.strings;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s$4 = (i3, t2) => {
  const e2 = i3._$AN;
  if (void 0 === e2)
    return false;
  for (const i4 of e2)
    i4._$AO?.(t2, false), s$4(i4, t2);
  return true;
}, o$8 = (i3) => {
  let t2, e2;
  do {
    if (void 0 === (t2 = i3._$AM))
      break;
    e2 = t2._$AN, e2.delete(i3), i3 = t2;
  } while (0 === e2?.size);
}, r$7 = (i3) => {
  for (let t2; t2 = i3._$AM; i3 = t2) {
    let e2 = t2._$AN;
    if (void 0 === e2)
      t2._$AN = e2 = /* @__PURE__ */ new Set();
    else if (e2.has(i3))
      break;
    e2.add(i3), c$4(t2);
  }
};
function h$6(i3) {
  void 0 !== this._$AN ? (o$8(this), this._$AM = i3, r$7(this)) : this._$AM = i3;
}
function n$7(i3, t2 = false, e2 = 0) {
  const r2 = this._$AH, h4 = this._$AN;
  if (void 0 !== h4 && 0 !== h4.size)
    if (t2)
      if (Array.isArray(r2))
        for (let i4 = e2; i4 < r2.length; i4++)
          s$4(r2[i4], false), o$8(r2[i4]);
      else
        null != r2 && (s$4(r2, false), o$8(r2));
    else
      s$4(this, i3);
}
const c$4 = (i3) => {
  i3.type == t$3.CHILD && (i3._$AP ?? (i3._$AP = n$7), i3._$AQ ?? (i3._$AQ = h$6));
};
let f$4 = class f extends i$5 {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(i3, t2, e2) {
    super._$AT(i3, t2, e2), r$7(this), this.isConnected = i3._$AU;
  }
  _$AO(i3, t2 = true) {
    i3 !== this.isConnected && (this.isConnected = i3, i3 ? this.reconnected?.() : this.disconnected?.()), t2 && (s$4(this, i3), o$8(this));
  }
  setValue(t2) {
    if (f$5(this._$Ct))
      this._$Ct._$AI(t2, this);
    else {
      const i3 = [...this._$Ct._$AH];
      i3[this._$Ci] = t2, this._$Ct._$AI(i3, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$5 = () => new h$5();
let h$5 = class h {
};
const o$7 = /* @__PURE__ */ new WeakMap(), n$6 = e$7(class extends f$4 {
  render(i3) {
    return T$2;
  }
  update(i3, [s4]) {
    const e2 = s4 !== this.G;
    return e2 && void 0 !== this.G && this.ot(void 0), (e2 || this.rt !== this.lt) && (this.G = s4, this.ct = i3.options?.host, this.ot(this.lt = i3.element)), T$2;
  }
  ot(t2) {
    if ("function" == typeof this.G) {
      const i3 = this.ct ?? globalThis;
      let s4 = o$7.get(i3);
      void 0 === s4 && (s4 = /* @__PURE__ */ new WeakMap(), o$7.set(i3, s4)), void 0 !== s4.get(this.G) && this.G.call(this.ct, void 0), s4.set(this.G, t2), void 0 !== t2 && this.G.call(this.ct, t2);
    } else
      this.G.value = t2;
  }
  get rt() {
    return "function" == typeof this.G ? o$7.get(this.ct ?? globalThis)?.get(this.G) : this.G?.value;
  }
  disconnected() {
    this.rt === this.lt && this.ot(void 0);
  }
  reconnected() {
    this.ot(this.lt);
  }
});
const styles$P = i$8`
  :host {
    position: relative;
    width: 100%;
    display: inline-block;
    color: var(--wui-color-fg-275);
  }

  input {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-gray-glass-005);
    background: var(--wui-gray-glass-005);
    font-size: var(--wui-font-size-paragraph);
    font-weight: var(--wui-font-weight-light);
    letter-spacing: var(--wui-letter-spacing-paragraph);
    color: var(--wui-color-fg-100);
    transition: all var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    caret-color: var(--wui-color-accent-100);
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-gray-glass-010);
    background: var(--wui-gray-glass-015);
  }

  input:disabled::placeholder,
  input:disabled + wui-icon {
    color: var(--wui-color-fg-300);
  }

  input::placeholder {
    color: var(--wui-color-fg-275);
  }

  input:focus:enabled {
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    background-color: var(--wui-gray-glass-010);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  input:hover:enabled {
    background-color: var(--wui-gray-glass-010);
  }

  wui-icon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
  }

  .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px var(--wui-spacing-s);
  }

  wui-icon + .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px 36px;
  }

  wui-icon[data-input='sm'] {
    left: var(--wui-spacing-s);
  }

  .wui-size-md {
    padding: 15px var(--wui-spacing-m) var(--wui-spacing-l) var(--wui-spacing-m);
  }

  wui-icon + .wui-size-md {
    padding: 10.5px var(--wui-spacing-l) 10.5px 44px;
  }

  wui-icon[data-input='md'] {
    left: var(--wui-spacing-l);
  }

  input:placeholder-shown ~ ::slotted(wui-input-element),
  input:placeholder-shown ~ ::slotted(wui-icon) {
    opacity: 0;
    pointer-events: none;
  }

  ::slotted(wui-input-element),
  ::slotted(wui-icon) {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    transition: all var(--wui-ease-in-power-2) var(--wui-duration-md);
  }

  ::slotted(wui-input-element) {
    right: var(--wui-spacing-m);
  }

  ::slotted(wui-icon) {
    right: 0px;
  }
`;
var __decorate$16 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiInputText = class WuiInputText2 extends s$5 {
  constructor() {
    super(...arguments);
    this.inputElementRef = e$5();
    this.size = "md";
    this.disabled = false;
    this.placeholder = "";
    this.type = "text";
  }
  render() {
    const sizeClass = `wui-size-${this.size}`;
    return x$1` ${this.templateIcon()}
      <input
        ${n$6(this.inputElementRef)}
        class=${sizeClass}
        type=${this.type}
        enterkeyhint=${o$9(this.enterKeyHint)}
        ?disabled=${this.disabled}
        placeholder=${this.placeholder}
        @input=${this.dispatchInputChangeEvent.bind(this)}
        value=${o$9(this.value)}
      />
      <slot></slot>`;
  }
  templateIcon() {
    if (this.icon) {
      return x$1`<wui-icon
        data-input=${this.size}
        size="sm"
        color="inherit"
        name=${this.icon}
      ></wui-icon>`;
    }
    return null;
  }
  dispatchInputChangeEvent() {
    this.dispatchEvent(new CustomEvent("inputChange", {
      detail: this.inputElementRef.value?.value,
      bubbles: true,
      composed: true
    }));
  }
};
WuiInputText.styles = [resetStyles, elementStyles, styles$P];
__decorate$16([
  n$8()
], WuiInputText.prototype, "size", void 0);
__decorate$16([
  n$8()
], WuiInputText.prototype, "icon", void 0);
__decorate$16([
  n$8({ type: Boolean })
], WuiInputText.prototype, "disabled", void 0);
__decorate$16([
  n$8()
], WuiInputText.prototype, "placeholder", void 0);
__decorate$16([
  n$8()
], WuiInputText.prototype, "type", void 0);
__decorate$16([
  n$8()
], WuiInputText.prototype, "keyHint", void 0);
__decorate$16([
  n$8()
], WuiInputText.prototype, "value", void 0);
WuiInputText = __decorate$16([
  customElement("wui-input-text")
], WuiInputText);
const styles$O = i$8`
  :host {
    position: relative;
    display: inline-block;
  }

  wui-text {
    margin: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-0) var(--wui-spacing-m);
  }
`;
var __decorate$15 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiEmailInput = class WuiEmailInput2 extends s$5 {
  constructor() {
    super(...arguments);
    this.disabled = false;
  }
  render() {
    return x$1`
      <wui-input-text
        placeholder="Email"
        icon="mail"
        size="md"
        .disabled=${this.disabled}
        .value=${this.value}
        data-testid="wui-email-input"
      ></wui-input-text>
      ${this.templateError()}
    `;
  }
  templateError() {
    if (this.errorMessage) {
      return x$1`<wui-text variant="tiny-500" color="error-100">${this.errorMessage}</wui-text>`;
    }
    return null;
  }
};
WuiEmailInput.styles = [resetStyles, styles$O];
__decorate$15([
  n$8()
], WuiEmailInput.prototype, "errorMessage", void 0);
__decorate$15([
  n$8({ type: Boolean })
], WuiEmailInput.prototype, "disabled", void 0);
__decorate$15([
  n$8()
], WuiEmailInput.prototype, "value", void 0);
WuiEmailInput = __decorate$15([
  customElement("wui-email-input")
], WuiEmailInput);
const styles$N = i$8`
  button {
    border-radius: var(--wui-border-radius-xxs);
    color: var(--wui-color-fg-100);
    padding: var(--wui-spacing-2xs);
  }

  @media (max-width: 700px) {
    button {
      padding: var(--wui-spacing-s);
    }
  }

  button > wui-icon {
    pointer-events: none;
  }

  button:disabled > wui-icon {
    color: var(--wui-color-bg-300) !important;
  }

  button:disabled {
    background-color: transparent;
  }
`;
var __decorate$14 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiIconLink = class WuiIconLink2 extends s$5 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.disabled = false;
    this.icon = "copy";
    this.iconColor = "inherit";
  }
  render() {
    return x$1`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-icon color=${this.iconColor} size=${this.size} name=${this.icon}></wui-icon>
      </button>
    `;
  }
};
WuiIconLink.styles = [resetStyles, elementStyles, colorStyles, styles$N];
__decorate$14([
  n$8()
], WuiIconLink.prototype, "size", void 0);
__decorate$14([
  n$8({ type: Boolean })
], WuiIconLink.prototype, "disabled", void 0);
__decorate$14([
  n$8()
], WuiIconLink.prototype, "icon", void 0);
__decorate$14([
  n$8()
], WuiIconLink.prototype, "iconColor", void 0);
WuiIconLink = __decorate$14([
  customElement("wui-icon-link")
], WuiIconLink);
const styles$M = i$8`
  button {
    background-color: var(--wui-color-fg-300);
    border-radius: var(--wui-border-radius-4xs);
    width: 16px;
    height: 16px;
  }

  button:disabled {
    background-color: var(--wui-color-bg-300);
  }

  wui-icon {
    color: var(--wui-color-bg-200) !important;
  }

  button:focus-visible {
    background-color: var(--wui-color-fg-250);
    border: 1px solid var(--wui-color-accent-100);
  }

  button:active:enabled {
    background-color: var(--wui-color-fg-225);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-fg-250);
    }
  }
`;
var __decorate$13 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiInputElement = class WuiInputElement2 extends s$5 {
  constructor() {
    super(...arguments);
    this.icon = "copy";
  }
  render() {
    return x$1`
      <button>
        <wui-icon color="inherit" size="xxs" name=${this.icon}></wui-icon>
      </button>
    `;
  }
};
WuiInputElement.styles = [resetStyles, elementStyles, styles$M];
__decorate$13([
  n$8()
], WuiInputElement.prototype, "icon", void 0);
WuiInputElement = __decorate$13([
  customElement("wui-input-element")
], WuiInputElement);
const styles$L = i$8`
  :host {
    position: relative;
    display: inline-block;
  }

  input {
    width: 50px;
    height: 50px;
    background: var(--wui-gray-glass-005);
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-gray-glass-005);
    font-family: var(--wui-font-family);
    font-size: var(--wui-font-size-large);
    font-weight: var(--wui-font-weight-regular);
    letter-spacing: var(--wui-letter-spacing-large);
    text-align: center;
    color: var(--wui-color-fg-100);
    caret-color: var(--wui-color-accent-100);
    transition: all var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-gray-glass-010);
    background: var(--wui-gray-glass-015);
  }

  input:focus:enabled {
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    background-color: var(--wui-gray-glass-010);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }
  @media (hover: hover) and (pointer: fine) {
    input:hover:enabled {
      background-color: var(--wui-gray-glass-010);
    }
  }
`;
var __decorate$12 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiInputNumeric = class WuiInputNumeric2 extends s$5 {
  constructor() {
    super(...arguments);
    this.disabled = false;
  }
  render() {
    return x$1`<input
      type="number"
      maxlength="1"
      inputmode="numeric"
      autofocus
      ?disabled=${this.disabled}
    /> `;
  }
};
WuiInputNumeric.styles = [resetStyles, elementStyles, styles$L];
__decorate$12([
  n$8({ type: Boolean })
], WuiInputNumeric.prototype, "disabled", void 0);
WuiInputNumeric = __decorate$12([
  customElement("wui-input-numeric")
], WuiInputNumeric);
const styles$K = i$8`
  button {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
    border-radius: var(--wui-border-radius-3xs);
    background-color: transparent;
    color: var(--wui-color-accent-100);
  }

  button:disabled {
    background-color: transparent;
    color: var(--wui-gray-glass-015);
  }
`;
var __decorate$11 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLink = class WuiLink2 extends s$5 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.color = "inherit";
  }
  render() {
    return x$1`
      <button ?disabled=${this.disabled} ontouchstart>
        <slot name="iconLeft"></slot>
        <wui-text variant="small-600" color=${this.color}>
          <slot></slot>
        </wui-text>
        <slot name="iconRight"></slot>
      </button>
    `;
  }
};
WuiLink.styles = [resetStyles, elementStyles, styles$K];
__decorate$11([
  n$8({ type: Boolean })
], WuiLink.prototype, "disabled", void 0);
__decorate$11([
  n$8()
], WuiLink.prototype, "color", void 0);
WuiLink = __decorate$11([
  customElement("wui-link")
], WuiLink);
const styles$J = i$8`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 11px 18px 11px var(--wui-spacing-s);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  button[data-iconvariant='square'],
  button[data-iconvariant='square-blue'] {
    padding: 6px 18px 6px 9px;
  }

  button > wui-flex {
    flex: 1;
  }

  button > wui-image {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
    border-radius: var(--wui-border-radius-3xl);
  }

  button > wui-icon {
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='blue'] {
    box-shadow: 0 0 0 2px var(--wui-accent-glass-005);
  }

  button > wui-icon-box[data-variant='overlay'] {
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  button > wui-icon-box[data-variant='square-blue'] {
    border-radius: var(--wui-border-radius-3xs);
    position: relative;
    border: none;
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='square-blue']::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-accent-glass-010);
    pointer-events: none;
  }

  button > wui-icon:last-child {
    width: 14px;
    height: 14px;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  button[data-loading='true'] > wui-icon {
    transition: opacity 200ms ease-in-out;
    opacity: 0;
  }

  wui-loading-spinner {
    position: absolute;
    right: 18px;
    top: 50%;
    transform: translateY(-50%);
  }
`;
var __decorate$10 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListItem = class WuiListItem2 extends s$5 {
  constructor() {
    super(...arguments);
    this.variant = "icon";
    this.disabled = false;
    this.imageSrc = void 0;
    this.alt = void 0;
    this.chevron = false;
    this.loading = false;
  }
  render() {
    return x$1`
      <button
        ?disabled=${this.loading ? true : Boolean(this.disabled)}
        data-loading=${this.loading}
        data-iconvariant=${o$9(this.iconVariant)}
        ontouchstart
      >
        ${this.loadingTemplate()} ${this.visualTemplate()}
        <wui-flex gap="3xs">
          <slot></slot>
        </wui-flex>
        ${this.chevronTemplate()}
      </button>
    `;
  }
  visualTemplate() {
    if (this.variant === "image" && this.imageSrc) {
      return x$1`<wui-image src=${this.imageSrc} alt=${this.alt ?? "list item"}></wui-image>`;
    } else if (this.iconVariant === "square" && this.icon && this.variant === "icon") {
      return x$1`<wui-icon name=${this.icon}></wui-icon>`;
    } else if (this.variant === "icon" && this.icon && this.iconVariant) {
      const color2 = ["blue", "square-blue"].includes(this.iconVariant) ? "accent-100" : "fg-200";
      const size2 = this.iconVariant === "square-blue" ? "mdl" : "md";
      const iconSize = this.iconSize ? this.iconSize : size2;
      return x$1`
        <wui-icon-box
          data-variant=${this.iconVariant}
          icon=${this.icon}
          iconSize=${iconSize}
          background="transparent"
          iconColor=${color2}
          backgroundColor=${color2}
          size=${size2}
        ></wui-icon-box>
      `;
    }
    return null;
  }
  loadingTemplate() {
    if (this.loading) {
      return x$1`<wui-loading-spinner color="fg-300"></wui-loading-spinner>`;
    }
    return x$1``;
  }
  chevronTemplate() {
    if (this.chevron) {
      return x$1`<wui-icon size="inherit" color="fg-200" name="chevronRight"></wui-icon>`;
    }
    return null;
  }
};
WuiListItem.styles = [resetStyles, elementStyles, styles$J];
__decorate$10([
  n$8()
], WuiListItem.prototype, "icon", void 0);
__decorate$10([
  n$8()
], WuiListItem.prototype, "iconSize", void 0);
__decorate$10([
  n$8()
], WuiListItem.prototype, "variant", void 0);
__decorate$10([
  n$8()
], WuiListItem.prototype, "iconVariant", void 0);
__decorate$10([
  n$8({ type: Boolean })
], WuiListItem.prototype, "disabled", void 0);
__decorate$10([
  n$8()
], WuiListItem.prototype, "imageSrc", void 0);
__decorate$10([
  n$8()
], WuiListItem.prototype, "alt", void 0);
__decorate$10([
  n$8({ type: Boolean })
], WuiListItem.prototype, "chevron", void 0);
__decorate$10([
  n$8({ type: Boolean })
], WuiListItem.prototype, "loading", void 0);
WuiListItem = __decorate$10([
  customElement("wui-list-item")
], WuiListItem);
var TransactionTypePastTense;
(function(TransactionTypePastTense2) {
  TransactionTypePastTense2["approve"] = "approved";
  TransactionTypePastTense2["bought"] = "bought";
  TransactionTypePastTense2["borrow"] = "borrowed";
  TransactionTypePastTense2["burn"] = "burnt";
  TransactionTypePastTense2["cancel"] = "canceled";
  TransactionTypePastTense2["claim"] = "claimed";
  TransactionTypePastTense2["deploy"] = "deployed";
  TransactionTypePastTense2["deposit"] = "deposited";
  TransactionTypePastTense2["execute"] = "executed";
  TransactionTypePastTense2["mint"] = "minted";
  TransactionTypePastTense2["receive"] = "received";
  TransactionTypePastTense2["repay"] = "repaid";
  TransactionTypePastTense2["send"] = "sent";
  TransactionTypePastTense2["sell"] = "sold";
  TransactionTypePastTense2["stake"] = "staked";
  TransactionTypePastTense2["trade"] = "swapped";
  TransactionTypePastTense2["unstake"] = "unstaked";
  TransactionTypePastTense2["withdraw"] = "withdrawn";
})(TransactionTypePastTense || (TransactionTypePastTense = {}));
const styles$I = i$8`
  :host > wui-flex {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: 40px;
    height: 40px;
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
    background-color: var(--wui-gray-glass-005);
  }

  :host > wui-flex wui-image {
    display: block;
    z-index: -1;
  }

  :host > wui-flex,
  :host > wui-flex wui-image,
  .swap-images-container,
  .swap-images-container.nft,
  wui-image.nft {
    border-top-left-radius: var(--local-left-border-radius);
    border-top-right-radius: var(--local-right-border-radius);
    border-bottom-left-radius: var(--local-left-border-radius);
    border-bottom-right-radius: var(--local-right-border-radius);
  }

  wui-icon {
    width: 20px;
    height: 20px;
  }

  wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }

  .swap-images-container {
    position: relative;
    width: 40px;
    height: 40px;
    overflow: hidden;
  }

  .swap-images-container wui-image:first-child {
    position: absolute;
    width: 40px;
    height: 40px;
    top: 0;
    left: 0%;
    clip-path: inset(0px calc(50% + 2px) 0px 0%);
  }

  .swap-images-container wui-image:last-child {
    clip-path: inset(0px 0px 0px calc(50% + 2px));
  }
`;
var __decorate$$ = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTransactionVisual = class WuiTransactionVisual2 extends s$5 {
  constructor() {
    super(...arguments);
    this.images = [];
    this.secondImage = {
      type: void 0,
      url: ""
    };
  }
  render() {
    const [firstImage, secondImage] = this.images;
    const isLeftNFT = firstImage?.type === "NFT";
    const isRightNFT = secondImage?.url ? secondImage.type === "NFT" : isLeftNFT;
    const leftRadius = isLeftNFT ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)";
    const rightRadius = isRightNFT ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)";
    this.style.cssText = `
    --local-left-border-radius: ${leftRadius};
    --local-right-border-radius: ${rightRadius};
    `;
    return x$1`<wui-flex> ${this.templateVisual()} ${this.templateIcon()} </wui-flex>`;
  }
  templateVisual() {
    const [firstImage, secondImage] = this.images;
    const firstImageType = firstImage?.type;
    const haveTwoImages = this.images.length === 2;
    if (haveTwoImages && (firstImage?.url || secondImage?.url)) {
      return x$1`<div class="swap-images-container">
        ${firstImage?.url ? x$1`<wui-image src=${firstImage.url} alt="Transaction image"></wui-image>` : null}
        ${secondImage?.url ? x$1`<wui-image src=${secondImage.url} alt="Transaction image"></wui-image>` : null}
      </div>`;
    } else if (firstImage?.url) {
      return x$1`<wui-image src=${firstImage.url} alt="Transaction image"></wui-image>`;
    } else if (firstImageType === "NFT") {
      return x$1`<wui-icon size="inherit" color="fg-200" name="nftPlaceholder"></wui-icon>`;
    }
    return x$1`<wui-icon size="inherit" color="fg-200" name="coinPlaceholder"></wui-icon>`;
  }
  templateIcon() {
    let color2 = "accent-100";
    let icon = void 0;
    icon = this.getIcon();
    if (this.status) {
      color2 = this.getStatusColor();
    }
    if (!icon) {
      return null;
    }
    return x$1`
      <wui-icon-box
        size="xxs"
        iconColor=${color2}
        backgroundColor=${color2}
        background="opaque"
        icon=${icon}
        ?border=${true}
        borderColor="wui-color-bg-125"
      ></wui-icon-box>
    `;
  }
  getDirectionIcon() {
    switch (this.direction) {
      case "in":
        return "arrowBottom";
      case "out":
        return "arrowTop";
      default:
        return void 0;
    }
  }
  getIcon() {
    if (this.onlyDirectionIcon) {
      return this.getDirectionIcon();
    }
    if (this.type === "trade") {
      return "swapHorizontalBold";
    } else if (this.type === "approve") {
      return "checkmark";
    } else if (this.type === "cancel") {
      return "close";
    }
    return this.getDirectionIcon();
  }
  getStatusColor() {
    switch (this.status) {
      case "confirmed":
        return "success-100";
      case "failed":
        return "error-100";
      case "pending":
        return "inverse-100";
      default:
        return "accent-100";
    }
  }
};
WuiTransactionVisual.styles = [styles$I];
__decorate$$([
  n$8()
], WuiTransactionVisual.prototype, "type", void 0);
__decorate$$([
  n$8()
], WuiTransactionVisual.prototype, "status", void 0);
__decorate$$([
  n$8()
], WuiTransactionVisual.prototype, "direction", void 0);
__decorate$$([
  n$8({ type: Boolean })
], WuiTransactionVisual.prototype, "onlyDirectionIcon", void 0);
__decorate$$([
  n$8({ type: Array })
], WuiTransactionVisual.prototype, "images", void 0);
__decorate$$([
  n$8({ type: Object })
], WuiTransactionVisual.prototype, "secondImage", void 0);
WuiTransactionVisual = __decorate$$([
  customElement("wui-transaction-visual")
], WuiTransactionVisual);
const styles$H = i$8`
  :host > wui-flex:first-child {
    align-items: center;
    column-gap: var(--wui-spacing-s);
    padding: 6.5px var(--wui-spacing-l) 6.5px var(--wui-spacing-xs);
    width: 100%;
  }

  :host > wui-flex:first-child wui-text:nth-child(1) {
    text-transform: capitalize;
  }

  wui-transaction-visual {
    width: 40px;
    height: 40px;
  }

  wui-flex {
    flex: 1;
  }

  :host wui-flex wui-flex {
    overflow: hidden;
  }

  :host .description-container wui-text span {
    word-break: break-all;
  }

  :host .description-container wui-text {
    overflow: hidden;
  }

  :host .description-separator-icon {
    margin: 0px 6px;
  }

  :host wui-text > span {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }
`;
var __decorate$_ = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTransactionListItem = class WuiTransactionListItem2 extends s$5 {
  constructor() {
    super(...arguments);
    this.type = "approve";
    this.onlyDirectionIcon = false;
    this.images = [];
  }
  render() {
    return x$1`
      <wui-flex>
        <wui-transaction-visual
          .status=${this.status}
          direction=${o$9(this.direction)}
          type=${this.type}
          onlyDirectionIcon=${o$9(this.onlyDirectionIcon)}
          .images=${this.images}
        ></wui-transaction-visual>
        <wui-flex flexDirection="column" gap="3xs">
          <wui-text variant="paragraph-600" color="fg-100">
            ${TransactionTypePastTense[this.type]}
          </wui-text>
          <wui-flex class="description-container">
            ${this.templateDescription()} ${this.templateSecondDescription()}
          </wui-flex>
        </wui-flex>
        <wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></wui-text>
      </wui-flex>
    `;
  }
  templateDescription() {
    const description2 = this.descriptions?.[0];
    return description2 ? x$1`
          <wui-text variant="small-500" color="fg-200">
            <span>${description2}</span>
          </wui-text>
        ` : null;
  }
  templateSecondDescription() {
    const description2 = this.descriptions?.[1];
    return description2 ? x$1`
          <wui-icon class="description-separator-icon" size="xxs" name="arrowRight"></wui-icon>
          <wui-text variant="small-400" color="fg-200">
            <span>${description2}</span>
          </wui-text>
        ` : null;
  }
};
WuiTransactionListItem.styles = [resetStyles, styles$H];
__decorate$_([
  n$8()
], WuiTransactionListItem.prototype, "type", void 0);
__decorate$_([
  n$8({ type: Array })
], WuiTransactionListItem.prototype, "descriptions", void 0);
__decorate$_([
  n$8()
], WuiTransactionListItem.prototype, "date", void 0);
__decorate$_([
  n$8({ type: Boolean })
], WuiTransactionListItem.prototype, "onlyDirectionIcon", void 0);
__decorate$_([
  n$8()
], WuiTransactionListItem.prototype, "status", void 0);
__decorate$_([
  n$8()
], WuiTransactionListItem.prototype, "direction", void 0);
__decorate$_([
  n$8({ type: Array })
], WuiTransactionListItem.prototype, "images", void 0);
WuiTransactionListItem = __decorate$_([
  customElement("wui-transaction-list-item")
], WuiTransactionListItem);
const styles$G = i$8`
  :host > wui-flex:first-child {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
  }

  wui-flex {
    display: flex;
    flex: 1;
  }
`;
var __decorate$Z = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTransactionListItemLoader = class WuiTransactionListItemLoader2 extends s$5 {
  render() {
    return x$1`
      <wui-flex alignItems="center">
        <wui-shimmer width="40px" height="40px"></wui-shimmer>
        <wui-flex flexDirection="column" gap="2xs">
          <wui-shimmer width="72px" height="16px" borderRadius="4xs"></wui-shimmer>
          <wui-shimmer width="148px" height="14px" borderRadius="4xs"></wui-shimmer>
        </wui-flex>
        <wui-shimmer width="24px" height="12px" borderRadius="5xs"></wui-shimmer>
      </wui-flex>
    `;
  }
};
WuiTransactionListItemLoader.styles = [resetStyles, styles$G];
WuiTransactionListItemLoader = __decorate$Z([
  customElement("wui-transaction-list-item-loader")
], WuiTransactionListItemLoader);
const styles$F = i$8`
  :host {
    display: block;
    padding: 3.5px 5px !important;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host([data-variant='main']) {
    background-color: var(--wui-accent-glass-015);
    color: var(--wui-color-accent-100);
  }

  :host([data-variant='shade']) {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  :host([data-variant='success']) {
    background-color: var(--wui-icon-box-bg-success-100);
    color: var(--wui-color-success-100);
  }

  :host([data-variant='error']) {
    background-color: var(--wui-icon-box-bg-error-100);
    color: var(--wui-color-error-100);
  }
`;
var __decorate$Y = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTag = class WuiTag2 extends s$5 {
  constructor() {
    super(...arguments);
    this.variant = "main";
  }
  render() {
    this.dataset["variant"] = this.variant;
    return x$1`
      <wui-text data-variant=${this.variant} variant="micro-700" color="inherit">
        <slot></slot>
      </wui-text>
    `;
  }
};
WuiTag.styles = [resetStyles, styles$F];
__decorate$Y([
  n$8()
], WuiTag.prototype, "variant", void 0);
WuiTag = __decorate$Y([
  customElement("wui-tag")
], WuiTag);
const styles$E = i$8`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  wui-icon {
    color: var(--wui-color-fg-200) !important;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-tag {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-300);
  }
`;
var __decorate$X = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListWallet = class WuiListWallet2 extends s$5 {
  constructor() {
    super(...arguments);
    this.walletImages = [];
    this.imageSrc = "";
    this.name = "";
    this.installed = false;
    this.disabled = false;
    this.showAllWallets = false;
  }
  render() {
    return x$1`
      <button ?disabled=${this.disabled} ontouchstart>
        ${this.templateAllWallets()} ${this.templateWalletImage()}
        <wui-text variant="paragraph-500" color="inherit">${this.name}</wui-text>
        ${this.templateStatus()}
      </button>
    `;
  }
  templateAllWallets() {
    if (this.showAllWallets && this.imageSrc) {
      return x$1` <wui-all-wallets-image .imageeSrc=${this.imageSrc}> </wui-all-wallets-image> `;
    } else if (this.showAllWallets && this.walletIcon) {
      return x$1` <wui-wallet-image .walletIcon=${this.walletIcon} size="sm"> </wui-wallet-image> `;
    }
    return null;
  }
  templateWalletImage() {
    if (!this.showAllWallets && this.imageSrc) {
      return x$1`<wui-wallet-image
        size="sm"
        imageSrc=${this.imageSrc}
        name=${this.name}
        .installed=${this.installed}
      ></wui-wallet-image>`;
    } else if (!this.showAllWallets && !this.imageSrc) {
      return x$1`<wui-wallet-image size="sm" name=${this.name}></wui-wallet-image>`;
    }
    return null;
  }
  templateStatus() {
    if (this.tagLabel && this.tagVariant) {
      return x$1`<wui-tag variant=${this.tagVariant}>${this.tagLabel}</wui-tag>`;
    } else if (this.icon) {
      return x$1`<wui-icon color="inherit" size="sm" name=${this.icon}></wui-icon>`;
    }
    return null;
  }
};
WuiListWallet.styles = [resetStyles, elementStyles, styles$E];
__decorate$X([
  n$8({ type: Array })
], WuiListWallet.prototype, "walletImages", void 0);
__decorate$X([
  n$8()
], WuiListWallet.prototype, "imageSrc", void 0);
__decorate$X([
  n$8()
], WuiListWallet.prototype, "name", void 0);
__decorate$X([
  n$8()
], WuiListWallet.prototype, "tagLabel", void 0);
__decorate$X([
  n$8()
], WuiListWallet.prototype, "tagVariant", void 0);
__decorate$X([
  n$8()
], WuiListWallet.prototype, "icon", void 0);
__decorate$X([
  n$8()
], WuiListWallet.prototype, "walletIcon", void 0);
__decorate$X([
  n$8({ type: Boolean })
], WuiListWallet.prototype, "installed", void 0);
__decorate$X([
  n$8({ type: Boolean })
], WuiListWallet.prototype, "disabled", void 0);
__decorate$X([
  n$8({ type: Boolean })
], WuiListWallet.prototype, "showAllWallets", void 0);
WuiListWallet = __decorate$X([
  customElement("wui-list-wallet")
], WuiListWallet);
const styles$D = i$8`
  :host {
    display: block;
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-010);
    overflow: hidden;
  }

  wui-icon {
    width: 100%;
    height: 100%;
  }
`;
var __decorate$W = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLogo = class WuiLogo2 extends s$5 {
  constructor() {
    super(...arguments);
    this.logo = "google";
  }
  render() {
    return x$1`<wui-icon color="inherit" size="inherit" name=${this.logo}></wui-icon> `;
  }
};
WuiLogo.styles = [resetStyles, styles$D];
__decorate$W([
  n$8()
], WuiLogo.prototype, "logo", void 0);
WuiLogo = __decorate$W([
  customElement("wui-logo")
], WuiLogo);
const styles$C = i$8`
  :host {
    display: block;
  }

  button {
    width: 50px;
    height: 50px;
    background: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$V = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLogoSelect = class WuiLogoSelect2 extends s$5 {
  constructor() {
    super(...arguments);
    this.logo = "google";
    this.disabled = false;
  }
  render() {
    return x$1`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-logo logo=${this.logo}></wui-logo>
      </button>
    `;
  }
};
WuiLogoSelect.styles = [resetStyles, elementStyles, styles$C];
__decorate$V([
  n$8()
], WuiLogoSelect.prototype, "logo", void 0);
__decorate$V([
  n$8({ type: Boolean })
], WuiLogoSelect.prototype, "disabled", void 0);
WuiLogoSelect = __decorate$V([
  customElement("wui-logo-select")
], WuiLogoSelect);
const styles$B = i$8`
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-2xs) var(--wui-spacing-s) var(--wui-spacing-2xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-gray-glass-010);
    background-color: var(--wui-gray-glass-005);
    color: var(--wui-color-fg-100);
  }

  button:disabled {
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-gray-glass-010);
    }

    button:active:enabled {
      background-color: var(--wui-gray-glass-015);
    }
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }
`;
var __decorate$U = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiNetworkButton = class WuiNetworkButton2 extends s$5 {
  constructor() {
    super(...arguments);
    this.imageSrc = void 0;
    this.disabled = false;
  }
  render() {
    return x$1`
      <button ?disabled=${this.disabled}>
        ${this.visualTemplate()}
        <wui-text variant="paragraph-600" color="inherit">
          <slot></slot>
        </wui-text>
      </button>
    `;
  }
  visualTemplate() {
    if (this.imageSrc) {
      return x$1`<wui-image src=${this.imageSrc}></wui-image>`;
    }
    return x$1`
      <wui-icon-box
        size="sm"
        iconColor="inverse-100"
        backgroundColor="fg-100"
        icon="networkPlaceholder"
      ></wui-icon-box>
    `;
  }
};
WuiNetworkButton.styles = [resetStyles, elementStyles, styles$B];
__decorate$U([
  n$8()
], WuiNetworkButton.prototype, "imageSrc", void 0);
__decorate$U([
  n$8({ type: Boolean })
], WuiNetworkButton.prototype, "disabled", void 0);
WuiNetworkButton = __decorate$U([
  customElement("wui-network-button")
], WuiNetworkButton);
const styles$A = i$8`
  :host {
    position: relative;
    display: block;
  }
`;
var __decorate$T = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiOtp = class WuiOtp2 extends s$5 {
  constructor() {
    super(...arguments);
    this.length = 6;
    this.valueArr = Array.from({ length: this.length }).map(() => "");
    this.numerics = [];
    this.shouldInputBeEnabled = (index2) => {
      const previousInputs = this.valueArr.slice(0, index2);
      return previousInputs.every((input) => input !== "");
    };
    this.handleKeyDown = (e2, index2) => {
      const inputElement = e2.target;
      const input = this.getInputElement(inputElement);
      const keyArr = ["ArrowLeft", "ArrowRight", "Shift", "Delete"];
      if (!input) {
        return;
      }
      if (keyArr.includes(e2.key)) {
        e2.preventDefault();
      }
      const currentCaretPos = input.selectionStart;
      switch (e2.key) {
        case "ArrowLeft":
          if (currentCaretPos) {
            input.setSelectionRange(currentCaretPos + 1, currentCaretPos + 1);
          }
          this.focusInputField("prev", index2);
          break;
        case "ArrowRight":
          this.focusInputField("next", index2);
          break;
        case "Shift":
          this.focusInputField("next", index2);
          break;
        case "Delete":
          if (input.value === "") {
            this.focusInputField("prev", index2);
          } else {
            this.updateInput(input, index2, "");
          }
          break;
        case "Backspace":
          if (input.value === "") {
            this.focusInputField("prev", index2);
          } else {
            this.updateInput(input, index2, "");
          }
          break;
      }
    };
    this.focusInputField = (dir, index2) => {
      if (dir === "next") {
        const nextIndex = index2 + 1;
        if (!this.shouldInputBeEnabled(nextIndex)) {
          return;
        }
        const numeric2 = this.numerics[nextIndex < this.length ? nextIndex : index2];
        const input = numeric2 ? this.getInputElement(numeric2) : void 0;
        if (input) {
          input.disabled = false;
          input.focus();
        }
      }
      if (dir === "prev") {
        const nextIndex = index2 - 1;
        const numeric2 = this.numerics[nextIndex > -1 ? nextIndex : index2];
        const input = numeric2 ? this.getInputElement(numeric2) : void 0;
        if (input) {
          input.focus();
        }
      }
    };
  }
  firstUpdated() {
    const numericElements = this.shadowRoot?.querySelectorAll("wui-input-numeric");
    if (numericElements) {
      this.numerics = Array.from(numericElements);
    }
    this.numerics[0]?.focus();
  }
  render() {
    return x$1`
      <wui-flex gap="xxs" data-testid="wui-otp-input">
        ${Array.from({ length: this.length }).map((_2, index2) => x$1`
            <wui-input-numeric
              @input=${(e2) => this.handleInput(e2, index2)}
              @keydown=${(e2) => this.handleKeyDown(e2, index2)}
              .disabled=${!this.shouldInputBeEnabled(index2)}
            >
            </wui-input-numeric>
          `)}
      </wui-flex>
    `;
  }
  updateInput(element, index2, value) {
    const numeric2 = this.numerics[index2];
    const input = element || (numeric2 ? this.getInputElement(numeric2) : void 0);
    if (input) {
      input.value = value;
      this.valueArr = this.valueArr.map((val, i3) => i3 === index2 ? value : val);
    }
  }
  handleInput(e2, index2) {
    const inputElement = e2.target;
    const input = this.getInputElement(inputElement);
    if (input) {
      const inputValue = input.value;
      if (e2.inputType === "insertFromPaste") {
        this.handlePaste(input, inputValue, index2);
      } else {
        const isValid3 = UiHelperUtil.isNumber(inputValue);
        if (isValid3 && e2.data) {
          this.updateInput(input, index2, e2.data);
          this.focusInputField("next", index2);
        } else {
          this.updateInput(input, index2, "");
        }
      }
    }
    this.dispatchInputChangeEvent();
  }
  handlePaste(input, inputValue, index2) {
    const value = inputValue[0];
    const isValid3 = value && UiHelperUtil.isNumber(value);
    if (isValid3) {
      this.updateInput(input, index2, value);
      const inputString = inputValue.substring(1);
      if (index2 + 1 < this.length && inputString.length) {
        const nextNumeric = this.numerics[index2 + 1];
        const nextInput = nextNumeric ? this.getInputElement(nextNumeric) : void 0;
        if (nextInput) {
          this.handlePaste(nextInput, inputString, index2 + 1);
        }
      } else {
        this.focusInputField("next", index2);
      }
    } else {
      this.updateInput(input, index2, "");
    }
  }
  getInputElement(el2) {
    if (el2.shadowRoot?.querySelector("input")) {
      return el2.shadowRoot.querySelector("input");
    }
    return null;
  }
  dispatchInputChangeEvent() {
    const value = this.valueArr.join("");
    this.dispatchEvent(new CustomEvent("inputChange", {
      detail: value,
      bubbles: true,
      composed: true
    }));
  }
};
WuiOtp.styles = [resetStyles, styles$A];
__decorate$T([
  n$8({ type: Number })
], WuiOtp.prototype, "length", void 0);
__decorate$T([
  r$8()
], WuiOtp.prototype, "valueArr", void 0);
WuiOtp = __decorate$T([
  customElement("wui-otp")
], WuiOtp);
var browser$1 = {};
var canPromise$1 = function() {
  return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
};
var qrcode = {};
var utils$2 = {};
let toSJISFunction;
const CODEWORDS_COUNT = [
  0,
  // Not used
  26,
  44,
  70,
  100,
  134,
  172,
  196,
  242,
  292,
  346,
  404,
  466,
  532,
  581,
  655,
  733,
  815,
  901,
  991,
  1085,
  1156,
  1258,
  1364,
  1474,
  1588,
  1706,
  1828,
  1921,
  2051,
  2185,
  2323,
  2465,
  2611,
  2761,
  2876,
  3034,
  3196,
  3362,
  3532,
  3706
];
utils$2.getSymbolSize = function getSymbolSize(version2) {
  if (!version2)
    throw new Error('"version" cannot be null or undefined');
  if (version2 < 1 || version2 > 40)
    throw new Error('"version" should be in range from 1 to 40');
  return version2 * 4 + 17;
};
utils$2.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
  return CODEWORDS_COUNT[version2];
};
utils$2.getBCHDigit = function(data2) {
  let digit = 0;
  while (data2 !== 0) {
    digit++;
    data2 >>>= 1;
  }
  return digit;
};
utils$2.setToSJISFunction = function setToSJISFunction(f3) {
  if (typeof f3 !== "function") {
    throw new Error('"toSJISFunc" is not a valid function.');
  }
  toSJISFunction = f3;
};
utils$2.isKanjiModeEnabled = function() {
  return typeof toSJISFunction !== "undefined";
};
utils$2.toSJIS = function toSJIS(kanji2) {
  return toSJISFunction(kanji2);
};
var errorCorrectionLevel = {};
(function(exports) {
  exports.L = { bit: 1 };
  exports.M = { bit: 0 };
  exports.Q = { bit: 3 };
  exports.H = { bit: 2 };
  function fromString2(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "l":
      case "low":
        return exports.L;
      case "m":
      case "medium":
        return exports.M;
      case "q":
      case "quartile":
        return exports.Q;
      case "h":
      case "high":
        return exports.H;
      default:
        throw new Error("Unknown EC Level: " + string2);
    }
  }
  exports.isValid = function isValid3(level) {
    return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
  };
  exports.from = function from2(value, defaultValue) {
    if (exports.isValid(value)) {
      return value;
    }
    try {
      return fromString2(value);
    } catch (e2) {
      return defaultValue;
    }
  };
})(errorCorrectionLevel);
function BitBuffer$1() {
  this.buffer = [];
  this.length = 0;
}
BitBuffer$1.prototype = {
  get: function(index2) {
    const bufIndex = Math.floor(index2 / 8);
    return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
  },
  put: function(num, length2) {
    for (let i3 = 0; i3 < length2; i3++) {
      this.putBit((num >>> length2 - i3 - 1 & 1) === 1);
    }
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(bit) {
    const bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8;
    }
    this.length++;
  }
};
var bitBuffer = BitBuffer$1;
function BitMatrix$1(size2) {
  if (!size2 || size2 < 1) {
    throw new Error("BitMatrix size must be defined and greater than 0");
  }
  this.size = size2;
  this.data = new Uint8Array(size2 * size2);
  this.reservedBit = new Uint8Array(size2 * size2);
}
BitMatrix$1.prototype.set = function(row, col, value, reserved) {
  const index2 = row * this.size + col;
  this.data[index2] = value;
  if (reserved)
    this.reservedBit[index2] = true;
};
BitMatrix$1.prototype.get = function(row, col) {
  return this.data[row * this.size + col];
};
BitMatrix$1.prototype.xor = function(row, col, value) {
  this.data[row * this.size + col] ^= value;
};
BitMatrix$1.prototype.isReserved = function(row, col) {
  return this.reservedBit[row * this.size + col];
};
var bitMatrix = BitMatrix$1;
var alignmentPattern = {};
(function(exports) {
  const getSymbolSize3 = utils$2.getSymbolSize;
  exports.getRowColCoords = function getRowColCoords(version2) {
    if (version2 === 1)
      return [];
    const posCount = Math.floor(version2 / 7) + 2;
    const size2 = getSymbolSize3(version2);
    const intervals = size2 === 145 ? 26 : Math.ceil((size2 - 13) / (2 * posCount - 2)) * 2;
    const positions = [size2 - 7];
    for (let i3 = 1; i3 < posCount - 1; i3++) {
      positions[i3] = positions[i3 - 1] - intervals;
    }
    positions.push(6);
    return positions.reverse();
  };
  exports.getPositions = function getPositions2(version2) {
    const coords = [];
    const pos = exports.getRowColCoords(version2);
    const posLength = pos.length;
    for (let i3 = 0; i3 < posLength; i3++) {
      for (let j2 = 0; j2 < posLength; j2++) {
        if (i3 === 0 && j2 === 0 || // top-left
        i3 === 0 && j2 === posLength - 1 || // bottom-left
        i3 === posLength - 1 && j2 === 0) {
          continue;
        }
        coords.push([pos[i3], pos[j2]]);
      }
    }
    return coords;
  };
})(alignmentPattern);
var finderPattern = {};
const getSymbolSize2 = utils$2.getSymbolSize;
const FINDER_PATTERN_SIZE = 7;
finderPattern.getPositions = function getPositions(version2) {
  const size2 = getSymbolSize2(version2);
  return [
    // top-left
    [0, 0],
    // top-right
    [size2 - FINDER_PATTERN_SIZE, 0],
    // bottom-left
    [0, size2 - FINDER_PATTERN_SIZE]
  ];
};
var maskPattern = {};
(function(exports) {
  exports.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  const PenaltyScores = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  exports.isValid = function isValid3(mask) {
    return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
  };
  exports.from = function from2(value) {
    return exports.isValid(value) ? parseInt(value, 10) : void 0;
  };
  exports.getPenaltyN1 = function getPenaltyN1(data2) {
    const size2 = data2.size;
    let points = 0;
    let sameCountCol = 0;
    let sameCountRow = 0;
    let lastCol = null;
    let lastRow = null;
    for (let row = 0; row < size2; row++) {
      sameCountCol = sameCountRow = 0;
      lastCol = lastRow = null;
      for (let col = 0; col < size2; col++) {
        let module = data2.get(row, col);
        if (module === lastCol) {
          sameCountCol++;
        } else {
          if (sameCountCol >= 5)
            points += PenaltyScores.N1 + (sameCountCol - 5);
          lastCol = module;
          sameCountCol = 1;
        }
        module = data2.get(col, row);
        if (module === lastRow) {
          sameCountRow++;
        } else {
          if (sameCountRow >= 5)
            points += PenaltyScores.N1 + (sameCountRow - 5);
          lastRow = module;
          sameCountRow = 1;
        }
      }
      if (sameCountCol >= 5)
        points += PenaltyScores.N1 + (sameCountCol - 5);
      if (sameCountRow >= 5)
        points += PenaltyScores.N1 + (sameCountRow - 5);
    }
    return points;
  };
  exports.getPenaltyN2 = function getPenaltyN2(data2) {
    const size2 = data2.size;
    let points = 0;
    for (let row = 0; row < size2 - 1; row++) {
      for (let col = 0; col < size2 - 1; col++) {
        const last = data2.get(row, col) + data2.get(row, col + 1) + data2.get(row + 1, col) + data2.get(row + 1, col + 1);
        if (last === 4 || last === 0)
          points++;
      }
    }
    return points * PenaltyScores.N2;
  };
  exports.getPenaltyN3 = function getPenaltyN3(data2) {
    const size2 = data2.size;
    let points = 0;
    let bitsCol = 0;
    let bitsRow = 0;
    for (let row = 0; row < size2; row++) {
      bitsCol = bitsRow = 0;
      for (let col = 0; col < size2; col++) {
        bitsCol = bitsCol << 1 & 2047 | data2.get(row, col);
        if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
          points++;
        bitsRow = bitsRow << 1 & 2047 | data2.get(col, row);
        if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
          points++;
      }
    }
    return points * PenaltyScores.N3;
  };
  exports.getPenaltyN4 = function getPenaltyN4(data2) {
    let darkCount = 0;
    const modulesCount = data2.data.length;
    for (let i3 = 0; i3 < modulesCount; i3++)
      darkCount += data2.data[i3];
    const k4 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
    return k4 * PenaltyScores.N4;
  };
  function getMaskAt(maskPattern2, i3, j2) {
    switch (maskPattern2) {
      case exports.Patterns.PATTERN000:
        return (i3 + j2) % 2 === 0;
      case exports.Patterns.PATTERN001:
        return i3 % 2 === 0;
      case exports.Patterns.PATTERN010:
        return j2 % 3 === 0;
      case exports.Patterns.PATTERN011:
        return (i3 + j2) % 3 === 0;
      case exports.Patterns.PATTERN100:
        return (Math.floor(i3 / 2) + Math.floor(j2 / 3)) % 2 === 0;
      case exports.Patterns.PATTERN101:
        return i3 * j2 % 2 + i3 * j2 % 3 === 0;
      case exports.Patterns.PATTERN110:
        return (i3 * j2 % 2 + i3 * j2 % 3) % 2 === 0;
      case exports.Patterns.PATTERN111:
        return (i3 * j2 % 3 + (i3 + j2) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern2);
    }
  }
  exports.applyMask = function applyMask(pattern, data2) {
    const size2 = data2.size;
    for (let col = 0; col < size2; col++) {
      for (let row = 0; row < size2; row++) {
        if (data2.isReserved(row, col))
          continue;
        data2.xor(row, col, getMaskAt(pattern, row, col));
      }
    }
  };
  exports.getBestMask = function getBestMask(data2, setupFormatFunc) {
    const numPatterns = Object.keys(exports.Patterns).length;
    let bestPattern = 0;
    let lowerPenalty = Infinity;
    for (let p2 = 0; p2 < numPatterns; p2++) {
      setupFormatFunc(p2);
      exports.applyMask(p2, data2);
      const penalty = exports.getPenaltyN1(data2) + exports.getPenaltyN2(data2) + exports.getPenaltyN3(data2) + exports.getPenaltyN4(data2);
      exports.applyMask(p2, data2);
      if (penalty < lowerPenalty) {
        lowerPenalty = penalty;
        bestPattern = p2;
      }
    }
    return bestPattern;
  };
})(maskPattern);
var errorCorrectionCode = {};
const ECLevel$1 = errorCorrectionLevel;
const EC_BLOCKS_TABLE = [
  // L  M  Q  H
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  1,
  2,
  2,
  4,
  1,
  2,
  4,
  4,
  2,
  4,
  4,
  4,
  2,
  4,
  6,
  5,
  2,
  4,
  6,
  6,
  2,
  5,
  8,
  8,
  4,
  5,
  8,
  8,
  4,
  5,
  8,
  11,
  4,
  8,
  10,
  11,
  4,
  9,
  12,
  16,
  4,
  9,
  16,
  16,
  6,
  10,
  12,
  18,
  6,
  10,
  17,
  16,
  6,
  11,
  16,
  19,
  6,
  13,
  18,
  21,
  7,
  14,
  21,
  25,
  8,
  16,
  20,
  25,
  8,
  17,
  23,
  25,
  9,
  17,
  23,
  34,
  9,
  18,
  25,
  30,
  10,
  20,
  27,
  32,
  12,
  21,
  29,
  35,
  12,
  23,
  34,
  37,
  12,
  25,
  34,
  40,
  13,
  26,
  35,
  42,
  14,
  28,
  38,
  45,
  15,
  29,
  40,
  48,
  16,
  31,
  43,
  51,
  17,
  33,
  45,
  54,
  18,
  35,
  48,
  57,
  19,
  37,
  51,
  60,
  19,
  38,
  53,
  63,
  20,
  40,
  56,
  66,
  21,
  43,
  59,
  70,
  22,
  45,
  62,
  74,
  24,
  47,
  65,
  77,
  25,
  49,
  68,
  81
];
const EC_CODEWORDS_TABLE = [
  // L  M  Q  H
  7,
  10,
  13,
  17,
  10,
  16,
  22,
  28,
  15,
  26,
  36,
  44,
  20,
  36,
  52,
  64,
  26,
  48,
  72,
  88,
  36,
  64,
  96,
  112,
  40,
  72,
  108,
  130,
  48,
  88,
  132,
  156,
  60,
  110,
  160,
  192,
  72,
  130,
  192,
  224,
  80,
  150,
  224,
  264,
  96,
  176,
  260,
  308,
  104,
  198,
  288,
  352,
  120,
  216,
  320,
  384,
  132,
  240,
  360,
  432,
  144,
  280,
  408,
  480,
  168,
  308,
  448,
  532,
  180,
  338,
  504,
  588,
  196,
  364,
  546,
  650,
  224,
  416,
  600,
  700,
  224,
  442,
  644,
  750,
  252,
  476,
  690,
  816,
  270,
  504,
  750,
  900,
  300,
  560,
  810,
  960,
  312,
  588,
  870,
  1050,
  336,
  644,
  952,
  1110,
  360,
  700,
  1020,
  1200,
  390,
  728,
  1050,
  1260,
  420,
  784,
  1140,
  1350,
  450,
  812,
  1200,
  1440,
  480,
  868,
  1290,
  1530,
  510,
  924,
  1350,
  1620,
  540,
  980,
  1440,
  1710,
  570,
  1036,
  1530,
  1800,
  570,
  1064,
  1590,
  1890,
  600,
  1120,
  1680,
  1980,
  630,
  1204,
  1770,
  2100,
  660,
  1260,
  1860,
  2220,
  720,
  1316,
  1950,
  2310,
  750,
  1372,
  2040,
  2430
];
errorCorrectionCode.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
var polynomial = {};
var galoisField = {};
const EXP_TABLE = new Uint8Array(512);
const LOG_TABLE = new Uint8Array(256);
(function initTables() {
  let x2 = 1;
  for (let i3 = 0; i3 < 255; i3++) {
    EXP_TABLE[i3] = x2;
    LOG_TABLE[x2] = i3;
    x2 <<= 1;
    if (x2 & 256) {
      x2 ^= 285;
    }
  }
  for (let i3 = 255; i3 < 512; i3++) {
    EXP_TABLE[i3] = EXP_TABLE[i3 - 255];
  }
})();
galoisField.log = function log2(n4) {
  if (n4 < 1)
    throw new Error("log(" + n4 + ")");
  return LOG_TABLE[n4];
};
galoisField.exp = function exp2(n4) {
  return EXP_TABLE[n4];
};
galoisField.mul = function mul3(x2, y2) {
  if (x2 === 0 || y2 === 0)
    return 0;
  return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y2]];
};
(function(exports) {
  const GF = galoisField;
  exports.mul = function mul4(p1, p2) {
    const coeff = new Uint8Array(p1.length + p2.length - 1);
    for (let i3 = 0; i3 < p1.length; i3++) {
      for (let j2 = 0; j2 < p2.length; j2++) {
        coeff[i3 + j2] ^= GF.mul(p1[i3], p2[j2]);
      }
    }
    return coeff;
  };
  exports.mod = function mod(divident, divisor) {
    let result = new Uint8Array(divident);
    while (result.length - divisor.length >= 0) {
      const coeff = result[0];
      for (let i3 = 0; i3 < divisor.length; i3++) {
        result[i3] ^= GF.mul(divisor[i3], coeff);
      }
      let offset = 0;
      while (offset < result.length && result[offset] === 0)
        offset++;
      result = result.slice(offset);
    }
    return result;
  };
  exports.generateECPolynomial = function generateECPolynomial(degree) {
    let poly = new Uint8Array([1]);
    for (let i3 = 0; i3 < degree; i3++) {
      poly = exports.mul(poly, new Uint8Array([1, GF.exp(i3)]));
    }
    return poly;
  };
})(polynomial);
const Polynomial = polynomial;
function ReedSolomonEncoder$1(degree) {
  this.genPoly = void 0;
  this.degree = degree;
  if (this.degree)
    this.initialize(this.degree);
}
ReedSolomonEncoder$1.prototype.initialize = function initialize(degree) {
  this.degree = degree;
  this.genPoly = Polynomial.generateECPolynomial(this.degree);
};
ReedSolomonEncoder$1.prototype.encode = function encode2(data2) {
  if (!this.genPoly) {
    throw new Error("Encoder not initialized");
  }
  const paddedData = new Uint8Array(data2.length + this.degree);
  paddedData.set(data2);
  const remainder = Polynomial.mod(paddedData, this.genPoly);
  const start = this.degree - remainder.length;
  if (start > 0) {
    const buff = new Uint8Array(this.degree);
    buff.set(remainder, start);
    return buff;
  }
  return remainder;
};
var reedSolomonEncoder = ReedSolomonEncoder$1;
var version = {};
var mode = {};
var versionCheck = {};
versionCheck.isValid = function isValid(version2) {
  return !isNaN(version2) && version2 >= 1 && version2 <= 40;
};
var regex = {};
const numeric = "[0-9]+";
const alphanumeric = "[A-Z $%*+\\-./:]+";
let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
kanji = kanji.replace(/u/g, "\\u");
const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
regex.KANJI = new RegExp(kanji, "g");
regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
regex.BYTE = new RegExp(byte, "g");
regex.NUMERIC = new RegExp(numeric, "g");
regex.ALPHANUMERIC = new RegExp(alphanumeric, "g");
const TEST_KANJI = new RegExp("^" + kanji + "$");
const TEST_NUMERIC = new RegExp("^" + numeric + "$");
const TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
regex.testKanji = function testKanji(str) {
  return TEST_KANJI.test(str);
};
regex.testNumeric = function testNumeric(str) {
  return TEST_NUMERIC.test(str);
};
regex.testAlphanumeric = function testAlphanumeric(str) {
  return TEST_ALPHANUMERIC.test(str);
};
(function(exports) {
  const VersionCheck = versionCheck;
  const Regex = regex;
  exports.NUMERIC = {
    id: "Numeric",
    bit: 1 << 0,
    ccBits: [10, 12, 14]
  };
  exports.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 1 << 1,
    ccBits: [9, 11, 13]
  };
  exports.BYTE = {
    id: "Byte",
    bit: 1 << 2,
    ccBits: [8, 16, 16]
  };
  exports.KANJI = {
    id: "Kanji",
    bit: 1 << 3,
    ccBits: [8, 10, 12]
  };
  exports.MIXED = {
    bit: -1
  };
  exports.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
    if (!mode2.ccBits)
      throw new Error("Invalid mode: " + mode2);
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid version: " + version2);
    }
    if (version2 >= 1 && version2 < 10)
      return mode2.ccBits[0];
    else if (version2 < 27)
      return mode2.ccBits[1];
    return mode2.ccBits[2];
  };
  exports.getBestModeForData = function getBestModeForData(dataStr) {
    if (Regex.testNumeric(dataStr))
      return exports.NUMERIC;
    else if (Regex.testAlphanumeric(dataStr))
      return exports.ALPHANUMERIC;
    else if (Regex.testKanji(dataStr))
      return exports.KANJI;
    else
      return exports.BYTE;
  };
  exports.toString = function toString2(mode2) {
    if (mode2 && mode2.id)
      return mode2.id;
    throw new Error("Invalid mode");
  };
  exports.isValid = function isValid3(mode2) {
    return mode2 && mode2.bit && mode2.ccBits;
  };
  function fromString2(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "numeric":
        return exports.NUMERIC;
      case "alphanumeric":
        return exports.ALPHANUMERIC;
      case "kanji":
        return exports.KANJI;
      case "byte":
        return exports.BYTE;
      default:
        throw new Error("Unknown mode: " + string2);
    }
  }
  exports.from = function from2(value, defaultValue) {
    if (exports.isValid(value)) {
      return value;
    }
    try {
      return fromString2(value);
    } catch (e2) {
      return defaultValue;
    }
  };
})(mode);
(function(exports) {
  const Utils2 = utils$2;
  const ECCode2 = errorCorrectionCode;
  const ECLevel2 = errorCorrectionLevel;
  const Mode2 = mode;
  const VersionCheck = versionCheck;
  const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
  const G18_BCH = Utils2.getBCHDigit(G18);
  function getBestVersionForDataLength(mode2, length2, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  function getReservedBitsCount(mode2, version2) {
    return Mode2.getCharCountIndicator(mode2, version2) + 4;
  }
  function getTotalBitsFromDataArray(segments2, version2) {
    let totalBits = 0;
    segments2.forEach(function(data2) {
      const reservedBits = getReservedBitsCount(data2.mode, version2);
      totalBits += reservedBits + data2.getBitsLength();
    });
    return totalBits;
  }
  function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      const length2 = getTotalBitsFromDataArray(segments2, currentVersion);
      if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel2, Mode2.MIXED)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  exports.from = function from2(value, defaultValue) {
    if (VersionCheck.isValid(value)) {
      return parseInt(value, 10);
    }
    return defaultValue;
  };
  exports.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid QR Code version");
    }
    if (typeof mode2 === "undefined")
      mode2 = Mode2.BYTE;
    const totalCodewords = Utils2.getSymbolTotalCodewords(version2);
    const ecTotalCodewords = ECCode2.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (mode2 === Mode2.MIXED)
      return dataTotalCodewordsBits;
    const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
    switch (mode2) {
      case Mode2.NUMERIC:
        return Math.floor(usableBits / 10 * 3);
      case Mode2.ALPHANUMERIC:
        return Math.floor(usableBits / 11 * 2);
      case Mode2.KANJI:
        return Math.floor(usableBits / 13);
      case Mode2.BYTE:
      default:
        return Math.floor(usableBits / 8);
    }
  };
  exports.getBestVersionForData = function getBestVersionForData(data2, errorCorrectionLevel2) {
    let seg;
    const ecl = ECLevel2.from(errorCorrectionLevel2, ECLevel2.M);
    if (Array.isArray(data2)) {
      if (data2.length > 1) {
        return getBestVersionForMixedData(data2, ecl);
      }
      if (data2.length === 0) {
        return 1;
      }
      seg = data2[0];
    } else {
      seg = data2;
    }
    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
  };
  exports.getEncodedBits = function getEncodedBits2(version2) {
    if (!VersionCheck.isValid(version2) || version2 < 7) {
      throw new Error("Invalid QR Code version");
    }
    let d2 = version2 << 12;
    while (Utils2.getBCHDigit(d2) - G18_BCH >= 0) {
      d2 ^= G18 << Utils2.getBCHDigit(d2) - G18_BCH;
    }
    return version2 << 12 | d2;
  };
})(version);
var formatInfo = {};
const Utils$3 = utils$2;
const G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
const G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
const G15_BCH = Utils$3.getBCHDigit(G15);
formatInfo.getEncodedBits = function getEncodedBits(errorCorrectionLevel2, mask) {
  const data2 = errorCorrectionLevel2.bit << 3 | mask;
  let d2 = data2 << 10;
  while (Utils$3.getBCHDigit(d2) - G15_BCH >= 0) {
    d2 ^= G15 << Utils$3.getBCHDigit(d2) - G15_BCH;
  }
  return (data2 << 10 | d2) ^ G15_MASK;
};
var segments = {};
const Mode$4 = mode;
function NumericData(data2) {
  this.mode = Mode$4.NUMERIC;
  this.data = data2.toString();
}
NumericData.getBitsLength = function getBitsLength(length2) {
  return 10 * Math.floor(length2 / 3) + (length2 % 3 ? length2 % 3 * 3 + 1 : 0);
};
NumericData.prototype.getLength = function getLength2() {
  return this.data.length;
};
NumericData.prototype.getBitsLength = function getBitsLength2() {
  return NumericData.getBitsLength(this.data.length);
};
NumericData.prototype.write = function write(bitBuffer2) {
  let i3, group, value;
  for (i3 = 0; i3 + 3 <= this.data.length; i3 += 3) {
    group = this.data.substr(i3, 3);
    value = parseInt(group, 10);
    bitBuffer2.put(value, 10);
  }
  const remainingNum = this.data.length - i3;
  if (remainingNum > 0) {
    group = this.data.substr(i3);
    value = parseInt(group, 10);
    bitBuffer2.put(value, remainingNum * 3 + 1);
  }
};
var numericData = NumericData;
const Mode$3 = mode;
const ALPHA_NUM_CHARS = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  " ",
  "$",
  "%",
  "*",
  "+",
  "-",
  ".",
  "/",
  ":"
];
function AlphanumericData(data2) {
  this.mode = Mode$3.ALPHANUMERIC;
  this.data = data2;
}
AlphanumericData.getBitsLength = function getBitsLength3(length2) {
  return 11 * Math.floor(length2 / 2) + 6 * (length2 % 2);
};
AlphanumericData.prototype.getLength = function getLength3() {
  return this.data.length;
};
AlphanumericData.prototype.getBitsLength = function getBitsLength4() {
  return AlphanumericData.getBitsLength(this.data.length);
};
AlphanumericData.prototype.write = function write2(bitBuffer2) {
  let i3;
  for (i3 = 0; i3 + 2 <= this.data.length; i3 += 2) {
    let value = ALPHA_NUM_CHARS.indexOf(this.data[i3]) * 45;
    value += ALPHA_NUM_CHARS.indexOf(this.data[i3 + 1]);
    bitBuffer2.put(value, 11);
  }
  if (this.data.length % 2) {
    bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i3]), 6);
  }
};
var alphanumericData = AlphanumericData;
var encodeUtf8$1 = function encodeUtf8(input) {
  var result = [];
  var size2 = input.length;
  for (var index2 = 0; index2 < size2; index2++) {
    var point3 = input.charCodeAt(index2);
    if (point3 >= 55296 && point3 <= 56319 && size2 > index2 + 1) {
      var second = input.charCodeAt(index2 + 1);
      if (second >= 56320 && second <= 57343) {
        point3 = (point3 - 55296) * 1024 + second - 56320 + 65536;
        index2 += 1;
      }
    }
    if (point3 < 128) {
      result.push(point3);
      continue;
    }
    if (point3 < 2048) {
      result.push(point3 >> 6 | 192);
      result.push(point3 & 63 | 128);
      continue;
    }
    if (point3 < 55296 || point3 >= 57344 && point3 < 65536) {
      result.push(point3 >> 12 | 224);
      result.push(point3 >> 6 & 63 | 128);
      result.push(point3 & 63 | 128);
      continue;
    }
    if (point3 >= 65536 && point3 <= 1114111) {
      result.push(point3 >> 18 | 240);
      result.push(point3 >> 12 & 63 | 128);
      result.push(point3 >> 6 & 63 | 128);
      result.push(point3 & 63 | 128);
      continue;
    }
    result.push(239, 191, 189);
  }
  return new Uint8Array(result).buffer;
};
const encodeUtf82 = encodeUtf8$1;
const Mode$2 = mode;
function ByteData(data2) {
  this.mode = Mode$2.BYTE;
  if (typeof data2 === "string") {
    data2 = encodeUtf82(data2);
  }
  this.data = new Uint8Array(data2);
}
ByteData.getBitsLength = function getBitsLength5(length2) {
  return length2 * 8;
};
ByteData.prototype.getLength = function getLength4() {
  return this.data.length;
};
ByteData.prototype.getBitsLength = function getBitsLength6() {
  return ByteData.getBitsLength(this.data.length);
};
ByteData.prototype.write = function(bitBuffer2) {
  for (let i3 = 0, l2 = this.data.length; i3 < l2; i3++) {
    bitBuffer2.put(this.data[i3], 8);
  }
};
var byteData = ByteData;
const Mode$1 = mode;
const Utils$2 = utils$2;
function KanjiData(data2) {
  this.mode = Mode$1.KANJI;
  this.data = data2;
}
KanjiData.getBitsLength = function getBitsLength7(length2) {
  return length2 * 13;
};
KanjiData.prototype.getLength = function getLength5() {
  return this.data.length;
};
KanjiData.prototype.getBitsLength = function getBitsLength8() {
  return KanjiData.getBitsLength(this.data.length);
};
KanjiData.prototype.write = function(bitBuffer2) {
  let i3;
  for (i3 = 0; i3 < this.data.length; i3++) {
    let value = Utils$2.toSJIS(this.data[i3]);
    if (value >= 33088 && value <= 40956) {
      value -= 33088;
    } else if (value >= 57408 && value <= 60351) {
      value -= 49472;
    } else {
      throw new Error(
        "Invalid SJIS character: " + this.data[i3] + "\nMake sure your charset is UTF-8"
      );
    }
    value = (value >>> 8 & 255) * 192 + (value & 255);
    bitBuffer2.put(value, 13);
  }
};
var kanjiData = KanjiData;
var dijkstra = { exports: {} };
(function(module) {
  var dijkstra2 = {
    single_source_shortest_paths: function(graph, s4, d2) {
      var predecessors = {};
      var costs = {};
      costs[s4] = 0;
      var open = dijkstra2.PriorityQueue.make();
      open.push(s4, 0);
      var closest, u2, v2, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
      while (!open.empty()) {
        closest = open.pop();
        u2 = closest.value;
        cost_of_s_to_u = closest.cost;
        adjacent_nodes = graph[u2] || {};
        for (v2 in adjacent_nodes) {
          if (adjacent_nodes.hasOwnProperty(v2)) {
            cost_of_e = adjacent_nodes[v2];
            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
            cost_of_s_to_v = costs[v2];
            first_visit = typeof costs[v2] === "undefined";
            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
              costs[v2] = cost_of_s_to_u_plus_cost_of_e;
              open.push(v2, cost_of_s_to_u_plus_cost_of_e);
              predecessors[v2] = u2;
            }
          }
        }
      }
      if (typeof d2 !== "undefined" && typeof costs[d2] === "undefined") {
        var msg = ["Could not find a path from ", s4, " to ", d2, "."].join("");
        throw new Error(msg);
      }
      return predecessors;
    },
    extract_shortest_path_from_predecessor_list: function(predecessors, d2) {
      var nodes = [];
      var u2 = d2;
      while (u2) {
        nodes.push(u2);
        predecessors[u2];
        u2 = predecessors[u2];
      }
      nodes.reverse();
      return nodes;
    },
    find_path: function(graph, s4, d2) {
      var predecessors = dijkstra2.single_source_shortest_paths(graph, s4, d2);
      return dijkstra2.extract_shortest_path_from_predecessor_list(
        predecessors,
        d2
      );
    },
    /**
     * A very naive priority queue implementation.
     */
    PriorityQueue: {
      make: function(opts) {
        var T2 = dijkstra2.PriorityQueue, t2 = {}, key2;
        opts = opts || {};
        for (key2 in T2) {
          if (T2.hasOwnProperty(key2)) {
            t2[key2] = T2[key2];
          }
        }
        t2.queue = [];
        t2.sorter = opts.sorter || T2.default_sorter;
        return t2;
      },
      default_sorter: function(a2, b3) {
        return a2.cost - b3.cost;
      },
      /**
       * Add a new item to the queue and ensure the highest priority element
       * is at the front of the queue.
       */
      push: function(value, cost) {
        var item = { value, cost };
        this.queue.push(item);
        this.queue.sort(this.sorter);
      },
      /**
       * Return the highest priority element in the queue.
       */
      pop: function() {
        return this.queue.shift();
      },
      empty: function() {
        return this.queue.length === 0;
      }
    }
  };
  {
    module.exports = dijkstra2;
  }
})(dijkstra);
var dijkstraExports = dijkstra.exports;
(function(exports) {
  const Mode2 = mode;
  const NumericData2 = numericData;
  const AlphanumericData2 = alphanumericData;
  const ByteData2 = byteData;
  const KanjiData2 = kanjiData;
  const Regex = regex;
  const Utils2 = utils$2;
  const dijkstra2 = dijkstraExports;
  function getStringByteLength(str) {
    return unescape(encodeURIComponent(str)).length;
  }
  function getSegments(regex2, mode2, str) {
    const segments2 = [];
    let result;
    while ((result = regex2.exec(str)) !== null) {
      segments2.push({
        data: result[0],
        index: result.index,
        mode: mode2,
        length: result[0].length
      });
    }
    return segments2;
  }
  function getSegmentsFromString(dataStr) {
    const numSegs = getSegments(Regex.NUMERIC, Mode2.NUMERIC, dataStr);
    const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode2.ALPHANUMERIC, dataStr);
    let byteSegs;
    let kanjiSegs;
    if (Utils2.isKanjiModeEnabled()) {
      byteSegs = getSegments(Regex.BYTE, Mode2.BYTE, dataStr);
      kanjiSegs = getSegments(Regex.KANJI, Mode2.KANJI, dataStr);
    } else {
      byteSegs = getSegments(Regex.BYTE_KANJI, Mode2.BYTE, dataStr);
      kanjiSegs = [];
    }
    const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
    return segs.sort(function(s1, s22) {
      return s1.index - s22.index;
    }).map(function(obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      };
    });
  }
  function getSegmentBitsLength(length2, mode2) {
    switch (mode2) {
      case Mode2.NUMERIC:
        return NumericData2.getBitsLength(length2);
      case Mode2.ALPHANUMERIC:
        return AlphanumericData2.getBitsLength(length2);
      case Mode2.KANJI:
        return KanjiData2.getBitsLength(length2);
      case Mode2.BYTE:
        return ByteData2.getBitsLength(length2);
    }
  }
  function mergeSegments(segs) {
    return segs.reduce(function(acc, curr) {
      const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
      if (prevSeg && prevSeg.mode === curr.mode) {
        acc[acc.length - 1].data += curr.data;
        return acc;
      }
      acc.push(curr);
      return acc;
    }, []);
  }
  function buildNodes(segs) {
    const nodes = [];
    for (let i3 = 0; i3 < segs.length; i3++) {
      const seg = segs[i3];
      switch (seg.mode) {
        case Mode2.NUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.ALPHANUMERIC, length: seg.length },
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.ALPHANUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.KANJI:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
          break;
        case Mode2.BYTE:
          nodes.push([
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
      }
    }
    return nodes;
  }
  function buildGraph(nodes, version2) {
    const table = {};
    const graph = { start: {} };
    let prevNodeIds = ["start"];
    for (let i3 = 0; i3 < nodes.length; i3++) {
      const nodeGroup = nodes[i3];
      const currentNodeIds = [];
      for (let j2 = 0; j2 < nodeGroup.length; j2++) {
        const node2 = nodeGroup[j2];
        const key2 = "" + i3 + j2;
        currentNodeIds.push(key2);
        table[key2] = { node: node2, lastCount: 0 };
        graph[key2] = {};
        for (let n4 = 0; n4 < prevNodeIds.length; n4++) {
          const prevNodeId = prevNodeIds[n4];
          if (table[prevNodeId] && table[prevNodeId].node.mode === node2.mode) {
            graph[prevNodeId][key2] = getSegmentBitsLength(table[prevNodeId].lastCount + node2.length, node2.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node2.mode);
            table[prevNodeId].lastCount += node2.length;
          } else {
            if (table[prevNodeId])
              table[prevNodeId].lastCount = node2.length;
            graph[prevNodeId][key2] = getSegmentBitsLength(node2.length, node2.mode) + 4 + Mode2.getCharCountIndicator(node2.mode, version2);
          }
        }
      }
      prevNodeIds = currentNodeIds;
    }
    for (let n4 = 0; n4 < prevNodeIds.length; n4++) {
      graph[prevNodeIds[n4]].end = 0;
    }
    return { map: graph, table };
  }
  function buildSingleSegment(data2, modesHint) {
    let mode2;
    const bestMode = Mode2.getBestModeForData(data2);
    mode2 = Mode2.from(modesHint, bestMode);
    if (mode2 !== Mode2.BYTE && mode2.bit < bestMode.bit) {
      throw new Error('"' + data2 + '" cannot be encoded with mode ' + Mode2.toString(mode2) + ".\n Suggested mode is: " + Mode2.toString(bestMode));
    }
    if (mode2 === Mode2.KANJI && !Utils2.isKanjiModeEnabled()) {
      mode2 = Mode2.BYTE;
    }
    switch (mode2) {
      case Mode2.NUMERIC:
        return new NumericData2(data2);
      case Mode2.ALPHANUMERIC:
        return new AlphanumericData2(data2);
      case Mode2.KANJI:
        return new KanjiData2(data2);
      case Mode2.BYTE:
        return new ByteData2(data2);
    }
  }
  exports.fromArray = function fromArray(array) {
    return array.reduce(function(acc, seg) {
      if (typeof seg === "string") {
        acc.push(buildSingleSegment(seg, null));
      } else if (seg.data) {
        acc.push(buildSingleSegment(seg.data, seg.mode));
      }
      return acc;
    }, []);
  };
  exports.fromString = function fromString2(data2, version2) {
    const segs = getSegmentsFromString(data2, Utils2.isKanjiModeEnabled());
    const nodes = buildNodes(segs);
    const graph = buildGraph(nodes, version2);
    const path = dijkstra2.find_path(graph.map, "start", "end");
    const optimizedSegs = [];
    for (let i3 = 1; i3 < path.length - 1; i3++) {
      optimizedSegs.push(graph.table[path[i3]].node);
    }
    return exports.fromArray(mergeSegments(optimizedSegs));
  };
  exports.rawSplit = function rawSplit(data2) {
    return exports.fromArray(
      getSegmentsFromString(data2, Utils2.isKanjiModeEnabled())
    );
  };
})(segments);
const Utils$1 = utils$2;
const ECLevel = errorCorrectionLevel;
const BitBuffer = bitBuffer;
const BitMatrix = bitMatrix;
const AlignmentPattern = alignmentPattern;
const FinderPattern = finderPattern;
const MaskPattern = maskPattern;
const ECCode = errorCorrectionCode;
const ReedSolomonEncoder = reedSolomonEncoder;
const Version = version;
const FormatInfo = formatInfo;
const Mode = mode;
const Segments = segments;
function setupFinderPattern(matrix, version2) {
  const size2 = matrix.size;
  const pos = FinderPattern.getPositions(version2);
  for (let i3 = 0; i3 < pos.length; i3++) {
    const row = pos[i3][0];
    const col = pos[i3][1];
    for (let r2 = -1; r2 <= 7; r2++) {
      if (row + r2 <= -1 || size2 <= row + r2)
        continue;
      for (let c2 = -1; c2 <= 7; c2++) {
        if (col + c2 <= -1 || size2 <= col + c2)
          continue;
        if (r2 >= 0 && r2 <= 6 && (c2 === 0 || c2 === 6) || c2 >= 0 && c2 <= 6 && (r2 === 0 || r2 === 6) || r2 >= 2 && r2 <= 4 && c2 >= 2 && c2 <= 4) {
          matrix.set(row + r2, col + c2, true, true);
        } else {
          matrix.set(row + r2, col + c2, false, true);
        }
      }
    }
  }
}
function setupTimingPattern(matrix) {
  const size2 = matrix.size;
  for (let r2 = 8; r2 < size2 - 8; r2++) {
    const value = r2 % 2 === 0;
    matrix.set(r2, 6, value, true);
    matrix.set(6, r2, value, true);
  }
}
function setupAlignmentPattern(matrix, version2) {
  const pos = AlignmentPattern.getPositions(version2);
  for (let i3 = 0; i3 < pos.length; i3++) {
    const row = pos[i3][0];
    const col = pos[i3][1];
    for (let r2 = -2; r2 <= 2; r2++) {
      for (let c2 = -2; c2 <= 2; c2++) {
        if (r2 === -2 || r2 === 2 || c2 === -2 || c2 === 2 || r2 === 0 && c2 === 0) {
          matrix.set(row + r2, col + c2, true, true);
        } else {
          matrix.set(row + r2, col + c2, false, true);
        }
      }
    }
  }
}
function setupVersionInfo(matrix, version2) {
  const size2 = matrix.size;
  const bits = Version.getEncodedBits(version2);
  let row, col, mod;
  for (let i3 = 0; i3 < 18; i3++) {
    row = Math.floor(i3 / 3);
    col = i3 % 3 + size2 - 8 - 3;
    mod = (bits >> i3 & 1) === 1;
    matrix.set(row, col, mod, true);
    matrix.set(col, row, mod, true);
  }
}
function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
  const size2 = matrix.size;
  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
  let i3, mod;
  for (i3 = 0; i3 < 15; i3++) {
    mod = (bits >> i3 & 1) === 1;
    if (i3 < 6) {
      matrix.set(i3, 8, mod, true);
    } else if (i3 < 8) {
      matrix.set(i3 + 1, 8, mod, true);
    } else {
      matrix.set(size2 - 15 + i3, 8, mod, true);
    }
    if (i3 < 8) {
      matrix.set(8, size2 - i3 - 1, mod, true);
    } else if (i3 < 9) {
      matrix.set(8, 15 - i3 - 1 + 1, mod, true);
    } else {
      matrix.set(8, 15 - i3 - 1, mod, true);
    }
  }
  matrix.set(size2 - 8, 8, 1, true);
}
function setupData(matrix, data2) {
  const size2 = matrix.size;
  let inc = -1;
  let row = size2 - 1;
  let bitIndex = 7;
  let byteIndex = 0;
  for (let col = size2 - 1; col > 0; col -= 2) {
    if (col === 6)
      col--;
    while (true) {
      for (let c2 = 0; c2 < 2; c2++) {
        if (!matrix.isReserved(row, col - c2)) {
          let dark2 = false;
          if (byteIndex < data2.length) {
            dark2 = (data2[byteIndex] >>> bitIndex & 1) === 1;
          }
          matrix.set(row, col - c2, dark2);
          bitIndex--;
          if (bitIndex === -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row += inc;
      if (row < 0 || size2 <= row) {
        row -= inc;
        inc = -inc;
        break;
      }
    }
  }
}
function createData(version2, errorCorrectionLevel2, segments2) {
  const buffer2 = new BitBuffer();
  segments2.forEach(function(data2) {
    buffer2.put(data2.mode.bit, 4);
    buffer2.put(data2.getLength(), Mode.getCharCountIndicator(data2.mode, version2));
    data2.write(buffer2);
  });
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
  if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer2.put(0, 4);
  }
  while (buffer2.getLengthInBits() % 8 !== 0) {
    buffer2.putBit(0);
  }
  const remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
  for (let i3 = 0; i3 < remainingByte; i3++) {
    buffer2.put(i3 % 2 ? 17 : 236, 8);
  }
  return createCodewords(buffer2, version2, errorCorrectionLevel2);
}
function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewords = totalCodewords - ecTotalCodewords;
  const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
  const blocksInGroup2 = totalCodewords % ecTotalBlocks;
  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
  const rs = new ReedSolomonEncoder(ecCount);
  let offset = 0;
  const dcData = new Array(ecTotalBlocks);
  const ecData = new Array(ecTotalBlocks);
  let maxDataSize = 0;
  const buffer2 = new Uint8Array(bitBuffer2.buffer);
  for (let b3 = 0; b3 < ecTotalBlocks; b3++) {
    const dataSize = b3 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
    dcData[b3] = buffer2.slice(offset, offset + dataSize);
    ecData[b3] = rs.encode(dcData[b3]);
    offset += dataSize;
    maxDataSize = Math.max(maxDataSize, dataSize);
  }
  const data2 = new Uint8Array(totalCodewords);
  let index2 = 0;
  let i3, r2;
  for (i3 = 0; i3 < maxDataSize; i3++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      if (i3 < dcData[r2].length) {
        data2[index2++] = dcData[r2][i3];
      }
    }
  }
  for (i3 = 0; i3 < ecCount; i3++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      data2[index2++] = ecData[r2][i3];
    }
  }
  return data2;
}
function createSymbol(data2, version2, errorCorrectionLevel2, maskPattern2) {
  let segments2;
  if (Array.isArray(data2)) {
    segments2 = Segments.fromArray(data2);
  } else if (typeof data2 === "string") {
    let estimatedVersion = version2;
    if (!estimatedVersion) {
      const rawSegments = Segments.rawSplit(data2);
      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel2);
    }
    segments2 = Segments.fromString(data2, estimatedVersion || 40);
  } else {
    throw new Error("Invalid data");
  }
  const bestVersion = Version.getBestVersionForData(segments2, errorCorrectionLevel2);
  if (!bestVersion) {
    throw new Error("The amount of data is too big to be stored in a QR Code");
  }
  if (!version2) {
    version2 = bestVersion;
  } else if (version2 < bestVersion) {
    throw new Error(
      "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
    );
  }
  const dataBits = createData(version2, errorCorrectionLevel2, segments2);
  const moduleCount = Utils$1.getSymbolSize(version2);
  const modules = new BitMatrix(moduleCount);
  setupFinderPattern(modules, version2);
  setupTimingPattern(modules);
  setupAlignmentPattern(modules, version2);
  setupFormatInfo(modules, errorCorrectionLevel2, 0);
  if (version2 >= 7) {
    setupVersionInfo(modules, version2);
  }
  setupData(modules, dataBits);
  if (isNaN(maskPattern2)) {
    maskPattern2 = MaskPattern.getBestMask(
      modules,
      setupFormatInfo.bind(null, modules, errorCorrectionLevel2)
    );
  }
  MaskPattern.applyMask(maskPattern2, modules);
  setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
  return {
    modules,
    version: version2,
    errorCorrectionLevel: errorCorrectionLevel2,
    maskPattern: maskPattern2,
    segments: segments2
  };
}
qrcode.create = function create2(data2, options) {
  if (typeof data2 === "undefined" || data2 === "") {
    throw new Error("No input text");
  }
  let errorCorrectionLevel2 = ECLevel.M;
  let version2;
  let mask;
  if (typeof options !== "undefined") {
    errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
    version2 = Version.from(options.version);
    mask = MaskPattern.from(options.maskPattern);
    if (options.toSJISFunc) {
      Utils$1.setToSJISFunction(options.toSJISFunc);
    }
  }
  return createSymbol(data2, version2, errorCorrectionLevel2, mask);
};
var canvas = {};
var utils$1 = {};
(function(exports) {
  function hex2rgba(hex) {
    if (typeof hex === "number") {
      hex = hex.toString();
    }
    if (typeof hex !== "string") {
      throw new Error("Color should be defined as hex string");
    }
    let hexCode = hex.slice().replace("#", "").split("");
    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
      throw new Error("Invalid hex color: " + hex);
    }
    if (hexCode.length === 3 || hexCode.length === 4) {
      hexCode = Array.prototype.concat.apply([], hexCode.map(function(c2) {
        return [c2, c2];
      }));
    }
    if (hexCode.length === 6)
      hexCode.push("F", "F");
    const hexValue2 = parseInt(hexCode.join(""), 16);
    return {
      r: hexValue2 >> 24 & 255,
      g: hexValue2 >> 16 & 255,
      b: hexValue2 >> 8 & 255,
      a: hexValue2 & 255,
      hex: "#" + hexCode.slice(0, 6).join("")
    };
  }
  exports.getOptions = function getOptions(options) {
    if (!options)
      options = {};
    if (!options.color)
      options.color = {};
    const margin2 = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
    const width2 = options.width && options.width >= 21 ? options.width : void 0;
    const scale = options.scale || 4;
    return {
      width: width2,
      scale: width2 ? 4 : scale,
      margin: margin2,
      color: {
        dark: hex2rgba(options.color.dark || "#000000ff"),
        light: hex2rgba(options.color.light || "#ffffffff")
      },
      type: options.type,
      rendererOpts: options.rendererOpts || {}
    };
  };
  exports.getScale = function getScale2(qrSize, opts) {
    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
  };
  exports.getImageWidth = function getImageWidth(qrSize, opts) {
    const scale = exports.getScale(qrSize, opts);
    return Math.floor((qrSize + opts.margin * 2) * scale);
  };
  exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
    const size2 = qr.modules.size;
    const data2 = qr.modules.data;
    const scale = exports.getScale(size2, opts);
    const symbolSize = Math.floor((size2 + opts.margin * 2) * scale);
    const scaledMargin = opts.margin * scale;
    const palette = [opts.color.light, opts.color.dark];
    for (let i3 = 0; i3 < symbolSize; i3++) {
      for (let j2 = 0; j2 < symbolSize; j2++) {
        let posDst = (i3 * symbolSize + j2) * 4;
        let pxColor = opts.color.light;
        if (i3 >= scaledMargin && j2 >= scaledMargin && i3 < symbolSize - scaledMargin && j2 < symbolSize - scaledMargin) {
          const iSrc = Math.floor((i3 - scaledMargin) / scale);
          const jSrc = Math.floor((j2 - scaledMargin) / scale);
          pxColor = palette[data2[iSrc * size2 + jSrc] ? 1 : 0];
        }
        imgData[posDst++] = pxColor.r;
        imgData[posDst++] = pxColor.g;
        imgData[posDst++] = pxColor.b;
        imgData[posDst] = pxColor.a;
      }
    }
  };
})(utils$1);
(function(exports) {
  const Utils2 = utils$1;
  function clearCanvas(ctx, canvas2, size2) {
    ctx.clearRect(0, 0, canvas2.width, canvas2.height);
    if (!canvas2.style)
      canvas2.style = {};
    canvas2.height = size2;
    canvas2.width = size2;
    canvas2.style.height = size2 + "px";
    canvas2.style.width = size2 + "px";
  }
  function getCanvasElement() {
    try {
      return document.createElement("canvas");
    } catch (e2) {
      throw new Error("You need to specify a canvas element");
    }
  }
  exports.render = function render2(qrData, canvas2, options) {
    let opts = options;
    let canvasEl = canvas2;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!canvas2) {
      canvasEl = getCanvasElement();
    }
    opts = Utils2.getOptions(opts);
    const size2 = Utils2.getImageWidth(qrData.modules.size, opts);
    const ctx = canvasEl.getContext("2d");
    const image = ctx.createImageData(size2, size2);
    Utils2.qrToImageData(image.data, qrData, opts);
    clearCanvas(ctx, canvasEl, size2);
    ctx.putImageData(image, 0, 0);
    return canvasEl;
  };
  exports.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
    let opts = options;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!opts)
      opts = {};
    const canvasEl = exports.render(qrData, canvas2, opts);
    const type = opts.type || "image/png";
    const rendererOpts = opts.rendererOpts || {};
    return canvasEl.toDataURL(type, rendererOpts.quality);
  };
})(canvas);
var svgTag = {};
const Utils = utils$1;
function getColorAttrib(color2, attrib) {
  const alpha2 = color2.a / 255;
  const str = attrib + '="' + color2.hex + '"';
  return alpha2 < 1 ? str + " " + attrib + '-opacity="' + alpha2.toFixed(2).slice(1) + '"' : str;
}
function svgCmd(cmd, x2, y2) {
  let str = cmd + x2;
  if (typeof y2 !== "undefined")
    str += " " + y2;
  return str;
}
function qrToPath(data2, size2, margin2) {
  let path = "";
  let moveBy = 0;
  let newRow = false;
  let lineLength = 0;
  for (let i3 = 0; i3 < data2.length; i3++) {
    const col = Math.floor(i3 % size2);
    const row = Math.floor(i3 / size2);
    if (!col && !newRow)
      newRow = true;
    if (data2[i3]) {
      lineLength++;
      if (!(i3 > 0 && col > 0 && data2[i3 - 1])) {
        path += newRow ? svgCmd("M", col + margin2, 0.5 + row + margin2) : svgCmd("m", moveBy, 0);
        moveBy = 0;
        newRow = false;
      }
      if (!(col + 1 < size2 && data2[i3 + 1])) {
        path += svgCmd("h", lineLength);
        lineLength = 0;
      }
    } else {
      moveBy++;
    }
  }
  return path;
}
svgTag.render = function render(qrData, options, cb2) {
  const opts = Utils.getOptions(options);
  const size2 = qrData.modules.size;
  const data2 = qrData.modules.data;
  const qrcodesize = size2 + opts.margin * 2;
  const bg2 = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
  const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data2, size2, opts.margin) + '"/>';
  const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
  const width2 = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
  const svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width2 + viewBox + ' shape-rendering="crispEdges">' + bg2 + path + "</svg>\n";
  if (typeof cb2 === "function") {
    cb2(null, svgTag2);
  }
  return svgTag2;
};
const canPromise = canPromise$1;
const QRCode = qrcode;
const CanvasRenderer = canvas;
const SvgRenderer = svgTag;
function renderCanvas(renderFunc, canvas2, text, opts, cb2) {
  const args = [].slice.call(arguments, 1);
  const argsNum = args.length;
  const isLastArgCb = typeof args[argsNum - 1] === "function";
  if (!isLastArgCb && !canPromise()) {
    throw new Error("Callback required as last argument");
  }
  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 2) {
      cb2 = text;
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 3) {
      if (canvas2.getContext && typeof cb2 === "undefined") {
        cb2 = opts;
        opts = void 0;
      } else {
        cb2 = opts;
        opts = text;
        text = canvas2;
        canvas2 = void 0;
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 1) {
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 2 && !canvas2.getContext) {
      opts = text;
      text = canvas2;
      canvas2 = void 0;
    }
    return new Promise(function(resolve, reject) {
      try {
        const data2 = QRCode.create(text, opts);
        resolve(renderFunc(data2, canvas2, opts));
      } catch (e2) {
        reject(e2);
      }
    });
  }
  try {
    const data2 = QRCode.create(text, opts);
    cb2(null, renderFunc(data2, canvas2, opts));
  } catch (e2) {
    cb2(e2);
  }
}
browser$1.create = QRCode.create;
browser$1.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
browser$1.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
browser$1.toString = renderCanvas.bind(null, function(data2, _2, opts) {
  return SvgRenderer.render(data2, opts);
});
const CONNECTING_ERROR_MARGIN = 0.1;
const CIRCLE_SIZE_MODIFIER = 2.5;
const QRCODE_MATRIX_MARGIN = 7;
function isAdjecentDots(cy, otherCy, cellSize) {
  if (cy === otherCy) {
    return false;
  }
  const diff = cy - otherCy < 0 ? otherCy - cy : cy - otherCy;
  return diff <= cellSize + CONNECTING_ERROR_MARGIN;
}
function getMatrix(value, errorCorrectionLevel2) {
  const arr = Array.prototype.slice.call(browser$1.create(value, { errorCorrectionLevel: errorCorrectionLevel2 }).modules.data, 0);
  const sqrt2 = Math.sqrt(arr.length);
  return arr.reduce((rows, key2, index2) => (index2 % sqrt2 === 0 ? rows.push([key2]) : rows[rows.length - 1].push(key2)) && rows, []);
}
const QrCodeUtil = {
  generate(uri, size2, logoSize) {
    const dotColor = "#141414";
    const edgeColor = "transparent";
    const strokeWidth = 5;
    const dots = [];
    const matrix = getMatrix(uri, "Q");
    const cellSize = size2 / matrix.length;
    const qrList = [
      { x: 0, y: 0 },
      { x: 1, y: 0 },
      { x: 0, y: 1 }
    ];
    qrList.forEach(({ x: x2, y: y2 }) => {
      const x1 = (matrix.length - QRCODE_MATRIX_MARGIN) * cellSize * x2;
      const y1 = (matrix.length - QRCODE_MATRIX_MARGIN) * cellSize * y2;
      const borderRadius2 = 0.45;
      for (let i3 = 0; i3 < qrList.length; i3 += 1) {
        const dotSize = cellSize * (QRCODE_MATRIX_MARGIN - i3 * 2);
        dots.push(b$1`
            <rect
              fill=${i3 === 2 ? dotColor : edgeColor}
              width=${i3 === 0 ? dotSize - strokeWidth : dotSize}
              rx= ${i3 === 0 ? (dotSize - strokeWidth) * borderRadius2 : dotSize * borderRadius2}
              ry= ${i3 === 0 ? (dotSize - strokeWidth) * borderRadius2 : dotSize * borderRadius2}
              stroke=${dotColor}
              stroke-width=${i3 === 0 ? strokeWidth : 0}
              height=${i3 === 0 ? dotSize - strokeWidth : dotSize}
              x= ${i3 === 0 ? y1 + cellSize * i3 + strokeWidth / 2 : y1 + cellSize * i3}
              y= ${i3 === 0 ? x1 + cellSize * i3 + strokeWidth / 2 : x1 + cellSize * i3}
            />
          `);
      }
    });
    const clearArenaSize = Math.floor((logoSize + 25) / cellSize);
    const matrixMiddleStart = matrix.length / 2 - clearArenaSize / 2;
    const matrixMiddleEnd = matrix.length / 2 + clearArenaSize / 2 - 1;
    const circles = [];
    matrix.forEach((row, i3) => {
      row.forEach((_2, j2) => {
        if (matrix[i3][j2]) {
          if (!(i3 < QRCODE_MATRIX_MARGIN && j2 < QRCODE_MATRIX_MARGIN || i3 > matrix.length - (QRCODE_MATRIX_MARGIN + 1) && j2 < QRCODE_MATRIX_MARGIN || i3 < QRCODE_MATRIX_MARGIN && j2 > matrix.length - (QRCODE_MATRIX_MARGIN + 1))) {
            if (!(i3 > matrixMiddleStart && i3 < matrixMiddleEnd && j2 > matrixMiddleStart && j2 < matrixMiddleEnd)) {
              const cx = i3 * cellSize + cellSize / 2;
              const cy = j2 * cellSize + cellSize / 2;
              circles.push([cx, cy]);
            }
          }
        }
      });
    });
    const circlesToConnect = {};
    circles.forEach(([cx, cy]) => {
      if (circlesToConnect[cx]) {
        circlesToConnect[cx]?.push(cy);
      } else {
        circlesToConnect[cx] = [cy];
      }
    });
    Object.entries(circlesToConnect).map(([cx, cys]) => {
      const newCys = cys.filter((cy) => cys.every((otherCy) => !isAdjecentDots(cy, otherCy, cellSize)));
      return [Number(cx), newCys];
    }).forEach(([cx, cys]) => {
      cys.forEach((cy) => {
        dots.push(b$1`<circle cx=${cx} cy=${cy} fill=${dotColor} r=${cellSize / CIRCLE_SIZE_MODIFIER} />`);
      });
    });
    Object.entries(circlesToConnect).filter(([_2, cys]) => cys.length > 1).map(([cx, cys]) => {
      const newCys = cys.filter((cy) => cys.some((otherCy) => isAdjecentDots(cy, otherCy, cellSize)));
      return [Number(cx), newCys];
    }).map(([cx, cys]) => {
      cys.sort((a2, b3) => a2 < b3 ? -1 : 1);
      const groups = [];
      for (const cy of cys) {
        const group = groups.find((item) => item.some((otherCy) => isAdjecentDots(cy, otherCy, cellSize)));
        if (group) {
          group.push(cy);
        } else {
          groups.push([cy]);
        }
      }
      return [cx, groups.map((item) => [item[0], item[item.length - 1]])];
    }).forEach(([cx, groups]) => {
      groups.forEach(([y1, y2]) => {
        dots.push(b$1`
              <line
                x1=${cx}
                x2=${cx}
                y1=${y1}
                y2=${y2}
                stroke=${dotColor}
                stroke-width=${cellSize / (CIRCLE_SIZE_MODIFIER / 2)}
                stroke-linecap="round"
              />
            `);
      });
    });
    return dots;
  }
};
const styles$z = i$8`
  :host {
    position: relative;
    user-select: none;
    display: block;
    overflow: hidden;
    aspect-ratio: 1 / 1;
    width: var(--local-size);
  }

  :host([data-theme='dark']) {
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px);
    background-color: var(--wui-color-inverse-100);
    padding: var(--wui-spacing-l);
  }

  :host([data-theme='light']) {
    box-shadow: 0 0 0 1px var(--wui-color-bg-125);
    background-color: var(--wui-color-bg-125);
  }

  svg:first-child,
  wui-image,
  wui-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateY(-50%) translateX(-50%);
  }

  wui-image {
    width: 25%;
    height: 25%;
    border-radius: var(--wui-border-radius-xs);
  }

  wui-icon {
    width: 100%;
    height: 100%;
    color: #3396ff !important;
    transform: translateY(-50%) translateX(-50%) scale(0.25);
  }
`;
var __decorate$S = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiQrCode = class WuiQrCode2 extends s$5 {
  constructor() {
    super(...arguments);
    this.uri = "";
    this.size = 0;
    this.theme = "dark";
    this.imageSrc = void 0;
    this.alt = void 0;
  }
  render() {
    this.dataset["theme"] = this.theme;
    this.style.cssText = `--local-size: ${this.size}px`;
    return x$1`${this.templateVisual()} ${this.templateSvg()}`;
  }
  templateSvg() {
    const size2 = this.theme === "light" ? this.size : this.size - 16 * 2;
    return b$1`
      <svg height=${size2} width=${size2}>
        ${QrCodeUtil.generate(this.uri, size2, size2 / 4)}
      </svg>
    `;
  }
  templateVisual() {
    if (this.imageSrc) {
      return x$1`<wui-image src=${this.imageSrc} alt=${this.alt ?? "logo"}></wui-image>`;
    }
    return x$1`<wui-icon size="inherit" color="inherit" name="walletConnect"></wui-icon>`;
  }
};
WuiQrCode.styles = [resetStyles, styles$z];
__decorate$S([
  n$8()
], WuiQrCode.prototype, "uri", void 0);
__decorate$S([
  n$8({ type: Number })
], WuiQrCode.prototype, "size", void 0);
__decorate$S([
  n$8()
], WuiQrCode.prototype, "theme", void 0);
__decorate$S([
  n$8()
], WuiQrCode.prototype, "imageSrc", void 0);
__decorate$S([
  n$8()
], WuiQrCode.prototype, "alt", void 0);
WuiQrCode = __decorate$S([
  customElement("wui-qr-code")
], WuiQrCode);
const styles$y = i$8`
  :host {
    position: relative;
    display: inline-block;
    width: 100%;
  }
`;
var __decorate$R = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiSearchBar = class WuiSearchBar2 extends s$5 {
  constructor() {
    super(...arguments);
    this.inputComponentRef = e$5();
  }
  render() {
    return x$1`
      <wui-input-text
        ${n$6(this.inputComponentRef)}
        placeholder="Search wallet"
        icon="search"
        type="search"
        enterKeyHint="search"
        size="sm"
      >
        <wui-input-element @click=${this.clearValue} icon="close"></wui-input-element>
      </wui-input-text>
    `;
  }
  clearValue() {
    const inputComponent = this.inputComponentRef.value;
    const inputElement = inputComponent?.inputElementRef.value;
    if (inputElement) {
      inputElement.value = "";
      inputElement.focus();
      inputElement.dispatchEvent(new Event("input"));
    }
  }
};
WuiSearchBar.styles = [resetStyles, styles$y];
WuiSearchBar = __decorate$R([
  customElement("wui-search-bar")
], WuiSearchBar);
const styles$x = i$8`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-xs);
    align-items: center;
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-color-bg-175);
    box-shadow:
      0px 14px 64px -4px rgba(0, 0, 0, 0.15),
      0px 8px 22px -6px rgba(0, 0, 0, 0.15);
  }
`;
var __decorate$Q = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiSnackbar = class WuiSnackbar2 extends s$5 {
  constructor() {
    super(...arguments);
    this.backgroundColor = "accent-100";
    this.iconColor = "accent-100";
    this.icon = "checkmark";
    this.message = "";
  }
  render() {
    return x$1`
      <wui-icon-box
        size="xs"
        iconColor=${this.iconColor}
        backgroundColor=${this.backgroundColor}
        icon=${this.icon}
      ></wui-icon-box>
      <wui-text variant="paragraph-500" color="fg-100">${this.message}</wui-text>
    `;
  }
};
WuiSnackbar.styles = [resetStyles, styles$x];
__decorate$Q([
  n$8()
], WuiSnackbar.prototype, "backgroundColor", void 0);
__decorate$Q([
  n$8()
], WuiSnackbar.prototype, "iconColor", void 0);
__decorate$Q([
  n$8()
], WuiSnackbar.prototype, "icon", void 0);
__decorate$Q([
  n$8()
], WuiSnackbar.prototype, "message", void 0);
WuiSnackbar = __decorate$Q([
  customElement("wui-snackbar")
], WuiSnackbar);
const styles$w = i$8`
  :host {
    display: inline-flex;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    padding: var(--wui-spacing-3xs);
    position: relative;
    height: 36px;
    overflow: hidden;
  }

  :host::before {
    content: '';
    position: absolute;
    pointer-events: none;
    top: 4px;
    left: 4px;
    display: block;
    width: var(--local-tab-width);
    height: 28px;
    border-radius: var(--wui-border-radius-3xl);
    background-color: var(--wui-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-002);
    transform: translateX(calc(var(--local-tab) * var(--local-tab-width)));
    transition: transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  :host([data-type='flex'])::before {
    left: 3px;
    transform: translateX(calc((var(--local-tab) * 34px) + (var(--local-tab) * 4px)));
  }

  :host([data-type='flex']) {
    display: flex;
    padding: 0px 0px 0px 12px;
    gap: 4px;
  }

  :host([data-type='flex']) > button > wui-text {
    position: absolute;
    left: 18px;
    opacity: 0;
  }

  button[data-active='true'] > wui-icon,
  button[data-active='true'] > wui-text {
    color: var(--wui-color-fg-100);
  }

  button[data-active='false'] > wui-icon,
  button[data-active='false'] > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='true']:disabled,
  button[data-active='false']:disabled {
    background-color: transparent;
    opacity: 0.5;
    cursor: not-allowed;
  }

  button[data-active='true']:disabled > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='false']:disabled > wui-text {
    color: var(--wui-color-fg-300);
  }

  button > wui-icon,
  button > wui-text {
    pointer-events: none;
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  button {
    width: var(--local-tab-width);
  }

  :host([data-type='flex']) > button {
    width: 34px;
    position: relative;
    display: flex;
    justify-content: flex-start;
  }

  button:hover:enabled,
  button:active:enabled {
    background-color: transparent !important;
  }

  button:hover:enabled > wui-icon,
  button:active:enabled > wui-icon {
    color: var(--wui-color-fg-125);
  }

  button:hover:enabled > wui-text,
  button:active:enabled > wui-text {
    color: var(--wui-color-fg-125);
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
  }
`;
var __decorate$P = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTabs = class WuiTabs2 extends s$5 {
  constructor() {
    super(...arguments);
    this.tabs = [];
    this.onTabChange = () => null;
    this.buttons = [];
    this.disabled = false;
    this.activeTab = 0;
    this.localTabWidth = "100px";
    this.isDense = false;
  }
  render() {
    this.isDense = this.tabs.length > 3;
    this.style.cssText = `
      --local-tab: ${this.activeTab};
      --local-tab-width: ${this.localTabWidth};
    `;
    this.dataset["type"] = this.isDense ? "flex" : "block";
    return this.tabs.map((tab, index2) => {
      const isActive = index2 === this.activeTab;
      return x$1`
        <button
          ?disabled=${this.disabled}
          @click=${() => this.onTabClick(index2)}
          data-active=${isActive}
        >
          <wui-icon size="xs" color="inherit" name=${tab.icon}></wui-icon>
          <wui-text variant="small-600" color="inherit"> ${tab.label} </wui-text>
        </button>
      `;
    });
  }
  firstUpdated() {
    if (this.shadowRoot && this.isDense) {
      this.buttons = [...this.shadowRoot.querySelectorAll("button")];
      setTimeout(() => {
        this.animateTabs(0, true);
      }, 0);
    }
  }
  onTabClick(index2) {
    if (this.buttons) {
      this.animateTabs(index2, false);
    }
    this.activeTab = index2;
    this.onTabChange(index2);
  }
  animateTabs(index2, initialAnimation) {
    const passiveBtn = this.buttons[this.activeTab];
    const activeBtn = this.buttons[index2];
    const passiveBtnText = passiveBtn?.querySelector("wui-text");
    const activeBtnText = activeBtn?.querySelector("wui-text");
    const activeBtnBounds = activeBtn?.getBoundingClientRect();
    const activeBtnTextBounds = activeBtnText?.getBoundingClientRect();
    if (passiveBtn && passiveBtnText && !initialAnimation && index2 !== this.activeTab) {
      passiveBtnText.animate([{ opacity: 0 }], {
        duration: 50,
        easing: "ease",
        fill: "forwards"
      });
      passiveBtn.animate([{ width: `34px` }], {
        duration: 500,
        easing: "ease",
        fill: "forwards"
      });
    }
    if (activeBtn && activeBtnBounds && activeBtnTextBounds && activeBtnText) {
      if (index2 !== this.activeTab || initialAnimation) {
        this.localTabWidth = `${Math.round(activeBtnBounds.width + activeBtnTextBounds.width) + 6}px`;
        activeBtn.animate([{ width: `${activeBtnBounds.width + activeBtnTextBounds.width}px` }], {
          duration: initialAnimation ? 0 : 500,
          fill: "forwards",
          easing: "ease"
        });
        activeBtnText.animate([{ opacity: 1 }], {
          duration: initialAnimation ? 0 : 125,
          delay: initialAnimation ? 0 : 200,
          fill: "forwards",
          easing: "ease"
        });
      }
    }
  }
};
WuiTabs.styles = [resetStyles, elementStyles, styles$w];
__decorate$P([
  n$8({ type: Array })
], WuiTabs.prototype, "tabs", void 0);
__decorate$P([
  n$8()
], WuiTabs.prototype, "onTabChange", void 0);
__decorate$P([
  n$8({ type: Array })
], WuiTabs.prototype, "buttons", void 0);
__decorate$P([
  n$8({ type: Boolean })
], WuiTabs.prototype, "disabled", void 0);
__decorate$P([
  r$8()
], WuiTabs.prototype, "activeTab", void 0);
__decorate$P([
  r$8()
], WuiTabs.prototype, "localTabWidth", void 0);
__decorate$P([
  r$8()
], WuiTabs.prototype, "isDense", void 0);
WuiTabs = __decorate$P([
  customElement("wui-tabs")
], WuiTabs);
const styles$v = i$8`
  :host {
    display: block;
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    background-color: var(--wui-color-fg-100);
    color: var(--wui-color-bg-100);
    position: relative;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
  }

  wui-icon[data-placement='top'] {
    bottom: 0;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;
var __decorate$O = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTooltip = class WuiTooltip2 extends s$5 {
  constructor() {
    super(...arguments);
    this.placement = "top";
    this.message = "";
  }
  render() {
    return x$1`<wui-icon
        data-placement=${this.placement}
        color="fg-100"
        size="inherit"
        name="cursor"
      ></wui-icon>
      <wui-text color="inherit" variant="small-500">${this.message}</wui-text>`;
  }
};
WuiTooltip.styles = [resetStyles, elementStyles, styles$v];
__decorate$O([
  n$8()
], WuiTooltip.prototype, "placement", void 0);
__decorate$O([
  n$8()
], WuiTooltip.prototype, "message", void 0);
WuiTooltip = __decorate$O([
  customElement("wui-tooltip")
], WuiTooltip);
const styles$u = i$8`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--wui-icon-box-size-xl);
    height: var(--wui-icon-box-size-xl);
    box-shadow: 0 0 0 8px var(--wui-thumbnail-border);
    border-radius: var(--local-border-radius);
    overflow: hidden;
  }

  wui-icon {
    width: 32px;
    height: 32px;
  }
`;
var __decorate$N = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiVisualThumbnail = class WuiVisualThumbnail2 extends s$5 {
  render() {
    this.style.cssText = `--local-border-radius: ${this.borderRadiusFull ? "1000px" : "20px"};`;
    return x$1`${this.templateVisual()}`;
  }
  templateVisual() {
    if (this.imageSrc) {
      return x$1`<wui-image src=${this.imageSrc} alt=${this.alt ?? ""}></wui-image>`;
    }
    return x$1`<wui-icon
      data-parent-size="md"
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`;
  }
};
WuiVisualThumbnail.styles = [resetStyles, styles$u];
__decorate$N([
  n$8()
], WuiVisualThumbnail.prototype, "imageSrc", void 0);
__decorate$N([
  n$8()
], WuiVisualThumbnail.prototype, "alt", void 0);
__decorate$N([
  n$8({ type: Boolean })
], WuiVisualThumbnail.prototype, "borderRadiusFull", void 0);
WuiVisualThumbnail = __decorate$N([
  customElement("wui-visual-thumbnail")
], WuiVisualThumbnail);
const styles$t = i$8`
  :host {
    display: block;
  }

  button {
    width: 100%;
    display: block;
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    padding-left: var(--wui-spacing-s);
    padding-right: var(--wui-spacing-2l);
    border-radius: var(--wui-border-radius-s);
    background-color: var(--wui-accent-glass-015);
  }

  button:hover {
    background-color: var(--wui-accent-glass-010) !important;
  }

  button:active {
    background-color: var(--wui-accent-glass-020) !important;
  }
`;
var __decorate$M = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiNoticeCard = class WuiNoticeCard2 extends s$5 {
  constructor() {
    super(...arguments);
    this.label = "";
    this.description = "";
    this.icon = "wallet";
  }
  render() {
    return x$1`
      <button>
        <wui-flex gap="m" alignItems="center" justifyContent="space-between">
          <wui-icon-box
            size="lg"
            iconcolor="accent-100"
            backgroundcolor="accent-100"
            icon=${this.icon}
            background="transparent"
          ></wui-icon-box>

          <wui-flex flexDirection="column" gap="3xs">
            <wui-text variant="paragraph-500" color="fg-100">${this.label}</wui-text>
            <wui-text variant="small-400" color="fg-200">${this.description}</wui-text>
          </wui-flex>

          <wui-icon size="md" color="fg-200" name="chevronRight"></wui-icon>
        </wui-flex>
      </button>
    `;
  }
};
WuiNoticeCard.styles = [resetStyles, elementStyles, styles$t];
__decorate$M([
  n$8()
], WuiNoticeCard.prototype, "label", void 0);
__decorate$M([
  n$8()
], WuiNoticeCard.prototype, "description", void 0);
__decorate$M([
  n$8()
], WuiNoticeCard.prototype, "icon", void 0);
WuiNoticeCard = __decorate$M([
  customElement("wui-notice-card")
], WuiNoticeCard);
const styles$s = i$8`
  button {
    height: auto;
    position: relative;
    flex-direction: column;
    gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  .overflowedContent {
    width: 100%;
    overflow: hidden;
  }

  .overflowedContent[data-active='false']:after {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to top, var(--wui-color-bg-200), transparent);
    border-bottom-left-radius: var(--wui-border-radius-xs);
    border-bottom-right-radius: var(--wui-border-radius-xs);
  }

  .heightContent {
    max-height: 100px;
  }

  pre {
    text-align: left;
    white-space: pre-wrap;
    height: auto;
    overflow-x: auto;
    overflow-wrap: anywhere;
  }
`;
var __decorate$L = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const MAX_HEIGHT = 100;
let WuiListAccordion = class WuiListAccordion2 extends s$5 {
  constructor() {
    super(...arguments);
    this.textTitle = "";
    this.overflowedContent = "";
    this.toggled = false;
    this.enableAccordion = false;
    this.scrollElement = void 0;
    this.scrollHeightElement = 0;
  }
  firstUpdated() {
    setTimeout(() => {
      const heightElement = this.shadowRoot?.querySelector(".heightContent");
      if (heightElement) {
        this.scrollElement = heightElement;
        const scrollHeight = heightElement?.scrollHeight;
        if (scrollHeight && scrollHeight > MAX_HEIGHT) {
          this.enableAccordion = true;
          this.scrollHeightElement = scrollHeight;
          this.requestUpdate();
        }
      }
    }, 0);
  }
  render() {
    return x$1`
      <button ontouchstart @click=${() => this.onClick()}>
        <wui-flex justifyContent="space-between" alignItems="center">
          <wui-text variant="paragraph-500" color="fg-100">${this.textTitle}</wui-text>
          ${this.chevronTemplate()}
        </wui-flex>
        <div
          data-active=${this.enableAccordion ? Boolean(this.toggled) : true}
          class="overflowedContent"
        >
          <div class="heightContent">
            <wui-text variant="paragraph-400" color="fg-200">
              <pre>${this.overflowedContent}</pre>
            </wui-text>
          </div>
        </div>
      </button>
    `;
  }
  onClick() {
    const icon = this.shadowRoot?.querySelector("wui-icon");
    if (this.enableAccordion) {
      this.toggled = !this.toggled;
      this.requestUpdate();
      if (this.scrollElement) {
        this.scrollElement.animate([
          { maxHeight: this.toggled ? `${MAX_HEIGHT}px` : `${this.scrollHeightElement}px` },
          { maxHeight: this.toggled ? `${this.scrollHeightElement}px` : `${MAX_HEIGHT}px` }
        ], {
          duration: 300,
          fill: "forwards",
          easing: "ease"
        });
      }
      if (icon) {
        icon.animate([
          { transform: this.toggled ? `rotate(0deg)` : `rotate(180deg)` },
          { transform: this.toggled ? `rotate(180deg)` : `rotate(0deg)` }
        ], {
          duration: 300,
          fill: "forwards",
          easing: "ease"
        });
      }
    }
  }
  chevronTemplate() {
    if (this.enableAccordion) {
      return x$1` <wui-icon color="fg-100" size="sm" name="chevronBottom"></wui-icon>`;
    }
    return null;
  }
};
WuiListAccordion.styles = [resetStyles, elementStyles, styles$s];
__decorate$L([
  n$8()
], WuiListAccordion.prototype, "textTitle", void 0);
__decorate$L([
  n$8()
], WuiListAccordion.prototype, "overflowedContent", void 0);
WuiListAccordion = __decorate$L([
  customElement("wui-list-accordion")
], WuiListAccordion);
const styles$r = i$8`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;
var __decorate$K = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListContent = class WuiListContent2 extends s$5 {
  constructor() {
    super(...arguments);
    this.imageSrc = void 0;
    this.textTitle = "";
    this.textValue = void 0;
  }
  render() {
    return x$1`
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color=${this.textValue ? "fg-200" : "fg-100"}>
          ${this.textTitle}
        </wui-text>
        ${this.templateContent()}
      </wui-flex>
    `;
  }
  templateContent() {
    if (this.imageSrc) {
      return x$1`<wui-image src=${this.imageSrc} alt=${this.textTitle}></wui-image>`;
    } else if (this.textValue) {
      return x$1` <wui-text variant="paragraph-400" color="fg-100"> ${this.textValue} </wui-text>`;
    }
    return x$1`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
WuiListContent.styles = [resetStyles, elementStyles, styles$r];
__decorate$K([
  n$8()
], WuiListContent.prototype, "imageSrc", void 0);
__decorate$K([
  n$8()
], WuiListContent.prototype, "textTitle", void 0);
__decorate$K([
  n$8()
], WuiListContent.prototype, "textValue", void 0);
WuiListContent = __decorate$K([
  customElement("wui-list-content")
], WuiListContent);
const styles$q = i$8`
  :host {
    display: flex;
    flex-direction: column;
    gap: var(--wui-spacing-l);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;
var __decorate$J = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListWalletTransaction = class WuiListWalletTransaction2 extends s$5 {
  constructor() {
    super(...arguments);
    this.amount = "";
    this.networkCurreny = "";
    this.networkImageUrl = "";
    this.receiverAddress = "";
  }
  render() {
    return x$1`
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">Sending</wui-text>
        <wui-flex gap="xs" alignItems="center">
          <wui-text variant="paragraph-400" color="fg-100">
            ${this.amount} ${this.networkCurreny}
          </wui-text>
          ${this.templateNetworkVisual()}
        </wui-flex>
      </wui-flex>
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">To</wui-text>
        <wui-chip
          icon="externalLink"
          variant="shadeSmall"
          href=${this.receiverAddress}
          title=${this.receiverAddress}
        ></wui-chip>
      </wui-flex>
    `;
  }
  templateNetworkVisual() {
    if (this.networkImageUrl) {
      return x$1`<wui-image src=${this.networkImageUrl} alt="Network Image"></wui-image>`;
    }
    return x$1`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
WuiListWalletTransaction.styles = [resetStyles, elementStyles, styles$q];
__decorate$J([
  n$8()
], WuiListWalletTransaction.prototype, "amount", void 0);
__decorate$J([
  n$8()
], WuiListWalletTransaction.prototype, "networkCurreny", void 0);
__decorate$J([
  n$8()
], WuiListWalletTransaction.prototype, "networkImageUrl", void 0);
__decorate$J([
  n$8()
], WuiListWalletTransaction.prototype, "receiverAddress", void 0);
WuiListWalletTransaction = __decorate$J([
  customElement("wui-list-wallet-transaction")
], WuiListWalletTransaction);
const styles$p = i$8`
  :host {
    display: grid;
    width: inherit;
    height: inherit;
  }
`;
var __decorate$I = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiGrid = class WuiGrid2 extends s$5 {
  render() {
    this.style.cssText = `
      grid-template-rows: ${this.gridTemplateRows};
      grid-template-columns: ${this.gridTemplateColumns};
      justify-items: ${this.justifyItems};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      align-content: ${this.alignContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `;
    return x$1`<slot></slot>`;
  }
};
WuiGrid.styles = [resetStyles, styles$p];
__decorate$I([
  n$8()
], WuiGrid.prototype, "gridTemplateRows", void 0);
__decorate$I([
  n$8()
], WuiGrid.prototype, "gridTemplateColumns", void 0);
__decorate$I([
  n$8()
], WuiGrid.prototype, "justifyItems", void 0);
__decorate$I([
  n$8()
], WuiGrid.prototype, "alignItems", void 0);
__decorate$I([
  n$8()
], WuiGrid.prototype, "justifyContent", void 0);
__decorate$I([
  n$8()
], WuiGrid.prototype, "alignContent", void 0);
__decorate$I([
  n$8()
], WuiGrid.prototype, "columnGap", void 0);
__decorate$I([
  n$8()
], WuiGrid.prototype, "rowGap", void 0);
__decorate$I([
  n$8()
], WuiGrid.prototype, "gap", void 0);
__decorate$I([
  n$8()
], WuiGrid.prototype, "padding", void 0);
__decorate$I([
  n$8()
], WuiGrid.prototype, "margin", void 0);
WuiGrid = __decorate$I([
  customElement("wui-grid")
], WuiGrid);
const styles$o = i$8`
  :host {
    position: relative;
    display: flex;
    width: 100%;
    height: 1px;
    background-color: var(--wui-gray-glass-005);
    justify-content: center;
    align-items: center;
  }

  :host > wui-text {
    position: absolute;
    padding: 0px 10px;
    background-color: var(--wui-color-modal-bg);
  }
`;
var __decorate$H = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiSeparator = class WuiSeparator2 extends s$5 {
  constructor() {
    super(...arguments);
    this.text = "";
  }
  render() {
    return x$1`${this.template()}`;
  }
  template() {
    if (this.text) {
      return x$1`<wui-text variant="small-500" color="fg-200">${this.text}</wui-text>`;
    }
    return null;
  }
};
WuiSeparator.styles = [resetStyles, styles$o];
__decorate$H([
  n$8()
], WuiSeparator.prototype, "text", void 0);
WuiSeparator = __decorate$H([
  customElement("wui-separator")
], WuiSeparator);
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e2 = 6e4, n4 = 36e5, r2 = "millisecond", i3 = "second", s4 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f3 = "quarter", h4 = "year", d2 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M3 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e3 = ["th", "st", "nd", "rd"], n5 = t3 % 100;
      return "[" + t3 + (e3[(n5 - 20) % 10] || e3[n5] || e3[0]) + "]";
    } }, m2 = function(t3, e3, n5) {
      var r3 = String(t3);
      return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n5) + t3;
    }, v2 = { s: m2, z: function(t3) {
      var e3 = -t3.utcOffset(), n5 = Math.abs(e3), r3 = Math.floor(n5 / 60), i4 = n5 % 60;
      return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i4, 2, "0");
    }, m: function t3(e3, n5) {
      if (e3.date() < n5.date())
        return -t3(n5, e3);
      var r3 = 12 * (n5.year() - e3.year()) + (n5.month() - e3.month()), i4 = e3.clone().add(r3, c2), s5 = n5 - i4 < 0, u3 = e3.clone().add(r3 + (s5 ? -1 : 1), c2);
      return +(-(r3 + (n5 - i4) / (s5 ? i4 - u3 : u3 - i4)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c2, y: h4, w: o2, d: a2, D: d2, h: u2, m: s4, s: i3, ms: r2, Q: f3 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g2 = "en", D2 = {};
    D2[g2] = M3;
    var p2 = "$isDayjsObject", S4 = function(t3) {
      return t3 instanceof _2 || !(!t3 || !t3[p2]);
    }, w2 = function t3(e3, n5, r3) {
      var i4;
      if (!e3)
        return g2;
      if ("string" == typeof e3) {
        var s5 = e3.toLowerCase();
        D2[s5] && (i4 = s5), n5 && (D2[s5] = n5, i4 = s5);
        var u3 = e3.split("-");
        if (!i4 && u3.length > 1)
          return t3(u3[0]);
      } else {
        var a3 = e3.name;
        D2[a3] = e3, i4 = a3;
      }
      return !r3 && i4 && (g2 = i4), i4 || !r3 && g2;
    }, O2 = function(t3, e3) {
      if (S4(t3))
        return t3.clone();
      var n5 = "object" == typeof e3 ? e3 : {};
      return n5.date = t3, n5.args = arguments, new _2(n5);
    }, b3 = v2;
    b3.l = w2, b3.i = S4, b3.w = function(t3, e3) {
      return O2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _2 = function() {
      function M4(t3) {
        this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
      }
      var m3 = M4.prototype;
      return m3.parse = function(t3) {
        this.$d = function(t4) {
          var e3 = t4.date, n5 = t4.utc;
          if (null === e3)
            return /* @__PURE__ */ new Date(NaN);
          if (b3.u(e3))
            return /* @__PURE__ */ new Date();
          if (e3 instanceof Date)
            return new Date(e3);
          if ("string" == typeof e3 && !/Z$/i.test(e3)) {
            var r3 = e3.match($2);
            if (r3) {
              var i4 = r3[2] - 1 || 0, s5 = (r3[7] || "0").substring(0, 3);
              return n5 ? new Date(Date.UTC(r3[1], i4, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s5)) : new Date(r3[1], i4, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s5);
            }
          }
          return new Date(e3);
        }(t3), this.init();
      }, m3.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m3.$utils = function() {
        return b3;
      }, m3.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m3.isSame = function(t3, e3) {
        var n5 = O2(t3);
        return this.startOf(e3) <= n5 && n5 <= this.endOf(e3);
      }, m3.isAfter = function(t3, e3) {
        return O2(t3) < this.startOf(e3);
      }, m3.isBefore = function(t3, e3) {
        return this.endOf(e3) < O2(t3);
      }, m3.$g = function(t3, e3, n5) {
        return b3.u(t3) ? this[e3] : this.set(n5, t3);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t3, e3) {
        var n5 = this, r3 = !!b3.u(e3) || e3, f4 = b3.p(t3), l3 = function(t4, e4) {
          var i4 = b3.w(n5.$u ? Date.UTC(n5.$y, e4, t4) : new Date(n5.$y, e4, t4), n5);
          return r3 ? i4 : i4.endOf(a2);
        }, $3 = function(t4, e4) {
          return b3.w(n5.toDate()[t4].apply(n5.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n5);
        }, y3 = this.$W, M5 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
        switch (f4) {
          case h4:
            return r3 ? l3(1, 0) : l3(31, 11);
          case c2:
            return r3 ? l3(1, M5) : l3(0, M5 + 1);
          case o2:
            var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
            return l3(r3 ? m4 - D3 : m4 + (6 - D3), M5);
          case a2:
          case d2:
            return $3(v3 + "Hours", 0);
          case u2:
            return $3(v3 + "Minutes", 1);
          case s4:
            return $3(v3 + "Seconds", 2);
          case i3:
            return $3(v3 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m3.$set = function(t3, e3) {
        var n5, o3 = b3.p(t3), f4 = "set" + (this.$u ? "UTC" : ""), l3 = (n5 = {}, n5[a2] = f4 + "Date", n5[d2] = f4 + "Date", n5[c2] = f4 + "Month", n5[h4] = f4 + "FullYear", n5[u2] = f4 + "Hours", n5[s4] = f4 + "Minutes", n5[i3] = f4 + "Seconds", n5[r2] = f4 + "Milliseconds", n5)[o3], $3 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o3 === c2 || o3 === h4) {
          var y3 = this.clone().set(d2, 1);
          y3.$d[l3]($3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
        } else
          l3 && this.$d[l3]($3);
        return this.init(), this;
      }, m3.set = function(t3, e3) {
        return this.clone().$set(t3, e3);
      }, m3.get = function(t3) {
        return this[b3.p(t3)]();
      }, m3.add = function(r3, f4) {
        var d3, l3 = this;
        r3 = Number(r3);
        var $3 = b3.p(f4), y3 = function(t3) {
          var e3 = O2(l3);
          return b3.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
        };
        if ($3 === c2)
          return this.set(c2, this.$M + r3);
        if ($3 === h4)
          return this.set(h4, this.$y + r3);
        if ($3 === a2)
          return y3(1);
        if ($3 === o2)
          return y3(7);
        var M5 = (d3 = {}, d3[s4] = e2, d3[u2] = n4, d3[i3] = t2, d3)[$3] || 1, m4 = this.$d.getTime() + r3 * M5;
        return b3.w(m4, this);
      }, m3.subtract = function(t3, e3) {
        return this.add(-1 * t3, e3);
      }, m3.format = function(t3) {
        var e3 = this, n5 = this.$locale();
        if (!this.isValid())
          return n5.invalidDate || l2;
        var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i4 = b3.z(this), s5 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n5.weekdays, c3 = n5.months, f4 = n5.meridiem, h5 = function(t4, n6, i5, s6) {
          return t4 && (t4[n6] || t4(e3, r3)) || i5[n6].slice(0, s6);
        }, d3 = function(t4) {
          return b3.s(s5 % 12 || 12, t4, "0");
        }, $3 = f4 || function(t4, e4, n6) {
          var r4 = t4 < 12 ? "AM" : "PM";
          return n6 ? r4.toLowerCase() : r4;
        };
        return r3.replace(y2, function(t4, r4) {
          return r4 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e3.$y).slice(-2);
              case "YYYY":
                return b3.s(e3.$y, 4, "0");
              case "M":
                return a3 + 1;
              case "MM":
                return b3.s(a3 + 1, 2, "0");
              case "MMM":
                return h5(n5.monthsShort, a3, c3, 3);
              case "MMMM":
                return h5(c3, a3);
              case "D":
                return e3.$D;
              case "DD":
                return b3.s(e3.$D, 2, "0");
              case "d":
                return String(e3.$W);
              case "dd":
                return h5(n5.weekdaysMin, e3.$W, o3, 2);
              case "ddd":
                return h5(n5.weekdaysShort, e3.$W, o3, 3);
              case "dddd":
                return o3[e3.$W];
              case "H":
                return String(s5);
              case "HH":
                return b3.s(s5, 2, "0");
              case "h":
                return d3(1);
              case "hh":
                return d3(2);
              case "a":
                return $3(s5, u3, true);
              case "A":
                return $3(s5, u3, false);
              case "m":
                return String(u3);
              case "mm":
                return b3.s(u3, 2, "0");
              case "s":
                return String(e3.$s);
              case "ss":
                return b3.s(e3.$s, 2, "0");
              case "SSS":
                return b3.s(e3.$ms, 3, "0");
              case "Z":
                return i4;
            }
            return null;
          }(t4) || i4.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r3, d3, l3) {
        var $3, y3 = this, M5 = b3.p(d3), m4 = O2(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D3 = function() {
          return b3.m(y3, m4);
        };
        switch (M5) {
          case h4:
            $3 = D3() / 12;
            break;
          case c2:
            $3 = D3();
            break;
          case f3:
            $3 = D3() / 3;
            break;
          case o2:
            $3 = (g3 - v3) / 6048e5;
            break;
          case a2:
            $3 = (g3 - v3) / 864e5;
            break;
          case u2:
            $3 = g3 / n4;
            break;
          case s4:
            $3 = g3 / e2;
            break;
          case i3:
            $3 = g3 / t2;
            break;
          default:
            $3 = g3;
        }
        return l3 ? $3 : b3.a($3);
      }, m3.daysInMonth = function() {
        return this.endOf(c2).$D;
      }, m3.$locale = function() {
        return D2[this.$L];
      }, m3.locale = function(t3, e3) {
        if (!t3)
          return this.$L;
        var n5 = this.clone(), r3 = w2(t3, e3, true);
        return r3 && (n5.$L = r3), n5;
      }, m3.clone = function() {
        return b3.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M4;
    }(), k4 = _2.prototype;
    return O2.prototype = k4, [["$ms", r2], ["$s", i3], ["$m", s4], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h4], ["$D", d2]].forEach(function(t3) {
      k4[t3[1]] = function(e3) {
        return this.$g(e3, t3[0], t3[1]);
      };
    }), O2.extend = function(t3, e3) {
      return t3.$i || (t3(e3, _2, O2), t3.$i = true), O2;
    }, O2.locale = w2, O2.isDayjs = S4, O2.unix = function(t3) {
      return O2(1e3 * t3);
    }, O2.en = D2[g2], O2.Ls = D2, O2.p = {}, O2;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
var updateLocale$1 = { exports: {} };
(function(module, exports) {
  !function(e2, n4) {
    module.exports = n4();
  }(commonjsGlobal, function() {
    return function(e2, n4, t2) {
      t2.updateLocale = function(e3, n5) {
        var o2 = t2.Ls[e3];
        if (o2)
          return (n5 ? Object.keys(n5) : []).forEach(function(e4) {
            o2[e4] = n5[e4];
          }), o2;
      };
    };
  });
})(updateLocale$1);
var updateLocaleExports = updateLocale$1.exports;
const updateLocale = /* @__PURE__ */ getDefaultExportFromCjs(updateLocaleExports);
var relativeTime$1 = { exports: {} };
(function(module, exports) {
  !function(r2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    return function(r2, e2, t2) {
      r2 = r2 || {};
      var n4 = e2.prototype, o2 = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
      function i3(r3, e3, t3, o3) {
        return n4.fromToBase(r3, e3, t3, o3);
      }
      t2.en.relativeTime = o2, n4.fromToBase = function(e3, n5, i4, d3, u2) {
        for (var f3, a2, s4, l2 = i4.$locale().relativeTime || o2, h4 = r2.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], m2 = h4.length, c2 = 0; c2 < m2; c2 += 1) {
          var y2 = h4[c2];
          y2.d && (f3 = d3 ? t2(e3).diff(i4, y2.d, true) : i4.diff(e3, y2.d, true));
          var p2 = (r2.rounding || Math.round)(Math.abs(f3));
          if (s4 = f3 > 0, p2 <= y2.r || !y2.r) {
            p2 <= 1 && c2 > 0 && (y2 = h4[c2 - 1]);
            var v2 = l2[y2.l];
            u2 && (p2 = u2("" + p2)), a2 = "string" == typeof v2 ? v2.replace("%d", p2) : v2(p2, n5, y2.l, s4);
            break;
          }
        }
        if (n5)
          return a2;
        var M3 = s4 ? l2.future : l2.past;
        return "function" == typeof M3 ? M3(a2) : M3.replace("%s", a2);
      }, n4.to = function(r3, e3) {
        return i3(r3, e3, this, true);
      }, n4.from = function(r3, e3) {
        return i3(r3, e3, this);
      };
      var d2 = function(r3) {
        return r3.$u ? t2.utc() : t2();
      };
      n4.toNow = function(r3) {
        return this.to(d2(this), r3);
      }, n4.fromNow = function(r3) {
        return this.from(d2(this), r3);
      };
    };
  });
})(relativeTime$1);
var relativeTimeExports = relativeTime$1.exports;
const relativeTime = /* @__PURE__ */ getDefaultExportFromCjs(relativeTimeExports);
dayjs.extend(relativeTime);
dayjs.extend(updateLocale);
dayjs.updateLocale("en", {
  relativeTime: {
    future: "in %s",
    past: "%s ago",
    s: "%s sec",
    m: "1 min",
    mm: "%d min",
    h: "1 hr",
    hh: "%d hrs",
    d: "1 d",
    dd: "%d d",
    M: "1 mo",
    MM: "%d mo",
    y: "1 yr",
    yy: "%d yr"
  }
});
const DateUtil = {
  getYear(date = (/* @__PURE__ */ new Date()).toISOString()) {
    return dayjs(date).year();
  },
  getRelativeDateFromNow(date) {
    return dayjs(date).fromNow(true);
  }
};
const FLOAT_FIXED_VALUE = 3;
const plusTypes = ["receive", "deposit", "borrow", "claim"];
const minusTypes = ["withdraw", "repay", "burn"];
const TransactionUtil = {
  getTransactionGroupTitle(year) {
    const currentYear = DateUtil.getYear();
    const isCurrentYear = year === currentYear;
    const groupTitle = isCurrentYear ? "This Year" : year;
    return groupTitle;
  },
  getTransactionImages(transfers) {
    const [transfer, secondTransfer] = transfers;
    const isAllNFT = Boolean(transfer) && transfers?.every((item) => Boolean(item.nft_info));
    const haveMultipleTransfers = transfers?.length > 1;
    const haveTwoTransfers = transfers?.length === 2;
    if (haveTwoTransfers && !isAllNFT) {
      return [this.getTransactionImage(transfer), this.getTransactionImage(secondTransfer)];
    }
    if (haveMultipleTransfers) {
      return transfers.map((item) => this.getTransactionImage(item));
    }
    return [this.getTransactionImage(transfer)];
  },
  getTransactionImage(transfer) {
    return {
      type: TransactionUtil.getTransactionTransferTokenType(transfer),
      url: TransactionUtil.getTransactionImageURL(transfer)
    };
  },
  getTransactionImageURL(transfer) {
    let imageURL = null;
    const isNFT = Boolean(transfer?.nft_info);
    const isFungible = Boolean(transfer?.fungible_info);
    if (transfer && isNFT) {
      imageURL = transfer?.nft_info?.content?.preview?.url;
    } else if (transfer && isFungible) {
      imageURL = transfer?.fungible_info?.icon?.url;
    }
    return imageURL;
  },
  getTransactionTransferTokenType(transfer) {
    if (transfer?.fungible_info) {
      return "FUNGIBLE";
    } else if (transfer?.nft_info) {
      return "NFT";
    }
    return null;
  },
  getTransactionDescriptions(transaction) {
    const type = transaction.metadata?.operationType;
    const transfers = transaction.transfers;
    const haveTransfer = transaction.transfers?.length > 0;
    const haveMultipleTransfers = transaction.transfers?.length > 1;
    const isFungible = haveTransfer && transfers?.every((transfer) => Boolean(transfer.fungible_info));
    const [firstTransfer, secondTransfer] = transfers;
    let firstDescription = this.getTransferDescription(firstTransfer);
    let secondDescription = this.getTransferDescription(secondTransfer);
    if (!haveTransfer) {
      const isSendOrReceive = type === "send" || type === "receive";
      if (isSendOrReceive && isFungible) {
        firstDescription = UiHelperUtil.getTruncateString({
          string: transaction.metadata.sentFrom,
          charsStart: 4,
          charsEnd: 6,
          truncate: "middle"
        });
        secondDescription = UiHelperUtil.getTruncateString({
          string: transaction.metadata.sentTo,
          charsStart: 4,
          charsEnd: 6,
          truncate: "middle"
        });
        return [firstDescription, secondDescription];
      }
      return [transaction.metadata.status];
    }
    if (haveMultipleTransfers) {
      return transfers.map((item) => this.getTransferDescription(item));
    }
    let prefix2 = "";
    if (plusTypes.includes(type)) {
      prefix2 = "+";
    } else if (minusTypes.includes(type)) {
      prefix2 = "-";
    }
    firstDescription = prefix2.concat(firstDescription);
    return [firstDescription];
  },
  getTransferDescription(transfer) {
    let description2 = "";
    if (!transfer) {
      return description2;
    }
    if (transfer?.nft_info) {
      description2 = transfer?.nft_info?.name || "-";
    } else if (transfer?.fungible_info) {
      description2 = this.getFungibleTransferDescription(transfer) || "-";
    }
    return description2;
  },
  getFungibleTransferDescription(transfer) {
    if (!transfer) {
      return null;
    }
    const quantity = this.getQuantityFixedValue(transfer?.quantity.numeric);
    const description2 = [quantity, transfer?.fungible_info?.symbol].join(" ").trim();
    return description2;
  },
  getQuantityFixedValue(value) {
    if (!value) {
      return null;
    }
    const parsedValue = parseFloat(value);
    return parsedValue.toFixed(FLOAT_FIXED_VALUE);
  }
};
const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TransactionUtil,
  UiHelperUtil,
  get WuiAccountButton() {
    return WuiAccountButton;
  },
  get WuiAllWalletsImage() {
    return WuiAllWalletsImage;
  },
  get WuiAvatar() {
    return WuiAvatar;
  },
  get WuiButton() {
    return WuiButton;
  },
  get WuiCard() {
    return WuiCard;
  },
  get WuiCardSelect() {
    return WuiCardSelect;
  },
  get WuiCardSelectLoader() {
    return WuiCardSelectLoader;
  },
  get WuiChip() {
    return WuiChip;
  },
  get WuiConnectButton() {
    return WuiConnectButton;
  },
  get WuiCtaButton() {
    return WuiCtaButton;
  },
  get WuiEmailInput() {
    return WuiEmailInput;
  },
  get WuiFlex() {
    return WuiFlex;
  },
  get WuiGrid() {
    return WuiGrid;
  },
  get WuiIcon() {
    return WuiIcon;
  },
  get WuiIconBox() {
    return WuiIconBox;
  },
  get WuiIconLink() {
    return WuiIconLink;
  },
  get WuiImage() {
    return WuiImage;
  },
  get WuiInputElement() {
    return WuiInputElement;
  },
  get WuiInputNumeric() {
    return WuiInputNumeric;
  },
  get WuiInputText() {
    return WuiInputText;
  },
  get WuiLink() {
    return WuiLink;
  },
  get WuiListAccordion() {
    return WuiListAccordion;
  },
  get WuiListContent() {
    return WuiListContent;
  },
  get WuiListItem() {
    return WuiListItem;
  },
  get WuiListWallet() {
    return WuiListWallet;
  },
  get WuiListWalletTransaction() {
    return WuiListWalletTransaction;
  },
  get WuiLoadingHexagon() {
    return WuiLoadingHexagon;
  },
  get WuiLoadingSpinner() {
    return WuiLoadingSpinner;
  },
  get WuiLoadingThumbnail() {
    return WuiLoadingThumbnail;
  },
  get WuiLogo() {
    return WuiLogo;
  },
  get WuiLogoSelect() {
    return WuiLogoSelect;
  },
  get WuiNetworkButton() {
    return WuiNetworkButton;
  },
  get WuiNetworkImage() {
    return WuiNetworkImage;
  },
  get WuiNoticeCard() {
    return WuiNoticeCard;
  },
  get WuiOtp() {
    return WuiOtp;
  },
  get WuiQrCode() {
    return WuiQrCode;
  },
  get WuiSearchBar() {
    return WuiSearchBar;
  },
  get WuiSeparator() {
    return WuiSeparator;
  },
  get WuiShimmer() {
    return WuiShimmer;
  },
  get WuiSnackbar() {
    return WuiSnackbar;
  },
  get WuiTabs() {
    return WuiTabs;
  },
  get WuiTag() {
    return WuiTag;
  },
  get WuiText() {
    return WuiText;
  },
  get WuiTooltip() {
    return WuiTooltip;
  },
  get WuiTransactionListItem() {
    return WuiTransactionListItem;
  },
  get WuiTransactionListItemLoader() {
    return WuiTransactionListItemLoader;
  },
  get WuiTransactionVisual() {
    return WuiTransactionVisual;
  },
  get WuiVisual() {
    return WuiVisual;
  },
  get WuiVisualThumbnail() {
    return WuiVisualThumbnail;
  },
  get WuiWalletImage() {
    return WuiWalletImage;
  },
  customElement,
  initializeTheming,
  setColorTheme,
  setThemeVariables
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$2 = globalThis, e$4 = t$2.ShadowRoot && (void 0 === t$2.ShadyCSS || t$2.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s$3 = Symbol(), o$6 = /* @__PURE__ */ new WeakMap();
let n$5 = class n2 {
  constructor(t2, e2, o2) {
    if (this._$cssResult$ = true, o2 !== s$3)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t2, this.t = e2;
  }
  get styleSheet() {
    let t2 = this.o;
    const s4 = this.t;
    if (e$4 && void 0 === t2) {
      const e2 = void 0 !== s4 && 1 === s4.length;
      e2 && (t2 = o$6.get(s4)), void 0 === t2 && ((this.o = t2 = new CSSStyleSheet()).replaceSync(this.cssText), e2 && o$6.set(s4, t2));
    }
    return t2;
  }
  toString() {
    return this.cssText;
  }
};
const r$6 = (t2) => new n$5("string" == typeof t2 ? t2 : t2 + "", void 0, s$3), i$4 = (t2, ...e2) => {
  const o2 = 1 === t2.length ? t2[0] : e2.reduce((e3, s4, o3) => e3 + ((t3) => {
    if (true === t3._$cssResult$)
      return t3.cssText;
    if ("number" == typeof t3)
      return t3;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t3 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s4) + t2[o3 + 1], t2[0]);
  return new n$5(o2, t2, s$3);
}, S$2 = (s4, o2) => {
  if (e$4)
    s4.adoptedStyleSheets = o2.map((t2) => t2 instanceof CSSStyleSheet ? t2 : t2.styleSheet);
  else
    for (const e2 of o2) {
      const o3 = document.createElement("style"), n4 = t$2.litNonce;
      void 0 !== n4 && o3.setAttribute("nonce", n4), o3.textContent = e2.cssText, s4.appendChild(o3);
    }
}, c$3 = e$4 ? (t2) => t2 : (t2) => t2 instanceof CSSStyleSheet ? ((t3) => {
  let e2 = "";
  for (const s4 of t3.cssRules)
    e2 += s4.cssText;
  return r$6(e2);
})(t2) : t2;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: i$3, defineProperty: e$3, getOwnPropertyDescriptor: r$5, getOwnPropertyNames: h$4, getOwnPropertySymbols: o$5, getPrototypeOf: n$4 } = Object, a$1 = globalThis, c$2 = a$1.trustedTypes, l$1 = c$2 ? c$2.emptyScript : "", p$2 = a$1.reactiveElementPolyfillSupport, d$1 = (t2, s4) => t2, u$1 = { toAttribute(t2, s4) {
  switch (s4) {
    case Boolean:
      t2 = t2 ? l$1 : null;
      break;
    case Object:
    case Array:
      t2 = null == t2 ? t2 : JSON.stringify(t2);
  }
  return t2;
}, fromAttribute(t2, s4) {
  let i3 = t2;
  switch (s4) {
    case Boolean:
      i3 = null !== t2;
      break;
    case Number:
      i3 = null === t2 ? null : Number(t2);
      break;
    case Object:
    case Array:
      try {
        i3 = JSON.parse(t2);
      } catch (t3) {
        i3 = null;
      }
  }
  return i3;
} }, f$3 = (t2, s4) => !i$3(t2, s4), y$1 = { attribute: true, type: String, converter: u$1, reflect: false, hasChanged: f$3 };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), a$1.litPropertyMetadata ?? (a$1.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class b2 extends HTMLElement {
  static addInitializer(t2) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t2);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t2, s4 = y$1) {
    if (s4.state && (s4.attribute = false), this._$Ei(), this.elementProperties.set(t2, s4), !s4.noAccessor) {
      const i3 = Symbol(), r2 = this.getPropertyDescriptor(t2, i3, s4);
      void 0 !== r2 && e$3(this.prototype, t2, r2);
    }
  }
  static getPropertyDescriptor(t2, s4, i3) {
    const { get: e2, set: h4 } = r$5(this.prototype, t2) ?? { get() {
      return this[s4];
    }, set(t3) {
      this[s4] = t3;
    } };
    return { get() {
      return e2?.call(this);
    }, set(s5) {
      const r2 = e2?.call(this);
      h4.call(this, s5), this.requestUpdate(t2, r2, i3);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t2) {
    return this.elementProperties.get(t2) ?? y$1;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d$1("elementProperties")))
      return;
    const t2 = n$4(this);
    t2.finalize(), void 0 !== t2.l && (this.l = [...t2.l]), this.elementProperties = new Map(t2.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d$1("finalized")))
      return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d$1("properties"))) {
      const t3 = this.properties, s4 = [...h$4(t3), ...o$5(t3)];
      for (const i3 of s4)
        this.createProperty(i3, t3[i3]);
    }
    const t2 = this[Symbol.metadata];
    if (null !== t2) {
      const s4 = litPropertyMetadata.get(t2);
      if (void 0 !== s4)
        for (const [t3, i3] of s4)
          this.elementProperties.set(t3, i3);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t3, s4] of this.elementProperties) {
      const i3 = this._$Eu(t3, s4);
      void 0 !== i3 && this._$Eh.set(i3, t3);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s4) {
    const i3 = [];
    if (Array.isArray(s4)) {
      const e2 = new Set(s4.flat(1 / 0).reverse());
      for (const s5 of e2)
        i3.unshift(c$3(s5));
    } else
      void 0 !== s4 && i3.push(c$3(s4));
    return i3;
  }
  static _$Eu(t2, s4) {
    const i3 = s4.attribute;
    return false === i3 ? void 0 : "string" == typeof i3 ? i3 : "string" == typeof t2 ? t2.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$Eg = new Promise((t2) => this.enableUpdating = t2), this._$AL = /* @__PURE__ */ new Map(), this._$ES(), this.requestUpdate(), this.constructor.l?.forEach((t2) => t2(this));
  }
  addController(t2) {
    (this._$E_ ?? (this._$E_ = /* @__PURE__ */ new Set())).add(t2), void 0 !== this.renderRoot && this.isConnected && t2.hostConnected?.();
  }
  removeController(t2) {
    this._$E_?.delete(t2);
  }
  _$ES() {
    const t2 = /* @__PURE__ */ new Map(), s4 = this.constructor.elementProperties;
    for (const i3 of s4.keys())
      this.hasOwnProperty(i3) && (t2.set(i3, this[i3]), delete this[i3]);
    t2.size > 0 && (this._$Ep = t2);
  }
  createRenderRoot() {
    const t2 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S$2(t2, this.constructor.elementStyles), t2;
  }
  connectedCallback() {
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), this._$E_?.forEach((t2) => t2.hostConnected?.());
  }
  enableUpdating(t2) {
  }
  disconnectedCallback() {
    this._$E_?.forEach((t2) => t2.hostDisconnected?.());
  }
  attributeChangedCallback(t2, s4, i3) {
    this._$AK(t2, i3);
  }
  _$EO(t2, s4) {
    const i3 = this.constructor.elementProperties.get(t2), e2 = this.constructor._$Eu(t2, i3);
    if (void 0 !== e2 && true === i3.reflect) {
      const r2 = (void 0 !== i3.converter?.toAttribute ? i3.converter : u$1).toAttribute(s4, i3.type);
      this._$Em = t2, null == r2 ? this.removeAttribute(e2) : this.setAttribute(e2, r2), this._$Em = null;
    }
  }
  _$AK(t2, s4) {
    const i3 = this.constructor, e2 = i3._$Eh.get(t2);
    if (void 0 !== e2 && this._$Em !== e2) {
      const t3 = i3.getPropertyOptions(e2), r2 = "function" == typeof t3.converter ? { fromAttribute: t3.converter } : void 0 !== t3.converter?.fromAttribute ? t3.converter : u$1;
      this._$Em = e2, this[e2] = r2.fromAttribute(s4, t3.type), this._$Em = null;
    }
  }
  requestUpdate(t2, s4, i3) {
    if (void 0 !== t2) {
      if (i3 ?? (i3 = this.constructor.getPropertyOptions(t2)), !(i3.hasChanged ?? f$3)(this[t2], s4))
        return;
      this.C(t2, s4, i3);
    }
    false === this.isUpdatePending && (this._$Eg = this._$EP());
  }
  C(t2, s4, i3) {
    this._$AL.has(t2) || this._$AL.set(t2, s4), true === i3.reflect && this._$Em !== t2 && (this._$ET ?? (this._$ET = /* @__PURE__ */ new Set())).add(t2);
  }
  async _$EP() {
    this.isUpdatePending = true;
    try {
      await this._$Eg;
    } catch (t3) {
      Promise.reject(t3);
    }
    const t2 = this.scheduleUpdate();
    return null != t2 && await t2, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [t4, s5] of this._$Ep)
          this[t4] = s5;
        this._$Ep = void 0;
      }
      const t3 = this.constructor.elementProperties;
      if (t3.size > 0)
        for (const [s5, i3] of t3)
          true !== i3.wrapped || this._$AL.has(s5) || void 0 === this[s5] || this.C(s5, this[s5], i3);
    }
    let t2 = false;
    const s4 = this._$AL;
    try {
      t2 = this.shouldUpdate(s4), t2 ? (this.willUpdate(s4), this._$E_?.forEach((t3) => t3.hostUpdate?.()), this.update(s4)) : this._$Ej();
    } catch (s5) {
      throw t2 = false, this._$Ej(), s5;
    }
    t2 && this._$AE(s4);
  }
  willUpdate(t2) {
  }
  _$AE(t2) {
    this._$E_?.forEach((t3) => t3.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t2)), this.updated(t2);
  }
  _$Ej() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$Eg;
  }
  shouldUpdate(t2) {
    return true;
  }
  update(t2) {
    this._$ET && (this._$ET = this._$ET.forEach((t3) => this._$EO(t3, this[t3]))), this._$Ej();
  }
  updated(t2) {
  }
  firstUpdated(t2) {
  }
}
b2.elementStyles = [], b2.shadowRootOptions = { mode: "open" }, b2[d$1("elementProperties")] = /* @__PURE__ */ new Map(), b2[d$1("finalized")] = /* @__PURE__ */ new Map(), p$2?.({ ReactiveElement: b2 }), (a$1.reactiveElementVersions ?? (a$1.reactiveElementVersions = [])).push("2.0.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$1 = globalThis, i$2 = t$1.trustedTypes, s$2 = i$2 ? i$2.createPolicy("lit-html", { createHTML: (t2) => t2 }) : void 0, e$2 = "$lit$", h$3 = `lit$${(Math.random() + "").slice(9)}$`, o$4 = "?" + h$3, n$3 = `<${o$4}>`, r$4 = document, l = () => r$4.createComment(""), c$1 = (t2) => null === t2 || "object" != typeof t2 && "function" != typeof t2, a = Array.isArray, u = (t2) => a(t2) || "function" == typeof t2?.[Symbol.iterator], d = "[ 	\n\f\r]", f$2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, v = /-->/g, _$1 = />/g, m$1 = RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), p$1 = /'/g, g = /"/g, $$1 = /^(?:script|style|textarea|title)$/i, y = (t2) => (i3, ...s4) => ({ _$litType$: t2, strings: i3, values: s4 }), x = y(1), w$1 = Symbol.for("lit-noChange"), T$1 = Symbol.for("lit-nothing"), A$1 = /* @__PURE__ */ new WeakMap(), E = r$4.createTreeWalker(r$4, 129);
function C$1(t2, i3) {
  if (!Array.isArray(t2) || !t2.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return void 0 !== s$2 ? s$2.createHTML(i3) : i3;
}
const P = (t2, i3) => {
  const s4 = t2.length - 1, o2 = [];
  let r2, l2 = 2 === i3 ? "<svg>" : "", c2 = f$2;
  for (let i4 = 0; i4 < s4; i4++) {
    const s5 = t2[i4];
    let a2, u2, d2 = -1, y2 = 0;
    for (; y2 < s5.length && (c2.lastIndex = y2, u2 = c2.exec(s5), null !== u2); )
      y2 = c2.lastIndex, c2 === f$2 ? "!--" === u2[1] ? c2 = v : void 0 !== u2[1] ? c2 = _$1 : void 0 !== u2[2] ? ($$1.test(u2[2]) && (r2 = RegExp("</" + u2[2], "g")), c2 = m$1) : void 0 !== u2[3] && (c2 = m$1) : c2 === m$1 ? ">" === u2[0] ? (c2 = r2 ?? f$2, d2 = -1) : void 0 === u2[1] ? d2 = -2 : (d2 = c2.lastIndex - u2[2].length, a2 = u2[1], c2 = void 0 === u2[3] ? m$1 : '"' === u2[3] ? g : p$1) : c2 === g || c2 === p$1 ? c2 = m$1 : c2 === v || c2 === _$1 ? c2 = f$2 : (c2 = m$1, r2 = void 0);
    const x2 = c2 === m$1 && t2[i4 + 1].startsWith("/>") ? " " : "";
    l2 += c2 === f$2 ? s5 + n$3 : d2 >= 0 ? (o2.push(a2), s5.slice(0, d2) + e$2 + s5.slice(d2) + h$3 + x2) : s5 + h$3 + (-2 === d2 ? i4 : x2);
  }
  return [C$1(t2, l2 + (t2[s4] || "<?>") + (2 === i3 ? "</svg>" : "")), o2];
};
let V$1 = class V2 {
  constructor({ strings: t2, _$litType$: s4 }, n4) {
    let r2;
    this.parts = [];
    let c2 = 0, a2 = 0;
    const u2 = t2.length - 1, d2 = this.parts, [f3, v2] = P(t2, s4);
    if (this.el = V2.createElement(f3, n4), E.currentNode = this.el.content, 2 === s4) {
      const t3 = this.el.content.firstChild;
      t3.replaceWith(...t3.childNodes);
    }
    for (; null !== (r2 = E.nextNode()) && d2.length < u2; ) {
      if (1 === r2.nodeType) {
        if (r2.hasAttributes())
          for (const t3 of r2.getAttributeNames())
            if (t3.endsWith(e$2)) {
              const i3 = v2[a2++], s5 = r2.getAttribute(t3).split(h$3), e2 = /([.?@])?(.*)/.exec(i3);
              d2.push({ type: 1, index: c2, name: e2[2], strings: s5, ctor: "." === e2[1] ? k$1 : "?" === e2[1] ? H$1 : "@" === e2[1] ? I2 : R2 }), r2.removeAttribute(t3);
            } else
              t3.startsWith(h$3) && (d2.push({ type: 6, index: c2 }), r2.removeAttribute(t3));
        if ($$1.test(r2.tagName)) {
          const t3 = r2.textContent.split(h$3), s5 = t3.length - 1;
          if (s5 > 0) {
            r2.textContent = i$2 ? i$2.emptyScript : "";
            for (let i3 = 0; i3 < s5; i3++)
              r2.append(t3[i3], l()), E.nextNode(), d2.push({ type: 2, index: ++c2 });
            r2.append(t3[s5], l());
          }
        }
      } else if (8 === r2.nodeType)
        if (r2.data === o$4)
          d2.push({ type: 2, index: c2 });
        else {
          let t3 = -1;
          for (; -1 !== (t3 = r2.data.indexOf(h$3, t3 + 1)); )
            d2.push({ type: 7, index: c2 }), t3 += h$3.length - 1;
        }
      c2++;
    }
  }
  static createElement(t2, i3) {
    const s4 = r$4.createElement("template");
    return s4.innerHTML = t2, s4;
  }
};
function N$1(t2, i3, s4 = t2, e2) {
  if (i3 === w$1)
    return i3;
  let h4 = void 0 !== e2 ? s4._$Co?.[e2] : s4._$Cl;
  const o2 = c$1(i3) ? void 0 : i3._$litDirective$;
  return h4?.constructor !== o2 && (h4?._$AO?.(false), void 0 === o2 ? h4 = void 0 : (h4 = new o2(t2), h4._$AT(t2, s4, e2)), void 0 !== e2 ? (s4._$Co ?? (s4._$Co = []))[e2] = h4 : s4._$Cl = h4), void 0 !== h4 && (i3 = N$1(t2, h4._$AS(t2, i3.values), h4, e2)), i3;
}
let S$1 = class S2 {
  constructor(t2, i3) {
    this._$AV = [], this._$AN = void 0, this._$AD = t2, this._$AM = i3;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t2) {
    const { el: { content: i3 }, parts: s4 } = this._$AD, e2 = (t2?.creationScope ?? r$4).importNode(i3, true);
    E.currentNode = e2;
    let h4 = E.nextNode(), o2 = 0, n4 = 0, l2 = s4[0];
    for (; void 0 !== l2; ) {
      if (o2 === l2.index) {
        let i4;
        2 === l2.type ? i4 = new M2(h4, h4.nextSibling, this, t2) : 1 === l2.type ? i4 = new l2.ctor(h4, l2.name, l2.strings, this, t2) : 6 === l2.type && (i4 = new L$1(h4, this, t2)), this._$AV.push(i4), l2 = s4[++n4];
      }
      o2 !== l2?.index && (h4 = E.nextNode(), o2++);
    }
    return E.currentNode = r$4, e2;
  }
  p(t2) {
    let i3 = 0;
    for (const s4 of this._$AV)
      void 0 !== s4 && (void 0 !== s4.strings ? (s4._$AI(t2, s4, i3), i3 += s4.strings.length - 2) : s4._$AI(t2[i3])), i3++;
  }
};
class M2 {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t2, i3, s4, e2) {
    this.type = 2, this._$AH = T$1, this._$AN = void 0, this._$AA = t2, this._$AB = i3, this._$AM = s4, this.options = e2, this._$Cv = e2?.isConnected ?? true;
  }
  get parentNode() {
    let t2 = this._$AA.parentNode;
    const i3 = this._$AM;
    return void 0 !== i3 && 11 === t2?.nodeType && (t2 = i3.parentNode), t2;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t2, i3 = this) {
    t2 = N$1(this, t2, i3), c$1(t2) ? t2 === T$1 || null == t2 || "" === t2 ? (this._$AH !== T$1 && this._$AR(), this._$AH = T$1) : t2 !== this._$AH && t2 !== w$1 && this._(t2) : void 0 !== t2._$litType$ ? this.g(t2) : void 0 !== t2.nodeType ? this.$(t2) : u(t2) ? this.T(t2) : this._(t2);
  }
  k(t2) {
    return this._$AA.parentNode.insertBefore(t2, this._$AB);
  }
  $(t2) {
    this._$AH !== t2 && (this._$AR(), this._$AH = this.k(t2));
  }
  _(t2) {
    this._$AH !== T$1 && c$1(this._$AH) ? this._$AA.nextSibling.data = t2 : this.$(r$4.createTextNode(t2)), this._$AH = t2;
  }
  g(t2) {
    const { values: i3, _$litType$: s4 } = t2, e2 = "number" == typeof s4 ? this._$AC(t2) : (void 0 === s4.el && (s4.el = V$1.createElement(C$1(s4.h, s4.h[0]), this.options)), s4);
    if (this._$AH?._$AD === e2)
      this._$AH.p(i3);
    else {
      const t3 = new S$1(e2, this), s5 = t3.u(this.options);
      t3.p(i3), this.$(s5), this._$AH = t3;
    }
  }
  _$AC(t2) {
    let i3 = A$1.get(t2.strings);
    return void 0 === i3 && A$1.set(t2.strings, i3 = new V$1(t2)), i3;
  }
  T(t2) {
    a(this._$AH) || (this._$AH = [], this._$AR());
    const i3 = this._$AH;
    let s4, e2 = 0;
    for (const h4 of t2)
      e2 === i3.length ? i3.push(s4 = new M2(this.k(l()), this.k(l()), this, this.options)) : s4 = i3[e2], s4._$AI(h4), e2++;
    e2 < i3.length && (this._$AR(s4 && s4._$AB.nextSibling, e2), i3.length = e2);
  }
  _$AR(t2 = this._$AA.nextSibling, i3) {
    for (this._$AP?.(false, true, i3); t2 && t2 !== this._$AB; ) {
      const i4 = t2.nextSibling;
      t2.remove(), t2 = i4;
    }
  }
  setConnected(t2) {
    void 0 === this._$AM && (this._$Cv = t2, this._$AP?.(t2));
  }
}
class R2 {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t2, i3, s4, e2, h4) {
    this.type = 1, this._$AH = T$1, this._$AN = void 0, this.element = t2, this.name = i3, this._$AM = e2, this.options = h4, s4.length > 2 || "" !== s4[0] || "" !== s4[1] ? (this._$AH = Array(s4.length - 1).fill(new String()), this.strings = s4) : this._$AH = T$1;
  }
  _$AI(t2, i3 = this, s4, e2) {
    const h4 = this.strings;
    let o2 = false;
    if (void 0 === h4)
      t2 = N$1(this, t2, i3, 0), o2 = !c$1(t2) || t2 !== this._$AH && t2 !== w$1, o2 && (this._$AH = t2);
    else {
      const e3 = t2;
      let n4, r2;
      for (t2 = h4[0], n4 = 0; n4 < h4.length - 1; n4++)
        r2 = N$1(this, e3[s4 + n4], i3, n4), r2 === w$1 && (r2 = this._$AH[n4]), o2 || (o2 = !c$1(r2) || r2 !== this._$AH[n4]), r2 === T$1 ? t2 = T$1 : t2 !== T$1 && (t2 += (r2 ?? "") + h4[n4 + 1]), this._$AH[n4] = r2;
    }
    o2 && !e2 && this.O(t2);
  }
  O(t2) {
    t2 === T$1 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t2 ?? "");
  }
}
let k$1 = class k2 extends R2 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  O(t2) {
    this.element[this.name] = t2 === T$1 ? void 0 : t2;
  }
};
let H$1 = class H2 extends R2 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  O(t2) {
    this.element.toggleAttribute(this.name, !!t2 && t2 !== T$1);
  }
};
class I2 extends R2 {
  constructor(t2, i3, s4, e2, h4) {
    super(t2, i3, s4, e2, h4), this.type = 5;
  }
  _$AI(t2, i3 = this) {
    if ((t2 = N$1(this, t2, i3, 0) ?? T$1) === w$1)
      return;
    const s4 = this._$AH, e2 = t2 === T$1 && s4 !== T$1 || t2.capture !== s4.capture || t2.once !== s4.once || t2.passive !== s4.passive, h4 = t2 !== T$1 && (s4 === T$1 || e2);
    e2 && this.element.removeEventListener(this.name, this, s4), h4 && this.element.addEventListener(this.name, this, t2), this._$AH = t2;
  }
  handleEvent(t2) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t2) : this._$AH.handleEvent(t2);
  }
}
let L$1 = class L2 {
  constructor(t2, i3, s4) {
    this.element = t2, this.type = 6, this._$AN = void 0, this._$AM = i3, this.options = s4;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t2) {
    N$1(this, t2);
  }
};
const Z$1 = t$1.litHtmlPolyfillSupport;
Z$1?.(V$1, M2), (t$1.litHtmlVersions ?? (t$1.litHtmlVersions = [])).push("3.1.1");
const j = (t2, i3, s4) => {
  const e2 = s4?.renderBefore ?? i3;
  let h4 = e2._$litPart$;
  if (void 0 === h4) {
    const t3 = s4?.renderBefore ?? null;
    e2._$litPart$ = h4 = new M2(i3.insertBefore(l(), t3), t3, void 0, s4 ?? {});
  }
  return h4._$AI(t2), h4;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$1 = class s2 extends b2 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var _a;
    const t2 = super.createRenderRoot();
    return (_a = this.renderOptions).renderBefore ?? (_a.renderBefore = t2.firstChild), t2;
  }
  update(t2) {
    const i3 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t2), this._$Do = j(i3, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(false);
  }
  render() {
    return w$1;
  }
};
s$1._$litElement$ = true, s$1["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: s$1 });
const r$3 = globalThis.litElementPolyfillSupport;
r$3?.({ LitElement: s$1 });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$3 = { attribute: true, type: String, converter: u$1, reflect: false, hasChanged: f$3 }, r$2 = (t2 = o$3, e2, r2) => {
  const { kind: n4, metadata: i3 } = r2;
  let s4 = globalThis.litPropertyMetadata.get(i3);
  if (void 0 === s4 && globalThis.litPropertyMetadata.set(i3, s4 = /* @__PURE__ */ new Map()), s4.set(r2.name, t2), "accessor" === n4) {
    const { name: o2 } = r2;
    return { set(r3) {
      const n5 = e2.get.call(this);
      e2.set.call(this, r3), this.requestUpdate(o2, n5, t2);
    }, init(e3) {
      return void 0 !== e3 && this.C(o2, void 0, t2), e3;
    } };
  }
  if ("setter" === n4) {
    const { name: o2 } = r2;
    return function(r3) {
      const n5 = this[o2];
      e2.call(this, r3), this.requestUpdate(o2, n5, t2);
    };
  }
  throw Error("Unsupported decorator location: " + n4);
};
function n$2(t2) {
  return (e2, o2) => "object" == typeof o2 ? r$2(t2, e2, o2) : ((t3, e3, o3) => {
    const r2 = e3.hasOwnProperty(o3);
    return e3.constructor.createProperty(o3, r2 ? { ...t3, wrapped: true } : t3), r2 ? Object.getOwnPropertyDescriptor(e3, o3) : void 0;
  })(t2, e2, o2);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$1(r2) {
  return n$2({ ...r2, state: true, attribute: false });
}
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$2 = (o2) => o2 ?? T$1;
var __decorate$G = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAccountButton = class W3mAccountButton2 extends s$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.balance = "show";
    this.charsStart = 4;
    this.charsEnd = 6;
    this.address = AccountController.state.address;
    this.balanceVal = AccountController.state.balance;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.profileName = AccountController.state.profileName;
    this.profileImage = AccountController.state.profileImage;
    this.network = NetworkController.state.caipNetwork;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.isConnected) {
          this.address = val.address;
          this.balanceVal = val.balance;
          this.profileName = val.profileName;
          this.profileImage = val.profileImage;
          this.balanceSymbol = val.balanceSymbol;
        } else {
          this.address = "";
          this.balanceVal = "";
          this.profileName = "";
          this.profileImage = "";
          this.balanceSymbol = "";
        }
      }),
      NetworkController.subscribeKey("caipNetwork", (val) => this.network = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const networkImage = AssetUtil.getNetworkImage(this.network);
    const showBalance = this.balance === "show";
    return x`
      <wui-account-button
        .disabled=${Boolean(this.disabled)}
        address=${o$2(this.profileName ?? this.address)}
        ?isProfileName=${Boolean(this.profileName)}
        networkSrc=${o$2(networkImage)}
        avatarSrc=${o$2(this.profileImage)}
        balance=${showBalance ? CoreHelperUtil.formatBalance(this.balanceVal, this.balanceSymbol) : ""}
        @click=${this.onClick.bind(this)}
        data-testid="account-button"
        .charsStart=${this.charsStart}
        .charsEnd=${this.charsEnd}
      >
      </wui-account-button>
    `;
  }
  onClick() {
    ModalController.open();
  }
};
__decorate$G([
  n$2({ type: Boolean })
], W3mAccountButton.prototype, "disabled", void 0);
__decorate$G([
  n$2()
], W3mAccountButton.prototype, "balance", void 0);
__decorate$G([
  n$2()
], W3mAccountButton.prototype, "charsStart", void 0);
__decorate$G([
  n$2()
], W3mAccountButton.prototype, "charsEnd", void 0);
__decorate$G([
  r$1()
], W3mAccountButton.prototype, "address", void 0);
__decorate$G([
  r$1()
], W3mAccountButton.prototype, "balanceVal", void 0);
__decorate$G([
  r$1()
], W3mAccountButton.prototype, "balanceSymbol", void 0);
__decorate$G([
  r$1()
], W3mAccountButton.prototype, "profileName", void 0);
__decorate$G([
  r$1()
], W3mAccountButton.prototype, "profileImage", void 0);
__decorate$G([
  r$1()
], W3mAccountButton.prototype, "network", void 0);
W3mAccountButton = __decorate$G([
  customElement("w3m-account-button")
], W3mAccountButton);
const styles$n = i$4`
  :host {
    display: block;
    width: max-content;
  }
`;
var __decorate$F = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mButton = class W3mButton2 extends s$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.balance = void 0;
    this.size = void 0;
    this.label = void 0;
    this.loadingLabel = void 0;
    this.charsStart = 4;
    this.charsEnd = 6;
    this.isAccount = AccountController.state.isConnected;
    this.unsubscribe.push(AccountController.subscribeKey("isConnected", (val) => {
      this.isAccount = val;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return this.isAccount ? x`
          <w3m-account-button
            .disabled=${Boolean(this.disabled)}
            balance=${o$2(this.balance)}
            .charsStart=${o$2(this.charsStart)}
            .charsEnd=${o$2(this.charsEnd)}
          >
          </w3m-account-button>
        ` : x`
          <w3m-connect-button
            size=${o$2(this.size)}
            label=${o$2(this.label)}
            loadingLabel=${o$2(this.loadingLabel)}
          ></w3m-connect-button>
        `;
  }
};
W3mButton.styles = styles$n;
__decorate$F([
  n$2({ type: Boolean })
], W3mButton.prototype, "disabled", void 0);
__decorate$F([
  n$2()
], W3mButton.prototype, "balance", void 0);
__decorate$F([
  n$2()
], W3mButton.prototype, "size", void 0);
__decorate$F([
  n$2()
], W3mButton.prototype, "label", void 0);
__decorate$F([
  n$2()
], W3mButton.prototype, "loadingLabel", void 0);
__decorate$F([
  n$2()
], W3mButton.prototype, "charsStart", void 0);
__decorate$F([
  n$2()
], W3mButton.prototype, "charsEnd", void 0);
__decorate$F([
  r$1()
], W3mButton.prototype, "isAccount", void 0);
W3mButton = __decorate$F([
  customElement("w3m-button")
], W3mButton);
var __decorate$E = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectButton = class W3mConnectButton2 extends s$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.size = "md";
    this.label = "Connect Wallet";
    this.loadingLabel = "Connecting...";
    this.open = ModalController.state.open;
    this.loading = ModalController.state.loading;
    this.unsubscribe.push(ModalController.subscribe((val) => {
      this.open = val.open;
      this.loading = val.loading;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const isLoading = this.loading || this.open;
    return x`
      <wui-connect-button
        size=${o$2(this.size)}
        .loading=${isLoading}
        @click=${this.onClick.bind(this)}
        data-testid="connect-button"
      >
        ${isLoading ? this.loadingLabel : this.label}
      </wui-connect-button>
    `;
  }
  onClick() {
    if (this.open) {
      ModalController.close();
    } else if (!this.loading) {
      ModalController.open();
    }
  }
};
__decorate$E([
  n$2()
], W3mConnectButton.prototype, "size", void 0);
__decorate$E([
  n$2()
], W3mConnectButton.prototype, "label", void 0);
__decorate$E([
  n$2()
], W3mConnectButton.prototype, "loadingLabel", void 0);
__decorate$E([
  r$1()
], W3mConnectButton.prototype, "open", void 0);
__decorate$E([
  r$1()
], W3mConnectButton.prototype, "loading", void 0);
W3mConnectButton = __decorate$E([
  customElement("w3m-connect-button")
], W3mConnectButton);
const styles$m = i$4`
  :host {
    z-index: var(--w3m-z-index);
    display: block;
    backface-visibility: hidden;
    will-change: opacity;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    opacity: 0;
    background-color: var(--wui-cover);
  }

  @keyframes zoom-in {
    0% {
      transform: scale(0.95) translateY(0);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  @keyframes slide-in {
    0% {
      transform: scale(1) translateY(50px);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  wui-card {
    max-width: 360px;
    width: 100%;
    position: relative;
    animation-delay: 0.3s;
    animation-duration: 0.2s;
    animation-name: zoom-in;
    animation-fill-mode: backwards;
    animation-timing-function: var(--wui-ease-out-power-2);
    outline: none;
  }

  wui-flex {
    overflow-x: hidden;
    overflow-y: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }

  @media (max-height: 700px) and (min-width: 431px) {
    wui-flex {
      align-items: flex-start;
    }

    wui-card {
      margin: var(--wui-spacing-xxl) 0px;
    }
  }

  @media (max-width: 430px) {
    wui-flex {
      align-items: flex-end;
    }

    wui-card {
      max-width: 100%;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border-bottom: none;
      animation-name: slide-in;
    }
  }
`;
var __decorate$D = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const SCROLL_LOCK = "scroll-lock";
let W3mModal = class W3mModal2 extends s$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.abortController = void 0;
    this.open = ModalController.state.open;
    this.caipAddress = AccountController.state.address;
    this.isSiweEnabled = SIWEController.state.isSiweEnabled;
    this.initializeTheming();
    ApiController.prefetch();
    this.unsubscribe.push(ModalController.subscribeKey("open", (val) => val ? this.onOpen() : this.onClose()), SIWEController.subscribeKey("isSiweEnabled", (isEnabled) => {
      this.isSiweEnabled = isEnabled;
    }), AccountController.subscribe((newAccountState) => this.onNewAccountState(newAccountState)));
    EventsController.sendEvent({ type: "track", event: "MODAL_LOADED" });
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    this.onRemoveKeyboardListener();
  }
  render() {
    return this.open ? x`
          <wui-flex @click=${this.onOverlayClick.bind(this)}>
            <wui-card role="alertdialog" aria-modal="true" tabindex="0">
              <w3m-header></w3m-header>
              <w3m-router></w3m-router>
              <w3m-snackbar></w3m-snackbar>
            </wui-card>
          </wui-flex>
        ` : null;
  }
  async onOverlayClick(event) {
    if (event.target === event.currentTarget) {
      await this.handleClose();
    }
  }
  async handleClose() {
    if (this.isSiweEnabled && SIWEController.state.status !== "success") {
      await ConnectionController.disconnect();
    }
    ModalController.close();
  }
  initializeTheming() {
    const { themeVariables, themeMode } = ThemeController.state;
    const defaultThemeMode = UiHelperUtil.getColorTheme(themeMode);
    initializeTheming(themeVariables, defaultThemeMode);
  }
  async onClose() {
    this.onScrollUnlock();
    await this.animate([{ opacity: 1 }, { opacity: 0 }], {
      duration: 200,
      easing: "ease",
      fill: "forwards"
    }).finished;
    SnackController.hide();
    this.open = false;
    this.onRemoveKeyboardListener();
  }
  async onOpen() {
    this.onScrollLock();
    this.open = true;
    await this.animate([{ opacity: 0 }, { opacity: 1 }], {
      duration: 200,
      easing: "ease",
      fill: "forwards",
      delay: 300
    }).finished;
    this.onAddKeyboardListener();
  }
  onScrollLock() {
    const styleTag = document.createElement("style");
    styleTag.dataset["w3m"] = SCROLL_LOCK;
    styleTag.textContent = `
      html, body {
        touch-action: none;
        overflow: hidden;
        overscroll-behavior: contain;
      }
      w3m-modal {
        pointer-events: auto;
      }
    `;
    document.head.appendChild(styleTag);
  }
  onScrollUnlock() {
    const styleTag = document.head.querySelector(`style[data-w3m="${SCROLL_LOCK}"]`);
    if (styleTag) {
      styleTag.remove();
    }
  }
  onAddKeyboardListener() {
    this.abortController = new AbortController();
    const card = this.shadowRoot?.querySelector("wui-card");
    card?.focus();
    window.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        this.handleClose();
      } else if (event.key === "Tab") {
        const { tagName } = event.target;
        if (tagName && !tagName.includes("W3M-") && !tagName.includes("WUI-")) {
          card?.focus();
        }
      }
    }, this.abortController);
  }
  onRemoveKeyboardListener() {
    this.abortController?.abort();
    this.abortController = void 0;
  }
  async onNewAccountState(newState) {
    const { isConnected, caipAddress: newCaipAddress } = newState;
    if (this.isSiweEnabled) {
      if (isConnected && !this.caipAddress) {
        this.caipAddress = newCaipAddress;
      }
      if (isConnected && newCaipAddress && this.caipAddress !== newCaipAddress) {
        await SIWEController.signOut();
        this.onSiweNavigation();
        this.caipAddress = newCaipAddress;
      }
      try {
        const session = await SIWEController.getSession();
        if (session && !isConnected) {
          await SIWEController.signOut();
        } else if (isConnected && !session) {
          this.onSiweNavigation();
        }
      } catch (error) {
        if (isConnected) {
          this.onSiweNavigation();
        }
      }
    }
  }
  onSiweNavigation() {
    if (this.open) {
      RouterController.push("ConnectingSiwe");
    } else {
      ModalController.open({
        view: "ConnectingSiwe"
      });
    }
  }
};
W3mModal.styles = styles$m;
__decorate$D([
  r$1()
], W3mModal.prototype, "open", void 0);
__decorate$D([
  r$1()
], W3mModal.prototype, "caipAddress", void 0);
__decorate$D([
  r$1()
], W3mModal.prototype, "isSiweEnabled", void 0);
W3mModal = __decorate$D([
  customElement("w3m-modal")
], W3mModal);
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get W3mModal() {
    return W3mModal;
  }
}, Symbol.toStringTag, { value: "Module" }));
const styles$l = i$4`
  :host {
    display: block;
    width: max-content;
  }
`;
var __decorate$C = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mNetworkButton = class W3mNetworkButton2 extends s$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.network = NetworkController.state.caipNetwork;
    this.connected = AccountController.state.isConnected;
    this.loading = ModalController.state.loading;
    this.unsubscribe.push(...[
      NetworkController.subscribeKey("caipNetwork", (val) => this.network = val),
      AccountController.subscribeKey("isConnected", (val) => this.connected = val),
      ModalController.subscribeKey("loading", (val) => this.loading = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`
      <wui-network-button
        .disabled=${Boolean(this.disabled || this.loading)}
        imageSrc=${o$2(AssetUtil.getNetworkImage(this.network))}
        @click=${this.onClick.bind(this)}
      >
        ${this.network?.name ?? (this.connected ? "Unknown Network" : "Select Network")}
      </wui-network-button>
    `;
  }
  onClick() {
    if (!this.loading) {
      ModalController.open({ view: "Networks" });
    }
  }
};
W3mNetworkButton.styles = styles$l;
__decorate$C([
  n$2({ type: Boolean })
], W3mNetworkButton.prototype, "disabled", void 0);
__decorate$C([
  r$1()
], W3mNetworkButton.prototype, "network", void 0);
__decorate$C([
  r$1()
], W3mNetworkButton.prototype, "connected", void 0);
__decorate$C([
  r$1()
], W3mNetworkButton.prototype, "loading", void 0);
W3mNetworkButton = __decorate$C([
  customElement("w3m-network-button")
], W3mNetworkButton);
const styles$k = i$4`
  :host {
    display: block;
    will-change: transform, opacity;
  }
`;
var __decorate$B = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mRouter = class W3mRouter2 extends s$1 {
  constructor() {
    super();
    this.resizeObserver = void 0;
    this.prevHeight = "0px";
    this.prevHistoryLength = 1;
    this.unsubscribe = [];
    this.view = RouterController.state.view;
    this.unsubscribe.push(RouterController.subscribeKey("view", (val) => this.onViewChange(val)));
  }
  firstUpdated() {
    this.resizeObserver = new ResizeObserver(async ([content]) => {
      const height2 = `${content?.contentRect.height}px`;
      if (this.prevHeight !== "0px") {
        await this.animate([{ height: this.prevHeight }, { height: height2 }], {
          duration: 150,
          easing: "ease",
          fill: "forwards"
        }).finished;
        this.style.height = "auto";
      }
      this.prevHeight = height2;
    });
    this.resizeObserver.observe(this.getWrapper());
  }
  disconnectedCallback() {
    this.resizeObserver?.unobserve(this.getWrapper());
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`<div>${this.viewTemplate()}</div>`;
  }
  viewTemplate() {
    switch (this.view) {
      case "Connect":
        return x`<w3m-connect-view></w3m-connect-view>`;
      case "ConnectingWalletConnect":
        return x`<w3m-connecting-wc-view></w3m-connecting-wc-view>`;
      case "ConnectingExternal":
        return x`<w3m-connecting-external-view></w3m-connecting-external-view>`;
      case "ConnectingSiwe":
        return x`<w3m-connecting-siwe-view></w3m-connecting-siwe-view>`;
      case "AllWallets":
        return x`<w3m-all-wallets-view></w3m-all-wallets-view>`;
      case "Networks":
        return x`<w3m-networks-view></w3m-networks-view>`;
      case "SwitchNetwork":
        return x`<w3m-network-switch-view></w3m-network-switch-view>`;
      case "Account":
        return x`<w3m-account-view></w3m-account-view>`;
      case "WhatIsAWallet":
        return x`<w3m-what-is-a-wallet-view></w3m-what-is-a-wallet-view>`;
      case "WhatIsANetwork":
        return x`<w3m-what-is-a-network-view></w3m-what-is-a-network-view>`;
      case "GetWallet":
        return x`<w3m-get-wallet-view></w3m-get-wallet-view>`;
      case "Downloads":
        return x`<w3m-downloads-view></w3m-downloads-view>`;
      case "EmailVerifyOtp":
        return x`<w3m-email-verify-otp-view></w3m-email-verify-otp-view>`;
      case "EmailVerifyDevice":
        return x`<w3m-email-verify-device-view></w3m-email-verify-device-view>`;
      case "ApproveTransaction":
        return x`<w3m-approve-transaction-view></w3m-approve-transaction-view>`;
      case "Transactions":
        return x`<w3m-transactions-view></w3m-transactions-view>`;
      case "UpgradeEmailWallet":
        return x`<w3m-upgrade-wallet-view></w3m-upgrade-wallet-view>`;
      case "UpdateEmailWallet":
        return x`<w3m-update-email-wallet-view></w3m-update-email-wallet-view>`;
      case "UpdateEmailWalletWaiting":
        return x`<w3m-update-email-wallet-waiting-view></w3m-update-email-wallet-waiting-view>`;
      default:
        return x`<w3m-connect-view></w3m-connect-view>`;
    }
  }
  async onViewChange(newView) {
    const { history } = RouterController.state;
    let xOut = -10;
    let xIn = 10;
    if (history.length < this.prevHistoryLength) {
      xOut = 10;
      xIn = -10;
    }
    this.prevHistoryLength = history.length;
    await this.animate([
      { opacity: 1, transform: "translateX(0px)" },
      { opacity: 0, transform: `translateX(${xOut}px)` }
    ], { duration: 150, easing: "ease", fill: "forwards" }).finished;
    this.view = newView;
    await this.animate([
      { opacity: 0, transform: `translateX(${xIn}px)` },
      { opacity: 1, transform: "translateX(0px)" }
    ], { duration: 150, easing: "ease", fill: "forwards", delay: 50 }).finished;
  }
  getWrapper() {
    return this.shadowRoot?.querySelector("div");
  }
};
W3mRouter.styles = styles$k;
__decorate$B([
  r$1()
], W3mRouter.prototype, "view", void 0);
W3mRouter = __decorate$B([
  customElement("w3m-router")
], W3mRouter);
const styles$j = i$4`
  wui-flex {
    width: 100%;
  }

  :host > wui-flex:first-child {
    transform: translateY(calc(var(--wui-spacing-xxs) * -1));
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  wui-notice-card {
    margin-bottom: var(--wui-spacing-3xs);
  }
`;
var __decorate$A = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAccountView = class W3mAccountView2 extends s$1 {
  constructor() {
    super();
    this.usubscribe = [];
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.balance = AccountController.state.balance;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.network = NetworkController.state.caipNetwork;
    this.disconecting = false;
    this.usubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileImage = val.profileImage;
          this.profileName = val.profileName;
          this.balance = val.balance;
          this.balanceSymbol = val.balanceSymbol;
        } else {
          ModalController.close();
        }
      })
    ], NetworkController.subscribeKey("caipNetwork", (val) => {
      if (val?.id) {
        this.network = val;
      }
    }));
  }
  disconnectedCallback() {
    this.usubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.address) {
      throw new Error("w3m-account-view: No account provided");
    }
    const networkImage = AssetUtil.getNetworkImage(this.network);
    return x`
      <wui-flex
        flexDirection="column"
        .padding=${["0", "s", "m", "s"]}
        alignItems="center"
        gap="l"
      >
        <wui-avatar
          alt=${this.address}
          address=${this.address}
          imageSrc=${o$2(this.profileImage === null ? void 0 : this.profileImage)}
        ></wui-avatar>

        <wui-flex flexDirection="column" alignItems="center">
          <wui-flex gap="3xs" alignItems="center" justifyContent="center">
            <wui-text variant="large-600" color="fg-100">
              ${this.profileName ? UiHelperUtil.getTruncateString({
      string: this.profileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}
            </wui-text>
            <wui-icon-link
              size="md"
              icon="copy"
              iconColor="fg-200"
              @click=${this.onCopyAddress}
            ></wui-icon-link>
          </wui-flex>
          <wui-flex gap="s" flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-500" color="fg-200">
              ${CoreHelperUtil.formatBalance(this.balance, this.balanceSymbol)}
            </wui-text>

            ${this.explorerBtnTemplate()}
          </wui-flex>
        </wui-flex>
      </wui-flex>

      <wui-flex flexDirection="column" gap="xs" .padding=${["0", "s", "s", "s"]}>
        ${this.emailCardTemplate()} ${this.emailBtnTemplate()}

        <wui-list-item
          .variant=${networkImage ? "image" : "icon"}
          iconVariant="overlay"
          icon="networkPlaceholder"
          imageSrc=${o$2(networkImage)}
          ?chevron=${this.isAllowedNetworkSwitch()}
          @click=${this.onNetworks.bind(this)}
          data-testid="w3m-account-select-network"
        >
          <wui-text variant="paragraph-500" color="fg-100">
            ${this.network?.name ?? "Unknown"}
          </wui-text>
        </wui-list-item>
        <wui-list-item
          iconVariant="blue"
          icon="swapHorizontalBold"
          iconSize="sm"
          ?chevron=${true}
          @click=${this.onTransactions.bind(this)}
        >
          <wui-text variant="paragraph-500" color="fg-100">Activity</wui-text>
        </wui-list-item>
        <wui-list-item
          variant="icon"
          iconVariant="overlay"
          icon="disconnect"
          ?chevron=${false}
          .loading=${this.disconecting}
          @click=${this.onDisconnect.bind(this)}
          data-testid="disconnect-button"
        >
          <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
        </wui-list-item>
      </wui-flex>
    `;
  }
  emailCardTemplate() {
    const type = StorageUtil.getConnectedConnector();
    const emailConnector = ConnectorController.getEmailConnector();
    const { origin } = location;
    if (!emailConnector || type !== "EMAIL" || origin.includes(ConstantsUtil$1.SECURE_SITE)) {
      return null;
    }
    return x`
      <wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a non-custodial wallet"
        icon="wallet"
      ></wui-notice-card>
    `;
  }
  emailBtnTemplate() {
    const type = StorageUtil.getConnectedConnector();
    const emailConnector = ConnectorController.getEmailConnector();
    if (!emailConnector || type !== "EMAIL") {
      return null;
    }
    const email = emailConnector.provider.getEmail() ?? "";
    return x`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="mail"
        iconSize="sm"
        ?chevron=${true}
        @click=${() => this.onGoToUpdateEmail(email)}
      >
        <wui-text variant="paragraph-500" color="fg-100">${email}</wui-text>
      </wui-list-item>
    `;
  }
  explorerBtnTemplate() {
    const { addressExplorerUrl } = AccountController.state;
    if (!addressExplorerUrl) {
      return null;
    }
    return x`
      <wui-button size="sm" variant="shade" @click=${this.onExplorer.bind(this)}>
        <wui-icon size="sm" color="inherit" slot="iconLeft" name="compass"></wui-icon>
        Block Explorer
        <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
      </wui-button>
    `;
  }
  isAllowedNetworkSwitch() {
    const { requestedCaipNetworks } = NetworkController.state;
    const isMultiNetwork = requestedCaipNetworks ? requestedCaipNetworks.length > 1 : false;
    const isValidNetwork = requestedCaipNetworks?.find(({ id: id2 }) => id2 === this.network?.id);
    return isMultiNetwork || !isValidNetwork;
  }
  onCopyAddress() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
  onNetworks() {
    if (this.isAllowedNetworkSwitch()) {
      RouterController.push("Networks");
    }
  }
  onTransactions() {
    EventsController.sendEvent({ type: "track", event: "CLICK_TRANSACTIONS" });
    RouterController.push("Transactions");
  }
  async onDisconnect() {
    try {
      this.disconecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_SUCCESS" });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconecting = false;
    }
  }
  onExplorer() {
    const { addressExplorerUrl } = AccountController.state;
    if (addressExplorerUrl) {
      CoreHelperUtil.openHref(addressExplorerUrl, "_blank");
    }
  }
  onGoToUpgradeView() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_UPGRADE_FROM_MODAL" });
    RouterController.push("UpgradeEmailWallet");
  }
  onGoToUpdateEmail(email) {
    RouterController.push("UpdateEmailWallet", { email });
  }
};
W3mAccountView.styles = styles$j;
__decorate$A([
  r$1()
], W3mAccountView.prototype, "address", void 0);
__decorate$A([
  r$1()
], W3mAccountView.prototype, "profileImage", void 0);
__decorate$A([
  r$1()
], W3mAccountView.prototype, "profileName", void 0);
__decorate$A([
  r$1()
], W3mAccountView.prototype, "balance", void 0);
__decorate$A([
  r$1()
], W3mAccountView.prototype, "balanceSymbol", void 0);
__decorate$A([
  r$1()
], W3mAccountView.prototype, "network", void 0);
__decorate$A([
  r$1()
], W3mAccountView.prototype, "disconecting", void 0);
W3mAccountView = __decorate$A([
  customElement("w3m-account-view")
], W3mAccountView);
var __decorate$z = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAllWalletsView = class W3mAllWalletsView2 extends s$1 {
  constructor() {
    super(...arguments);
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
      this.search = value;
    });
  }
  render() {
    const isSearch = this.search.length >= 2;
    return x`
      <wui-flex padding="s" gap="s">
        <wui-search-bar @inputChange=${this.onInputChange.bind(this)}></wui-search-bar>
        ${this.qrButtonTemplate()}
      </wui-flex>
      ${isSearch ? x`<w3m-all-wallets-search query=${this.search}></w3m-all-wallets-search>` : x`<w3m-all-wallets-list></w3m-all-wallets-list>`}
    `;
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  qrButtonTemplate() {
    if (CoreHelperUtil.isMobile()) {
      return x`
        <wui-icon-box
          size="lg"
          iconSize="xl"
          iconColor="accent-100"
          backgroundColor="accent-100"
          icon="qrCode"
          background="transparent"
          border
          borderColor="wui-accent-glass-010"
          @click=${this.onWalletConnectQr.bind(this)}
        ></wui-icon-box>
      `;
    }
    return null;
  }
  onWalletConnectQr() {
    RouterController.push("ConnectingWalletConnect");
  }
};
__decorate$z([
  r$1()
], W3mAllWalletsView.prototype, "search", void 0);
W3mAllWalletsView = __decorate$z([
  customElement("w3m-all-wallets-view")
], W3mAllWalletsView);
const styles$i = i$4`
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$y = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectView = class W3mConnectView2 extends s$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        <w3m-email-login-widget></w3m-email-login-widget>

        ${this.walletConnectConnectorTemplate()} ${this.recentTemplate()}
        ${this.announcedTemplate()} ${this.injectedTemplate()} ${this.featuredTemplate()}
        ${this.customTemplate()} ${this.recommendedTemplate()} ${this.externalTemplate()}
        ${this.allWalletsTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  walletConnectConnectorTemplate() {
    if (CoreHelperUtil.isMobile()) {
      return null;
    }
    const connector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    if (!connector) {
      return null;
    }
    return x`
      <wui-list-wallet
        imageSrc=${o$2(AssetUtil.getConnectorImage(connector))}
        name=${connector.name ?? "Unknown"}
        @click=${() => this.onConnector(connector)}
        tagLabel="qr code"
        tagVariant="main"
        data-testid="wallet-selector-walletconnect"
      >
      </wui-list-wallet>
    `;
  }
  customTemplate() {
    const { customWallets } = OptionsController.state;
    if (!customWallets?.length) {
      return null;
    }
    const wallets = this.filterOutDuplicateWallets(customWallets);
    return wallets.map((wallet) => x`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getWalletImage(wallet))}
          name=${wallet.name ?? "Unknown"}
          @click=${() => this.onConnectWallet(wallet)}
        >
        </wui-list-wallet>
      `);
  }
  featuredTemplate() {
    const connector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    if (!connector) {
      return null;
    }
    const { featured } = ApiController.state;
    if (!featured.length) {
      return null;
    }
    const wallets = this.filterOutDuplicateWallets(featured);
    return wallets.map((wallet) => x`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getWalletImage(wallet))}
          name=${wallet.name ?? "Unknown"}
          @click=${() => this.onConnectWallet(wallet)}
        >
        </wui-list-wallet>
      `);
  }
  recentTemplate() {
    const recent = StorageUtil.getRecentWallets();
    return recent.map((wallet) => x`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getWalletImage(wallet))}
          name=${wallet.name ?? "Unknown"}
          @click=${() => this.onConnectWallet(wallet)}
          tagLabel="recent"
          tagVariant="shade"
        >
        </wui-list-wallet>
      `);
  }
  announcedTemplate() {
    return this.connectors.map((connector) => {
      if (connector.type !== "ANNOUNCED") {
        return null;
      }
      return x`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getConnectorImage(connector))}
          name=${connector.name ?? "Unknown"}
          @click=${() => this.onConnector(connector)}
          tagVariant="success"
          .installed=${true}
        >
        </wui-list-wallet>
      `;
    });
  }
  injectedTemplate() {
    return this.connectors.map((connector) => {
      if (connector.type !== "INJECTED") {
        return null;
      }
      if (!ConnectionController.checkInstalled()) {
        return null;
      }
      return x`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getConnectorImage(connector))}
          .installed=${true}
          name=${connector.name ?? "Unknown"}
          @click=${() => this.onConnector(connector)}
        >
        </wui-list-wallet>
      `;
    });
  }
  externalTemplate() {
    const announcedRdns = ConnectorController.getAnnouncedConnectorRdns();
    return this.connectors.map((connector) => {
      if (["WALLET_CONNECT", "INJECTED", "ANNOUNCED", "EMAIL"].includes(connector.type)) {
        return null;
      }
      if (announcedRdns.includes(ConstantsUtil$1.CONNECTOR_RDNS_MAP[connector.id])) {
        return null;
      }
      return x`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getConnectorImage(connector))}
          name=${connector.name ?? "Unknown"}
          @click=${() => this.onConnector(connector)}
        >
        </wui-list-wallet>
      `;
    });
  }
  allWalletsTemplate() {
    const connector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    if (!connector) {
      return null;
    }
    const count = ApiController.state.count;
    const featuredCount = ApiController.state.featured.length;
    const rawCount = count + featuredCount;
    const roundedCount = rawCount < 10 ? rawCount : Math.floor(rawCount / 10) * 10;
    const tagLabel = roundedCount < rawCount ? `${roundedCount}+` : `${roundedCount}`;
    return x`
      <wui-list-wallet
        name="All Wallets"
        walletIcon="allWallets"
        showAllWallets
        @click=${this.onAllWallets.bind(this)}
        tagLabel=${tagLabel}
        tagVariant="shade"
        data-testid="all-wallets"
      ></wui-list-wallet>
    `;
  }
  recommendedTemplate() {
    const connector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    if (!connector) {
      return null;
    }
    const { recommended } = ApiController.state;
    const { customWallets, featuredWalletIds } = OptionsController.state;
    const { connectors } = ConnectorController.state;
    const recent = StorageUtil.getRecentWallets();
    const injected = connectors.filter((c2) => c2.type === "INJECTED");
    const eip6963 = connectors.filter((c2) => c2.type === "ANNOUNCED");
    if (featuredWalletIds || customWallets || !recommended.length) {
      return null;
    }
    const eip6963Amount = eip6963.length || Math.max(0, injected.length - 1);
    const overrideLength = eip6963Amount + recent.length;
    const maxRecommended = Math.max(0, 2 - overrideLength);
    const wallets = this.filterOutDuplicateWallets(recommended).slice(0, maxRecommended);
    return wallets.map((wallet) => x`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getWalletImage(wallet))}
          name=${wallet?.name ?? "Unknown"}
          @click=${() => this.onConnectWallet(wallet)}
        >
        </wui-list-wallet>
      `);
  }
  onConnector(connector) {
    if (connector.type === "WALLET_CONNECT") {
      if (CoreHelperUtil.isMobile()) {
        RouterController.push("AllWallets");
      } else {
        RouterController.push("ConnectingWalletConnect");
      }
    } else {
      RouterController.push("ConnectingExternal", { connector });
    }
  }
  filterOutDuplicateWallets(wallets) {
    const { connectors } = ConnectorController.state;
    const recent = StorageUtil.getRecentWallets();
    const recentIds = recent.map((wallet) => wallet.id);
    const filtered = wallets.filter((wallet) => !recentIds.includes(wallet.id) && !connectors.find((c2) => c2.id === wallet.rdns || c2?.info?.rdns === wallet.rdns));
    return filtered;
  }
  onAllWallets() {
    EventsController.sendEvent({ type: "track", event: "CLICK_ALL_WALLETS" });
    RouterController.push("AllWallets");
  }
  onConnectWallet(wallet) {
    RouterController.push("ConnectingWalletConnect", { wallet });
  }
};
W3mConnectView.styles = styles$i;
__decorate$y([
  r$1()
], W3mConnectView.prototype, "connectors", void 0);
W3mConnectView = __decorate$y([
  customElement("w3m-connect-view")
], W3mConnectView);
const styles$h = i$4`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }
`;
var __decorate$x = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
class W3mConnectingWidget extends s$1 {
  constructor() {
    super();
    this.wallet = RouterController.state.data?.wallet;
    this.connector = RouterController.state.data?.connector;
    this.timeout = void 0;
    this.secondaryBtnLabel = "Try again";
    this.secondaryBtnIcon = "refresh";
    this.secondaryLabel = "Accept connection request in the wallet";
    this.onConnect = void 0;
    this.onRender = void 0;
    this.onAutoConnect = void 0;
    this.isWalletConnect = true;
    this.unsubscribe = [];
    this.imageSrc = AssetUtil.getWalletImage(this.wallet) ?? AssetUtil.getConnectorImage(this.connector);
    this.name = this.wallet?.name ?? this.connector?.name ?? "Wallet";
    this.isRetrying = false;
    this.uri = ConnectionController.state.wcUri;
    this.error = ConnectionController.state.wcError;
    this.ready = false;
    this.showRetry = false;
    this.buffering = false;
    this.isMobile = false;
    this.onRetry = void 0;
    this.unsubscribe.push(...[
      ConnectionController.subscribeKey("wcUri", (val) => {
        this.uri = val;
        if (this.isRetrying && this.onRetry) {
          this.isRetrying = false;
          this.onConnect?.();
        }
      }),
      ConnectionController.subscribeKey("wcError", (val) => this.error = val),
      ConnectionController.subscribeKey("buffering", (val) => this.buffering = val)
    ]);
  }
  firstUpdated() {
    this.onAutoConnect?.();
    this.showRetry = !this.onAutoConnect;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    clearTimeout(this.timeout);
  }
  render() {
    this.onRender?.();
    this.onShowRetry();
    const subLabel = this.error ? "Connection can be declined if a previous request is still active" : this.secondaryLabel;
    let label = `Continue in ${this.name}`;
    if (this.buffering) {
      label = "Connecting...";
    }
    if (this.error) {
      label = "Connection declined";
    }
    return x`
      <wui-flex
        data-error=${o$2(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image size="lg" imageSrc=${o$2(this.imageSrc)}></wui-wallet-image>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${label}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        <wui-button
          variant="accent"
          ?disabled=${!this.error && this.buffering}
          @click=${this.onTryAgain.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name=${this.secondaryBtnIcon}></wui-icon>
          ${this.secondaryBtnLabel}
        </wui-button>
      </wui-flex>

      ${this.isWalletConnect ? x`
            <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
              <wui-link @click=${this.onCopyUri} color="fg-200">
                <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
                Copy link
              </wui-link>
            </wui-flex>
          ` : null}

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
  onShowRetry() {
    if (this.error && !this.showRetry) {
      this.showRetry = true;
      const retryButton = this.shadowRoot?.querySelector("wui-button");
      retryButton?.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  onTryAgain() {
    if (!this.buffering) {
      ConnectionController.setWcError(false);
      if (this.onRetry) {
        this.isRetrying = true;
        this.onRetry?.();
      } else {
        this.onConnect?.();
      }
    }
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return x`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  onCopyUri() {
    try {
      if (this.uri) {
        CoreHelperUtil.copyToClopboard(this.uri);
        SnackController.showSuccess("Link copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
}
W3mConnectingWidget.styles = styles$h;
__decorate$x([
  r$1()
], W3mConnectingWidget.prototype, "uri", void 0);
__decorate$x([
  r$1()
], W3mConnectingWidget.prototype, "error", void 0);
__decorate$x([
  r$1()
], W3mConnectingWidget.prototype, "ready", void 0);
__decorate$x([
  r$1()
], W3mConnectingWidget.prototype, "showRetry", void 0);
__decorate$x([
  r$1()
], W3mConnectingWidget.prototype, "buffering", void 0);
__decorate$x([
  n$2({ type: Boolean })
], W3mConnectingWidget.prototype, "isMobile", void 0);
__decorate$x([
  n$2()
], W3mConnectingWidget.prototype, "onRetry", void 0);
var __decorate$w = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const platformMap = {
  INJECTED: "browser",
  ANNOUNCED: "browser"
};
let W3mConnectingExternalView = class W3mConnectingExternalView2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.connector) {
      throw new Error("w3m-connecting-view: No connector provided");
    }
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: {
        name: this.connector.name ?? "Unknown",
        platform: platformMap[this.connector.type] ?? "external"
      }
    });
    this.onConnect = this.onConnectProxy.bind(this);
    this.onAutoConnect = this.onConnectProxy.bind(this);
    this.isWalletConnect = false;
  }
  async onConnectProxy() {
    try {
      this.error = false;
      if (this.connector) {
        if (this.connector.imageUrl) {
          StorageUtil.setConnectedWalletImageUrl(this.connector.imageUrl);
        }
        await ConnectionController.connectExternal(this.connector);
        if (SIWEController.state.isSiweEnabled) {
          RouterController.push("ConnectingSiwe");
        } else {
          ModalController.close();
        }
        EventsController.sendEvent({
          type: "track",
          event: "CONNECT_SUCCESS",
          properties: { method: "external" }
        });
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: error?.message ?? "Unknown" }
      });
      this.error = true;
    }
  }
};
W3mConnectingExternalView = __decorate$w([
  customElement("w3m-connecting-external-view")
], W3mConnectingExternalView);
var __decorate$v = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingSiweView = class W3mConnectingSiweView2 extends s$1 {
  constructor() {
    super(...arguments);
    this.dappName = OptionsController.state.metadata?.name;
    this.isSigning = false;
  }
  render() {
    return x`
      <wui-flex justifyContent="center" .padding=${["2xl", "0", "xxl", "0"]}>
        <w3m-connecting-siwe></w3m-connecting-siwe>
      </wui-flex>
      <wui-flex
        .padding=${["0", "4xl", "l", "4xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100"
          >${this.dappName ?? "Dapp"} needs to connect to your wallet</wui-text
        >
      </wui-flex>
      <wui-flex
        .padding=${["0", "3xl", "l", "3xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="small-400" align="center" color="fg-200"
          >Sign this message to prove you own this wallet and proceed. Canceling will disconnect
          you.</wui-text
        >
      </wui-flex>
      <wui-flex .padding=${["l", "xl", "xl", "xl"]} gap="s" justifyContent="space-between">
        <wui-button
          size="md"
          ?fullwidth=${true}
          variant="shade"
          @click=${this.onCancel.bind(this)}
          data-testid="w3m-connecting-siwe-cancel"
        >
          Cancel
        </wui-button>
        <wui-button
          size="md"
          ?fullwidth=${true}
          variant="fill"
          @click=${this.onSign.bind(this)}
          ?loading=${this.isSigning}
          data-testid="w3m-connecting-siwe-sign"
        >
          ${this.isSigning ? "Signing..." : "Sign"}
        </wui-button>
      </wui-flex>
    `;
  }
  async onSign() {
    this.isSigning = true;
    EventsController.sendEvent({
      event: "CLICK_SIGN_SIWE_MESSAGE",
      type: "track"
    });
    try {
      SIWEController.setStatus("loading");
      const session = await SIWEController.signIn();
      SIWEController.setStatus("success");
      EventsController.sendEvent({
        event: "SIWE_AUTH_SUCCESS",
        type: "track"
      });
      return session;
    } catch (error) {
      SnackController.showError("Signature declined");
      SIWEController.setStatus("error");
      return EventsController.sendEvent({
        event: "SIWE_AUTH_ERROR",
        type: "track"
      });
    } finally {
      this.isSigning = false;
    }
  }
  async onCancel() {
    const { isConnected } = AccountController.state;
    if (isConnected) {
      await ConnectionController.disconnect();
      ModalController.close();
    } else {
      RouterController.push("Connect");
    }
    EventsController.sendEvent({
      event: "CLICK_CANCEL_SIWE",
      type: "track"
    });
  }
};
__decorate$v([
  r$1()
], W3mConnectingSiweView.prototype, "isSigning", void 0);
W3mConnectingSiweView = __decorate$v([
  customElement("w3m-connecting-siwe-view")
], W3mConnectingSiweView);
var __decorate$u = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcView = class W3mConnectingWcView2 extends s$1 {
  constructor() {
    super();
    this.interval = void 0;
    this.lastRetry = Date.now();
    this.wallet = RouterController.state.data?.wallet;
    this.platform = void 0;
    this.platforms = [];
    this.initializeConnection();
    this.interval = setInterval(this.initializeConnection.bind(this), ConstantsUtil$1.TEN_SEC_MS);
  }
  disconnectedCallback() {
    clearTimeout(this.interval);
  }
  render() {
    if (!this.wallet) {
      return x`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
    }
    this.determinePlatforms();
    return x`
      ${this.headerTemplate()}
      <div>${this.platformTemplate()}</div>
    `;
  }
  async initializeConnection(retry2 = false) {
    try {
      const { wcPairingExpiry } = ConnectionController.state;
      if (retry2 || CoreHelperUtil.isPairingExpired(wcPairingExpiry)) {
        ConnectionController.connectWalletConnect();
        if (this.wallet) {
          const url = AssetUtil.getWalletImage(this.wallet);
          if (url) {
            StorageUtil.setConnectedWalletImageUrl(url);
          }
        } else {
          const connectors = ConnectorController.state.connectors;
          const connector = connectors.find((c2) => c2.type === "WALLET_CONNECT");
          const url = AssetUtil.getConnectorImage(connector);
          if (url) {
            StorageUtil.setConnectedWalletImageUrl(url);
          }
        }
        await ConnectionController.state.wcPromise;
        this.finalizeConnection();
        if (SIWEController.state.isSiweEnabled) {
          RouterController.push("ConnectingSiwe");
        } else {
          ModalController.close();
        }
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: error?.message ?? "Unknown" }
      });
      ConnectionController.setWcError(true);
      if (CoreHelperUtil.isAllowedRetry(this.lastRetry)) {
        SnackController.showError("Declined");
        this.lastRetry = Date.now();
        this.initializeConnection(true);
      }
    }
  }
  finalizeConnection() {
    const { wcLinking, recentWallet } = ConnectionController.state;
    if (wcLinking) {
      StorageUtil.setWalletConnectDeepLink(wcLinking);
    }
    if (recentWallet) {
      StorageUtil.setWeb3ModalRecent(recentWallet);
    }
    EventsController.sendEvent({
      type: "track",
      event: "CONNECT_SUCCESS",
      properties: {
        method: wcLinking ? "mobile" : "qrcode"
      }
    });
  }
  determinePlatforms() {
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-view:determinePlatforms No wallet");
    }
    if (this.platform) {
      return;
    }
    const { mobile_link, desktop_link, webapp_link, injected, rdns } = this.wallet;
    const injectedIds = injected?.map(({ injected_id }) => injected_id).filter(Boolean);
    const browserIds = rdns ? [rdns] : injectedIds ?? [];
    const isBrowser2 = browserIds.length;
    const isMobileWc = mobile_link;
    const isWebWc = webapp_link;
    const isBrowserInstalled = ConnectionController.checkInstalled(browserIds);
    const isBrowserWc = isBrowser2 && isBrowserInstalled;
    const isDesktopWc = desktop_link && !CoreHelperUtil.isMobile();
    if (isBrowserWc) {
      this.platforms.push("browser");
    }
    if (isMobileWc) {
      this.platforms.push(CoreHelperUtil.isMobile() ? "mobile" : "qrcode");
    }
    if (isWebWc) {
      this.platforms.push("web");
    }
    if (isDesktopWc) {
      this.platforms.push("desktop");
    }
    if (!isBrowserWc && isBrowser2) {
      this.platforms.push("unsupported");
    }
    this.platform = this.platforms[0];
  }
  platformTemplate() {
    switch (this.platform) {
      case "browser":
        return x`<w3m-connecting-wc-browser></w3m-connecting-wc-browser>`;
      case "desktop":
        return x`
          <w3m-connecting-wc-desktop .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-desktop>
        `;
      case "web":
        return x`
          <w3m-connecting-wc-web .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-web>
        `;
      case "mobile":
        return x`
          <w3m-connecting-wc-mobile isMobile .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-mobile>
        `;
      case "qrcode":
        return x`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
      default:
        return x`<w3m-connecting-wc-unsupported></w3m-connecting-wc-unsupported>`;
    }
  }
  headerTemplate() {
    const multiPlatform = this.platforms.length > 1;
    if (!multiPlatform) {
      return null;
    }
    return x`
      <w3m-connecting-header
        .platforms=${this.platforms}
        .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
      >
      </w3m-connecting-header>
    `;
  }
  async onSelectPlatform(platform) {
    const container = this.shadowRoot?.querySelector("div");
    if (container) {
      await container.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.platform = platform;
      container.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
__decorate$u([
  r$1()
], W3mConnectingWcView.prototype, "platform", void 0);
__decorate$u([
  r$1()
], W3mConnectingWcView.prototype, "platforms", void 0);
W3mConnectingWcView = __decorate$u([
  customElement("w3m-connecting-wc-view")
], W3mConnectingWcView);
var __decorate$t = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mDownloadsView = class W3mDownloadsView2 extends s$1 {
  constructor() {
    super(...arguments);
    this.wallet = RouterController.state.data?.wallet;
  }
  render() {
    if (!this.wallet) {
      throw new Error("w3m-downloads-view");
    }
    return x`
      <wui-flex gap="xs" flexDirection="column" .padding=${["s", "s", "l", "s"]}>
        ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
        ${this.homepageTemplate()}
      </wui-flex>
    `;
  }
  chromeTemplate() {
    if (!this.wallet?.chrome_store) {
      return null;
    }
    return x`<wui-list-item
      variant="icon"
      icon="chromeStore"
      iconVariant="square"
      @click=${this.onChromeStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Chrome Extension</wui-text>
    </wui-list-item>`;
  }
  iosTemplate() {
    if (!this.wallet?.app_store) {
      return null;
    }
    return x`<wui-list-item
      variant="icon"
      icon="appStore"
      iconVariant="square"
      @click=${this.onAppStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">iOS App</wui-text>
    </wui-list-item>`;
  }
  androidTemplate() {
    if (!this.wallet?.play_store) {
      return null;
    }
    return x`<wui-list-item
      variant="icon"
      icon="playStore"
      iconVariant="square"
      @click=${this.onPlayStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Android App</wui-text>
    </wui-list-item>`;
  }
  homepageTemplate() {
    if (!this.wallet?.homepage) {
      return null;
    }
    return x`
      <wui-list-item
        variant="icon"
        icon="browser"
        iconVariant="square-blue"
        @click=${this.onHomePage.bind(this)}
        chevron
      >
        <wui-text variant="paragraph-500" color="fg-100">Website</wui-text>
      </wui-list-item>
    `;
  }
  onChromeStore() {
    if (this.wallet?.chrome_store) {
      CoreHelperUtil.openHref(this.wallet.chrome_store, "_blank");
    }
  }
  onAppStore() {
    if (this.wallet?.app_store) {
      CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
    }
  }
  onPlayStore() {
    if (this.wallet?.play_store) {
      CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
    }
  }
  onHomePage() {
    if (this.wallet?.homepage) {
      CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
    }
  }
};
W3mDownloadsView = __decorate$t([
  customElement("w3m-downloads-view")
], W3mDownloadsView);
var __decorate$s = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const EXPLORER = "https://walletconnect.com/explorer";
let W3mGetWalletView = class W3mGetWalletView2 extends s$1 {
  render() {
    return x`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.recommendedWalletsTemplate()}
        <wui-list-wallet
          name="Explore all"
          showAllWallets
          walletIcon="allWallets"
          icon="externalLink"
          @click=${() => {
      CoreHelperUtil.openHref("https://walletconnect.com/explorer?type=wallet", "_blank");
    }}
        ></wui-list-wallet>
      </wui-flex>
    `;
  }
  recommendedWalletsTemplate() {
    const { recommended, featured } = ApiController.state;
    const { customWallets } = OptionsController.state;
    const wallets = [...featured, ...customWallets ?? [], ...recommended].slice(0, 4);
    return wallets.map((wallet) => x`
        <wui-list-wallet
          name=${wallet.name ?? "Unknown"}
          tagVariant="main"
          imageSrc=${o$2(AssetUtil.getWalletImage(wallet))}
          @click=${() => {
      CoreHelperUtil.openHref(wallet.homepage ?? EXPLORER, "_blank");
    }}
        ></wui-list-wallet>
      `);
  }
};
W3mGetWalletView = __decorate$s([
  customElement("w3m-get-wallet-view")
], W3mGetWalletView);
const styles$g = i$4`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: 4px;
    bottom: 0;
    opacity: 0;
    transform: scale(0.5);
    z-index: 1;
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-button {
    display: none;
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  wui-button[data-retry='true'] {
    display: block;
    opacity: 1;
  }
`;
var __decorate$r = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mNetworkSwitchView = class W3mNetworkSwitchView2 extends s$1 {
  constructor() {
    super();
    this.network = RouterController.state.data?.network;
    this.unsubscribe = [];
    this.showRetry = false;
    this.error = false;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  firstUpdated() {
    this.onSwitchNetwork();
  }
  render() {
    if (!this.network) {
      throw new Error("w3m-network-switch-view: No network provided");
    }
    this.onShowRetry();
    const label = this.error ? "Switch declined" : "Approve in wallet";
    const subLabel = this.error ? "Switch can be declined if chain is not supported by a wallet or previous request is still active" : "Accept connection request in your wallet";
    return x`
      <wui-flex
        data-error=${this.error}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-network-image
            size="lg"
            imageSrc=${o$2(AssetUtil.getNetworkImage(this.network))}
          ></wui-network-image>

          ${this.error ? null : x`<wui-loading-hexagon></wui-loading-hexagon>`}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            ?border=${true}
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">${label}</wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        <wui-button
          data-retry=${this.showRetry}
          variant="fill"
          .disabled=${!this.error}
          @click=${this.onSwitchNetwork.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
          Try again
        </wui-button>
      </wui-flex>
    `;
  }
  onShowRetry() {
    if (this.error && !this.showRetry) {
      this.showRetry = true;
      const retryButton = this.shadowRoot?.querySelector("wui-button");
      retryButton?.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  async onSwitchNetwork() {
    try {
      this.error = false;
      if (this.network) {
        await NetworkController.switchActiveNetwork(this.network);
        if (!SIWEController.state.isSiweEnabled) {
          RouterUtil.navigateAfterNetworkSwitch();
        }
      }
    } catch {
      this.error = true;
    }
  }
};
W3mNetworkSwitchView.styles = styles$g;
__decorate$r([
  r$1()
], W3mNetworkSwitchView.prototype, "showRetry", void 0);
__decorate$r([
  r$1()
], W3mNetworkSwitchView.prototype, "error", void 0);
W3mNetworkSwitchView = __decorate$r([
  customElement("w3m-network-switch-view")
], W3mNetworkSwitchView);
const styles$f = i$4`
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$q = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mNetworksView = class W3mNetworksView2 extends s$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.caipNetwork = NetworkController.state.caipNetwork;
    this.unsubscribe.push(NetworkController.subscribeKey("caipNetwork", (val) => this.caipNetwork = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`
      <wui-grid padding="s" gridTemplateColumns="repeat(4, 1fr)" rowGap="l" columnGap="xs">
        ${this.networksTemplate()}
      </wui-grid>

      <wui-separator></wui-separator>

      <wui-flex padding="s" flexDirection="column" gap="m" alignItems="center">
        <wui-text variant="small-400" color="fg-300" align="center">
          Your connected wallet may not support some of the networks available for this dApp
        </wui-text>
        <wui-link @click=${this.onNetworkHelp.bind(this)}>
          <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
          What is a network
        </wui-link>
      </wui-flex>
    `;
  }
  onNetworkHelp() {
    EventsController.sendEvent({ type: "track", event: "CLICK_NETWORK_HELP" });
    RouterController.push("WhatIsANetwork");
  }
  networksTemplate() {
    const { approvedCaipNetworkIds, requestedCaipNetworks, supportsAllNetworks } = NetworkController.state;
    const approvedIds = approvedCaipNetworkIds;
    const requestedNetworks = requestedCaipNetworks;
    const approvedIndexMap = {};
    if (requestedNetworks && approvedIds) {
      approvedIds.forEach((id2, index2) => {
        approvedIndexMap[id2] = index2;
      });
      requestedNetworks.sort((a2, b3) => {
        const indexA = approvedIndexMap[a2.id];
        const indexB = approvedIndexMap[b3.id];
        if (indexA !== void 0 && indexB !== void 0) {
          return indexA - indexB;
        } else if (indexA !== void 0) {
          return -1;
        } else if (indexB !== void 0) {
          return 1;
        }
        return 0;
      });
    }
    return requestedNetworks?.map((network) => x`
        <wui-card-select
          .selected=${this.caipNetwork?.id === network.id}
          imageSrc=${o$2(AssetUtil.getNetworkImage(network))}
          type="network"
          name=${network.name ?? network.id}
          @click=${() => this.onSwitchNetwork(network)}
          .disabled=${!supportsAllNetworks && !approvedIds?.includes(network.id)}
          data-testid=${`w3m-network-switch-${network.name ?? network.id}`}
        ></wui-card-select>
      `);
  }
  async onSwitchNetwork(network) {
    const { isConnected } = AccountController.state;
    const { approvedCaipNetworkIds, supportsAllNetworks, caipNetwork } = NetworkController.state;
    const { data: data2 } = RouterController.state;
    if (isConnected && caipNetwork?.id !== network.id) {
      if (approvedCaipNetworkIds?.includes(network.id)) {
        await NetworkController.switchActiveNetwork(network);
        RouterUtil.navigateAfterNetworkSwitch();
      } else if (supportsAllNetworks) {
        RouterController.push("SwitchNetwork", { ...data2, network });
      }
    } else if (!isConnected) {
      NetworkController.setCaipNetwork(network);
      RouterController.push("Connect");
    }
  }
};
W3mNetworksView.styles = styles$f;
__decorate$q([
  r$1()
], W3mNetworksView.prototype, "caipNetwork", void 0);
W3mNetworksView = __decorate$q([
  customElement("w3m-networks-view")
], W3mNetworksView);
const styles$e = i$4`
  :host > wui-flex:first-child {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }
`;
var __decorate$p = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const PAGINATOR_ID$1 = "last-transaction";
const LOADING_ITEM_COUNT = 7;
let W3mTransactionsView = class W3mTransactionsView2 extends s$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.paginationObserver = void 0;
    this.address = AccountController.state.address;
    this.transactions = TransactionsController.state.transactions;
    this.transactionsByYear = TransactionsController.state.transactionsByYear;
    this.loading = TransactionsController.state.loading;
    this.empty = TransactionsController.state.empty;
    this.next = TransactionsController.state.next;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.isConnected) {
          if (this.address !== val.address) {
            this.address = val.address;
            TransactionsController.resetTransactions();
            TransactionsController.fetchTransactions(val.address);
          }
        }
      }),
      TransactionsController.subscribe((val) => {
        this.transactions = val.transactions;
        this.transactionsByYear = val.transactionsByYear;
        this.loading = val.loading;
        this.empty = val.empty;
        this.next = val.next;
      })
    ]);
  }
  firstUpdated() {
    if (this.transactions.length === 0) {
      TransactionsController.fetchTransactions(this.address);
    }
    this.createPaginationObserver();
  }
  updated() {
    this.setPaginationObserver();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`
      <wui-flex flexDirection="column" padding="s" gap="s">
        ${this.empty ? null : this.templateTransactionsByYear()}
        ${this.loading ? this.templateLoading() : null}
        ${!this.loading && this.empty ? this.templateEmpty() : null}
      </wui-flex>
    `;
  }
  templateTransactionsByYear() {
    const sortedYearKeys = Object.keys(this.transactionsByYear).sort().reverse();
    return sortedYearKeys.map((year, index2) => {
      const isLastGroup = index2 === sortedYearKeys.length - 1;
      const yearInt = parseInt(year, 10);
      const groupTitle = TransactionUtil.getTransactionGroupTitle(yearInt);
      const transactions = this.transactionsByYear[yearInt];
      if (!transactions) {
        return null;
      }
      return x`
        <wui-flex flexDirection="column" gap="s">
          <wui-flex
            alignItems="center"
            flexDirection="row"
            .padding=${["xs", "s", "s", "s"]}
          >
            <wui-text variant="paragraph-500" color="fg-200">${groupTitle}</wui-text>
          </wui-flex>
          <wui-flex flexDirection="column" gap="xs">
            ${this.templateTransactions(transactions, isLastGroup)}
          </wui-flex>
        </wui-flex>
      `;
    });
  }
  templateRenderTransaction(transaction, isLastTransaction) {
    const { date, descriptions, direction, isAllNFT, images, status, transfers, type } = this.getTransactionListItemProps(transaction);
    const haveMultipleTransfers = transfers?.length > 1;
    const haveTwoTransfers = transfers?.length === 2;
    if (haveTwoTransfers && !isAllNFT) {
      return x`
        <wui-transaction-list-item
          date=${date}
          .direction=${direction}
          id=${isLastTransaction && this.next ? PAGINATOR_ID$1 : ""}
          status=${status}
          type=${type}
          .images=${images}
          .descriptions=${descriptions}
        ></wui-transaction-list-item>
      `;
    }
    if (haveMultipleTransfers) {
      return transfers.map((transfer, index2) => {
        const description2 = TransactionUtil.getTransferDescription(transfer);
        const isLastTransfer = isLastTransaction && index2 === transfers.length - 1;
        return x` <wui-transaction-list-item
          date=${date}
          direction=${transfer.direction}
          id=${isLastTransfer && this.next ? PAGINATOR_ID$1 : ""}
          status=${status}
          type=${type}
          .onlyDirectionIcon=${true}
          .images=${[images?.[index2]]}
          .descriptions=${[description2]}
        ></wui-transaction-list-item>`;
      });
    }
    return x`
      <wui-transaction-list-item
        date=${date}
        .direction=${direction}
        id=${isLastTransaction && this.next ? PAGINATOR_ID$1 : ""}
        status=${status}
        type=${type}
        .images=${images}
        .descriptions=${descriptions}
      ></wui-transaction-list-item>
    `;
  }
  templateTransactions(transactions, isLastGroup) {
    return transactions.map((transaction, index2) => {
      const isLastTransaction = isLastGroup && index2 === transactions.length - 1;
      return x`${this.templateRenderTransaction(transaction, isLastTransaction)}`;
    });
  }
  templateEmpty() {
    return x`
      <wui-flex
        flexGrow="1"
        flexDirection="column"
        justifyContent="center"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <wui-icon-box
          backgroundColor="glass-005"
          background="gray"
          iconColor="fg-200"
          icon="wallet"
          size="lg"
          ?border=${true}
          borderColor="wui-color-bg-125"
        ></wui-icon-box>
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100"
            >No Transactions yet</wui-text
          >
          <wui-text align="center" variant="small-500" color="fg-200"
            >Start trading on dApps <br />
            to grow your wallet!</wui-text
          >
        </wui-flex>
      </wui-flex>
    `;
  }
  templateLoading() {
    return Array(LOADING_ITEM_COUNT).fill(x` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map((item) => item);
  }
  createPaginationObserver() {
    const { projectId: projectId2 } = OptionsController.state;
    this.paginationObserver = new IntersectionObserver(([element]) => {
      if (element?.isIntersecting && !this.loading) {
        TransactionsController.fetchTransactions(this.address);
        EventsController.sendEvent({
          type: "track",
          event: "LOAD_MORE_TRANSACTIONS",
          properties: {
            address: this.address,
            projectId: projectId2,
            cursor: this.next
          }
        });
      }
    }, {});
    this.setPaginationObserver();
  }
  setPaginationObserver() {
    this.paginationObserver?.disconnect();
    const lastItem = this.shadowRoot?.querySelector(`#${PAGINATOR_ID$1}`);
    if (lastItem) {
      this.paginationObserver?.observe(lastItem);
    }
  }
  getTransactionListItemProps(transaction) {
    const date = DateUtil.getRelativeDateFromNow(transaction?.metadata?.minedAt);
    const descriptions = TransactionUtil.getTransactionDescriptions(transaction);
    const transfers = transaction?.transfers;
    const transfer = transaction?.transfers?.[0];
    const isAllNFT = Boolean(transfer) && transaction?.transfers?.every((item) => Boolean(item.nft_info));
    const images = TransactionUtil.getTransactionImages(transfers);
    return {
      date,
      direction: transfer?.direction,
      descriptions,
      isAllNFT,
      images,
      status: transaction.metadata?.status,
      transfers,
      type: transaction.metadata?.operationType
    };
  }
};
W3mTransactionsView.styles = styles$e;
__decorate$p([
  r$1()
], W3mTransactionsView.prototype, "address", void 0);
__decorate$p([
  r$1()
], W3mTransactionsView.prototype, "transactions", void 0);
__decorate$p([
  r$1()
], W3mTransactionsView.prototype, "transactionsByYear", void 0);
__decorate$p([
  r$1()
], W3mTransactionsView.prototype, "loading", void 0);
__decorate$p([
  r$1()
], W3mTransactionsView.prototype, "empty", void 0);
__decorate$p([
  r$1()
], W3mTransactionsView.prototype, "next", void 0);
W3mTransactionsView = __decorate$p([
  customElement("w3m-transactions-view")
], W3mTransactionsView);
var __decorate$o = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const data$1 = [
  {
    images: ["network", "layers", "system"],
    title: "The systems nuts and bolts",
    text: "A network is what brings the blockchain to life, as this technical infrastructure allows apps to access the ledger and smart contract services."
  },
  {
    images: ["noun", "defiAlt", "dao"],
    title: "Designed for different uses",
    text: "Each network is designed differently, and may therefore suit certain apps and experiences."
  }
];
let W3mWhatIsANetworkView = class W3mWhatIsANetworkView2 extends s$1 {
  render() {
    return x`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data$1}></w3m-help-widget>
        <wui-button
          variant="fill"
          size="sm"
          @click=${() => {
      CoreHelperUtil.openHref("https://ethereum.org/en/developers/docs/networks/", "_blank");
    }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-button>
      </wui-flex>
    `;
  }
};
W3mWhatIsANetworkView = __decorate$o([
  customElement("w3m-what-is-a-network-view")
], W3mWhatIsANetworkView);
var __decorate$n = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const data = [
  {
    images: ["login", "profile", "lock"],
    title: "One login for all of web3",
    text: "Log in to any app by connecting your wallet. Say goodbye to countless passwords!"
  },
  {
    images: ["defi", "nft", "eth"],
    title: "A home for your digital assets",
    text: "A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs."
  },
  {
    images: ["browser", "noun", "dao"],
    title: "Your gateway to a new web",
    text: "With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more."
  }
];
let W3mWhatIsAWalletView = class W3mWhatIsAWalletView2 extends s$1 {
  render() {
    return x`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data}></w3m-help-widget>
        <wui-button variant="fill" size="sm" @click=${this.onGetWallet.bind(this)}>
          <wui-icon color="inherit" slot="iconLeft" name="wallet"></wui-icon>
          Get a wallet
        </wui-button>
      </wui-flex>
    `;
  }
  onGetWallet() {
    EventsController.sendEvent({ type: "track", event: "CLICK_GET_WALLET" });
    RouterController.push("GetWallet");
  }
};
W3mWhatIsAWalletView = __decorate$n([
  customElement("w3m-what-is-a-wallet-view")
], W3mWhatIsAWalletView);
const styles$d = i$4`
  wui-loading-spinner {
    margin: 9px auto;
  }
`;
const W3mFrameConstants = {
  SECURE_SITE_SDK: "https://secure.web3modal.com/sdk",
  APP_EVENT_KEY: "@w3m-app/",
  FRAME_EVENT_KEY: "@w3m-frame/",
  RPC_METHOD_KEY: "RPC_",
  STORAGE_KEY: "@w3m-storage/",
  SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
  EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
  LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
  LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
  EMAIL: "EMAIL",
  APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
  APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
  APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
  APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
  APP_GET_USER: "@w3m-app/GET_USER",
  APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
  APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
  APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
  APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
  APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
  APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
  APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
  APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
  FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
  FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
  FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
  FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
  FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
  FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
  FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
  FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
  FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
  FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
  FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
  FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
  FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
  FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
  FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
  FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
  FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
  FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
  FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
  FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
  FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
  FRAME_AWAIT_UPDATE_EMAIL_SUCCESS: "@w3m-frame/AWAIT_UPDATE_EMAIL_SUCCESS",
  FRAME_AWAIT_UPDATE_EMAIL_ERROR: "@w3m-frame/AWAIT_UPDATE_EMAIL_ERROR",
  FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
  FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
  FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
  FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR"
};
const W3mFrameRpcConstants = {
  SAFE_RPC_METHODS: ["eth_blockNumber", "eth_estimateGas", "eth_getTransactionByHash"],
  GET_CHAIN_ID: "eth_chainId"
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k4) => typeof obj[obj[k4]] !== "number");
    const filtered = {};
    for (const k4 of validKeys) {
      filtered[k4] = obj[k4];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key2 in object) {
      if (Object.prototype.hasOwnProperty.call(object, key2)) {
        keys.push(key2);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data2) => {
  const t2 = typeof data2;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data2) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data2)) {
        return ZodParsedType.array;
      }
      if (data2 === null) {
        return ZodParsedType.null;
      }
      if (data2.then && typeof data2.then === "function" && data2.catch && typeof data2.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data2 instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data2 instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data2 instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i3 = 0;
          while (i3 < issue.path.length) {
            const el2 = issue.path[i3];
            const terminal = i3 === issue.path.length - 1;
            if (!terminal) {
              curr[el2] = curr[el2] || { _errors: [] };
            } else {
              curr[el2] = curr[el2] || { _errors: [] };
              curr[el2]._errors.push(mapper(issue));
            }
            curr = curr[el2];
            i3++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data: data2, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data: data2, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s4 of results) {
      if (s4.status === "aborted")
        return INVALID;
      if (s4.status === "dirty")
        status.dirty();
      arrayValue.push(s4.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key: key2, value } = pair;
      if (key2.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key2.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key2.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key2.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x2) => x2.status === "aborted";
const isDirty = (x2) => x2.status === "dirty";
const isValid2 = (x2) => x2.status === "valid";
const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent2, value, path, key2) {
    this._cachedPath = [];
    this.parent = parent2;
    this.data = value;
    this._path = path;
    this._key = key2;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid2(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description: description2 } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description: description2 };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description: description2 };
}
class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data2, params) {
    const result = this.safeParse(data2, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data2, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    const result = this._parseSync({ data: data2, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data2, params) {
    const result = await this.safeParseAsync(data2, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data2, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    const maybeAsyncResult = this._parse({ data: data2, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data2) => {
          if (!data2) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description2) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description: description2
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex2 = datetimeRegex(check);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex2, validation, message) {
    return this.refinement((data2) => regex2.test(data2), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex2, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex2,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch2) => ch2.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch2) => ch2.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util.isInteger(ch2.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
        return true;
      } else if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      } else if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i3) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i3) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key2 in schema.shape) {
      const fieldSchema = schema.shape[key2];
      newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape2 = this._def.shape();
    const keys = util.objectKeys(shape2);
    return this._cached = { shape: shape2, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape: shape2, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key2 in ctx.data) {
        if (!shapeKeys.includes(key2)) {
          extraKeys.push(key2);
        }
      }
    }
    const pairs = [];
    for (const key2 of shapeKeys) {
      const keyValidator = shape2[key2];
      const value = ctx.data[key2];
      pairs.push({
        key: { status: "valid", value: key2 },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
        alwaysSet: key2 in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key2 of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key2 },
            value: { status: "valid", value: ctx.data[key2] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key2 of extraKeys) {
        const value = ctx.data[key2];
        pairs.push({
          key: { status: "valid", value: key2 },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key2)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key2 in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key2 = await pair.key;
          syncPairs.push({
            key: key2,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key2, schema) {
    return this.augment({ [key2]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape2 = {};
    util.objectKeys(mask).forEach((key2) => {
      if (mask[key2] && this.shape[key2]) {
        shape2[key2] = this.shape[key2];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape2
    });
  }
  omit(mask) {
    const shape2 = {};
    util.objectKeys(this.shape).forEach((key2) => {
      if (!mask[key2]) {
        shape2[key2] = this.shape[key2];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape2
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key2) => {
      const fieldSchema = this.shape[key2];
      if (mask && !mask[key2]) {
        newShape[key2] = fieldSchema;
      } else {
        newShape[key2] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key2) => {
      if (mask && !mask[key2]) {
        newShape[key2] = this.shape[key2];
      } else {
        const fieldSchema = this.shape[key2];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key2] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape2, params) => {
  return new ZodObject({
    shape: () => shape2,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape2, params) => {
  return new ZodObject({
    shape: () => shape2,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape2, params) => {
  return new ZodObject({
    shape: shape2,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types2, params) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a2, b3) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b3);
  if (a2 === b3) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b3);
    const sharedKeys = util.objectKeys(a2).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = { ...a2, ...b3 };
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a2[key2], b3[key2]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b3.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b3[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b3) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key2 in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key2, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key2 = await pair.key;
          const value = await pair.value;
          if (key2.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key2.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key2.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key2 = pair.key;
        const value = pair.value;
        if (key2.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key2.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key2.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i3) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i3)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn2 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me2 = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e2) => {
          error.addIssue(makeArgsIssue(args, e2));
          throw error;
        });
        const result = await Reflect.apply(fn2, this, parsedArgs);
        const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error.addIssue(makeReturnsIssue(result, e2));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me2 = this;
      return OK(function(...args) {
        const parsedArgs = me2._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn2, this, parsedArgs.data);
        const parsedReturns = me2._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values2, params) {
  return new ZodEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values2) {
    return ZodEnum.create(values2);
  }
  exclude(values2) {
    return ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values2, params) => {
  return new ZodNativeEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data2) => {
      return this._def.type.parseAsync(data2, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base3 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid2(base3))
          return base3;
        const result = effect.transform(base3.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base3) => {
          if (!isValid2(base3))
            return base3;
          return Promise.resolve(effect.transform(base3.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data2 = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data2 = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data: data2,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data2 = ctx.data;
    return this._def.type._parse({
      data: data2,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b3) {
    return new ZodPipeline({
      in: a2,
      out: b3,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid2(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
const custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data2, ctx) => {
      var _a, _b;
      if (!check(data2)) {
        const p2 = typeof params === "function" ? params(data2) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p2.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p2 === "string" ? { message: p2 } : p2;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data2) => data2 instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce$1 = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid: isValid2,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce: coerce$1,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
const zError = z.object({ message: z.string() });
function zType(key2) {
  return z.literal(W3mFrameConstants[key2]);
}
z.object({
  accessList: z.array(z.string()),
  blockHash: z.string().nullable(),
  blockNumber: z.string().nullable(),
  chainId: z.string(),
  from: z.string(),
  gas: z.string(),
  hash: z.string(),
  input: z.string().nullable(),
  maxFeePerGas: z.string(),
  maxPriorityFeePerGas: z.string(),
  nonce: z.string(),
  r: z.string(),
  s: z.string(),
  to: z.string(),
  transactionIndex: z.string().nullable(),
  type: z.string(),
  v: z.string(),
  value: z.string()
});
const AppSwitchNetworkRequest = z.object({ chainId: z.number() });
const AppConnectEmailRequest = z.object({ email: z.string().email() });
const AppConnectOtpRequest = z.object({ otp: z.string() });
const AppGetUserRequest = z.object({ chainId: z.optional(z.number()) });
const AppUpdateEmailRequest = z.object({ email: z.string().email() });
const AppSyncThemeRequest = z.object({
  themeMode: z.optional(z.enum(["light", "dark"])),
  themeVariables: z.optional(z.record(z.string(), z.string().or(z.number())))
});
const AppSyncDappDataRequest = z.object({
  metadata: z.object({
    name: z.string(),
    description: z.string(),
    url: z.string(),
    icons: z.array(z.string())
  }).optional(),
  sdkVersion: z.string(),
  projectId: z.string()
});
const FrameConnectEmailResponse = z.object({
  action: z.enum(["VERIFY_DEVICE", "VERIFY_OTP"])
});
const FrameGetUserResponse = z.object({
  email: z.string().email(),
  address: z.string(),
  chainId: z.number()
});
const FrameIsConnectedResponse = z.object({ isConnected: z.boolean() });
const FrameGetChainIdResponse = z.object({ chainId: z.number() });
const FrameSwitchNetworkResponse = z.object({ chainId: z.number() });
const FrameAwaitUpdateEmailResponse = z.object({ email: z.string().email() });
const RpcResponse = z.any();
const RpcPersonalSignRequest = z.object({
  method: z.literal("personal_sign"),
  params: z.array(z.any())
});
const RpcEthSendTransactionRequest = z.object({
  method: z.literal("eth_sendTransaction"),
  params: z.array(z.any())
});
const RpcEthAccountsRequest = z.object({
  method: z.literal("eth_accounts")
});
const RpcGetBalance = z.object({
  method: z.literal("eth_getBalance"),
  params: z.array(z.any())
});
const RpcEthEstimateGas = z.object({
  method: z.literal("eth_estimateGas"),
  params: z.array(z.any())
});
const RpcEthGasPrice = z.object({
  method: z.literal("eth_gasPrice")
});
const RpcEthSignTypedDataV4 = z.object({
  method: z.literal("eth_signTypedData_v4"),
  params: z.array(z.any())
});
const RpcEthGetTransactionByHash = z.object({
  method: z.literal("eth_getTransactionByHash"),
  params: z.array(z.any())
});
const RpcEthBlockNumber = z.object({
  method: z.literal("eth_blockNumber")
});
const RpcEthChainId = z.object({
  method: z.literal("eth_chainId")
});
const FrameSession = z.object({
  token: z.string()
});
const W3mFrameSchema = {
  appEvent: z.object({ type: zType("APP_SWITCH_NETWORK"), payload: AppSwitchNetworkRequest }).or(z.object({ type: zType("APP_CONNECT_EMAIL"), payload: AppConnectEmailRequest })).or(z.object({ type: zType("APP_CONNECT_DEVICE") })).or(z.object({ type: zType("APP_CONNECT_OTP"), payload: AppConnectOtpRequest })).or(z.object({ type: zType("APP_GET_USER"), payload: z.optional(AppGetUserRequest) })).or(z.object({ type: zType("APP_SIGN_OUT") })).or(z.object({ type: zType("APP_IS_CONNECTED"), payload: z.optional(FrameSession) })).or(z.object({ type: zType("APP_GET_CHAIN_ID") })).or(z.object({
    type: zType("APP_RPC_REQUEST"),
    payload: RpcPersonalSignRequest.or(RpcEthSendTransactionRequest).or(RpcEthAccountsRequest).or(RpcGetBalance).or(RpcEthEstimateGas).or(RpcEthGasPrice).or(RpcEthSignTypedDataV4).or(RpcEthBlockNumber).or(RpcEthChainId).or(RpcEthGetTransactionByHash)
  })).or(z.object({ type: zType("APP_UPDATE_EMAIL"), payload: AppUpdateEmailRequest })).or(z.object({ type: zType("APP_AWAIT_UPDATE_EMAIL") })).or(z.object({ type: zType("APP_SYNC_THEME"), payload: AppSyncThemeRequest })).or(z.object({ type: zType("APP_SYNC_DAPP_DATA"), payload: AppSyncDappDataRequest })),
  frameEvent: z.object({ type: zType("FRAME_SWITCH_NETWORK_ERROR"), payload: zError }).or(z.object({ type: zType("FRAME_SWITCH_NETWORK_SUCCESS"), payload: FrameSwitchNetworkResponse })).or(z.object({ type: zType("FRAME_CONNECT_EMAIL_ERROR"), payload: zError })).or(z.object({ type: zType("FRAME_CONNECT_EMAIL_SUCCESS"), payload: FrameConnectEmailResponse })).or(z.object({ type: zType("FRAME_CONNECT_OTP_ERROR"), payload: zError })).or(z.object({ type: zType("FRAME_CONNECT_OTP_SUCCESS") })).or(z.object({ type: zType("FRAME_CONNECT_DEVICE_ERROR"), payload: zError })).or(z.object({ type: zType("FRAME_CONNECT_DEVICE_SUCCESS") })).or(z.object({ type: zType("FRAME_GET_USER_ERROR"), payload: zError })).or(z.object({ type: zType("FRAME_GET_USER_SUCCESS"), payload: FrameGetUserResponse })).or(z.object({ type: zType("FRAME_SIGN_OUT_ERROR"), payload: zError })).or(z.object({ type: zType("FRAME_SIGN_OUT_SUCCESS") })).or(z.object({ type: zType("FRAME_IS_CONNECTED_ERROR"), payload: zError })).or(z.object({ type: zType("FRAME_IS_CONNECTED_SUCCESS"), payload: FrameIsConnectedResponse })).or(z.object({ type: zType("FRAME_GET_CHAIN_ID_ERROR"), payload: zError })).or(z.object({ type: zType("FRAME_GET_CHAIN_ID_SUCCESS"), payload: FrameGetChainIdResponse })).or(z.object({ type: zType("FRAME_RPC_REQUEST_ERROR"), payload: zError })).or(z.object({ type: zType("FRAME_RPC_REQUEST_SUCCESS"), payload: RpcResponse })).or(z.object({ type: zType("FRAME_SESSION_UPDATE"), payload: FrameSession })).or(z.object({ type: zType("FRAME_UPDATE_EMAIL_ERROR"), payload: zError })).or(z.object({ type: zType("FRAME_UPDATE_EMAIL_SUCCESS") })).or(z.object({ type: zType("FRAME_AWAIT_UPDATE_EMAIL_ERROR"), payload: zError })).or(z.object({
    type: zType("FRAME_AWAIT_UPDATE_EMAIL_SUCCESS"),
    payload: FrameAwaitUpdateEmailResponse
  })).or(z.object({ type: zType("FRAME_SYNC_THEME_ERROR"), payload: zError })).or(z.object({ type: zType("FRAME_SYNC_THEME_SUCCESS") })).or(z.object({ type: zType("FRAME_SYNC_DAPP_DATA_ERROR"), payload: zError })).or(z.object({ type: zType("FRAME_SYNC_DAPP_DATA_SUCCESS") }))
};
const W3mFrameStorage = {
  set(key2, value) {
    localStorage.setItem(`${W3mFrameConstants.STORAGE_KEY}${key2}`, value);
  },
  get(key2) {
    return localStorage.getItem(`${W3mFrameConstants.STORAGE_KEY}${key2}`);
  },
  delete(key2) {
    localStorage.removeItem(`${W3mFrameConstants.STORAGE_KEY}${key2}`);
  }
};
const RESTRICTED_TIMEZONES = [
  "ASIA/SHANGHAI",
  "ASIA/URUMQI",
  "ASIA/CHONGQING",
  "ASIA/HARBIN",
  "ASIA/KASHGAR",
  "ASIA/MACAU",
  "ASIA/HONG_KONG",
  "ASIA/MACAO",
  "ASIA/BEIJING",
  "ASIA/HARBIN"
];
const EMAIL_MINIMUM_TIMEOUT = 30 * 1e3;
const W3mFrameHelpers = {
  getBlockchainApiUrl() {
    try {
      const { timeZone } = new Intl.DateTimeFormat().resolvedOptions();
      const capTimeZone = timeZone.toUpperCase();
      return RESTRICTED_TIMEZONES.includes(capTimeZone) ? "https://rpc.walletconnect.org" : "https://rpc.walletconnect.com";
    } catch {
      return false;
    }
  },
  checkIfAllowedToTriggerEmail() {
    const lastEmailLoginTime = W3mFrameStorage.get(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
    if (lastEmailLoginTime) {
      const difference = Date.now() - Number(lastEmailLoginTime);
      if (difference < EMAIL_MINIMUM_TIMEOUT) {
        const cooldownSec = Math.ceil((EMAIL_MINIMUM_TIMEOUT - difference) / 1e3);
        throw new Error(`Please try again after ${cooldownSec} seconds`);
      }
    }
  },
  getTimeToNextEmailLogin() {
    const lastEmailLoginTime = W3mFrameStorage.get(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
    if (lastEmailLoginTime) {
      const difference = Date.now() - Number(lastEmailLoginTime);
      if (difference < EMAIL_MINIMUM_TIMEOUT) {
        return Math.ceil((EMAIL_MINIMUM_TIMEOUT - difference) / 1e3);
      }
    }
    return 0;
  }
};
class W3mFrame {
  constructor(projectId2, isAppClient = false) {
    this.iframe = null;
    this.rpcUrl = W3mFrameHelpers.getBlockchainApiUrl();
    this.events = {
      onFrameEvent: (callback) => {
        window.addEventListener("message", ({ data: data2 }) => {
          if (!data2.type?.includes(W3mFrameConstants.FRAME_EVENT_KEY)) {
            return;
          }
          const frameEvent = W3mFrameSchema.frameEvent.parse(data2);
          callback(frameEvent);
        });
      },
      onAppEvent: (callback) => {
        window.addEventListener("message", ({ data: data2 }) => {
          if (!data2.type?.includes(W3mFrameConstants.APP_EVENT_KEY)) {
            return;
          }
          const appEvent = W3mFrameSchema.appEvent.parse(data2);
          callback(appEvent);
        });
      },
      postAppEvent: (event) => {
        if (!this.iframe?.contentWindow) {
          throw new Error("W3mFrame: iframe is not set");
        }
        W3mFrameSchema.appEvent.parse(event);
        window.postMessage(event);
        this.iframe.contentWindow.postMessage(event, "*");
      },
      postFrameEvent: (event) => {
        if (!parent) {
          throw new Error("W3mFrame: parent is not set");
        }
        W3mFrameSchema.frameEvent.parse(event);
        parent.postMessage(event, "*");
      }
    };
    this.projectId = projectId2;
    this.frameLoadPromise = new Promise((resolve, reject) => {
      this.frameLoadPromiseResolver = { resolve, reject };
    });
    if (isAppClient) {
      this.frameLoadPromise = new Promise((resolve, reject) => {
        this.frameLoadPromiseResolver = { resolve, reject };
      });
      const iframe = document.createElement("iframe");
      iframe.id = "w3m-iframe";
      iframe.src = `${W3mFrameConstants.SECURE_SITE_SDK}?projectId=${projectId2}`;
      iframe.style.position = "fixed";
      iframe.style.zIndex = "999999";
      iframe.style.display = "none";
      iframe.style.opacity = "0";
      iframe.style.borderRadius = `clamp(0px, var(--wui-border-radius-l), 44px)`;
      document.body.appendChild(iframe);
      this.iframe = iframe;
      this.iframe.onload = () => {
        this.frameLoadPromiseResolver?.resolve(void 0);
      };
      this.iframe.onerror = () => {
        this.frameLoadPromiseResolver?.reject("Unable to load email login dependency");
      };
    }
  }
  get networks() {
    const data2 = [
      1,
      5,
      11155111,
      10,
      420,
      42161,
      421613,
      137,
      80001,
      42220,
      1313161554,
      1313161555,
      56,
      97,
      43114,
      43113,
      324,
      280,
      100,
      8453,
      84531,
      7777777,
      999
    ].map((id2) => ({
      [id2]: {
        rpcUrl: `${this.rpcUrl}/v1/?chainId=eip155:${id2}&projectId=${this.projectId}`,
        chainId: id2
      }
    }));
    return Object.assign({}, ...data2);
  }
}
class W3mFrameProvider {
  constructor(projectId2) {
    this.connectEmailResolver = void 0;
    this.connectDeviceResolver = void 0;
    this.connectOtpResolver = void 0;
    this.connectResolver = void 0;
    this.disconnectResolver = void 0;
    this.isConnectedResolver = void 0;
    this.getChainIdResolver = void 0;
    this.switchChainResolver = void 0;
    this.rpcRequestResolver = void 0;
    this.updateEmailResolver = void 0;
    this.awaitUpdateEmailResolver = void 0;
    this.syncThemeResolver = void 0;
    this.syncDappDataResolver = void 0;
    this.w3mFrame = new W3mFrame(projectId2, true);
    this.w3mFrame.events.onFrameEvent((event) => {
      console.log(" received", event);
      switch (event.type) {
        case W3mFrameConstants.FRAME_CONNECT_EMAIL_SUCCESS:
          return this.onConnectEmailSuccess(event);
        case W3mFrameConstants.FRAME_CONNECT_EMAIL_ERROR:
          return this.onConnectEmailError(event);
        case W3mFrameConstants.FRAME_CONNECT_DEVICE_SUCCESS:
          return this.onConnectDeviceSuccess();
        case W3mFrameConstants.FRAME_CONNECT_DEVICE_ERROR:
          return this.onConnectDeviceError(event);
        case W3mFrameConstants.FRAME_CONNECT_OTP_SUCCESS:
          return this.onConnectOtpSuccess();
        case W3mFrameConstants.FRAME_CONNECT_OTP_ERROR:
          return this.onConnectOtpError(event);
        case W3mFrameConstants.FRAME_GET_USER_SUCCESS:
          return this.onConnectSuccess(event);
        case W3mFrameConstants.FRAME_GET_USER_ERROR:
          return this.onConnectError(event);
        case W3mFrameConstants.FRAME_IS_CONNECTED_SUCCESS:
          return this.onIsConnectedSuccess(event);
        case W3mFrameConstants.FRAME_IS_CONNECTED_ERROR:
          return this.onIsConnectedError(event);
        case W3mFrameConstants.FRAME_GET_CHAIN_ID_SUCCESS:
          return this.onGetChainIdSuccess(event);
        case W3mFrameConstants.FRAME_GET_CHAIN_ID_ERROR:
          return this.onGetChainIdError(event);
        case W3mFrameConstants.FRAME_SIGN_OUT_SUCCESS:
          return this.onSignOutSuccess();
        case W3mFrameConstants.FRAME_SIGN_OUT_ERROR:
          return this.onSignOutError(event);
        case W3mFrameConstants.FRAME_SWITCH_NETWORK_SUCCESS:
          return this.onSwitchChainSuccess(event);
        case W3mFrameConstants.FRAME_SWITCH_NETWORK_ERROR:
          return this.onSwitchChainError(event);
        case W3mFrameConstants.FRAME_RPC_REQUEST_SUCCESS:
          return this.onRpcRequestSuccess(event);
        case W3mFrameConstants.FRAME_RPC_REQUEST_ERROR:
          return this.onRpcRequestError(event);
        case W3mFrameConstants.FRAME_SESSION_UPDATE:
          return this.onSessionUpdate(event);
        case W3mFrameConstants.FRAME_UPDATE_EMAIL_SUCCESS:
          return this.onUpdateEmailSuccess();
        case W3mFrameConstants.FRAME_UPDATE_EMAIL_ERROR:
          return this.onUpdateEmailError(event);
        case W3mFrameConstants.FRAME_AWAIT_UPDATE_EMAIL_SUCCESS:
          return this.onAwaitUpdateEmailSuccess(event);
        case W3mFrameConstants.FRAME_AWAIT_UPDATE_EMAIL_ERROR:
          return this.onAwaitUpdateEmailError(event);
        case W3mFrameConstants.FRAME_SYNC_THEME_SUCCESS:
          return this.onSyncThemeSuccess();
        case W3mFrameConstants.FRAME_SYNC_THEME_ERROR:
          return this.onSyncThemeError(event);
        case W3mFrameConstants.FRAME_SYNC_DAPP_DATA_SUCCESS:
          return this.onSyncDappDataSuccess();
        case W3mFrameConstants.FRAME_SYNC_DAPP_DATA_ERROR:
          return this.onSyncDappDataError(event);
        default:
          return null;
      }
    });
  }
  getLoginEmailUsed() {
    return Boolean(W3mFrameStorage.get(W3mFrameConstants.EMAIL_LOGIN_USED_KEY));
  }
  getEmail() {
    return W3mFrameStorage.get(W3mFrameConstants.EMAIL);
  }
  async connectEmail(payload) {
    await this.w3mFrame.frameLoadPromise;
    W3mFrameHelpers.checkIfAllowedToTriggerEmail();
    this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_CONNECT_EMAIL, payload });
    return new Promise((resolve, reject) => {
      this.connectEmailResolver = { resolve, reject };
    });
  }
  async connectDevice() {
    await this.w3mFrame.frameLoadPromise;
    this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_CONNECT_DEVICE });
    return new Promise((resolve, reject) => {
      this.connectDeviceResolver = { resolve, reject };
    });
  }
  async connectOtp(payload) {
    await this.w3mFrame.frameLoadPromise;
    this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_CONNECT_OTP, payload });
    return new Promise((resolve, reject) => {
      this.connectOtpResolver = { resolve, reject };
    });
  }
  async isConnected() {
    await this.w3mFrame.frameLoadPromise;
    this.w3mFrame.events.postAppEvent({
      type: W3mFrameConstants.APP_IS_CONNECTED,
      payload: void 0
    });
    return new Promise((resolve, reject) => {
      this.isConnectedResolver = { resolve, reject };
    });
  }
  async getChainId() {
    await this.w3mFrame.frameLoadPromise;
    this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_GET_CHAIN_ID });
    return new Promise((resolve, reject) => {
      this.getChainIdResolver = { resolve, reject };
    });
  }
  async updateEmail(payload) {
    await this.w3mFrame.frameLoadPromise;
    W3mFrameHelpers.checkIfAllowedToTriggerEmail();
    this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_UPDATE_EMAIL, payload });
    return new Promise((resolve, reject) => {
      this.updateEmailResolver = { resolve, reject };
    });
  }
  async awaitUpdateEmail() {
    await this.w3mFrame.frameLoadPromise;
    this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_AWAIT_UPDATE_EMAIL });
    return new Promise((resolve, reject) => {
      this.awaitUpdateEmailResolver = { resolve, reject };
    });
  }
  async syncTheme(payload) {
    await this.w3mFrame.frameLoadPromise;
    this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_SYNC_THEME, payload });
    return new Promise((resolve, reject) => {
      this.syncThemeResolver = { resolve, reject };
    });
  }
  async syncDappData(payload) {
    await this.w3mFrame.frameLoadPromise;
    this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_SYNC_DAPP_DATA, payload });
    return new Promise((resolve, reject) => {
      this.syncDappDataResolver = { resolve, reject };
    });
  }
  async connect(payload) {
    const chainId2 = payload?.chainId ?? this.getLastUsedChainId() ?? 1;
    await this.w3mFrame.frameLoadPromise;
    this.w3mFrame.events.postAppEvent({
      type: W3mFrameConstants.APP_GET_USER,
      payload: { chainId: chainId2 }
    });
    return new Promise((resolve, reject) => {
      this.connectResolver = { resolve, reject };
    });
  }
  async switchNetwork(chainId2) {
    await this.w3mFrame.frameLoadPromise;
    this.w3mFrame.events.postAppEvent({
      type: W3mFrameConstants.APP_SWITCH_NETWORK,
      payload: { chainId: chainId2 }
    });
    return new Promise((resolve, reject) => {
      this.switchChainResolver = { resolve, reject };
    });
  }
  async disconnect() {
    await this.w3mFrame.frameLoadPromise;
    this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_SIGN_OUT });
    return new Promise((resolve, reject) => {
      this.disconnectResolver = { resolve, reject };
    });
  }
  async request(req) {
    await this.w3mFrame.frameLoadPromise;
    if (W3mFrameRpcConstants.GET_CHAIN_ID === req.method) {
      return this.getLastUsedChainId();
    }
    this.w3mFrame.events.postAppEvent({
      type: W3mFrameConstants.APP_RPC_REQUEST,
      payload: req
    });
    return new Promise((resolve, reject) => {
      this.rpcRequestResolver = { resolve, reject };
    });
  }
  onRpcRequest(callback) {
    this.w3mFrame.events.onAppEvent((event) => {
      if (event.type.includes(W3mFrameConstants.RPC_METHOD_KEY)) {
        callback(event);
      }
    });
  }
  onRpcResponse(callback) {
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type.includes(W3mFrameConstants.RPC_METHOD_KEY)) {
        callback(event);
      }
    });
  }
  onIsConnected(callback) {
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type === W3mFrameConstants.FRAME_GET_USER_SUCCESS) {
        callback();
      }
    });
  }
  onConnectEmailSuccess(event) {
    this.connectEmailResolver?.resolve(event.payload);
    this.setNewLastEmailLoginTime();
  }
  onConnectEmailError(event) {
    this.connectEmailResolver?.reject(event.payload.message);
  }
  onConnectDeviceSuccess() {
    this.connectDeviceResolver?.resolve(void 0);
  }
  onConnectDeviceError(event) {
    this.connectDeviceResolver?.reject(event.payload.message);
  }
  onConnectOtpSuccess() {
    this.connectOtpResolver?.resolve(void 0);
  }
  onConnectOtpError(event) {
    this.connectOtpResolver?.reject(event.payload.message);
  }
  onConnectSuccess(event) {
    this.setEmailLoginSuccess(event.payload.email);
    this.setLastUsedChainId(event.payload.chainId);
    this.connectResolver?.resolve(event.payload);
  }
  onConnectError(event) {
    this.connectResolver?.reject(event.payload.message);
  }
  onIsConnectedSuccess(event) {
    if (!event.payload.isConnected) {
      this.deleteEmailLoginCache();
    }
    this.isConnectedResolver?.resolve(event.payload);
  }
  onIsConnectedError(event) {
    this.isConnectedResolver?.reject(event.payload.message);
  }
  onGetChainIdSuccess(event) {
    this.setLastUsedChainId(event.payload.chainId);
    this.getChainIdResolver?.resolve(event.payload);
  }
  onGetChainIdError(event) {
    this.getChainIdResolver?.reject(event.payload.message);
  }
  onSignOutSuccess() {
    this.disconnectResolver?.resolve(void 0);
    this.deleteEmailLoginCache();
  }
  onSignOutError(event) {
    this.disconnectResolver?.reject(event.payload.message);
  }
  onSwitchChainSuccess(event) {
    this.setLastUsedChainId(event.payload.chainId);
    this.switchChainResolver?.resolve(event.payload);
  }
  onSwitchChainError(event) {
    this.switchChainResolver?.reject(event.payload.message);
  }
  onRpcRequestSuccess(event) {
    this.rpcRequestResolver?.resolve(event.payload);
  }
  onRpcRequestError(event) {
    this.rpcRequestResolver?.reject(event.payload.message);
  }
  onSessionUpdate(event) {
  }
  onUpdateEmailSuccess() {
    this.updateEmailResolver?.resolve(void 0);
    this.setNewLastEmailLoginTime();
  }
  onUpdateEmailError(event) {
    this.updateEmailResolver?.reject(event.payload.message);
  }
  onAwaitUpdateEmailSuccess(event) {
    this.setEmailLoginSuccess(event.payload.email);
    this.awaitUpdateEmailResolver?.resolve(event.payload);
  }
  onAwaitUpdateEmailError(event) {
    this.awaitUpdateEmailResolver?.reject(event.payload.message);
  }
  onSyncThemeSuccess() {
    this.syncThemeResolver?.resolve(void 0);
  }
  onSyncThemeError(event) {
    this.syncThemeResolver?.reject(event.payload.message);
  }
  onSyncDappDataSuccess() {
    this.syncDappDataResolver?.resolve(void 0);
  }
  onSyncDappDataError(event) {
    this.syncDappDataResolver?.reject(event.payload.message);
  }
  setNewLastEmailLoginTime() {
    W3mFrameStorage.set(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME, Date.now().toString());
  }
  setEmailLoginSuccess(email) {
    W3mFrameStorage.set(W3mFrameConstants.EMAIL, email);
    W3mFrameStorage.set(W3mFrameConstants.EMAIL_LOGIN_USED_KEY, "true");
    W3mFrameStorage.delete(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
  }
  deleteEmailLoginCache() {
    W3mFrameStorage.delete(W3mFrameConstants.EMAIL_LOGIN_USED_KEY);
    W3mFrameStorage.delete(W3mFrameConstants.EMAIL);
    W3mFrameStorage.delete(W3mFrameConstants.LAST_USED_CHAIN_KEY);
  }
  setLastUsedChainId(chainId2) {
    W3mFrameStorage.set(W3mFrameConstants.LAST_USED_CHAIN_KEY, `${chainId2}`);
  }
  getLastUsedChainId() {
    return Number(W3mFrameStorage.get(W3mFrameConstants.LAST_USED_CHAIN_KEY));
  }
}
var __decorate$m = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const OTP_LENGTH = 6;
let W3mEmailVerifyOtpView = class W3mEmailVerifyOtpView2 extends s$1 {
  constructor() {
    super(...arguments);
    this.email = RouterController.state.data?.email;
    this.emailConnector = ConnectorController.getEmailConnector();
    this.loading = false;
    this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
    this.error = "";
  }
  firstUpdated() {
    this.startOTPTimeout();
  }
  disconnectedCallback() {
    clearTimeout(this.OTPTimeout);
  }
  render() {
    if (!this.email) {
      throw new Error("w3m-email-verify-otp-view: No email provided");
    }
    const isResendDisabled = Boolean(this.timeoutTimeLeft);
    return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["l", "0", "l", "0"]}
        gap="l"
      >
        <wui-flex flexDirection="column" alignItems="center">
          <wui-text variant="paragraph-400" color="fg-100"> Enter the code we sent to </wui-text>
          <wui-text variant="paragraph-500" color="fg-100">${this.email}</wui-text>
        </wui-flex>

        <wui-text variant="small-400" color="fg-200">The code expires in 20 minutes</wui-text>

        ${this.loading ? x`<wui-loading-spinner size="xl" color="accent-100"></wui-loading-spinner>` : x` <wui-flex flexDirection="column" alignItems="center" gap="xs">
              <wui-otp
                dissabled
                length="6"
                @inputChange=${this.onOtpInputChange.bind(this)}
              ></wui-otp>
              ${this.error ? x`<wui-text variant="small-400" color="error-100"
                    >${this.error}. Try Again</wui-text
                  >` : null}
            </wui-flex>`}

        <wui-flex alignItems="center">
          <wui-text variant="small-400" color="fg-200">Didn't receive it?</wui-text>
          <wui-link @click=${this.onResendCode.bind(this)} .disabled=${isResendDisabled}>
            Resend ${isResendDisabled ? `in ${this.timeoutTimeLeft}s` : "Code"}
          </wui-link>
        </wui-flex>
      </wui-flex>
    `;
  }
  startOTPTimeout() {
    this.OTPTimeout = setInterval(() => {
      if (this.timeoutTimeLeft > 0) {
        this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
      } else {
        clearInterval(this.OTPTimeout);
      }
    }, 1e3);
  }
  async onOtpInputChange(event) {
    try {
      if (!this.loading) {
        const otp = event.detail;
        if (this.emailConnector && otp.length === OTP_LENGTH) {
          this.loading = true;
          await this.emailConnector.provider.connectOtp({ otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          await ConnectionController.connectExternal(this.emailConnector);
          ModalController.close();
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: { method: "email" }
          });
        }
      }
    } catch (error) {
      EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_FAIL" });
      this.error = CoreHelperUtil.parseError(error);
      this.loading = false;
    }
  }
  async onResendCode() {
    try {
      if (!this.loading && !this.timeoutTimeLeft) {
        const emailConnector = ConnectorController.getEmailConnector();
        if (!emailConnector || !this.email) {
          throw new Error("w3m-email-login-widget: Unable to resend email");
        }
        this.loading = true;
        await emailConnector.provider.connectEmail({ email: this.email });
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
        this.startOTPTimeout();
        SnackController.showSuccess("Code email resent");
      }
    } catch (error) {
      SnackController.showError(error);
    } finally {
      this.loading = false;
    }
  }
};
W3mEmailVerifyOtpView.styles = styles$d;
__decorate$m([
  r$1()
], W3mEmailVerifyOtpView.prototype, "loading", void 0);
__decorate$m([
  r$1()
], W3mEmailVerifyOtpView.prototype, "timeoutTimeLeft", void 0);
__decorate$m([
  r$1()
], W3mEmailVerifyOtpView.prototype, "error", void 0);
W3mEmailVerifyOtpView = __decorate$m([
  customElement("w3m-email-verify-otp-view")
], W3mEmailVerifyOtpView);
const styles$c = i$4`
  wui-icon-box {
    height: var(--wui-icon-box-size-xl);
    width: var(--wui-icon-box-size-xl);
  }
`;
var __decorate$l = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mEmailVerifyDeviceView = class W3mEmailVerifyDeviceView2 extends s$1 {
  constructor() {
    super();
    this.email = RouterController.state.data?.email;
    this.emailConnector = ConnectorController.getEmailConnector();
    this.loading = false;
    this.listenForDeviceApproval();
  }
  render() {
    if (!this.email) {
      throw new Error("w3m-email-verify-device-view: No email provided");
    }
    if (!this.emailConnector) {
      throw new Error("w3m-email-verify-device-view: No email connector provided");
    }
    return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xxl", "s", "xxl", "s"]}
        gap="l"
      >
        <wui-icon-box
          size="xl"
          iconcolor="accent-100"
          backgroundcolor="accent-100"
          icon="verify"
          background="opaque"
        ></wui-icon-box>

        <wui-flex flexDirection="column" alignItems="center" gap="s">
          <wui-flex flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-400" color="fg-100">
              Approve the login link we sent to
            </wui-text>
            <wui-text variant="paragraph-400" color="fg-100"><b>${this.email}</b></wui-text>
          </wui-flex>

          <wui-text variant="small-400" color="fg-200" align="center">
            The code expires in 20 minutes
          </wui-text>

          <wui-flex alignItems="center" id="w3m-resend-section">
            <wui-text variant="small-400" color="fg-100" align="center">
              Didn't receive it?
            </wui-text>
            <wui-link @click=${this.onResendCode.bind(this)} .disabled=${this.loading}>
              Resend email
            </wui-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
  }
  async listenForDeviceApproval() {
    if (this.emailConnector) {
      await this.emailConnector.provider.connectDevice();
      EventsController.sendEvent({ type: "track", event: "DEVICE_REGISTERED_FOR_EMAIL" });
      EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
      RouterController.replace("EmailVerifyOtp", { email: this.email });
    }
  }
  async onResendCode() {
    try {
      if (!this.loading) {
        if (!this.emailConnector || !this.email) {
          throw new Error("w3m-email-login-widget: Unable to resend email");
        }
        this.loading = true;
        await this.emailConnector.provider.connectEmail({ email: this.email });
        SnackController.showSuccess("Code email resent");
      }
    } catch (error) {
      SnackController.showError(error);
    } finally {
      this.loading = false;
    }
  }
};
W3mEmailVerifyDeviceView.styles = styles$c;
__decorate$l([
  r$1()
], W3mEmailVerifyDeviceView.prototype, "loading", void 0);
W3mEmailVerifyDeviceView = __decorate$l([
  customElement("w3m-email-verify-device-view")
], W3mEmailVerifyDeviceView);
const styles$b = i$4`
  div {
    width: 100%;
    height: 400px;
  }

  [data-ready='false'] {
    transform: scale(1.05);
  }

  @media (max-width: 430px) {
    [data-ready='false'] {
      transform: translateY(-50px);
    }
  }
`;
var __decorate$k = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mApproveTransactionView = class W3mApproveTransactionView2 extends s$1 {
  constructor() {
    super();
    this.bodyObserver = void 0;
    this.unsubscribe = [];
    this.iframe = document.getElementById("w3m-iframe");
    this.ready = false;
    this.unsubscribe.push(ModalController.subscribeKey("open", (val) => {
      if (!val) {
        this.onHideIframe();
      }
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    this.bodyObserver?.unobserve(window.document.body);
  }
  firstUpdated() {
    const verticalPadding = 10;
    this.iframe.style.display = "block";
    const blueprint = this.renderRoot.querySelector("div");
    this.bodyObserver = new ResizeObserver(() => {
      const data2 = blueprint?.getBoundingClientRect();
      const dimensions = data2 ?? { left: 0, top: 0, width: 0, height: 0 };
      this.iframe.style.width = `${dimensions.width}px`;
      this.iframe.style.height = `${dimensions.height - verticalPadding}px`;
      this.iframe.style.left = `${dimensions.left}px`;
      this.iframe.style.top = `${dimensions.top + verticalPadding / 2}px`;
      this.ready = true;
    });
    this.bodyObserver.observe(window.document.body);
  }
  render() {
    if (this.ready) {
      this.onShowIframe();
    }
    return x`<div data-ready=${this.ready}></div>`;
  }
  onShowIframe() {
    const isMobile = window.innerWidth <= 430;
    this.iframe.animate([
      { opacity: 0, transform: isMobile ? "translateY(50px)" : "scale(.95)" },
      { opacity: 1, transform: isMobile ? "translateY(0)" : "scale(1)" }
    ], { duration: 200, easing: "ease", fill: "forwards", delay: 300 });
  }
  async onHideIframe() {
    await this.iframe.animate([{ opacity: 1 }, { opacity: 0 }], {
      duration: 200,
      easing: "ease",
      fill: "forwards"
    }).finished;
    this.iframe.style.display = "none";
  }
};
W3mApproveTransactionView.styles = styles$b;
__decorate$k([
  r$1()
], W3mApproveTransactionView.prototype, "ready", void 0);
W3mApproveTransactionView = __decorate$k([
  customElement("w3m-approve-transaction-view")
], W3mApproveTransactionView);
var __decorate$j = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mUpgradeWalletView = class W3mUpgradeWalletView2 extends s$1 {
  render() {
    return x`
      <wui-flex flexDirection="column" alignItems="center" gap="xl" padding="xl">
        <wui-text variant="paragraph-400" color="fg-100">Follow the instructions on</wui-text>
        <wui-chip
          icon="externalLink"
          variant="fill"
          href=${ConstantsUtil$1.SECURE_SITE_DASHBOARD}
          imageSrc=${ConstantsUtil$1.SECURE_SITE_FAVICON}
        >
        </wui-chip>
        <wui-text variant="small-400" color="fg-200">
          You will have to reconnect for security reasons
        </wui-text>
      </wui-flex>
    `;
  }
};
W3mUpgradeWalletView = __decorate$j([
  customElement("w3m-upgrade-wallet-view")
], W3mUpgradeWalletView);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const f$1 = (o2) => void 0 === o2.strings;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, e$1 = (t2) => (...e2) => ({ _$litDirective$: t2, values: e2 });
let i$1 = class i2 {
  constructor(t2) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t2, e2, i3) {
    this._$Ct = t2, this._$AM = e2, this._$Ci = i3;
  }
  _$AS(t2, e2) {
    return this.update(t2, e2);
  }
  update(t2, e2) {
    return this.render(...e2);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s3 = (i3, t2) => {
  const e2 = i3._$AN;
  if (void 0 === e2)
    return false;
  for (const i4 of e2)
    i4._$AO?.(t2, false), s3(i4, t2);
  return true;
}, o$1 = (i3) => {
  let t2, e2;
  do {
    if (void 0 === (t2 = i3._$AM))
      break;
    e2 = t2._$AN, e2.delete(i3), i3 = t2;
  } while (0 === e2?.size);
}, r = (i3) => {
  for (let t2; t2 = i3._$AM; i3 = t2) {
    let e2 = t2._$AN;
    if (void 0 === e2)
      t2._$AN = e2 = /* @__PURE__ */ new Set();
    else if (e2.has(i3))
      break;
    e2.add(i3), c(t2);
  }
};
function h$2(i3) {
  void 0 !== this._$AN ? (o$1(this), this._$AM = i3, r(this)) : this._$AM = i3;
}
function n$1(i3, t2 = false, e2 = 0) {
  const r2 = this._$AH, h4 = this._$AN;
  if (void 0 !== h4 && 0 !== h4.size)
    if (t2)
      if (Array.isArray(r2))
        for (let i4 = e2; i4 < r2.length; i4++)
          s3(r2[i4], false), o$1(r2[i4]);
      else
        null != r2 && (s3(r2, false), o$1(r2));
    else
      s3(this, i3);
}
const c = (i3) => {
  i3.type == t.CHILD && (i3._$AP ?? (i3._$AP = n$1), i3._$AQ ?? (i3._$AQ = h$2));
};
class f2 extends i$1 {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(i3, t2, e2) {
    super._$AT(i3, t2, e2), r(this), this.isConnected = i3._$AU;
  }
  _$AO(i3, t2 = true) {
    i3 !== this.isConnected && (this.isConnected = i3, i3 ? this.reconnected?.() : this.disconnected?.()), t2 && (s3(this, i3), o$1(this));
  }
  setValue(t2) {
    if (f$1(this._$Ct))
      this._$Ct._$AI(t2, this);
    else {
      const i3 = [...this._$Ct._$AH];
      i3[this._$Ci] = t2, this._$Ct._$AI(i3, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e = () => new h$1();
let h$1 = class h2 {
};
const o = /* @__PURE__ */ new WeakMap(), n3 = e$1(class extends f2 {
  render(i3) {
    return T$1;
  }
  update(i3, [s4]) {
    const e2 = s4 !== this.G;
    return e2 && void 0 !== this.G && this.ot(void 0), (e2 || this.rt !== this.lt) && (this.G = s4, this.ct = i3.options?.host, this.ot(this.lt = i3.element)), T$1;
  }
  ot(t2) {
    if ("function" == typeof this.G) {
      const i3 = this.ct ?? globalThis;
      let s4 = o.get(i3);
      void 0 === s4 && (s4 = /* @__PURE__ */ new WeakMap(), o.set(i3, s4)), void 0 !== s4.get(this.G) && this.G.call(this.ct, void 0), s4.set(this.G, t2), void 0 !== t2 && this.G.call(this.ct, t2);
    } else
      this.G.value = t2;
  }
  get rt() {
    return "function" == typeof this.G ? o.get(this.ct ?? globalThis)?.get(this.G) : this.G?.value;
  }
  disconnected() {
    this.rt === this.lt && this.ot(void 0);
  }
  reconnected() {
    this.ot(this.lt);
  }
});
const styles$a = i$4`
  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }
`;
var __decorate$i = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mUpdateEmailWalletView = class W3mUpdateEmailWalletView2 extends s$1 {
  constructor() {
    super(...arguments);
    this.formRef = e();
    this.initialValue = RouterController.state.data?.email ?? "";
    this.email = "";
    this.loading = false;
  }
  firstUpdated() {
    this.formRef.value?.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        this.onSubmitEmail(event);
      }
    });
  }
  render() {
    const showSubmit = !this.loading && this.email.length > 3 && this.email !== this.initialValue;
    return x`
      <wui-flex flexDirection="column" padding="m" gap="m">
        <form ${n3(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
          <wui-email-input
            value=${this.initialValue}
            .disabled=${this.loading}
            @inputChange=${this.onEmailInputChange.bind(this)}
          >
          </wui-email-input>
          <input type="submit" hidden />
        </form>

        <wui-flex gap="s">
          <wui-button size="md" variant="shade" fullWidth @click=${RouterController.goBack}>
            Cancel
          </wui-button>

          <wui-button
            size="md"
            variant="fill"
            fullWidth
            @click=${this.onSubmitEmail.bind(this)}
            .disabled=${!showSubmit}
            .loading=${this.loading}
          >
            Save
          </wui-button>
        </wui-flex>
      </wui-flex>
    `;
  }
  onEmailInputChange(event) {
    this.email = event.detail;
  }
  async onSubmitEmail(event) {
    try {
      if (this.loading) {
        return;
      }
      this.loading = true;
      event.preventDefault();
      const emailConnector = ConnectorController.getEmailConnector();
      if (!emailConnector) {
        throw new Error("w3m-update-email-wallet: Email connector not found");
      }
      await emailConnector.provider.updateEmail({ email: this.email });
      EventsController.sendEvent({ type: "track", event: "EMAIL_EDIT" });
      RouterController.replace("UpdateEmailWalletWaiting", { email: this.email });
    } catch (error) {
      SnackController.showError(error);
      this.loading = false;
    }
  }
};
W3mUpdateEmailWalletView.styles = styles$a;
__decorate$i([
  r$1()
], W3mUpdateEmailWalletView.prototype, "email", void 0);
__decorate$i([
  r$1()
], W3mUpdateEmailWalletView.prototype, "loading", void 0);
W3mUpdateEmailWalletView = __decorate$i([
  customElement("w3m-update-email-wallet-view")
], W3mUpdateEmailWalletView);
const styles$9 = i$4`
  wui-icon-box {
    height: var(--wui-icon-box-size-xl);
    width: var(--wui-icon-box-size-xl);
  }
`;
var __decorate$h = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mUpdateEmailWalletWaitingView = class W3mUpdateEmailWalletWaitingView2 extends s$1 {
  constructor() {
    super();
    this.email = RouterController.state.data?.email;
    this.emailConnector = ConnectorController.getEmailConnector();
    this.loading = false;
    this.listenForEmailUpdateApproval();
  }
  render() {
    if (!this.email) {
      throw new Error("w3m-update-email-wallet-waiting-view: No email provided");
    }
    if (!this.emailConnector) {
      throw new Error("w3m-update-email-wallet-waiting-view: No email connector provided");
    }
    return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xxl", "s", "xxl", "s"]}
        gap="l"
      >
        <wui-icon-box
          size="xl"
          iconcolor="accent-100"
          backgroundcolor="accent-100"
          icon="mail"
          background="opaque"
        ></wui-icon-box>

        <wui-flex flexDirection="column" alignItems="center" gap="s">
          <wui-flex flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-400" color="fg-100">
              Approve verification link we sent to
            </wui-text>
            <wui-text variant="paragraph-400" color="fg-100">${this.email}</wui-text>
          </wui-flex>

          <wui-text variant="small-400" color="fg-200" align="center">
            You will receive an approval request on your former mail to confirm the new one
          </wui-text>

          <wui-flex alignItems="center" id="w3m-resend-section">
            <wui-text variant="small-400" color="fg-100" align="center">
              Didn't receive it?
            </wui-text>
            <wui-link @click=${this.onResendCode.bind(this)} .disabled=${this.loading}>
              Resend email
            </wui-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
  }
  async listenForEmailUpdateApproval() {
    if (this.emailConnector) {
      await this.emailConnector.provider.awaitUpdateEmail();
      RouterController.replace("Account");
      SnackController.showSuccess("Email updated");
    }
  }
  async onResendCode() {
    try {
      if (!this.loading) {
        if (!this.emailConnector || !this.email) {
          throw new Error("w3m-update-email-wallet-waiting-view: Unable to resend email");
        }
        this.loading = true;
        await this.emailConnector.provider.updateEmail({ email: this.email });
        this.listenForEmailUpdateApproval();
        SnackController.showSuccess("Code email resent");
      }
    } catch (error) {
      SnackController.showError(error);
    } finally {
      this.loading = false;
    }
  }
};
W3mUpdateEmailWalletWaitingView.styles = styles$9;
__decorate$h([
  r$1()
], W3mUpdateEmailWalletWaitingView.prototype, "loading", void 0);
W3mUpdateEmailWalletWaitingView = __decorate$h([
  customElement("w3m-update-email-wallet-waiting-view")
], W3mUpdateEmailWalletWaitingView);
const styles$8 = i$4`
  wui-grid {
    max-height: clamp(360px, 400px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 76px);
  }

  @media (max-width: 435px) {
    wui-grid {
      grid-template-columns: repeat(auto-fill, 77px);
    }
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    justify-content: center;
    grid-column: 1 / span 4;
  }
`;
function markWalletsAsInstalled(wallets) {
  const { connectors } = ConnectorController.state;
  const installedConnectors = connectors.filter((c2) => c2.type === "ANNOUNCED").reduce((acum, val) => {
    if (!val.info?.rdns) {
      return acum;
    }
    acum[val.info.rdns] = true;
    return acum;
  }, {});
  const walletsWithInstalled = wallets.map((wallet) => ({
    ...wallet,
    installed: Boolean(wallet.rdns) && Boolean(installedConnectors[wallet.rdns ?? ""])
  }));
  const sortedWallets = walletsWithInstalled.sort((a2, b3) => Number(b3.installed) - Number(a2.installed));
  return sortedWallets;
}
var __decorate$g = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const PAGINATOR_ID = "local-paginator";
let W3mAllWalletsList = class W3mAllWalletsList2 extends s$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.paginationObserver = void 0;
    this.initial = !ApiController.state.wallets.length;
    this.wallets = ApiController.state.wallets;
    this.recommended = ApiController.state.recommended;
    this.featured = ApiController.state.featured;
    this.unsubscribe.push(...[
      ApiController.subscribeKey("wallets", (val) => this.wallets = val),
      ApiController.subscribeKey("recommended", (val) => this.recommended = val),
      ApiController.subscribeKey("featured", (val) => this.featured = val)
    ]);
  }
  firstUpdated() {
    this.initialFetch();
    this.createPaginationObserver();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    this.paginationObserver?.disconnect();
  }
  render() {
    return x`
      <wui-grid
        data-scroll=${!this.initial}
        .padding=${["0", "s", "s", "s"]}
        columnGap="xxs"
        rowGap="l"
        justifyContent="space-between"
      >
        ${this.initial ? this.shimmerTemplate(16) : this.walletsTemplate()}
        ${this.paginationLoaderTemplate()}
      </wui-grid>
    `;
  }
  async initialFetch() {
    const gridEl = this.shadowRoot?.querySelector("wui-grid");
    if (this.initial && gridEl) {
      await ApiController.fetchWallets({ page: 1 });
      await gridEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.initial = false;
      gridEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  shimmerTemplate(items, id2) {
    return [...Array(items)].map(() => x`
        <wui-card-select-loader type="wallet" id=${o$2(id2)}></wui-card-select-loader>
      `);
  }
  walletsTemplate() {
    const wallets = [...this.featured, ...this.recommended, ...this.wallets];
    const walletsWithInstalled = markWalletsAsInstalled(wallets);
    return walletsWithInstalled.map((wallet) => x`
        <wui-card-select
          imageSrc=${o$2(AssetUtil.getWalletImage(wallet))}
          type="wallet"
          name=${wallet.name}
          @click=${() => this.onConnectWallet(wallet)}
          .installed=${wallet.installed}
        ></wui-card-select>
      `);
  }
  paginationLoaderTemplate() {
    const { wallets, recommended, featured, count } = ApiController.state;
    const columns = window.innerWidth < 352 ? 3 : 4;
    const currentWallets = wallets.length + recommended.length;
    const minimumRows = Math.ceil(currentWallets / columns);
    let shimmerCount = minimumRows * columns - currentWallets + columns;
    shimmerCount -= wallets.length ? featured.length % columns : 0;
    if (count === 0 && featured.length > 0) {
      return null;
    }
    if (count === 0 || [...featured, ...wallets, ...recommended].length < count) {
      return this.shimmerTemplate(shimmerCount, PAGINATOR_ID);
    }
    return null;
  }
  createPaginationObserver() {
    const loaderEl = this.shadowRoot?.querySelector(`#${PAGINATOR_ID}`);
    if (loaderEl) {
      this.paginationObserver = new IntersectionObserver(([element]) => {
        if (element?.isIntersecting && !this.initial) {
          const { page, count, wallets } = ApiController.state;
          if (wallets.length < count) {
            ApiController.fetchWallets({ page: page + 1 });
          }
        }
      });
      this.paginationObserver.observe(loaderEl);
    }
  }
  onConnectWallet(wallet) {
    const { connectors } = ConnectorController.state;
    const connector = connectors.find(({ explorerId }) => explorerId === wallet.id);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
W3mAllWalletsList.styles = styles$8;
__decorate$g([
  r$1()
], W3mAllWalletsList.prototype, "initial", void 0);
__decorate$g([
  r$1()
], W3mAllWalletsList.prototype, "wallets", void 0);
__decorate$g([
  r$1()
], W3mAllWalletsList.prototype, "recommended", void 0);
__decorate$g([
  r$1()
], W3mAllWalletsList.prototype, "featured", void 0);
W3mAllWalletsList = __decorate$g([
  customElement("w3m-all-wallets-list")
], W3mAllWalletsList);
const styles$7 = i$4`
  wui-grid,
  wui-loading-spinner,
  wui-flex {
    height: 360px;
  }

  wui-grid {
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    justify-content: center;
    align-items: center;
  }
`;
var __decorate$f = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAllWalletsSearch = class W3mAllWalletsSearch2 extends s$1 {
  constructor() {
    super(...arguments);
    this.prevQuery = "";
    this.loading = true;
    this.query = "";
  }
  render() {
    this.onSearch();
    return this.loading ? x`<wui-loading-spinner color="accent-100"></wui-loading-spinner>` : this.walletsTemplate();
  }
  async onSearch() {
    if (this.query !== this.prevQuery) {
      this.prevQuery = this.query;
      this.loading = true;
      await ApiController.searchWallet({ search: this.query });
      this.loading = false;
    }
  }
  walletsTemplate() {
    const { search } = ApiController.state;
    const wallets = markWalletsAsInstalled(search);
    if (!search.length) {
      return x`
        <wui-flex justifyContent="center" alignItems="center" gap="s" flexDirection="column">
          <wui-icon-box
            size="lg"
            iconColor="fg-200"
            backgroundColor="fg-300"
            icon="wallet"
            background="transparent"
          ></wui-icon-box>
          <wui-text color="fg-200" variant="paragraph-500">No Wallet found</wui-text>
        </wui-flex>
      `;
    }
    return x`
      <wui-grid
        .padding=${["0", "s", "s", "s"]}
        gridTemplateColumns="repeat(4, 1fr)"
        rowGap="l"
        columnGap="xs"
      >
        ${wallets.map((wallet) => x`
            <wui-card-select
              imageSrc=${o$2(AssetUtil.getWalletImage(wallet))}
              type="wallet"
              name=${wallet.name}
              @click=${() => this.onConnectWallet(wallet)}
              .installed=${wallet.installed}
            ></wui-card-select>
          `)}
      </wui-grid>
    `;
  }
  onConnectWallet(wallet) {
    const { connectors } = ConnectorController.state;
    const connector = connectors.find(({ explorerId }) => explorerId === wallet.id);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
W3mAllWalletsSearch.styles = styles$7;
__decorate$f([
  r$1()
], W3mAllWalletsSearch.prototype, "loading", void 0);
__decorate$f([
  n$2()
], W3mAllWalletsSearch.prototype, "query", void 0);
W3mAllWalletsSearch = __decorate$f([
  customElement("w3m-all-wallets-search")
], W3mAllWalletsSearch);
var __decorate$e = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingHeader = class W3mConnectingHeader2 extends s$1 {
  constructor() {
    super();
    this.platformTabs = [];
    this.unsubscribe = [];
    this.platforms = [];
    this.onSelectPlatfrom = void 0;
    this.buffering = false;
    this.unsubscribe.push(ConnectionController.subscribeKey("buffering", (val) => this.buffering = val));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const tabs = this.generateTabs();
    return x`
      <wui-flex justifyContent="center" .padding=${["l", "0", "0", "0"]}>
        <wui-tabs
          ?disabled=${this.buffering}
          .tabs=${tabs}
          .onTabChange=${this.onTabChange.bind(this)}
        ></wui-tabs>
      </wui-flex>
    `;
  }
  generateTabs() {
    const tabs = this.platforms.map((platform) => {
      if (platform === "browser") {
        return { label: "Browser", icon: "extension", platform: "browser" };
      } else if (platform === "mobile") {
        return { label: "Mobile", icon: "mobile", platform: "mobile" };
      } else if (platform === "qrcode") {
        return { label: "Mobile", icon: "mobile", platform: "qrcode" };
      } else if (platform === "web") {
        return { label: "Webapp", icon: "browser", platform: "web" };
      } else if (platform === "desktop") {
        return { label: "Desktop", icon: "desktop", platform: "desktop" };
      }
      return { label: "Browser", icon: "extension", platform: "unsupported" };
    });
    this.platformTabs = tabs.map(({ platform }) => platform);
    return tabs;
  }
  onTabChange(index2) {
    const tab = this.platformTabs[index2];
    if (tab) {
      this.onSelectPlatfrom?.(tab);
    }
  }
};
__decorate$e([
  n$2({ type: Array })
], W3mConnectingHeader.prototype, "platforms", void 0);
__decorate$e([
  n$2()
], W3mConnectingHeader.prototype, "onSelectPlatfrom", void 0);
__decorate$e([
  r$1()
], W3mConnectingHeader.prototype, "buffering", void 0);
W3mConnectingHeader = __decorate$e([
  customElement("w3m-connecting-header")
], W3mConnectingHeader);
var __decorate$d = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcBrowser = class W3mConnectingWcBrowser2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-browser: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onAutoConnect = this.onConnectProxy.bind(this);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  async onConnectProxy() {
    try {
      this.error = false;
      const { connectors } = ConnectorController.state;
      const announcedConnector = connectors.find((c2) => c2.type === "ANNOUNCED" && c2.info?.rdns === this.wallet?.rdns);
      const injectedConnector = connectors.find((c2) => c2.type === "INJECTED");
      if (announcedConnector) {
        await ConnectionController.connectExternal(announcedConnector);
      } else if (injectedConnector) {
        await ConnectionController.connectExternal(injectedConnector);
      }
      ModalController.close();
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_SUCCESS",
        properties: { method: "browser" }
      });
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: error?.message ?? "Unknown" }
      });
      this.error = true;
    }
  }
};
W3mConnectingWcBrowser = __decorate$d([
  customElement("w3m-connecting-wc-browser")
], W3mConnectingWcBrowser);
var __decorate$c = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcDesktop = class W3mConnectingWcDesktop2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-desktop: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onRender = this.onRenderProxy.bind(this);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "desktop" }
    });
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.ready = true;
      this.timeout = setTimeout(() => {
        this.onConnect?.();
      }, 200);
    }
  }
  onConnectProxy() {
    if (this.wallet?.desktop_link && this.uri) {
      try {
        this.error = false;
        const { desktop_link, name: name2 } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatNativeUrl(desktop_link, this.uri);
        ConnectionController.setWcLinking({ name: name2, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_blank");
      } catch {
        this.error = true;
      }
    }
  }
};
W3mConnectingWcDesktop = __decorate$c([
  customElement("w3m-connecting-wc-desktop")
], W3mConnectingWcDesktop);
var __decorate$b = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcMobile = class W3mConnectingWcMobile2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-mobile: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onRender = this.onRenderProxy.bind(this);
    document.addEventListener("visibilitychange", this.onBuffering.bind(this));
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "mobile" }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("visibilitychange", this.onBuffering.bind(this));
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.ready = true;
      this.onConnect?.();
    }
  }
  onConnectProxy() {
    if (this.wallet?.mobile_link && this.uri) {
      try {
        this.error = false;
        const { mobile_link, name: name2 } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatNativeUrl(mobile_link, this.uri);
        ConnectionController.setWcLinking({ name: name2, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_self");
      } catch {
        this.error = true;
      }
    }
  }
  onBuffering() {
    const isIos = CoreHelperUtil.isIos();
    if (document?.visibilityState === "visible" && !this.error && isIos) {
      ConnectionController.setBuffering(true);
      setTimeout(() => {
        ConnectionController.setBuffering(false);
      }, 5e3);
    }
  }
};
W3mConnectingWcMobile = __decorate$b([
  customElement("w3m-connecting-wc-mobile")
], W3mConnectingWcMobile);
const styles$6 = i$4`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }
`;
var __decorate$a = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcQrcode = class W3mConnectingWcQrcode2 extends W3mConnectingWidget {
  constructor() {
    super();
    this.forceUpdate = () => {
      this.requestUpdate();
    };
    window.addEventListener("resize", this.forceUpdate);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet?.name ?? "WalletConnect", platform: "qrcode" }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("resize", this.forceUpdate);
  }
  render() {
    this.onRenderProxy();
    return x`
      <wui-flex padding="xl" flexDirection="column" gap="xl" alignItems="center">
        <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

        <wui-text variant="paragraph-500" color="fg-100">
          Scan this QR Code with your phone
        </wui-text>
        ${this.copyTemplate()}
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.timeout = setTimeout(() => {
        this.ready = true;
      }, 200);
    }
  }
  qrCodeTemplate() {
    if (!this.uri || !this.ready) {
      return null;
    }
    const size2 = this.getBoundingClientRect().width - 40;
    const alt = this.wallet ? this.wallet.name : void 0;
    ConnectionController.setWcLinking(void 0);
    ConnectionController.setRecentWallet(this.wallet);
    return x` <wui-qr-code
      size=${size2}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      imageSrc=${o$2(AssetUtil.getWalletImage(this.wallet))}
      alt=${o$2(alt)}
    ></wui-qr-code>`;
  }
  copyTemplate() {
    const inactive = !this.uri || !this.ready;
    return x`<wui-link
      .disabled=${inactive}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
      Copy link
    </wui-link>`;
  }
};
W3mConnectingWcQrcode.styles = styles$6;
W3mConnectingWcQrcode = __decorate$a([
  customElement("w3m-connecting-wc-qrcode")
], W3mConnectingWcQrcode);
const styles$5 = i$4`
  :host {
    display: flex;
    justify-content: center;
    gap: var(--wui-spacing-2xl);
  }

  wui-visual-thumbnail:nth-child(1) {
    z-index: 1;
  }
`;
var __decorate$9 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingSiwe = class W3mConnectingSiwe2 extends s$1 {
  constructor() {
    super(...arguments);
    this.dappImageUrl = OptionsController.state.metadata?.icons;
    this.walletImageUrl = StorageUtil.getConnectedWalletImageUrl();
  }
  firstUpdated() {
    const visuals = this.shadowRoot?.querySelectorAll("wui-visual-thumbnail");
    if (visuals?.[0]) {
      this.createAnimation(visuals[0], "translate(18px)");
    }
    if (visuals?.[1]) {
      this.createAnimation(visuals[1], "translate(-18px)");
    }
  }
  render() {
    return x`
      <wui-visual-thumbnail
        ?borderRadiusFull=${true}
        .imageSrc=${this.dappImageUrl?.[0]}
      ></wui-visual-thumbnail>
      <wui-visual-thumbnail .imageSrc=${this.walletImageUrl}></wui-visual-thumbnail>
    `;
  }
  createAnimation(element, translation) {
    element.animate([{ transform: "translateX(0px)" }, { transform: translation }], {
      duration: 1600,
      easing: "cubic-bezier(0.56, 0, 0.48, 1)",
      direction: "alternate",
      iterations: Infinity
    });
  }
};
W3mConnectingSiwe.styles = styles$5;
W3mConnectingSiwe = __decorate$9([
  customElement("w3m-connecting-siwe")
], W3mConnectingSiwe);
var __decorate$8 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcUnsupported = class W3mConnectingWcUnsupported2 extends s$1 {
  constructor() {
    super();
    this.wallet = RouterController.state.data?.wallet;
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-unsupported: No wallet provided");
    }
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  render() {
    return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-wallet-image
          size="lg"
          imageSrc=${o$2(AssetUtil.getWalletImage(this.wallet))}
        ></wui-wallet-image>

        <wui-text variant="paragraph-500" color="fg-100">Not Detected</wui-text>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
};
W3mConnectingWcUnsupported = __decorate$8([
  customElement("w3m-connecting-wc-unsupported")
], W3mConnectingWcUnsupported);
var __decorate$7 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcWeb = class W3mConnectingWcWeb2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-web: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.secondaryBtnLabel = "Open";
    this.secondaryLabel = "Open and continue in a new browser tab";
    this.secondaryBtnIcon = "externalLink";
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "web" }
    });
  }
  onConnectProxy() {
    if (this.wallet?.webapp_link && this.uri) {
      try {
        this.error = false;
        const { webapp_link, name: name2 } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatUniversalUrl(webapp_link, this.uri);
        ConnectionController.setWcLinking({ name: name2, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_blank");
      } catch {
        this.error = true;
      }
    }
  }
};
W3mConnectingWcWeb = __decorate$7([
  customElement("w3m-connecting-wc-web")
], W3mConnectingWcWeb);
const styles$4 = i$4`
  wui-icon-link[data-hidden='true'] {
    opacity: 0 !important;
    pointer-events: none;
  }
`;
var __decorate$6 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
function headings() {
  const connectorName = RouterController.state.data?.connector?.name;
  const walletName = RouterController.state.data?.wallet?.name;
  const networkName = RouterController.state.data?.network?.name;
  const name2 = walletName ?? connectorName;
  const connectors = ConnectorController.getConnectors();
  const isEmail = connectors.length === 1 && connectors[0]?.id === "w3m-email";
  return {
    Connect: `Connect ${isEmail ? "Email" : ""} Wallet`,
    Account: void 0,
    ConnectingExternal: name2 ?? "Connect Wallet",
    ConnectingWalletConnect: name2 ?? "WalletConnect",
    ConnectingSiwe: "Sign In",
    Networks: "Choose Network",
    SwitchNetwork: networkName ?? "Switch Network",
    AllWallets: "All Wallets",
    WhatIsANetwork: "What is a network?",
    WhatIsAWallet: "What is a wallet?",
    GetWallet: "Get a wallet",
    Downloads: name2 ? `Get ${name2}` : "Downloads",
    EmailVerifyOtp: "Confirm Email",
    EmailVerifyDevice: "Register Device",
    ApproveTransaction: "Approve Transaction",
    Transactions: "Activity",
    UpgradeEmailWallet: "Upgrade your Wallet",
    UpdateEmailWallet: "Edit Email",
    UpdateEmailWalletWaiting: "Approve Email"
  };
}
let W3mHeader = class W3mHeader2 extends s$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.heading = headings()[RouterController.state.view];
    this.buffering = false;
    this.showBack = false;
    this.unsubscribe.push(RouterController.subscribeKey("view", (val) => {
      this.onViewChange(val);
      this.onHistoryChange();
    }), ConnectionController.subscribeKey("buffering", (val) => this.buffering = val));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`
      <wui-flex .padding=${this.getPadding()} justifyContent="space-between" alignItems="center">
        ${this.dynamicButtonTemplate()} ${this.titleTemplate()}
        <wui-icon-link
          ?disabled=${this.buffering}
          icon="close"
          @click=${this.onClose.bind(this)}
          data-testid="w3m-header-close"
        ></wui-icon-link>
      </wui-flex>
      ${this.separatorTemplate()}
    `;
  }
  onWalletHelp() {
    EventsController.sendEvent({ type: "track", event: "CLICK_WALLET_HELP" });
    RouterController.push("WhatIsAWallet");
  }
  async onClose() {
    if (SIWEController.state.isSiweEnabled && SIWEController.state.status !== "success") {
      await ConnectionController.disconnect();
    }
    ModalController.close();
  }
  titleTemplate() {
    return x`<wui-text variant="paragraph-700" color="fg-100">${this.heading}</wui-text>`;
  }
  dynamicButtonTemplate() {
    const { view } = RouterController.state;
    const isConnectHelp = view === "Connect";
    const isApproveTransaction = view === "ApproveTransaction";
    if (this.showBack && !isApproveTransaction) {
      return x`<wui-icon-link
        id="dynamic"
        icon="chevronLeft"
        ?disabled=${this.buffering}
        @click=${this.onGoBack.bind(this)}
      ></wui-icon-link>`;
    }
    return x`<wui-icon-link
      data-hidden=${!isConnectHelp}
      id="dynamic"
      icon="helpCircle"
      @click=${this.onWalletHelp.bind(this)}
    ></wui-icon-link>`;
  }
  separatorTemplate() {
    if (!this.heading) {
      return null;
    }
    return x`<wui-separator></wui-separator>`;
  }
  getPadding() {
    if (this.heading) {
      return ["l", "2l", "l", "2l"];
    }
    return ["l", "2l", "0", "2l"];
  }
  async onViewChange(view) {
    const headingEl = this.shadowRoot?.querySelector("wui-text");
    if (headingEl) {
      const preset = headings()[view];
      await headingEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.heading = preset;
      headingEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  async onHistoryChange() {
    const { history } = RouterController.state;
    const buttonEl = this.shadowRoot?.querySelector("#dynamic");
    if (history.length > 1 && !this.showBack && buttonEl) {
      await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.showBack = true;
      buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    } else if (history.length <= 1 && this.showBack && buttonEl) {
      await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.showBack = false;
      buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  onGoBack() {
    if (RouterController.state.view === "ConnectingSiwe") {
      RouterController.push("Connect");
    } else {
      RouterController.goBack();
    }
  }
};
W3mHeader.styles = [styles$4];
__decorate$6([
  r$1()
], W3mHeader.prototype, "heading", void 0);
__decorate$6([
  r$1()
], W3mHeader.prototype, "buffering", void 0);
__decorate$6([
  r$1()
], W3mHeader.prototype, "showBack", void 0);
W3mHeader = __decorate$6([
  customElement("w3m-header")
], W3mHeader);
var __decorate$5 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mHelpWidget = class W3mHelpWidget2 extends s$1 {
  constructor() {
    super(...arguments);
    this.data = [];
  }
  render() {
    return x`
      <wui-flex flexDirection="column" alignItems="center" gap="l">
        ${this.data.map((item) => x`
            <wui-flex flexDirection="column" alignItems="center" gap="xl">
              <wui-flex flexDirection="row" justifyContent="center" gap="1xs">
                ${item.images.map((image) => x`<wui-visual name=${image}></wui-visual>`)}
              </wui-flex>
            </wui-flex>
            <wui-flex flexDirection="column" alignItems="center" gap="xxs">
              <wui-text variant="paragraph-500" color="fg-100" align="center">
                ${item.title}
              </wui-text>
              <wui-text variant="small-500" color="fg-200" align="center">${item.text}</wui-text>
            </wui-flex>
          `)}
      </wui-flex>
    `;
  }
};
__decorate$5([
  n$2({ type: Array })
], W3mHelpWidget.prototype, "data", void 0);
W3mHelpWidget = __decorate$5([
  customElement("w3m-help-widget")
], W3mHelpWidget);
const styles$3 = i$4`
  wui-flex {
    background-color: var(--wui-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
  }
`;
var __decorate$4 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mLegalFooter = class W3mLegalFooter2 extends s$1 {
  render() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    if (!termsConditionsUrl && !privacyPolicyUrl) {
      return null;
    }
    return x`
      <wui-flex .padding=${["m", "s", "s", "s"]} justifyContent="center">
        <wui-text color="fg-250" variant="small-400" align="center">
          By connecting your wallet, you agree to our <br />
          ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
        </wui-text>
      </wui-flex>
    `;
  }
  andTemplate() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    return termsConditionsUrl && privacyPolicyUrl ? "and" : "";
  }
  termsTemplate() {
    const { termsConditionsUrl } = OptionsController.state;
    if (!termsConditionsUrl) {
      return null;
    }
    return x`<a href=${termsConditionsUrl}>Terms of Service</a>`;
  }
  privacyTemplate() {
    const { privacyPolicyUrl } = OptionsController.state;
    if (!privacyPolicyUrl) {
      return null;
    }
    return x`<a href=${privacyPolicyUrl}>Privacy Policy</a>`;
  }
};
W3mLegalFooter.styles = [styles$3];
W3mLegalFooter = __decorate$4([
  customElement("w3m-legal-footer")
], W3mLegalFooter);
const styles$2 = i$4`
  :host {
    display: block;
    padding: 0 var(--wui-spacing-xl) var(--wui-spacing-xl);
  }
`;
var __decorate$3 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mMobileDownloadLinks = class W3mMobileDownloadLinks2 extends s$1 {
  constructor() {
    super(...arguments);
    this.wallet = void 0;
  }
  render() {
    if (!this.wallet) {
      this.style.display = "none";
      return null;
    }
    const { name: name2, app_store, play_store, chrome_store, homepage: homepage2 } = this.wallet;
    const isMobile = CoreHelperUtil.isMobile();
    const isIos = CoreHelperUtil.isIos();
    const isAndroid = CoreHelperUtil.isAndroid();
    const isMultiple = [app_store, play_store, homepage2, chrome_store].filter(Boolean).length > 1;
    const shortName = UiHelperUtil.getTruncateString({
      string: name2,
      charsStart: 12,
      charsEnd: 0,
      truncate: "end"
    });
    if (isMultiple && !isMobile) {
      return x`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${() => RouterController.push("Downloads", { wallet: this.wallet })}
        ></wui-cta-button>
      `;
    }
    if (!isMultiple && homepage2) {
      return x`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onHomePage.bind(this)}
        ></wui-cta-button>
      `;
    }
    if (app_store && isIos) {
      return x`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onAppStore.bind(this)}
        ></wui-cta-button>
      `;
    }
    if (play_store && isAndroid) {
      return x`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onPlayStore.bind(this)}
        ></wui-cta-button>
      `;
    }
    this.style.display = "none";
    return null;
  }
  onAppStore() {
    if (this.wallet?.app_store) {
      CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
    }
  }
  onPlayStore() {
    if (this.wallet?.play_store) {
      CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
    }
  }
  onHomePage() {
    if (this.wallet?.homepage) {
      CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
    }
  }
};
W3mMobileDownloadLinks.styles = [styles$2];
__decorate$3([
  n$2({ type: Object })
], W3mMobileDownloadLinks.prototype, "wallet", void 0);
W3mMobileDownloadLinks = __decorate$3([
  customElement("w3m-mobile-download-links")
], W3mMobileDownloadLinks);
const styles$1 = i$4`
  :host {
    display: block;
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 11px;
    left: 50%;
    width: max-content;
  }
`;
var __decorate$2 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const presets = {
  success: {
    backgroundColor: "success-100",
    iconColor: "success-100",
    icon: "checkmark"
  },
  error: {
    backgroundColor: "error-100",
    iconColor: "error-100",
    icon: "close"
  }
};
let W3mSnackBar = class W3mSnackBar2 extends s$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.timeout = void 0;
    this.open = SnackController.state.open;
    this.unsubscribe.push(SnackController.subscribeKey("open", (val) => {
      this.open = val;
      this.onOpen();
    }));
  }
  disconnectedCallback() {
    clearTimeout(this.timeout);
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { message, variant } = SnackController.state;
    const preset = presets[variant];
    return x`
      <wui-snackbar
        message=${message}
        backgroundColor=${preset.backgroundColor}
        iconColor=${preset.iconColor}
        icon=${preset.icon}
      ></wui-snackbar>
    `;
  }
  onOpen() {
    clearTimeout(this.timeout);
    if (this.open) {
      this.animate([
        { opacity: 0, transform: "translateX(-50%) scale(0.85)" },
        { opacity: 1, transform: "translateX(-50%) scale(1)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
      this.timeout = setTimeout(() => SnackController.hide(), 2500);
    } else {
      this.animate([
        { opacity: 1, transform: "translateX(-50%) scale(1)" },
        { opacity: 0, transform: "translateX(-50%) scale(0.85)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
W3mSnackBar.styles = styles$1;
__decorate$2([
  r$1()
], W3mSnackBar.prototype, "open", void 0);
W3mSnackBar = __decorate$2([
  customElement("w3m-snackbar")
], W3mSnackBar);
const styles = i$4`
  :host {
    padding: var(--wui-spacing-3xs) 0;
  }

  wui-separator {
    margin: var(--wui-spacing-s) calc(var(--wui-spacing-s) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }

  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
    margin-bottom: var(--wui-spacing-m);
  }

  wui-icon-link,
  wui-loading-spinner {
    position: absolute;
    top: 22px;
    transform: translateY(-50%);
  }

  wui-icon-link {
    right: var(--wui-spacing-xs);
  }

  wui-loading-spinner {
    right: var(--wui-spacing-m);
  }

  .alphaBanner {
    padding: 10px 12px 10px 10px;
    border-radius: var(--wui-border-radius-s);
    background: var(--wui-accent-glass-010);
    margin-bottom: var(--wui-spacing-xxs);
  }
`;
var __decorate$1 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mEmailLoginWidget = class W3mEmailLoginWidget2 extends s$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.formRef = e();
    this.connectors = ConnectorController.state.connectors;
    this.email = "";
    this.loading = false;
    this.error = "";
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  firstUpdated() {
    this.formRef.value?.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        this.onSubmitEmail(event);
      }
    });
  }
  render() {
    const multipleConnectors = this.connectors.length > 1;
    const connector = this.connectors.find((c2) => c2.type === "EMAIL");
    if (!connector) {
      return null;
    }
    return x`
      ${this.alphaWarningTemplate()}
      <form ${n3(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
        <wui-email-input
          @focus=${this.onFocusEvent.bind(this)}
          .disabled=${this.loading}
          @inputChange=${this.onEmailInputChange.bind(this)}
          .errorMessage=${this.error}
        >
        </wui-email-input>

        ${this.submitButtonTemplate()}${this.loadingTemplate()}
        <input type="submit" hidden />
      </form>

      ${multipleConnectors ? x`<wui-separator text="or"></wui-separator>` : null}
    `;
  }
  alphaWarningTemplate() {
    const showAlphaWarning = true;
    return showAlphaWarning ? x`
          <wui-flex class="alphaBanner" gap="xs" alignItems="center" justifyContent="center">
            <wui-icon-box
              size="sm"
              icon="alpha"
              iconColor="accent-100"
              background="opaque"
              backgroundColor="accent-100"
            ></wui-icon-box>
            <wui-text variant="small-400" color="accent-100">
              This is an alpha version to test before launch
            </wui-text>
          </wui-flex>
        ` : null;
  }
  submitButtonTemplate() {
    const showSubmit = !this.loading && this.email.length > 3;
    return showSubmit ? x`
          <wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitEmail.bind(this)}
          >
          </wui-icon-link>
        ` : null;
  }
  loadingTemplate() {
    return this.loading ? x`<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>` : null;
  }
  onEmailInputChange(event) {
    this.email = event.detail;
    this.error = "";
  }
  async onSubmitEmail(event) {
    try {
      if (this.loading) {
        return;
      }
      this.loading = true;
      event.preventDefault();
      const emailConnector = ConnectorController.getEmailConnector();
      if (!emailConnector) {
        throw new Error("w3m-email-login-widget: Email connector not found");
      }
      const { action } = await emailConnector.provider.connectEmail({ email: this.email });
      EventsController.sendEvent({ type: "track", event: "EMAIL_SUBMITTED" });
      if (action === "VERIFY_OTP") {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
        RouterController.push("EmailVerifyOtp", { email: this.email });
      } else if (action === "VERIFY_DEVICE") {
        RouterController.push("EmailVerifyDevice", { email: this.email });
      }
    } catch (error) {
      const parsedError = CoreHelperUtil.parseError(error);
      if (parsedError?.includes("Invalid email")) {
        this.error = "Invalid email. Try again.";
      } else {
        SnackController.showError(error);
      }
    } finally {
      this.loading = false;
    }
  }
  onFocusEvent() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_LOGIN_SELECTED" });
  }
};
W3mEmailLoginWidget.styles = styles;
__decorate$1([
  r$1()
], W3mEmailLoginWidget.prototype, "connectors", void 0);
__decorate$1([
  r$1()
], W3mEmailLoginWidget.prototype, "email", void 0);
__decorate$1([
  r$1()
], W3mEmailLoginWidget.prototype, "loading", void 0);
__decorate$1([
  r$1()
], W3mEmailLoginWidget.prototype, "error", void 0);
W3mEmailLoginWidget = __decorate$1([
  customElement("w3m-email-login-widget")
], W3mEmailLoginWidget);
let isInitialized = false;
class Web3ModalScaffold {
  constructor(options) {
    this.initPromise = void 0;
    this.setIsConnected = (isConnected) => {
      AccountController.setIsConnected(isConnected);
    };
    this.setCaipAddress = (caipAddress) => {
      AccountController.setCaipAddress(caipAddress);
    };
    this.setBalance = (balance, balanceSymbol) => {
      AccountController.setBalance(balance, balanceSymbol);
    };
    this.setProfileName = (profileName) => {
      AccountController.setProfileName(profileName);
    };
    this.setProfileImage = (profileImage) => {
      AccountController.setProfileImage(profileImage);
    };
    this.resetAccount = () => {
      AccountController.resetAccount();
    };
    this.setCaipNetwork = (caipNetwork) => {
      NetworkController.setCaipNetwork(caipNetwork);
    };
    this.getCaipNetwork = () => NetworkController.state.caipNetwork;
    this.setRequestedCaipNetworks = (requestedCaipNetworks) => {
      NetworkController.setRequestedCaipNetworks(requestedCaipNetworks);
    };
    this.getApprovedCaipNetworksData = () => NetworkController.getApprovedCaipNetworksData();
    this.resetNetwork = () => {
      NetworkController.resetNetwork();
    };
    this.setConnectors = (connectors) => {
      ConnectorController.setConnectors(connectors);
    };
    this.addConnector = (connector) => {
      ConnectorController.addConnector(connector);
    };
    this.getConnectors = () => ConnectorController.getConnectors();
    this.resetWcConnection = () => {
      ConnectionController.resetWcConnection();
    };
    this.fetchIdentity = (request2) => BlockchainApiController.fetchIdentity(request2);
    this.setAddressExplorerUrl = (addressExplorerUrl) => {
      AccountController.setAddressExplorerUrl(addressExplorerUrl);
    };
    this.setSIWENonce = (nonce) => {
      SIWEController.setNonce(nonce);
    };
    this.setSIWESession = (session) => {
      SIWEController.setSession(session);
    };
    this.setSIWEStatus = (status) => {
      SIWEController.setStatus(status);
    };
    this.setSIWEMessage = (message) => {
      SIWEController.setMessage(message);
    };
    this.initControllers(options);
    this.initOrContinue();
  }
  async open(options) {
    await this.initOrContinue();
    ModalController.open(options);
  }
  async close() {
    await this.initOrContinue();
    ModalController.close();
  }
  setLoading(loading) {
    ModalController.setLoading(loading);
  }
  getThemeMode() {
    return ThemeController.state.themeMode;
  }
  getThemeVariables() {
    return ThemeController.state.themeVariables;
  }
  setThemeMode(themeMode) {
    ThemeController.setThemeMode(themeMode);
    setColorTheme(ThemeController.state.themeMode);
    try {
      const emailConnector = ConnectorController.getEmailConnector();
      if (emailConnector) {
        emailConnector.provider.syncTheme({
          themeMode: ThemeController.getSnapshot().themeMode
        });
      }
    } catch {
      console.info("Unable to sync theme to email connector");
    }
  }
  setThemeVariables(themeVariables) {
    ThemeController.setThemeVariables(themeVariables);
    setThemeVariables(ThemeController.state.themeVariables);
    try {
      const emailConnector = ConnectorController.getEmailConnector();
      if (emailConnector) {
        emailConnector.provider.syncTheme({
          themeVariables: ThemeController.getSnapshot().themeVariables
        });
      }
    } catch {
      console.info("Unable to sync theme to email connector");
    }
  }
  subscribeTheme(callback) {
    return ThemeController.subscribe(callback);
  }
  getState() {
    return { ...PublicStateController.state };
  }
  subscribeState(callback) {
    return PublicStateController.subscribe(callback);
  }
  getEvent() {
    return { ...EventsController.state };
  }
  subscribeEvents(callback) {
    return EventsController.subscribe(callback);
  }
  subscribeSIWEState(callback) {
    return SIWEController.subscribe(callback);
  }
  initControllers(options) {
    NetworkController.setClient(options.networkControllerClient);
    NetworkController.setDefaultCaipNetwork(options.defaultChain);
    OptionsController.setProjectId(options.projectId);
    OptionsController.setIncludeWalletIds(options.includeWalletIds);
    OptionsController.setExcludeWalletIds(options.excludeWalletIds);
    OptionsController.setFeaturedWalletIds(options.featuredWalletIds);
    OptionsController.setTokens(options.tokens);
    OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);
    OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);
    OptionsController.setCustomWallets(options.customWallets);
    OptionsController.setEnableAnalytics(options.enableAnalytics);
    OptionsController.setSdkVersion(options._sdkVersion);
    ConnectionController.setClient(options.connectionControllerClient);
    if (options.siweControllerClient) {
      const siweClient = options.siweControllerClient;
      SIWEController.setSIWEClient(siweClient);
    }
    if (options.metadata) {
      OptionsController.setMetadata(options.metadata);
    }
    if (options.themeMode) {
      ThemeController.setThemeMode(options.themeMode);
    }
    if (options.themeVariables) {
      ThemeController.setThemeVariables(options.themeVariables);
    }
  }
  async initOrContinue() {
    if (!this.initPromise && !isInitialized && CoreHelperUtil.isClient()) {
      isInitialized = true;
      this.initPromise = new Promise(async (resolve) => {
        await Promise.all([__vitePreload(() => Promise.resolve().then(() => index$1), true ? void 0 : void 0), __vitePreload(() => Promise.resolve().then(() => index), true ? void 0 : void 0)]);
        const modal2 = document.createElement("w3m-modal");
        document.body.insertAdjacentElement("beforeend", modal2);
        resolve();
      });
    }
    return this.initPromise;
  }
}
const ConstantsUtil = {
  WALLET_CONNECT_CONNECTOR_ID: "walletConnect",
  INJECTED_CONNECTOR_ID: "injected",
  COINBASE_CONNECTOR_ID: "coinbaseWallet",
  COINBASE_SDK_CONNECTOR_ID: "coinbaseWalletSDK",
  SAFE_CONNECTOR_ID: "safe",
  LEDGER_CONNECTOR_ID: "ledger",
  EIP6963_CONNECTOR_ID: "eip6963",
  EMAIL_CONNECTOR_ID: "w3mEmail",
  EIP155: "eip155",
  ADD_CHAIN_METHOD: "wallet_addEthereumChain",
  EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
  EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
  VERSION: "3.6.0-544a28f1"
};
const PresetsUtil = {
  ConnectorExplorerIds: {
    [ConstantsUtil.COINBASE_CONNECTOR_ID]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    [ConstantsUtil.SAFE_CONNECTOR_ID]: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
    [ConstantsUtil.LEDGER_CONNECTOR_ID]: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927"
  },
  EIP155NetworkImageIds: {
    1: "692ed6ba-e569-459a-556a-776476829e00",
    42161: "600a9a04-c1b9-42ca-6785-9b4b6ff85200",
    43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
    56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
    250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
    10: "ab9c186a-c52f-464b-2906-ca59d760a400",
    137: "41d04d42-da3b-4453-8506-668cc0727900",
    100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
    9001: "f926ff41-260d-4028-635e-91913fc28e00",
    324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
    314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
    4689: "34e68754-e536-40da-c153-6ef2e7188a00",
    1088: "3897a66d-40b9-4833-162f-a2c90531c900",
    1284: "161038da-44ae-4ec7-1208-0ea569454b00",
    1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
    7777777: "845c60df-d429-4991-e687-91ae45791600",
    42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
    8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
    1313161554: "3ff73439-a619-4894-9262-4470c773a100"
  },
  ConnectorImageIds: {
    [ConstantsUtil.COINBASE_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [ConstantsUtil.COINBASE_SDK_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [ConstantsUtil.SAFE_CONNECTOR_ID]: "461db637-8616-43ce-035a-d89b8a1d5800",
    [ConstantsUtil.LEDGER_CONNECTOR_ID]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
    [ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
    [ConstantsUtil.INJECTED_CONNECTOR_ID]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00"
  },
  ConnectorNamesMap: {
    [ConstantsUtil.INJECTED_CONNECTOR_ID]: "Browser Wallet",
    [ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID]: "WalletConnect",
    [ConstantsUtil.COINBASE_CONNECTOR_ID]: "Coinbase",
    [ConstantsUtil.COINBASE_SDK_CONNECTOR_ID]: "Coinbase",
    [ConstantsUtil.LEDGER_CONNECTOR_ID]: "Ledger",
    [ConstantsUtil.SAFE_CONNECTOR_ID]: "Safe"
  },
  ConnectorTypesMap: {
    [ConstantsUtil.INJECTED_CONNECTOR_ID]: "INJECTED",
    [ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID]: "WALLET_CONNECT",
    [ConstantsUtil.EIP6963_CONNECTOR_ID]: "ANNOUNCED",
    [ConstantsUtil.EMAIL_CONNECTOR_ID]: "EMAIL"
  },
  WalletConnectRpcChainIds: [
    1,
    5,
    11155111,
    10,
    420,
    42161,
    421613,
    137,
    80001,
    42220,
    1313161554,
    1313161555,
    56,
    97,
    43114,
    43113,
    100,
    8453,
    84531,
    7777777,
    999,
    324,
    280
  ]
};
const HelpersUtil = {
  caipNetworkIdToNumber(caipnetworkId) {
    return caipnetworkId ? Number(caipnetworkId.split(":")[1]) : void 0;
  },
  getCaipTokens(tokens2) {
    if (!tokens2) {
      return void 0;
    }
    const caipTokens = {};
    Object.entries(tokens2).forEach(([id2, token2]) => {
      caipTokens[`${ConstantsUtil.EIP155}:${id2}`] = token2;
    });
    return caipTokens;
  }
};
function getCaipDefaultChain(chain) {
  if (!chain) {
    return void 0;
  }
  return {
    id: `${ConstantsUtil.EIP155}:${chain.id}`,
    name: chain.name,
    imageId: PresetsUtil.EIP155NetworkImageIds[chain.id]
  };
}
const WALLET_CHOICE_KEY = "wagmi.wallet";
class Web3Modal extends Web3ModalScaffold {
  constructor(options) {
    const { wagmiConfig: wagmiConfig2, siweConfig, chains: chains2, defaultChain, tokens: tokens2, _sdkVersion, ...w3mOptions } = options;
    if (!wagmiConfig2) {
      throw new Error("web3modal:constructor - wagmiConfig is undefined");
    }
    if (!w3mOptions.projectId) {
      throw new Error("web3modal:constructor - projectId is undefined");
    }
    const networkControllerClient = {
      switchCaipNetwork: async (caipNetwork) => {
        const chainId2 = HelpersUtil.caipNetworkIdToNumber(caipNetwork?.id);
        if (chainId2) {
          await switchNetwork({ chainId: chainId2 });
        }
      },
      async getApprovedCaipNetworksData() {
        const walletChoice = localStorage.getItem(WALLET_CHOICE_KEY);
        if (walletChoice?.includes(ConstantsUtil.EMAIL_CONNECTOR_ID)) {
          return {
            supportsAllNetworks: false,
            approvedCaipNetworkIds: PresetsUtil.WalletConnectRpcChainIds.map((id2) => `${ConstantsUtil.EIP155}:${id2}`)
          };
        } else if (walletChoice?.includes(ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID)) {
          const connector = wagmiConfig2.connectors.find((c2) => c2.id === ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID);
          if (!connector) {
            throw new Error("networkControllerClient:getApprovedCaipNetworks - connector is undefined");
          }
          const provider = await connector.getProvider();
          const ns = provider.signer?.session?.namespaces;
          const nsMethods = ns?.[ConstantsUtil.EIP155]?.methods;
          const nsChains = ns?.[ConstantsUtil.EIP155]?.chains;
          return {
            supportsAllNetworks: nsMethods?.includes(ConstantsUtil.ADD_CHAIN_METHOD),
            approvedCaipNetworkIds: nsChains
          };
        }
        return { approvedCaipNetworkIds: void 0, supportsAllNetworks: true };
      }
    };
    const connectionControllerClient = {
      connectWalletConnect: async (onUri) => {
        const connector = wagmiConfig2.connectors.find((c2) => c2.id === ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID);
        if (!connector) {
          throw new Error("connectionControllerClient:getWalletConnectUri - connector is undefined");
        }
        connector.on("message", (event) => {
          if (event.type === "display_uri") {
            onUri(event.data);
            connector.removeAllListeners();
          }
        });
        const chainId2 = HelpersUtil.caipNetworkIdToNumber(this.getCaipNetwork()?.id);
        await connect({ connector, chainId: chainId2 });
      },
      connectExternal: async ({ id: id2, provider, info }) => {
        const connector = wagmiConfig2.connectors.find((c2) => c2.id === id2);
        if (!connector) {
          throw new Error("connectionControllerClient:connectExternal - connector is undefined");
        }
        if (provider && info && connector.id === ConstantsUtil.EIP6963_CONNECTOR_ID) {
          connector.setEip6963Wallet?.({ provider, info });
        }
        const chainId2 = HelpersUtil.caipNetworkIdToNumber(this.getCaipNetwork()?.id);
        await connect({ connector, chainId: chainId2 });
      },
      checkInstalled: (ids) => {
        const eip6963Connectors = this.getConnectors().filter((c2) => c2.type === "ANNOUNCED");
        const injectedConnector = this.getConnectors().find((c2) => c2.type === "INJECTED");
        if (!ids) {
          return Boolean(window.ethereum);
        }
        if (eip6963Connectors.length) {
          const installed = ids.some((id2) => eip6963Connectors.some((c2) => c2.info?.rdns === id2));
          if (installed) {
            return true;
          }
        }
        if (injectedConnector) {
          if (!window?.ethereum) {
            return false;
          }
          return ids.some((id2) => Boolean(window.ethereum?.[String(id2)]));
        }
        return false;
      },
      disconnect: async () => {
        await disconnect();
        if (siweConfig?.options?.signOutOnDisconnect) {
          await siweConfig.signOut();
        }
      },
      signMessage: async (message) => signMessage({ message })
    };
    super({
      networkControllerClient,
      connectionControllerClient,
      siweControllerClient: siweConfig,
      defaultChain: getCaipDefaultChain(defaultChain),
      tokens: HelpersUtil.getCaipTokens(tokens2),
      _sdkVersion: _sdkVersion ?? `html-wagmi-${ConstantsUtil.VERSION}`,
      ...w3mOptions
    });
    this.hasSyncedConnectedAccount = false;
    this.options = void 0;
    this.options = options;
    this.syncRequestedNetworks(chains2);
    this.syncConnectors(wagmiConfig2);
    this.syncEmailConnector(wagmiConfig2);
    this.listenEIP6963Connector(wagmiConfig2);
    this.listenEmailConnector(wagmiConfig2);
    watchAccount(() => this.syncAccount());
    watchNetwork(() => this.syncNetwork());
  }
  getState() {
    const state2 = super.getState();
    return {
      ...state2,
      selectedNetworkId: HelpersUtil.caipNetworkIdToNumber(state2.selectedNetworkId)
    };
  }
  subscribeState(callback) {
    return super.subscribeState((state2) => callback({
      ...state2,
      selectedNetworkId: HelpersUtil.caipNetworkIdToNumber(state2.selectedNetworkId)
    }));
  }
  syncRequestedNetworks(chains2) {
    const requestedCaipNetworks = chains2?.map((chain) => ({
      id: `${ConstantsUtil.EIP155}:${chain.id}`,
      name: chain.name,
      imageId: PresetsUtil.EIP155NetworkImageIds[chain.id],
      imageUrl: this.options?.chainImages?.[chain.id]
    }));
    this.setRequestedCaipNetworks(requestedCaipNetworks ?? []);
  }
  async syncAccount() {
    const { address, isConnected } = getAccount();
    const { chain } = getNetwork();
    this.resetAccount();
    if (isConnected && address && chain) {
      const caipAddress = `${ConstantsUtil.EIP155}:${chain.id}:${address}`;
      this.setIsConnected(isConnected);
      this.setCaipAddress(caipAddress);
      await Promise.all([
        this.syncProfile(address, chain),
        this.syncBalance(address, chain),
        this.getApprovedCaipNetworksData()
      ]);
      this.hasSyncedConnectedAccount = true;
    } else if (!isConnected && this.hasSyncedConnectedAccount) {
      this.resetWcConnection();
      this.resetNetwork();
    }
  }
  async syncNetwork() {
    const { address, isConnected } = getAccount();
    const { chain } = getNetwork();
    if (chain) {
      const chainId2 = String(chain.id);
      const caipChainId = `${ConstantsUtil.EIP155}:${chainId2}`;
      this.setCaipNetwork({
        id: caipChainId,
        name: chain.name,
        imageId: PresetsUtil.EIP155NetworkImageIds[chain.id],
        imageUrl: this.options?.chainImages?.[chain.id]
      });
      if (isConnected && address) {
        const caipAddress = `${ConstantsUtil.EIP155}:${chain.id}:${address}`;
        this.setCaipAddress(caipAddress);
        if (chain.blockExplorers?.default?.url) {
          const url = `${chain.blockExplorers.default.url}/address/${address}`;
          this.setAddressExplorerUrl(url);
        } else {
          this.setAddressExplorerUrl(void 0);
        }
        if (this.hasSyncedConnectedAccount) {
          await this.syncProfile(address, chain);
          await this.syncBalance(address, chain);
        }
      }
    }
  }
  async syncProfile(address, chain) {
    if (chain.id !== mainnet.id) {
      this.setProfileName(null);
      this.setProfileImage(null);
      return;
    }
    try {
      const { name: name2, avatar } = await this.fetchIdentity({
        caipChainId: `${ConstantsUtil.EIP155}:${chain.id}`,
        address
      });
      this.setProfileName(name2);
      this.setProfileImage(avatar);
    } catch {
      const profileName = await fetchEnsName({ address, chainId: chain.id });
      if (profileName) {
        this.setProfileName(profileName);
        const profileImage = await fetchEnsAvatar({ name: profileName, chainId: chain.id });
        if (profileImage) {
          this.setProfileImage(profileImage);
        }
      }
    }
  }
  async syncBalance(address, chain) {
    const balance = await fetchBalance({
      address,
      chainId: chain.id,
      token: this.options?.tokens?.[chain.id]?.address
    });
    this.setBalance(balance.formatted, balance.symbol);
  }
  syncConnectors(wagmiConfig2) {
    const w3mConnectors = [];
    wagmiConfig2.connectors.forEach(({ id: id2, name: name2 }) => {
      if (![ConstantsUtil.EIP6963_CONNECTOR_ID, ConstantsUtil.EMAIL_CONNECTOR_ID].includes(id2)) {
        w3mConnectors.push({
          id: id2,
          explorerId: PresetsUtil.ConnectorExplorerIds[id2],
          imageId: PresetsUtil.ConnectorImageIds[id2],
          imageUrl: this.options?.connectorImages?.[id2],
          name: PresetsUtil.ConnectorNamesMap[id2] ?? name2,
          type: PresetsUtil.ConnectorTypesMap[id2] ?? "EXTERNAL"
        });
      }
    });
    this.setConnectors(w3mConnectors);
  }
  async syncEmailConnector(wagmiConfig2) {
    const emailConnector = wagmiConfig2.connectors.find(({ id: id2 }) => id2 === "w3mEmail");
    if (emailConnector) {
      const provider = await emailConnector.getProvider();
      this.addConnector({
        id: ConstantsUtil.EMAIL_CONNECTOR_ID,
        type: "EMAIL",
        name: "Email",
        provider
      });
    }
  }
  eip6963EventHandler(connector, event) {
    if (event.detail) {
      const { info, provider } = event.detail;
      const connectors = this.getConnectors();
      const existingConnector = connectors.find((c2) => c2.name === info.name);
      if (!existingConnector) {
        this.addConnector({
          id: ConstantsUtil.EIP6963_CONNECTOR_ID,
          type: "ANNOUNCED",
          imageUrl: info.icon ?? this.options?.connectorImages?.[ConstantsUtil.EIP6963_CONNECTOR_ID],
          name: info.name,
          provider,
          info
        });
        connector.isAuthorized({ info, provider });
      }
    }
  }
  listenEIP6963Connector(wagmiConfig2) {
    const connector = wagmiConfig2.connectors.find((c2) => c2.id === ConstantsUtil.EIP6963_CONNECTOR_ID);
    if (typeof window !== "undefined" && connector) {
      const handler = this.eip6963EventHandler.bind(this, connector);
      window.addEventListener(ConstantsUtil.EIP6963_ANNOUNCE_EVENT, handler);
      window.dispatchEvent(new Event(ConstantsUtil.EIP6963_REQUEST_EVENT));
    }
  }
  async listenEmailConnector(wagmiConfig2) {
    const connector = wagmiConfig2.connectors.find((c2) => c2.id === ConstantsUtil.EMAIL_CONNECTOR_ID);
    if (typeof window !== "undefined" && connector) {
      super.setLoading(true);
      const provider = await connector.getProvider();
      const isLoginEmailUsed = provider.getLoginEmailUsed();
      super.setLoading(isLoginEmailUsed);
      provider.onRpcRequest(() => {
        super.open({ view: "ApproveTransaction" });
      });
      provider.onRpcResponse(() => {
        super.close();
      });
      provider.onIsConnected(() => {
        super.setLoading(false);
      });
    }
  }
}
var __classPrivateFieldSet$1 = function(receiver, state2, value, kind, f3) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f3)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state2 === "function" ? receiver !== state2 || !f3 : !state2.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state2.set(receiver, value), value;
};
var __classPrivateFieldGet$1 = function(receiver, state2, kind, f3) {
  if (kind === "a" && !f3)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 === "function" ? receiver !== state2 || !f3 : !state2.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state2.get(receiver);
};
var _EIP6963Connector_defaultProvider, _EIP6963Connector_eip6963Wallet;
const connectedRdnsKey = "connectedRdns";
class EIP6963Connector extends InjectedConnector {
  constructor(config2) {
    super({ chains: config2.chains, options: { shimDisconnect: true } });
    this.id = "eip6963";
    this.name = "EIP6963";
    _EIP6963Connector_defaultProvider.set(this, void 0);
    _EIP6963Connector_eip6963Wallet.set(this, void 0);
    this.onAccountsChanged = (accounts) => {
      if (accounts.length === 0) {
        this.storage?.removeItem(connectedRdnsKey);
        this.emit("disconnect");
      } else if (accounts[0]) {
        this.emit("change", {
          account: getAddress(accounts[0])
        });
      }
    };
    __classPrivateFieldSet$1(this, _EIP6963Connector_defaultProvider, this.options.getProvider(), "f");
  }
  async connect(options) {
    const data2 = await super.connect(options);
    if (__classPrivateFieldGet$1(this, _EIP6963Connector_eip6963Wallet, "f")) {
      this.storage?.setItem(connectedRdnsKey, __classPrivateFieldGet$1(this, _EIP6963Connector_eip6963Wallet, "f").info.rdns);
    }
    return data2;
  }
  async disconnect() {
    await super.disconnect();
    this.storage?.removeItem(connectedRdnsKey);
    __classPrivateFieldSet$1(this, _EIP6963Connector_eip6963Wallet, void 0, "f");
  }
  async isAuthorized(eip6963Wallet) {
    const connectedEIP6963Rdns = this.storage?.getItem(connectedRdnsKey);
    if (connectedEIP6963Rdns) {
      if (__classPrivateFieldGet$1(this, _EIP6963Connector_eip6963Wallet, "f") && connectedEIP6963Rdns === __classPrivateFieldGet$1(this, _EIP6963Connector_eip6963Wallet, "f").info.rdns) {
        const provider = __classPrivateFieldGet$1(this, _EIP6963Connector_eip6963Wallet, "f").provider;
        const accounts = await provider.request({ method: "eth_accounts" });
        if (accounts.length) {
          return true;
        }
      }
      if (eip6963Wallet) {
        __classPrivateFieldSet$1(this, _EIP6963Connector_eip6963Wallet, eip6963Wallet, "f");
      }
    }
    return super.isAuthorized();
  }
  async getProvider() {
    return Promise.resolve(__classPrivateFieldGet$1(this, _EIP6963Connector_eip6963Wallet, "f")?.provider ?? __classPrivateFieldGet$1(this, _EIP6963Connector_defaultProvider, "f"));
  }
  setEip6963Wallet(eip6963Wallet) {
    __classPrivateFieldSet$1(this, _EIP6963Connector_eip6963Wallet, eip6963Wallet, "f");
  }
}
_EIP6963Connector_defaultProvider = /* @__PURE__ */ new WeakMap(), _EIP6963Connector_eip6963Wallet = /* @__PURE__ */ new WeakMap();
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i3 = 0, len = code.length; i3 < len; ++i3) {
  lookup[i3] = code[i3];
  revLookup[code.charCodeAt(i3)] = i3;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i3;
  for (i3 = 0; i3 < len; i3 += 4) {
    tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output2 = [];
  for (var i3 = start; i3 < end; i3 += 3) {
    tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
    output2.push(tripletToBase64(tmp));
  }
  return output2.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i3 = 0, len2 = len - extraBytes; i3 < len2; i3 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len2 ? len2 : i3 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE2, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i3 = isLE2 ? nBytes - 1 : 0;
  var d2 = isLE2 ? -1 : 1;
  var s4 = buffer2[offset + i3];
  i3 += d2;
  e2 = s4 & (1 << -nBits) - 1;
  s4 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i3], i3 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i3], i3 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s4 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s4 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE2, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i3 = isLE2 ? 0 : nBytes - 1;
  var d2 = isLE2 ? 1 : -1;
  var s4 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt2 / c2;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i3] = m2 & 255, i3 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i3] = e2 & 255, i3 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset + i3 - d2] |= s4 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base642 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length2) {
    if (length2 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length2);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe2(arg);
    }
    return from2(arg, encodingOrOffset, length2);
  }
  Buffer2.poolSize = 8192;
  function from2(value, encodingOrOffset, length2) {
    if (typeof value === "string") {
      return fromString2(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length2);
    }
    const b3 = fromObject(value);
    if (b3)
      return b3;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length2) {
    return from2(value, encodingOrOffset, length2);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize2(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc2(size2, fill, encoding) {
    assertSize2(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding) {
    return alloc2(size2, fill, encoding);
  };
  function allocUnsafe2(size2) {
    assertSize2(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe2(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe2(size2);
  };
  function fromString2(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length2 = byteLength2(string2, encoding) | 0;
    let buf = createBuffer(length2);
    const actual = buf.write(string2, encoding);
    if (actual !== length2) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length2 = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length2);
    for (let i3 = 0; i3 < length2; i3 += 1) {
      buf[i3] = array[i3] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy2 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length2) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length2 === void 0) {
      buf = new Uint8Array(array);
    } else if (length2 === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length2);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length2) {
    if (length2 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length2 | 0;
  }
  function SlowBuffer(length2) {
    if (+length2 != length2) {
      length2 = 0;
    }
    return Buffer2.alloc(+length2);
  }
  Buffer2.isBuffer = function isBuffer2(b3) {
    return b3 != null && b3._isBuffer === true && b3 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare2(a2, b3) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b3, Uint8Array))
      b3 = Buffer2.from(b3, b3.offset, b3.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b3)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a2 === b3)
      return 0;
    let x2 = a2.length;
    let y2 = b3.length;
    for (let i3 = 0, len = Math.min(x2, y2); i3 < len; ++i3) {
      if (a2[i3] !== b3[i3]) {
        x2 = a2[i3];
        y2 = b3[i3];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length2) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i3;
    if (length2 === void 0) {
      length2 = 0;
      for (i3 = 0; i3 < list.length; ++i3) {
        length2 += list[i3].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length2);
    let pos = 0;
    for (i3 = 0; i3 < list.length; ++i3) {
      let buf = list[i3];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    const len = string2.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b3, n4, m2) {
    const i3 = b3[n4];
    b3[n4] = b3[m2];
    b3[m2] = i3;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i3 = 0; i3 < len; i3 += 2) {
      swap(this, i3, i3 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i3 = 0; i3 < len; i3 += 4) {
      swap(this, i3, i3 + 3);
      swap(this, i3 + 1, i3 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i3 = 0; i3 < len; i3 += 8) {
      swap(this, i3, i3 + 7);
      swap(this, i3 + 1, i3 + 6);
      swap(this, i3 + 2, i3 + 5);
      swap(this, i3 + 3, i3 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    const length2 = this.length;
    if (length2 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b3) {
    if (!Buffer2.isBuffer(b3))
      throw new TypeError("Argument must be a Buffer");
    if (this === b3)
      return true;
    return Buffer2.compare(this, b3) === 0;
  };
  Buffer2.prototype.inspect = function inspect5() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end - start;
    const len = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i3 = 0; i3 < len; ++i3) {
      if (thisCopy[i3] !== targetCopy[i3]) {
        x2 = thisCopy[i3];
        y2 = targetCopy[i3];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i4) {
      if (indexSize === 1) {
        return buf[i4];
      } else {
        return buf.readUInt16BE(i4 * indexSize);
      }
    }
    let i3;
    if (dir) {
      let foundIndex = -1;
      for (i3 = byteOffset; i3 < arrLength; i3++) {
        if (read(arr, i3) === read(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i3;
          if (i3 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i3 -= i3 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i3 = byteOffset; i3 >= 0; i3--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read(arr, i3 + j2) !== read(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i3;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string2, offset, length2) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    const strLen = string2.length;
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    let i3;
    for (i3 = 0; i3 < length2; ++i3) {
      const parsed = parseInt(string2.substr(i3 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i3;
      buf[offset + i3] = parsed;
    }
    return i3;
  }
  function utf8Write(buf, string2, offset, length2) {
    return blitBuffer(utf8ToBytes2(string2, buf.length - offset), buf, offset, length2);
  }
  function asciiWrite(buf, string2, offset, length2) {
    return blitBuffer(asciiToBytes(string2), buf, offset, length2);
  }
  function base64Write(buf, string2, offset, length2) {
    return blitBuffer(base64ToBytes(string2), buf, offset, length2);
  }
  function ucs2Write(buf, string2, offset, length2) {
    return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length2);
  }
  Buffer2.prototype.write = function write3(string2, offset, length2, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length2 = this.length;
      offset = 0;
    } else if (length2 === void 0 && typeof offset === "string") {
      encoding = offset;
      length2 = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length2)) {
        length2 = length2 >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length2;
        length2 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length2 === void 0 || length2 > remaining)
      length2 = remaining;
    if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length2);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length2);
        case "base64":
          return base64Write(this, string2, offset, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base642.fromByteArray(buf);
    } else {
      return base642.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i3 = start;
    while (i3 < end) {
      const firstByte = buf[i3];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i3 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i3 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i3 + 1];
            thirdByte = buf[i3 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i3 + 1];
            thirdByte = buf[i3 + 2];
            fourthByte = buf[i3 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i3 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i3 = 0;
    while (i3 < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i3 = start; i3 < end; ++i3) {
      ret += String.fromCharCode(buf[i3] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i3 = start; i3 < end; ++i3) {
      ret += String.fromCharCode(buf[i3]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i3 = start; i3 < end; ++i3) {
      out += hexSliceLookupTable[buf[i3]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes2 = buf.slice(start, end);
    let res = "";
    for (let i3 = 0; i3 < bytes2.length - 1; i3 += 2) {
      res += String.fromCharCode(bytes2[i3] + bytes2[i3 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice2(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length2) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul4 = 1;
    let i3 = 0;
    while (++i3 < byteLength3 && (mul4 *= 256)) {
      val += this[offset + i3] * mul4;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul4 = 1;
    while (byteLength3 > 0 && (mul4 *= 256)) {
      val += this[offset + --byteLength3] * mul4;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul4 = 1;
    let i3 = 0;
    while (++i3 < byteLength3 && (mul4 *= 256)) {
      val += this[offset + i3] * mul4;
    }
    mul4 *= 128;
    if (val >= mul4)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i3 = byteLength3;
    let mul4 = 1;
    let val = this[offset + --i3];
    while (i3 > 0 && (mul4 *= 256)) {
      val += this[offset + --i3] * mul4;
    }
    mul4 *= 128;
    if (val >= mul4)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul4 = 1;
    let i3 = 0;
    this[offset] = value & 255;
    while (++i3 < byteLength3 && (mul4 *= 256)) {
      this[offset + i3] = value / mul4 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i3 = byteLength3 - 1;
    let mul4 = 1;
    this[offset + i3] = value & 255;
    while (--i3 >= 0 && (mul4 *= 256)) {
      this[offset + i3] = value / mul4 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 2] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 1] = hi2;
    hi2 = hi2 >> 8;
    buf[offset] = hi2;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i3 = 0;
    let mul4 = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i3 < byteLength3 && (mul4 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i3 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i3] = (value / mul4 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i3 = byteLength3 - 1;
    let mul4 = 1;
    let sub = 0;
    this[offset + i3] = value & 255;
    while (--i3 >= 0 && (mul4 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i3 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i3] = (value / mul4 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i3;
    if (typeof val === "number") {
      for (i3 = start; i3 < end; ++i3) {
        this[i3] = val;
      }
    } else {
      const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len = bytes2.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i3 = 0; i3 < end - start; ++i3) {
        this[i3 + start] = bytes2[i3 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E2(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i3 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i3 >= start + 4; i3 -= 3) {
      res = `_${val.slice(i3 - 3, i3)}${res}`;
    }
    return `${val.slice(0, i3)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength3) {
    if (value > max || value < min) {
      const n4 = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n4} and < 2${n4} ** ${(byteLength3 + 1) * 8}${n4}`;
        } else {
          range = `>= -(2${n4} ** ${(byteLength3 + 1) * 8 - 1}${n4}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n4}`;
        }
      } else {
        range = `>= ${min}${n4} and <= ${max}${n4}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length2, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length2 < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      type || "offset",
      `>= ${type ? 1 : 0} and <= ${length2}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes2(string2, units) {
    units = units || Infinity;
    let codePoint;
    const length2 = string2.length;
    let leadSurrogate = null;
    const bytes2 = [];
    for (let i3 = 0; i3 < length2; ++i3) {
      codePoint = string2.charCodeAt(i3);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          } else if (i3 + 1 === length2) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes2.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes2.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes2.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i3 = 0; i3 < str.length; ++i3) {
      byteArray.push(str.charCodeAt(i3) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi2, lo;
    const byteArray = [];
    for (let i3 = 0; i3 < str.length; ++i3) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i3);
      hi2 = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length2) {
    let i3;
    for (i3 = 0; i3 < length2; ++i3) {
      if (i3 + offset >= dst.length || i3 >= src2.length)
        break;
      dst[i3 + offset] = src2[i3];
    }
    return i3;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet2 = "0123456789abcdef";
    const table = new Array(256);
    for (let i3 = 0; i3 < 16; ++i3) {
      const i16 = i3 * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet2[i3] + alphabet2[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn2) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
if (typeof window !== "undefined") {
  if (!window.Buffer) {
    window.Buffer = buffer.Buffer;
  }
  if (!window.global) {
    window.global = window;
  }
  if (!window.process) {
    window.process = {};
  }
  if (!window.process?.env) {
    window.process = { env: {} };
  }
}
var _client, _provider$1;
var CoinbaseWalletConnector = class extends Connector {
  constructor({ chains: chains2, options }) {
    super({
      chains: chains2,
      options: {
        reloadOnDisconnect: false,
        ...options
      }
    });
    this.id = "coinbaseWallet";
    this.name = "Coinbase Wallet";
    this.ready = true;
    __privateAdd$1(this, _client, void 0);
    __privateAdd$1(this, _provider$1, void 0);
    this.onAccountsChanged = (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", { account: getAddress(accounts[0]) });
    };
    this.onChainChanged = (chainId2) => {
      const id2 = normalizeChainId(chainId2);
      const unsupported = this.isChainUnsupported(id2);
      this.emit("change", { chain: { id: id2, unsupported } });
    };
    this.onDisconnect = () => {
      this.emit("disconnect");
    };
  }
  async connect({ chainId: chainId2 } = {}) {
    try {
      const provider = await this.getProvider();
      provider.on("accountsChanged", this.onAccountsChanged);
      provider.on("chainChanged", this.onChainChanged);
      provider.on("disconnect", this.onDisconnect);
      this.emit("message", { type: "connecting" });
      const accounts = await provider.enable();
      const account = getAddress(accounts[0]);
      let id2 = await this.getChainId();
      let unsupported = this.isChainUnsupported(id2);
      if (chainId2 && id2 !== chainId2) {
        const chain = await this.switchChain(chainId2);
        id2 = chain.id;
        unsupported = this.isChainUnsupported(id2);
      }
      return {
        account,
        chain: { id: id2, unsupported }
      };
    } catch (error) {
      if (/(user closed modal|accounts received is empty)/i.test(
        error.message
      ))
        throw new UserRejectedRequestError(error);
      throw error;
    }
  }
  async disconnect() {
    if (!__privateGet$1(this, _provider$1))
      return;
    const provider = await this.getProvider();
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);
    provider.disconnect();
    provider.close();
  }
  async getAccount() {
    const provider = await this.getProvider();
    const accounts = await provider.request({
      method: "eth_accounts"
    });
    return getAddress(accounts[0]);
  }
  async getChainId() {
    const provider = await this.getProvider();
    const chainId2 = normalizeChainId(provider.chainId);
    return chainId2;
  }
  async getProvider() {
    if (!__privateGet$1(this, _provider$1)) {
      let CoinbaseWalletSDK = (await __vitePreload(() => import("./index-c_1Q7joH.js").then((n4) => n4.i), true ? __vite__mapDeps([]) : void 0)).default;
      if (typeof CoinbaseWalletSDK !== "function" && typeof CoinbaseWalletSDK.default === "function")
        CoinbaseWalletSDK = CoinbaseWalletSDK.default;
      __privateSet$1(this, _client, new CoinbaseWalletSDK(this.options));
      const walletExtensionChainId = __privateGet$1(this, _client).walletExtension?.getChainId();
      const chain = this.chains.find(
        (chain2) => this.options.chainId ? chain2.id === this.options.chainId : chain2.id === walletExtensionChainId
      ) || this.chains[0];
      const chainId2 = this.options.chainId || chain?.id;
      const jsonRpcUrl = this.options.jsonRpcUrl || chain?.rpcUrls.default.http[0];
      __privateSet$1(this, _provider$1, __privateGet$1(this, _client).makeWeb3Provider(jsonRpcUrl, chainId2));
    }
    return __privateGet$1(this, _provider$1);
  }
  async getWalletClient({
    chainId: chainId2
  } = {}) {
    const [provider, account] = await Promise.all([
      this.getProvider(),
      this.getAccount()
    ]);
    const chain = this.chains.find((x2) => x2.id === chainId2);
    if (!provider)
      throw new Error("provider is required.");
    return createWalletClient({
      account,
      chain,
      transport: custom$1(provider)
    });
  }
  async isAuthorized() {
    try {
      const account = await this.getAccount();
      return !!account;
    } catch {
      return false;
    }
  }
  async switchChain(chainId2) {
    const provider = await this.getProvider();
    const id2 = numberToHex(chainId2);
    try {
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: id2 }]
      });
      return this.chains.find((x2) => x2.id === chainId2) ?? {
        id: chainId2,
        name: `Chain ${id2}`,
        network: `${id2}`,
        nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
        rpcUrls: { default: { http: [""] }, public: { http: [""] } }
      };
    } catch (error) {
      const chain = this.chains.find((x2) => x2.id === chainId2);
      if (!chain)
        throw new ChainNotConfiguredForConnectorError({
          chainId: chainId2,
          connectorId: this.id
        });
      if (error.code === 4902) {
        try {
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [
              {
                chainId: id2,
                chainName: chain.name,
                nativeCurrency: chain.nativeCurrency,
                rpcUrls: [chain.rpcUrls.public?.http[0] ?? ""],
                blockExplorerUrls: this.getBlockExplorerUrls(chain)
              }
            ]
          });
          return chain;
        } catch (error2) {
          throw new UserRejectedRequestError(error2);
        }
      }
      throw new SwitchChainError(error);
    }
  }
  async watchAsset({
    address,
    decimals = 18,
    image,
    symbol
  }) {
    const provider = await this.getProvider();
    return provider.request({
      method: "wallet_watchAsset",
      params: {
        type: "ERC20",
        options: {
          address,
          decimals,
          image,
          symbol
        }
      }
    });
  }
};
_client = /* @__PURE__ */ new WeakMap();
_provider$1 = /* @__PURE__ */ new WeakMap();
var chacha20poly1305 = {};
var chacha = {};
var binary = {};
var int = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  function imulShim(a2, b3) {
    var ah2 = a2 >>> 16 & 65535, al2 = a2 & 65535;
    var bh2 = b3 >>> 16 & 65535, bl2 = b3 & 65535;
    return al2 * bl2 + (ah2 * bl2 + al2 * bh2 << 16 >>> 0) | 0;
  }
  exports.mul = Math.imul || imulShim;
  function add4(a2, b3) {
    return a2 + b3 | 0;
  }
  exports.add = add4;
  function sub(a2, b3) {
    return a2 - b3 | 0;
  }
  exports.sub = sub;
  function rotl(x2, n4) {
    return x2 << n4 | x2 >>> 32 - n4;
  }
  exports.rotl = rotl;
  function rotr(x2, n4) {
    return x2 << 32 - n4 | x2 >>> n4;
  }
  exports.rotr = rotr;
  function isIntegerShim(n4) {
    return typeof n4 === "number" && isFinite(n4) && Math.floor(n4) === n4;
  }
  exports.isInteger = Number.isInteger || isIntegerShim;
  exports.MAX_SAFE_INTEGER = 9007199254740991;
  exports.isSafeInteger = function(n4) {
    return exports.isInteger(n4) && (n4 >= -exports.MAX_SAFE_INTEGER && n4 <= exports.MAX_SAFE_INTEGER);
  };
})(int);
Object.defineProperty(binary, "__esModule", { value: true });
var int_1 = int;
function readInt16BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
}
binary.readInt16BE = readInt16BE;
function readUint16BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
}
binary.readUint16BE = readUint16BE;
function readInt16LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
}
binary.readInt16LE = readInt16LE;
function readUint16LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 1] << 8 | array[offset]) >>> 0;
}
binary.readUint16LE = readUint16LE;
function writeUint16BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(2);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 8;
  out[offset + 1] = value >>> 0;
  return out;
}
binary.writeUint16BE = writeUint16BE;
binary.writeInt16BE = writeUint16BE;
function writeUint16LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(2);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 0;
  out[offset + 1] = value >>> 8;
  return out;
}
binary.writeUint16LE = writeUint16LE;
binary.writeInt16LE = writeUint16LE;
function readInt32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
}
binary.readInt32BE = readInt32BE;
function readUint32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
}
binary.readUint32BE = readUint32BE;
function readInt32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
}
binary.readInt32LE = readInt32LE;
function readUint32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
}
binary.readUint32LE = readUint32LE;
function writeUint32BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 24;
  out[offset + 1] = value >>> 16;
  out[offset + 2] = value >>> 8;
  out[offset + 3] = value >>> 0;
  return out;
}
binary.writeUint32BE = writeUint32BE;
binary.writeInt32BE = writeUint32BE;
function writeUint32LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 0;
  out[offset + 1] = value >>> 8;
  out[offset + 2] = value >>> 16;
  out[offset + 3] = value >>> 24;
  return out;
}
binary.writeUint32LE = writeUint32LE;
binary.writeInt32LE = writeUint32LE;
function readInt64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var hi2 = readInt32BE(array, offset);
  var lo = readInt32BE(array, offset + 4);
  return hi2 * 4294967296 + lo - (lo >> 31) * 4294967296;
}
binary.readInt64BE = readInt64BE;
function readUint64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var hi2 = readUint32BE(array, offset);
  var lo = readUint32BE(array, offset + 4);
  return hi2 * 4294967296 + lo;
}
binary.readUint64BE = readUint64BE;
function readInt64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var lo = readInt32LE(array, offset);
  var hi2 = readInt32LE(array, offset + 4);
  return hi2 * 4294967296 + lo - (lo >> 31) * 4294967296;
}
binary.readInt64LE = readInt64LE;
function readUint64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var lo = readUint32LE(array, offset);
  var hi2 = readUint32LE(array, offset + 4);
  return hi2 * 4294967296 + lo;
}
binary.readUint64LE = readUint64LE;
function writeUint64BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  writeUint32BE(value / 4294967296 >>> 0, out, offset);
  writeUint32BE(value >>> 0, out, offset + 4);
  return out;
}
binary.writeUint64BE = writeUint64BE;
binary.writeInt64BE = writeUint64BE;
function writeUint64LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  writeUint32LE(value >>> 0, out, offset);
  writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
  return out;
}
binary.writeUint64LE = writeUint64LE;
binary.writeInt64LE = writeUint64LE;
function readUintBE(bitLength, array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  }
  if (bitLength / 8 > array.length - offset) {
    throw new Error("readUintBE: array is too short for the given bitLength");
  }
  var result = 0;
  var mul4 = 1;
  for (var i3 = bitLength / 8 + offset - 1; i3 >= offset; i3--) {
    result += array[i3] * mul4;
    mul4 *= 256;
  }
  return result;
}
binary.readUintBE = readUintBE;
function readUintLE(bitLength, array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  }
  if (bitLength / 8 > array.length - offset) {
    throw new Error("readUintLE: array is too short for the given bitLength");
  }
  var result = 0;
  var mul4 = 1;
  for (var i3 = offset; i3 < offset + bitLength / 8; i3++) {
    result += array[i3] * mul4;
    mul4 *= 256;
  }
  return result;
}
binary.readUintLE = readUintLE;
function writeUintBE(bitLength, value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(bitLength / 8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  }
  if (!int_1.isSafeInteger(value)) {
    throw new Error("writeUintBE value must be an integer");
  }
  var div = 1;
  for (var i3 = bitLength / 8 + offset - 1; i3 >= offset; i3--) {
    out[i3] = value / div & 255;
    div *= 256;
  }
  return out;
}
binary.writeUintBE = writeUintBE;
function writeUintLE(bitLength, value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(bitLength / 8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  }
  if (!int_1.isSafeInteger(value)) {
    throw new Error("writeUintLE value must be an integer");
  }
  var div = 1;
  for (var i3 = offset; i3 < offset + bitLength / 8; i3++) {
    out[i3] = value / div & 255;
    div *= 256;
  }
  return out;
}
binary.writeUintLE = writeUintLE;
function readFloat32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset);
}
binary.readFloat32BE = readFloat32BE;
function readFloat32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset, true);
}
binary.readFloat32LE = readFloat32LE;
function readFloat64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset);
}
binary.readFloat64BE = readFloat64BE;
function readFloat64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset, true);
}
binary.readFloat64LE = readFloat64LE;
function writeFloat32BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat32(offset, value);
  return out;
}
binary.writeFloat32BE = writeFloat32BE;
function writeFloat32LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat32(offset, value, true);
  return out;
}
binary.writeFloat32LE = writeFloat32LE;
function writeFloat64BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat64(offset, value);
  return out;
}
binary.writeFloat64BE = writeFloat64BE;
function writeFloat64LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat64(offset, value, true);
  return out;
}
binary.writeFloat64LE = writeFloat64LE;
var wipe$1 = {};
Object.defineProperty(wipe$1, "__esModule", { value: true });
function wipe(array) {
  for (var i3 = 0; i3 < array.length; i3++) {
    array[i3] = 0;
  }
  return array;
}
wipe$1.wipe = wipe;
Object.defineProperty(chacha, "__esModule", { value: true });
var binary_1 = binary;
var wipe_1$3 = wipe$1;
var ROUNDS = 20;
function core(out, input, key2) {
  var j0 = 1634760805;
  var j1 = 857760878;
  var j2 = 2036477234;
  var j3 = 1797285236;
  var j4 = key2[3] << 24 | key2[2] << 16 | key2[1] << 8 | key2[0];
  var j5 = key2[7] << 24 | key2[6] << 16 | key2[5] << 8 | key2[4];
  var j6 = key2[11] << 24 | key2[10] << 16 | key2[9] << 8 | key2[8];
  var j7 = key2[15] << 24 | key2[14] << 16 | key2[13] << 8 | key2[12];
  var j8 = key2[19] << 24 | key2[18] << 16 | key2[17] << 8 | key2[16];
  var j9 = key2[23] << 24 | key2[22] << 16 | key2[21] << 8 | key2[20];
  var j10 = key2[27] << 24 | key2[26] << 16 | key2[25] << 8 | key2[24];
  var j11 = key2[31] << 24 | key2[30] << 16 | key2[29] << 8 | key2[28];
  var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
  var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
  var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
  var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
  var x0 = j0;
  var x1 = j1;
  var x2 = j2;
  var x3 = j3;
  var x4 = j4;
  var x5 = j5;
  var x6 = j6;
  var x7 = j7;
  var x8 = j8;
  var x9 = j9;
  var x10 = j10;
  var x11 = j11;
  var x12 = j12;
  var x13 = j13;
  var x14 = j14;
  var x15 = j15;
  for (var i3 = 0; i3 < ROUNDS; i3 += 2) {
    x0 = x0 + x4 | 0;
    x12 ^= x0;
    x12 = x12 >>> 32 - 16 | x12 << 16;
    x8 = x8 + x12 | 0;
    x4 ^= x8;
    x4 = x4 >>> 32 - 12 | x4 << 12;
    x1 = x1 + x5 | 0;
    x13 ^= x1;
    x13 = x13 >>> 32 - 16 | x13 << 16;
    x9 = x9 + x13 | 0;
    x5 ^= x9;
    x5 = x5 >>> 32 - 12 | x5 << 12;
    x2 = x2 + x6 | 0;
    x14 ^= x2;
    x14 = x14 >>> 32 - 16 | x14 << 16;
    x10 = x10 + x14 | 0;
    x6 ^= x10;
    x6 = x6 >>> 32 - 12 | x6 << 12;
    x3 = x3 + x7 | 0;
    x15 ^= x3;
    x15 = x15 >>> 32 - 16 | x15 << 16;
    x11 = x11 + x15 | 0;
    x7 ^= x11;
    x7 = x7 >>> 32 - 12 | x7 << 12;
    x2 = x2 + x6 | 0;
    x14 ^= x2;
    x14 = x14 >>> 32 - 8 | x14 << 8;
    x10 = x10 + x14 | 0;
    x6 ^= x10;
    x6 = x6 >>> 32 - 7 | x6 << 7;
    x3 = x3 + x7 | 0;
    x15 ^= x3;
    x15 = x15 >>> 32 - 8 | x15 << 8;
    x11 = x11 + x15 | 0;
    x7 ^= x11;
    x7 = x7 >>> 32 - 7 | x7 << 7;
    x1 = x1 + x5 | 0;
    x13 ^= x1;
    x13 = x13 >>> 32 - 8 | x13 << 8;
    x9 = x9 + x13 | 0;
    x5 ^= x9;
    x5 = x5 >>> 32 - 7 | x5 << 7;
    x0 = x0 + x4 | 0;
    x12 ^= x0;
    x12 = x12 >>> 32 - 8 | x12 << 8;
    x8 = x8 + x12 | 0;
    x4 ^= x8;
    x4 = x4 >>> 32 - 7 | x4 << 7;
    x0 = x0 + x5 | 0;
    x15 ^= x0;
    x15 = x15 >>> 32 - 16 | x15 << 16;
    x10 = x10 + x15 | 0;
    x5 ^= x10;
    x5 = x5 >>> 32 - 12 | x5 << 12;
    x1 = x1 + x6 | 0;
    x12 ^= x1;
    x12 = x12 >>> 32 - 16 | x12 << 16;
    x11 = x11 + x12 | 0;
    x6 ^= x11;
    x6 = x6 >>> 32 - 12 | x6 << 12;
    x2 = x2 + x7 | 0;
    x13 ^= x2;
    x13 = x13 >>> 32 - 16 | x13 << 16;
    x8 = x8 + x13 | 0;
    x7 ^= x8;
    x7 = x7 >>> 32 - 12 | x7 << 12;
    x3 = x3 + x4 | 0;
    x14 ^= x3;
    x14 = x14 >>> 32 - 16 | x14 << 16;
    x9 = x9 + x14 | 0;
    x4 ^= x9;
    x4 = x4 >>> 32 - 12 | x4 << 12;
    x2 = x2 + x7 | 0;
    x13 ^= x2;
    x13 = x13 >>> 32 - 8 | x13 << 8;
    x8 = x8 + x13 | 0;
    x7 ^= x8;
    x7 = x7 >>> 32 - 7 | x7 << 7;
    x3 = x3 + x4 | 0;
    x14 ^= x3;
    x14 = x14 >>> 32 - 8 | x14 << 8;
    x9 = x9 + x14 | 0;
    x4 ^= x9;
    x4 = x4 >>> 32 - 7 | x4 << 7;
    x1 = x1 + x6 | 0;
    x12 ^= x1;
    x12 = x12 >>> 32 - 8 | x12 << 8;
    x11 = x11 + x12 | 0;
    x6 ^= x11;
    x6 = x6 >>> 32 - 7 | x6 << 7;
    x0 = x0 + x5 | 0;
    x15 ^= x0;
    x15 = x15 >>> 32 - 8 | x15 << 8;
    x10 = x10 + x15 | 0;
    x5 ^= x10;
    x5 = x5 >>> 32 - 7 | x5 << 7;
  }
  binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
  binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
  binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
  binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
  binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
  binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
  binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
  binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
  binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
  binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
  binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
  binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
  binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
  binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
  binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
  binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
}
function streamXOR(key2, nonce, src2, dst, nonceInplaceCounterLength) {
  if (nonceInplaceCounterLength === void 0) {
    nonceInplaceCounterLength = 0;
  }
  if (key2.length !== 32) {
    throw new Error("ChaCha: key size must be 32 bytes");
  }
  if (dst.length < src2.length) {
    throw new Error("ChaCha: destination is shorter than source");
  }
  var nc2;
  var counterLength;
  if (nonceInplaceCounterLength === 0) {
    if (nonce.length !== 8 && nonce.length !== 12) {
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    }
    nc2 = new Uint8Array(16);
    counterLength = nc2.length - nonce.length;
    nc2.set(nonce, counterLength);
  } else {
    if (nonce.length !== 16) {
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    }
    nc2 = nonce;
    counterLength = nonceInplaceCounterLength;
  }
  var block2 = new Uint8Array(64);
  for (var i3 = 0; i3 < src2.length; i3 += 64) {
    core(block2, nc2, key2);
    for (var j2 = i3; j2 < i3 + 64 && j2 < src2.length; j2++) {
      dst[j2] = src2[j2] ^ block2[j2 - i3];
    }
    incrementCounter(nc2, 0, counterLength);
  }
  wipe_1$3.wipe(block2);
  if (nonceInplaceCounterLength === 0) {
    wipe_1$3.wipe(nc2);
  }
  return dst;
}
chacha.streamXOR = streamXOR;
function stream(key2, nonce, dst, nonceInplaceCounterLength) {
  if (nonceInplaceCounterLength === void 0) {
    nonceInplaceCounterLength = 0;
  }
  wipe_1$3.wipe(dst);
  return streamXOR(key2, nonce, dst, dst, nonceInplaceCounterLength);
}
chacha.stream = stream;
function incrementCounter(counter, pos, len) {
  var carry = 1;
  while (len--) {
    carry = carry + (counter[pos] & 255) | 0;
    counter[pos] = carry & 255;
    carry >>>= 8;
    pos++;
  }
  if (carry > 0) {
    throw new Error("ChaCha: counter overflow");
  }
}
var poly1305 = {};
var constantTime = {};
Object.defineProperty(constantTime, "__esModule", { value: true });
function select(subject, resultIfOne, resultIfZero) {
  return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
}
constantTime.select = select;
function lessOrEqual(a2, b3) {
  return (a2 | 0) - (b3 | 0) - 1 >>> 31 & 1;
}
constantTime.lessOrEqual = lessOrEqual;
function compare(a2, b3) {
  if (a2.length !== b3.length) {
    return 0;
  }
  var result = 0;
  for (var i3 = 0; i3 < a2.length; i3++) {
    result |= a2[i3] ^ b3[i3];
  }
  return 1 & result - 1 >>> 8;
}
constantTime.compare = compare;
function equal(a2, b3) {
  if (a2.length === 0 || b3.length === 0) {
    return false;
  }
  return compare(a2, b3) !== 0;
}
constantTime.equal = equal;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var constant_time_12 = constantTime;
  var wipe_12 = wipe$1;
  exports.DIGEST_LENGTH = 16;
  var Poly1305 = (
    /** @class */
    function() {
      function Poly13052(key2) {
        this.digestLength = exports.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key2[0] | key2[1] << 8;
        this._r[0] = t0 & 8191;
        var t1 = key2[2] | key2[3] << 8;
        this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        var t2 = key2[4] | key2[5] << 8;
        this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        var t3 = key2[6] | key2[7] << 8;
        this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        var t4 = key2[8] | key2[9] << 8;
        this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this._r[5] = t4 >>> 1 & 8190;
        var t5 = key2[10] | key2[11] << 8;
        this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        var t6 = key2[12] | key2[13] << 8;
        this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        var t7 = key2[14] | key2[15] << 8;
        this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this._r[9] = t7 >>> 5 & 127;
        this._pad[0] = key2[16] | key2[17] << 8;
        this._pad[1] = key2[18] | key2[19] << 8;
        this._pad[2] = key2[20] | key2[21] << 8;
        this._pad[3] = key2[22] | key2[23] << 8;
        this._pad[4] = key2[24] | key2[25] << 8;
        this._pad[5] = key2[26] | key2[27] << 8;
        this._pad[6] = key2[28] | key2[29] << 8;
        this._pad[7] = key2[30] | key2[31] << 8;
      }
      Poly13052.prototype._blocks = function(m2, mpos, bytes2) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0], h1 = this._h[1], h22 = this._h[2], h32 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while (bytes2 >= 16) {
          var t0 = m2[mpos + 0] | m2[mpos + 1] << 8;
          h0 += t0 & 8191;
          var t1 = m2[mpos + 2] | m2[mpos + 3] << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = m2[mpos + 4] | m2[mpos + 5] << 8;
          h22 += (t1 >>> 10 | t2 << 6) & 8191;
          var t3 = m2[mpos + 6] | m2[mpos + 7] << 8;
          h32 += (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = m2[mpos + 8] | m2[mpos + 9] << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          var t5 = m2[mpos + 10] | m2[mpos + 11] << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = m2[mpos + 12] | m2[mpos + 13] << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          var t7 = m2[mpos + 14] | m2[mpos + 15] << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          var c2 = 0;
          var d0 = c2;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h22 * (5 * r8);
          d0 += h32 * (5 * r7);
          d0 += h4 * (5 * r6);
          c2 = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c2 += d0 >>> 13;
          d0 &= 8191;
          var d1 = c2;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h22 * (5 * r9);
          d1 += h32 * (5 * r8);
          d1 += h4 * (5 * r7);
          c2 = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c2 += d1 >>> 13;
          d1 &= 8191;
          var d2 = c2;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h22 * r0;
          d2 += h32 * (5 * r9);
          d2 += h4 * (5 * r8);
          c2 = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c2 += d2 >>> 13;
          d2 &= 8191;
          var d3 = c2;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h22 * r1;
          d3 += h32 * r0;
          d3 += h4 * (5 * r9);
          c2 = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c2 += d3 >>> 13;
          d3 &= 8191;
          var d4 = c2;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h22 * r2;
          d4 += h32 * r1;
          d4 += h4 * r0;
          c2 = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c2 += d4 >>> 13;
          d4 &= 8191;
          var d5 = c2;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h22 * r3;
          d5 += h32 * r2;
          d5 += h4 * r1;
          c2 = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c2 += d5 >>> 13;
          d5 &= 8191;
          var d6 = c2;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h22 * r4;
          d6 += h32 * r3;
          d6 += h4 * r2;
          c2 = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c2 += d6 >>> 13;
          d6 &= 8191;
          var d7 = c2;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h22 * r5;
          d7 += h32 * r4;
          d7 += h4 * r3;
          c2 = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c2 += d7 >>> 13;
          d7 &= 8191;
          var d8 = c2;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h22 * r6;
          d8 += h32 * r5;
          d8 += h4 * r4;
          c2 = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c2 += d8 >>> 13;
          d8 &= 8191;
          var d9 = c2;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h22 * r7;
          d9 += h32 * r6;
          d9 += h4 * r5;
          c2 = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c2 += d9 >>> 13;
          d9 &= 8191;
          c2 = (c2 << 2) + c2 | 0;
          c2 = c2 + d0 | 0;
          d0 = c2 & 8191;
          c2 = c2 >>> 13;
          d1 += c2;
          h0 = d0;
          h1 = d1;
          h22 = d2;
          h32 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes2 -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h22;
        this._h[3] = h32;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
      };
      Poly13052.prototype.finish = function(mac, macpos) {
        if (macpos === void 0) {
          macpos = 0;
        }
        var g2 = new Uint16Array(10);
        var c2;
        var mask;
        var f3;
        var i3;
        if (this._leftover) {
          i3 = this._leftover;
          this._buffer[i3++] = 1;
          for (; i3 < 16; i3++) {
            this._buffer[i3] = 0;
          }
          this._fin = 1;
          this._blocks(this._buffer, 0, 16);
        }
        c2 = this._h[1] >>> 13;
        this._h[1] &= 8191;
        for (i3 = 2; i3 < 10; i3++) {
          this._h[i3] += c2;
          c2 = this._h[i3] >>> 13;
          this._h[i3] &= 8191;
        }
        this._h[0] += c2 * 5;
        c2 = this._h[0] >>> 13;
        this._h[0] &= 8191;
        this._h[1] += c2;
        c2 = this._h[1] >>> 13;
        this._h[1] &= 8191;
        this._h[2] += c2;
        g2[0] = this._h[0] + 5;
        c2 = g2[0] >>> 13;
        g2[0] &= 8191;
        for (i3 = 1; i3 < 10; i3++) {
          g2[i3] = this._h[i3] + c2;
          c2 = g2[i3] >>> 13;
          g2[i3] &= 8191;
        }
        g2[9] -= 1 << 13;
        mask = (c2 ^ 1) - 1;
        for (i3 = 0; i3 < 10; i3++) {
          g2[i3] &= mask;
        }
        mask = ~mask;
        for (i3 = 0; i3 < 10; i3++) {
          this._h[i3] = this._h[i3] & mask | g2[i3];
        }
        this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
        this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
        this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
        this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
        this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
        this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
        this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
        this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
        f3 = this._h[0] + this._pad[0];
        this._h[0] = f3 & 65535;
        for (i3 = 1; i3 < 8; i3++) {
          f3 = (this._h[i3] + this._pad[i3] | 0) + (f3 >>> 16) | 0;
          this._h[i3] = f3 & 65535;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
      };
      Poly13052.prototype.update = function(m2) {
        var mpos = 0;
        var bytes2 = m2.length;
        var want;
        if (this._leftover) {
          want = 16 - this._leftover;
          if (want > bytes2) {
            want = bytes2;
          }
          for (var i3 = 0; i3 < want; i3++) {
            this._buffer[this._leftover + i3] = m2[mpos + i3];
          }
          bytes2 -= want;
          mpos += want;
          this._leftover += want;
          if (this._leftover < 16) {
            return this;
          }
          this._blocks(this._buffer, 0, 16);
          this._leftover = 0;
        }
        if (bytes2 >= 16) {
          want = bytes2 - bytes2 % 16;
          this._blocks(m2, mpos, want);
          mpos += want;
          bytes2 -= want;
        }
        if (bytes2) {
          for (var i3 = 0; i3 < bytes2; i3++) {
            this._buffer[this._leftover + i3] = m2[mpos + i3];
          }
          this._leftover += bytes2;
        }
        return this;
      };
      Poly13052.prototype.digest = function() {
        if (this._finished) {
          throw new Error("Poly1305 was finished");
        }
        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
      };
      Poly13052.prototype.clean = function() {
        wipe_12.wipe(this._buffer);
        wipe_12.wipe(this._r);
        wipe_12.wipe(this._h);
        wipe_12.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true;
        return this;
      };
      return Poly13052;
    }()
  );
  exports.Poly1305 = Poly1305;
  function oneTimeAuth(key2, data2) {
    var h4 = new Poly1305(key2);
    h4.update(data2);
    var digest9 = h4.digest();
    h4.clean();
    return digest9;
  }
  exports.oneTimeAuth = oneTimeAuth;
  function equal2(a2, b3) {
    if (a2.length !== exports.DIGEST_LENGTH || b3.length !== exports.DIGEST_LENGTH) {
      return false;
    }
    return constant_time_12.equal(a2, b3);
  }
  exports.equal = equal2;
})(poly1305);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var chacha_1 = chacha;
  var poly1305_1 = poly1305;
  var wipe_12 = wipe$1;
  var binary_12 = binary;
  var constant_time_12 = constantTime;
  exports.KEY_LENGTH = 32;
  exports.NONCE_LENGTH = 12;
  exports.TAG_LENGTH = 16;
  var ZEROS = new Uint8Array(16);
  var ChaCha20Poly1305 = (
    /** @class */
    function() {
      function ChaCha20Poly13052(key2) {
        this.nonceLength = exports.NONCE_LENGTH;
        this.tagLength = exports.TAG_LENGTH;
        if (key2.length !== exports.KEY_LENGTH) {
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        this._key = new Uint8Array(key2);
      }
      ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var resultLength = plaintext.length + this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
        wipe_12.wipe(counter);
        return result;
      };
      ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        if (sealed.length < this.tagLength) {
          return null;
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var calculatedTag = new Uint8Array(this.tagLength);
        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
        if (!constant_time_12.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
          return null;
        }
        var resultLength = sealed.length - this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
        wipe_12.wipe(counter);
        return result;
      };
      ChaCha20Poly13052.prototype.clean = function() {
        wipe_12.wipe(this._key);
        return this;
      };
      ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
        var h4 = new poly1305_1.Poly1305(authKey);
        if (associatedData) {
          h4.update(associatedData);
          if (associatedData.length % 16 > 0) {
            h4.update(ZEROS.subarray(associatedData.length % 16));
          }
        }
        h4.update(ciphertext);
        if (ciphertext.length % 16 > 0) {
          h4.update(ZEROS.subarray(ciphertext.length % 16));
        }
        var length2 = new Uint8Array(8);
        if (associatedData) {
          binary_12.writeUint64LE(associatedData.length, length2);
        }
        h4.update(length2);
        binary_12.writeUint64LE(ciphertext.length, length2);
        h4.update(length2);
        var tag = h4.digest();
        for (var i3 = 0; i3 < tag.length; i3++) {
          tagOut[i3] = tag[i3];
        }
        h4.clean();
        wipe_12.wipe(tag);
        wipe_12.wipe(length2);
      };
      return ChaCha20Poly13052;
    }()
  );
  exports.ChaCha20Poly1305 = ChaCha20Poly1305;
})(chacha20poly1305);
var hkdf = {};
var hmac$1 = {};
var hash = {};
Object.defineProperty(hash, "__esModule", { value: true });
function isSerializableHash(h4) {
  return typeof h4.saveState !== "undefined" && typeof h4.restoreState !== "undefined" && typeof h4.cleanSavedState !== "undefined";
}
hash.isSerializableHash = isSerializableHash;
Object.defineProperty(hmac$1, "__esModule", { value: true });
var hash_1 = hash;
var constant_time_1 = constantTime;
var wipe_1$2 = wipe$1;
var HMAC = (
  /** @class */
  function() {
    function HMAC2(hash2, key2) {
      this._finished = false;
      this._inner = new hash2();
      this._outer = new hash2();
      this.blockSize = this._outer.blockSize;
      this.digestLength = this._outer.digestLength;
      var pad3 = new Uint8Array(this.blockSize);
      if (key2.length > this.blockSize) {
        this._inner.update(key2).finish(pad3).clean();
      } else {
        pad3.set(key2);
      }
      for (var i3 = 0; i3 < pad3.length; i3++) {
        pad3[i3] ^= 54;
      }
      this._inner.update(pad3);
      for (var i3 = 0; i3 < pad3.length; i3++) {
        pad3[i3] ^= 54 ^ 92;
      }
      this._outer.update(pad3);
      if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
        this._innerKeyedState = this._inner.saveState();
        this._outerKeyedState = this._outer.saveState();
      }
      wipe_1$2.wipe(pad3);
    }
    HMAC2.prototype.reset = function() {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      }
      this._inner.restoreState(this._innerKeyedState);
      this._outer.restoreState(this._outerKeyedState);
      this._finished = false;
      return this;
    };
    HMAC2.prototype.clean = function() {
      if (hash_1.isSerializableHash(this._inner)) {
        this._inner.cleanSavedState(this._innerKeyedState);
      }
      if (hash_1.isSerializableHash(this._outer)) {
        this._outer.cleanSavedState(this._outerKeyedState);
      }
      this._inner.clean();
      this._outer.clean();
    };
    HMAC2.prototype.update = function(data2) {
      this._inner.update(data2);
      return this;
    };
    HMAC2.prototype.finish = function(out) {
      if (this._finished) {
        this._outer.finish(out);
        return this;
      }
      this._inner.finish(out);
      this._outer.update(out.subarray(0, this.digestLength)).finish(out);
      this._finished = true;
      return this;
    };
    HMAC2.prototype.digest = function() {
      var out = new Uint8Array(this.digestLength);
      this.finish(out);
      return out;
    };
    HMAC2.prototype.saveState = function() {
      if (!hash_1.isSerializableHash(this._inner)) {
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      }
      return this._inner.saveState();
    };
    HMAC2.prototype.restoreState = function(savedState) {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      }
      this._inner.restoreState(savedState);
      this._outer.restoreState(this._outerKeyedState);
      this._finished = false;
      return this;
    };
    HMAC2.prototype.cleanSavedState = function(savedState) {
      if (!hash_1.isSerializableHash(this._inner)) {
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      }
      this._inner.cleanSavedState(savedState);
    };
    return HMAC2;
  }()
);
hmac$1.HMAC = HMAC;
function hmac2(hash2, key2, data2) {
  var h4 = new HMAC(hash2, key2);
  h4.update(data2);
  var digest9 = h4.digest();
  h4.clean();
  return digest9;
}
hmac$1.hmac = hmac2;
hmac$1.equal = constant_time_1.equal;
Object.defineProperty(hkdf, "__esModule", { value: true });
var hmac_1 = hmac$1;
var wipe_1$1 = wipe$1;
var HKDF = (
  /** @class */
  function() {
    function HKDF2(hash2, key2, salt, info) {
      if (salt === void 0) {
        salt = new Uint8Array(0);
      }
      this._counter = new Uint8Array(1);
      this._hash = hash2;
      this._info = info;
      var okm = hmac_1.hmac(this._hash, salt, key2);
      this._hmac = new hmac_1.HMAC(hash2, okm);
      this._buffer = new Uint8Array(this._hmac.digestLength);
      this._bufpos = this._buffer.length;
    }
    HKDF2.prototype._fillBuffer = function() {
      this._counter[0]++;
      var ctr = this._counter[0];
      if (ctr === 0) {
        throw new Error("hkdf: cannot expand more");
      }
      this._hmac.reset();
      if (ctr > 1) {
        this._hmac.update(this._buffer);
      }
      if (this._info) {
        this._hmac.update(this._info);
      }
      this._hmac.update(this._counter);
      this._hmac.finish(this._buffer);
      this._bufpos = 0;
    };
    HKDF2.prototype.expand = function(length2) {
      var out = new Uint8Array(length2);
      for (var i3 = 0; i3 < out.length; i3++) {
        if (this._bufpos === this._buffer.length) {
          this._fillBuffer();
        }
        out[i3] = this._buffer[this._bufpos++];
      }
      return out;
    };
    HKDF2.prototype.clean = function() {
      this._hmac.clean();
      wipe_1$1.wipe(this._buffer);
      wipe_1$1.wipe(this._counter);
      this._bufpos = 0;
    };
    return HKDF2;
  }()
);
var HKDF_1 = hkdf.HKDF = HKDF;
var random = {};
var system = {};
var browser = {};
Object.defineProperty(browser, "__esModule", { value: true });
browser.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
  constructor() {
    this.isAvailable = false;
    this.isInstantiated = false;
    const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
    if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
      this._crypto = browserCrypto;
      this.isAvailable = true;
      this.isInstantiated = true;
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable || !this._crypto) {
      throw new Error("Browser random byte generator is not available.");
    }
    const out = new Uint8Array(length2);
    for (let i3 = 0; i3 < out.length; i3 += QUOTA) {
      this._crypto.getRandomValues(out.subarray(i3, i3 + Math.min(out.length - i3, QUOTA)));
    }
    return out;
  }
}
browser.BrowserRandomSource = BrowserRandomSource;
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var node = {};
Object.defineProperty(node, "__esModule", { value: true });
node.NodeRandomSource = void 0;
const wipe_1 = wipe$1;
class NodeRandomSource {
  constructor() {
    this.isAvailable = false;
    this.isInstantiated = false;
    if (typeof commonjsRequire !== "undefined") {
      const nodeCrypto = require$$3$1;
      if (nodeCrypto && nodeCrypto.randomBytes) {
        this._crypto = nodeCrypto;
        this.isAvailable = true;
        this.isInstantiated = true;
      }
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable || !this._crypto) {
      throw new Error("Node.js random byte generator is not available.");
    }
    let buffer2 = this._crypto.randomBytes(length2);
    if (buffer2.length !== length2) {
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    }
    const out = new Uint8Array(length2);
    for (let i3 = 0; i3 < out.length; i3++) {
      out[i3] = buffer2[i3];
    }
    (0, wipe_1.wipe)(buffer2);
    return out;
  }
}
node.NodeRandomSource = NodeRandomSource;
Object.defineProperty(system, "__esModule", { value: true });
system.SystemRandomSource = void 0;
const browser_1 = browser;
const node_1 = node;
class SystemRandomSource {
  constructor() {
    this.isAvailable = false;
    this.name = "";
    this._source = new browser_1.BrowserRandomSource();
    if (this._source.isAvailable) {
      this.isAvailable = true;
      this.name = "Browser";
      return;
    }
    this._source = new node_1.NodeRandomSource();
    if (this._source.isAvailable) {
      this.isAvailable = true;
      this.name = "Node";
      return;
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable) {
      throw new Error("System random byte generator is not available.");
    }
    return this._source.randomBytes(length2);
  }
}
system.SystemRandomSource = SystemRandomSource;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
  const system_1 = system;
  const binary_12 = binary;
  const wipe_12 = wipe$1;
  exports.defaultRandomSource = new system_1.SystemRandomSource();
  function randomBytes(length2, prng = exports.defaultRandomSource) {
    return prng.randomBytes(length2);
  }
  exports.randomBytes = randomBytes;
  function randomUint32(prng = exports.defaultRandomSource) {
    const buf = randomBytes(4, prng);
    const result = (0, binary_12.readUint32LE)(buf);
    (0, wipe_12.wipe)(buf);
    return result;
  }
  exports.randomUint32 = randomUint32;
  const ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function randomString(length2, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    if (charset.length < 2) {
      throw new Error("randomString charset is too short");
    }
    if (charset.length > 256) {
      throw new Error("randomString charset is too long");
    }
    let out = "";
    const charsLen = charset.length;
    const maxByte = 256 - 256 % charsLen;
    while (length2 > 0) {
      const buf = randomBytes(Math.ceil(length2 * 256 / maxByte), prng);
      for (let i3 = 0; i3 < buf.length && length2 > 0; i3++) {
        const randomByte = buf[i3];
        if (randomByte < maxByte) {
          out += charset.charAt(randomByte % charsLen);
          length2--;
        }
      }
      (0, wipe_12.wipe)(buf);
    }
    return out;
  }
  exports.randomString = randomString;
  function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    const length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
    return randomString(length2, charset, prng);
  }
  exports.randomStringForEntropy = randomStringForEntropy;
})(random);
var sha256 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var binary_12 = binary;
  var wipe_12 = wipe$1;
  exports.DIGEST_LENGTH = 32;
  exports.BLOCK_SIZE = 64;
  var SHA2562 = (
    /** @class */
    function() {
      function SHA2563() {
        this.digestLength = exports.DIGEST_LENGTH;
        this.blockSize = exports.BLOCK_SIZE;
        this._state = new Int32Array(8);
        this._temp = new Int32Array(64);
        this._buffer = new Uint8Array(128);
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        this.reset();
      }
      SHA2563.prototype._initState = function() {
        this._state[0] = 1779033703;
        this._state[1] = 3144134277;
        this._state[2] = 1013904242;
        this._state[3] = 2773480762;
        this._state[4] = 1359893119;
        this._state[5] = 2600822924;
        this._state[6] = 528734635;
        this._state[7] = 1541459225;
      };
      SHA2563.prototype.reset = function() {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
      };
      SHA2563.prototype.clean = function() {
        wipe_12.wipe(this._buffer);
        wipe_12.wipe(this._temp);
        this.reset();
      };
      SHA2563.prototype.update = function(data2, dataLength) {
        if (dataLength === void 0) {
          dataLength = data2.length;
        }
        if (this._finished) {
          throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
          while (this._bufferLength < this.blockSize && dataLength > 0) {
            this._buffer[this._bufferLength++] = data2[dataPos++];
            dataLength--;
          }
          if (this._bufferLength === this.blockSize) {
            hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
            this._bufferLength = 0;
          }
        }
        if (dataLength >= this.blockSize) {
          dataPos = hashBlocks(this._temp, this._state, data2, dataPos, dataLength);
          dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
          this._buffer[this._bufferLength++] = data2[dataPos++];
          dataLength--;
        }
        return this;
      };
      SHA2563.prototype.finish = function(out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed;
          var left = this._bufferLength;
          var bitLenHi = bytesHashed / 536870912 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this._buffer[left] = 128;
          for (var i3 = left + 1; i3 < padLength - 8; i3++) {
            this._buffer[i3] = 0;
          }
          binary_12.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
          binary_12.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
          hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
          this._finished = true;
        }
        for (var i3 = 0; i3 < this.digestLength / 4; i3++) {
          binary_12.writeUint32BE(this._state[i3], out, i3 * 4);
        }
        return this;
      };
      SHA2563.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      SHA2563.prototype.saveState = function() {
        if (this._finished) {
          throw new Error("SHA256: cannot save finished state");
        }
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      };
      SHA2563.prototype.restoreState = function(savedState) {
        this._state.set(savedState.state);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
          this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
      };
      SHA2563.prototype.cleanSavedState = function(savedState) {
        wipe_12.wipe(savedState.state);
        if (savedState.buffer) {
          wipe_12.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
      };
      return SHA2563;
    }()
  );
  exports.SHA256 = SHA2562;
  var K2 = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function hashBlocks(w2, v2, p2, pos, len) {
    while (len >= 64) {
      var a2 = v2[0];
      var b3 = v2[1];
      var c2 = v2[2];
      var d2 = v2[3];
      var e2 = v2[4];
      var f3 = v2[5];
      var g2 = v2[6];
      var h4 = v2[7];
      for (var i3 = 0; i3 < 16; i3++) {
        var j2 = pos + i3 * 4;
        w2[i3] = binary_12.readUint32BE(p2, j2);
      }
      for (var i3 = 16; i3 < 64; i3++) {
        var u2 = w2[i3 - 2];
        var t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
        u2 = w2[i3 - 15];
        var t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
        w2[i3] = (t1 + w2[i3 - 7] | 0) + (t2 + w2[i3 - 16] | 0);
      }
      for (var i3 = 0; i3 < 64; i3++) {
        var t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f3 ^ ~e2 & g2) | 0) + (h4 + (K2[i3] + w2[i3] | 0) | 0) | 0;
        var t2 = ((a2 >>> 2 | a2 << 32 - 2) ^ (a2 >>> 13 | a2 << 32 - 13) ^ (a2 >>> 22 | a2 << 32 - 22)) + (a2 & b3 ^ a2 & c2 ^ b3 & c2) | 0;
        h4 = g2;
        g2 = f3;
        f3 = e2;
        e2 = d2 + t1 | 0;
        d2 = c2;
        c2 = b3;
        b3 = a2;
        a2 = t1 + t2 | 0;
      }
      v2[0] += a2;
      v2[1] += b3;
      v2[2] += c2;
      v2[3] += d2;
      v2[4] += e2;
      v2[5] += f3;
      v2[6] += g2;
      v2[7] += h4;
      pos += 64;
      len -= 64;
    }
    return pos;
  }
  function hash2(data2) {
    var h4 = new SHA2562();
    h4.update(data2);
    var digest9 = h4.digest();
    h4.clean();
    return digest9;
  }
  exports.hash = hash2;
})(sha256);
var x25519 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
  const random_1 = random;
  const wipe_12 = wipe$1;
  exports.PUBLIC_KEY_LENGTH = 32;
  exports.SECRET_KEY_LENGTH = 32;
  exports.SHARED_KEY_LENGTH = 32;
  function gf(init3) {
    const r2 = new Float64Array(16);
    if (init3) {
      for (let i3 = 0; i3 < init3.length; i3++) {
        r2[i3] = init3[i3];
      }
    }
    return r2;
  }
  const _9 = new Uint8Array(32);
  _9[0] = 9;
  const _121665 = gf([56129, 1]);
  function car25519(o2) {
    let c2 = 1;
    for (let i3 = 0; i3 < 16; i3++) {
      let v2 = o2[i3] + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      o2[i3] = v2 - c2 * 65536;
    }
    o2[0] += c2 - 1 + 37 * (c2 - 1);
  }
  function sel25519(p2, q2, b3) {
    const c2 = ~(b3 - 1);
    for (let i3 = 0; i3 < 16; i3++) {
      const t2 = c2 & (p2[i3] ^ q2[i3]);
      p2[i3] ^= t2;
      q2[i3] ^= t2;
    }
  }
  function pack25519(o2, n4) {
    const m2 = gf();
    const t2 = gf();
    for (let i3 = 0; i3 < 16; i3++) {
      t2[i3] = n4[i3];
    }
    car25519(t2);
    car25519(t2);
    car25519(t2);
    for (let j2 = 0; j2 < 2; j2++) {
      m2[0] = t2[0] - 65517;
      for (let i3 = 1; i3 < 15; i3++) {
        m2[i3] = t2[i3] - 65535 - (m2[i3 - 1] >> 16 & 1);
        m2[i3 - 1] &= 65535;
      }
      m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
      const b3 = m2[15] >> 16 & 1;
      m2[14] &= 65535;
      sel25519(t2, m2, 1 - b3);
    }
    for (let i3 = 0; i3 < 16; i3++) {
      o2[2 * i3] = t2[i3] & 255;
      o2[2 * i3 + 1] = t2[i3] >> 8;
    }
  }
  function unpack25519(o2, n4) {
    for (let i3 = 0; i3 < 16; i3++) {
      o2[i3] = n4[2 * i3] + (n4[2 * i3 + 1] << 8);
    }
    o2[15] &= 32767;
  }
  function add4(o2, a2, b3) {
    for (let i3 = 0; i3 < 16; i3++) {
      o2[i3] = a2[i3] + b3[i3];
    }
  }
  function sub(o2, a2, b3) {
    for (let i3 = 0; i3 < 16; i3++) {
      o2[i3] = a2[i3] - b3[i3];
    }
  }
  function mul4(o2, a2, b3) {
    let v2, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b3[0], b1 = b3[1], b22 = b3[2], b32 = b3[3], b4 = b3[4], b5 = b3[5], b6 = b3[6], b7 = b3[7], b8 = b3[8], b9 = b3[9], b10 = b3[10], b11 = b3[11], b12 = b3[12], b13 = b3[13], b14 = b3[14], b15 = b3[15];
    v2 = a2[0];
    t0 += v2 * b0;
    t1 += v2 * b1;
    t2 += v2 * b22;
    t3 += v2 * b32;
    t4 += v2 * b4;
    t5 += v2 * b5;
    t6 += v2 * b6;
    t7 += v2 * b7;
    t8 += v2 * b8;
    t9 += v2 * b9;
    t10 += v2 * b10;
    t11 += v2 * b11;
    t12 += v2 * b12;
    t13 += v2 * b13;
    t14 += v2 * b14;
    t15 += v2 * b15;
    v2 = a2[1];
    t1 += v2 * b0;
    t2 += v2 * b1;
    t3 += v2 * b22;
    t4 += v2 * b32;
    t5 += v2 * b4;
    t6 += v2 * b5;
    t7 += v2 * b6;
    t8 += v2 * b7;
    t9 += v2 * b8;
    t10 += v2 * b9;
    t11 += v2 * b10;
    t12 += v2 * b11;
    t13 += v2 * b12;
    t14 += v2 * b13;
    t15 += v2 * b14;
    t16 += v2 * b15;
    v2 = a2[2];
    t2 += v2 * b0;
    t3 += v2 * b1;
    t4 += v2 * b22;
    t5 += v2 * b32;
    t6 += v2 * b4;
    t7 += v2 * b5;
    t8 += v2 * b6;
    t9 += v2 * b7;
    t10 += v2 * b8;
    t11 += v2 * b9;
    t12 += v2 * b10;
    t13 += v2 * b11;
    t14 += v2 * b12;
    t15 += v2 * b13;
    t16 += v2 * b14;
    t17 += v2 * b15;
    v2 = a2[3];
    t3 += v2 * b0;
    t4 += v2 * b1;
    t5 += v2 * b22;
    t6 += v2 * b32;
    t7 += v2 * b4;
    t8 += v2 * b5;
    t9 += v2 * b6;
    t10 += v2 * b7;
    t11 += v2 * b8;
    t12 += v2 * b9;
    t13 += v2 * b10;
    t14 += v2 * b11;
    t15 += v2 * b12;
    t16 += v2 * b13;
    t17 += v2 * b14;
    t18 += v2 * b15;
    v2 = a2[4];
    t4 += v2 * b0;
    t5 += v2 * b1;
    t6 += v2 * b22;
    t7 += v2 * b32;
    t8 += v2 * b4;
    t9 += v2 * b5;
    t10 += v2 * b6;
    t11 += v2 * b7;
    t12 += v2 * b8;
    t13 += v2 * b9;
    t14 += v2 * b10;
    t15 += v2 * b11;
    t16 += v2 * b12;
    t17 += v2 * b13;
    t18 += v2 * b14;
    t19 += v2 * b15;
    v2 = a2[5];
    t5 += v2 * b0;
    t6 += v2 * b1;
    t7 += v2 * b22;
    t8 += v2 * b32;
    t9 += v2 * b4;
    t10 += v2 * b5;
    t11 += v2 * b6;
    t12 += v2 * b7;
    t13 += v2 * b8;
    t14 += v2 * b9;
    t15 += v2 * b10;
    t16 += v2 * b11;
    t17 += v2 * b12;
    t18 += v2 * b13;
    t19 += v2 * b14;
    t20 += v2 * b15;
    v2 = a2[6];
    t6 += v2 * b0;
    t7 += v2 * b1;
    t8 += v2 * b22;
    t9 += v2 * b32;
    t10 += v2 * b4;
    t11 += v2 * b5;
    t12 += v2 * b6;
    t13 += v2 * b7;
    t14 += v2 * b8;
    t15 += v2 * b9;
    t16 += v2 * b10;
    t17 += v2 * b11;
    t18 += v2 * b12;
    t19 += v2 * b13;
    t20 += v2 * b14;
    t21 += v2 * b15;
    v2 = a2[7];
    t7 += v2 * b0;
    t8 += v2 * b1;
    t9 += v2 * b22;
    t10 += v2 * b32;
    t11 += v2 * b4;
    t12 += v2 * b5;
    t13 += v2 * b6;
    t14 += v2 * b7;
    t15 += v2 * b8;
    t16 += v2 * b9;
    t17 += v2 * b10;
    t18 += v2 * b11;
    t19 += v2 * b12;
    t20 += v2 * b13;
    t21 += v2 * b14;
    t22 += v2 * b15;
    v2 = a2[8];
    t8 += v2 * b0;
    t9 += v2 * b1;
    t10 += v2 * b22;
    t11 += v2 * b32;
    t12 += v2 * b4;
    t13 += v2 * b5;
    t14 += v2 * b6;
    t15 += v2 * b7;
    t16 += v2 * b8;
    t17 += v2 * b9;
    t18 += v2 * b10;
    t19 += v2 * b11;
    t20 += v2 * b12;
    t21 += v2 * b13;
    t22 += v2 * b14;
    t23 += v2 * b15;
    v2 = a2[9];
    t9 += v2 * b0;
    t10 += v2 * b1;
    t11 += v2 * b22;
    t12 += v2 * b32;
    t13 += v2 * b4;
    t14 += v2 * b5;
    t15 += v2 * b6;
    t16 += v2 * b7;
    t17 += v2 * b8;
    t18 += v2 * b9;
    t19 += v2 * b10;
    t20 += v2 * b11;
    t21 += v2 * b12;
    t22 += v2 * b13;
    t23 += v2 * b14;
    t24 += v2 * b15;
    v2 = a2[10];
    t10 += v2 * b0;
    t11 += v2 * b1;
    t12 += v2 * b22;
    t13 += v2 * b32;
    t14 += v2 * b4;
    t15 += v2 * b5;
    t16 += v2 * b6;
    t17 += v2 * b7;
    t18 += v2 * b8;
    t19 += v2 * b9;
    t20 += v2 * b10;
    t21 += v2 * b11;
    t22 += v2 * b12;
    t23 += v2 * b13;
    t24 += v2 * b14;
    t25 += v2 * b15;
    v2 = a2[11];
    t11 += v2 * b0;
    t12 += v2 * b1;
    t13 += v2 * b22;
    t14 += v2 * b32;
    t15 += v2 * b4;
    t16 += v2 * b5;
    t17 += v2 * b6;
    t18 += v2 * b7;
    t19 += v2 * b8;
    t20 += v2 * b9;
    t21 += v2 * b10;
    t22 += v2 * b11;
    t23 += v2 * b12;
    t24 += v2 * b13;
    t25 += v2 * b14;
    t26 += v2 * b15;
    v2 = a2[12];
    t12 += v2 * b0;
    t13 += v2 * b1;
    t14 += v2 * b22;
    t15 += v2 * b32;
    t16 += v2 * b4;
    t17 += v2 * b5;
    t18 += v2 * b6;
    t19 += v2 * b7;
    t20 += v2 * b8;
    t21 += v2 * b9;
    t22 += v2 * b10;
    t23 += v2 * b11;
    t24 += v2 * b12;
    t25 += v2 * b13;
    t26 += v2 * b14;
    t27 += v2 * b15;
    v2 = a2[13];
    t13 += v2 * b0;
    t14 += v2 * b1;
    t15 += v2 * b22;
    t16 += v2 * b32;
    t17 += v2 * b4;
    t18 += v2 * b5;
    t19 += v2 * b6;
    t20 += v2 * b7;
    t21 += v2 * b8;
    t22 += v2 * b9;
    t23 += v2 * b10;
    t24 += v2 * b11;
    t25 += v2 * b12;
    t26 += v2 * b13;
    t27 += v2 * b14;
    t28 += v2 * b15;
    v2 = a2[14];
    t14 += v2 * b0;
    t15 += v2 * b1;
    t16 += v2 * b22;
    t17 += v2 * b32;
    t18 += v2 * b4;
    t19 += v2 * b5;
    t20 += v2 * b6;
    t21 += v2 * b7;
    t22 += v2 * b8;
    t23 += v2 * b9;
    t24 += v2 * b10;
    t25 += v2 * b11;
    t26 += v2 * b12;
    t27 += v2 * b13;
    t28 += v2 * b14;
    t29 += v2 * b15;
    v2 = a2[15];
    t15 += v2 * b0;
    t16 += v2 * b1;
    t17 += v2 * b22;
    t18 += v2 * b32;
    t19 += v2 * b4;
    t20 += v2 * b5;
    t21 += v2 * b6;
    t22 += v2 * b7;
    t23 += v2 * b8;
    t24 += v2 * b9;
    t25 += v2 * b10;
    t26 += v2 * b11;
    t27 += v2 * b12;
    t28 += v2 * b13;
    t29 += v2 * b14;
    t30 += v2 * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    c2 = 1;
    v2 = t0 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t0 = v2 - c2 * 65536;
    v2 = t1 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t1 = v2 - c2 * 65536;
    v2 = t2 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t2 = v2 - c2 * 65536;
    v2 = t3 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t3 = v2 - c2 * 65536;
    v2 = t4 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t4 = v2 - c2 * 65536;
    v2 = t5 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t5 = v2 - c2 * 65536;
    v2 = t6 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t6 = v2 - c2 * 65536;
    v2 = t7 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t7 = v2 - c2 * 65536;
    v2 = t8 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t8 = v2 - c2 * 65536;
    v2 = t9 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t9 = v2 - c2 * 65536;
    v2 = t10 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t10 = v2 - c2 * 65536;
    v2 = t11 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t11 = v2 - c2 * 65536;
    v2 = t12 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t12 = v2 - c2 * 65536;
    v2 = t13 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t13 = v2 - c2 * 65536;
    v2 = t14 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t14 = v2 - c2 * 65536;
    v2 = t15 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t15 = v2 - c2 * 65536;
    t0 += c2 - 1 + 37 * (c2 - 1);
    c2 = 1;
    v2 = t0 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t0 = v2 - c2 * 65536;
    v2 = t1 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t1 = v2 - c2 * 65536;
    v2 = t2 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t2 = v2 - c2 * 65536;
    v2 = t3 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t3 = v2 - c2 * 65536;
    v2 = t4 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t4 = v2 - c2 * 65536;
    v2 = t5 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t5 = v2 - c2 * 65536;
    v2 = t6 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t6 = v2 - c2 * 65536;
    v2 = t7 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t7 = v2 - c2 * 65536;
    v2 = t8 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t8 = v2 - c2 * 65536;
    v2 = t9 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t9 = v2 - c2 * 65536;
    v2 = t10 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t10 = v2 - c2 * 65536;
    v2 = t11 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t11 = v2 - c2 * 65536;
    v2 = t12 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t12 = v2 - c2 * 65536;
    v2 = t13 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t13 = v2 - c2 * 65536;
    v2 = t14 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t14 = v2 - c2 * 65536;
    v2 = t15 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t15 = v2 - c2 * 65536;
    t0 += c2 - 1 + 37 * (c2 - 1);
    o2[0] = t0;
    o2[1] = t1;
    o2[2] = t2;
    o2[3] = t3;
    o2[4] = t4;
    o2[5] = t5;
    o2[6] = t6;
    o2[7] = t7;
    o2[8] = t8;
    o2[9] = t9;
    o2[10] = t10;
    o2[11] = t11;
    o2[12] = t12;
    o2[13] = t13;
    o2[14] = t14;
    o2[15] = t15;
  }
  function square(o2, a2) {
    mul4(o2, a2, a2);
  }
  function inv25519(o2, inp) {
    const c2 = gf();
    for (let i3 = 0; i3 < 16; i3++) {
      c2[i3] = inp[i3];
    }
    for (let i3 = 253; i3 >= 0; i3--) {
      square(c2, c2);
      if (i3 !== 2 && i3 !== 4) {
        mul4(c2, c2, inp);
      }
    }
    for (let i3 = 0; i3 < 16; i3++) {
      o2[i3] = c2[i3];
    }
  }
  function scalarMult(n4, p2) {
    const z2 = new Uint8Array(32);
    const x2 = new Float64Array(80);
    const a2 = gf(), b3 = gf(), c2 = gf(), d2 = gf(), e2 = gf(), f3 = gf();
    for (let i3 = 0; i3 < 31; i3++) {
      z2[i3] = n4[i3];
    }
    z2[31] = n4[31] & 127 | 64;
    z2[0] &= 248;
    unpack25519(x2, p2);
    for (let i3 = 0; i3 < 16; i3++) {
      b3[i3] = x2[i3];
    }
    a2[0] = d2[0] = 1;
    for (let i3 = 254; i3 >= 0; --i3) {
      const r2 = z2[i3 >>> 3] >>> (i3 & 7) & 1;
      sel25519(a2, b3, r2);
      sel25519(c2, d2, r2);
      add4(e2, a2, c2);
      sub(a2, a2, c2);
      add4(c2, b3, d2);
      sub(b3, b3, d2);
      square(d2, e2);
      square(f3, a2);
      mul4(a2, c2, a2);
      mul4(c2, b3, e2);
      add4(e2, a2, c2);
      sub(a2, a2, c2);
      square(b3, a2);
      sub(c2, d2, f3);
      mul4(a2, c2, _121665);
      add4(a2, a2, d2);
      mul4(c2, c2, a2);
      mul4(a2, d2, f3);
      mul4(d2, b3, x2);
      square(b3, e2);
      sel25519(a2, b3, r2);
      sel25519(c2, d2, r2);
    }
    for (let i3 = 0; i3 < 16; i3++) {
      x2[i3 + 16] = a2[i3];
      x2[i3 + 32] = c2[i3];
      x2[i3 + 48] = b3[i3];
      x2[i3 + 64] = d2[i3];
    }
    const x32 = x2.subarray(32);
    const x16 = x2.subarray(16);
    inv25519(x32, x32);
    mul4(x16, x16, x32);
    const q2 = new Uint8Array(32);
    pack25519(q2, x16);
    return q2;
  }
  exports.scalarMult = scalarMult;
  function scalarMultBase(n4) {
    return scalarMult(n4, _9);
  }
  exports.scalarMultBase = scalarMultBase;
  function generateKeyPairFromSeed(seed) {
    if (seed.length !== exports.SECRET_KEY_LENGTH) {
      throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
    }
    const secretKey = new Uint8Array(seed);
    const publicKey = scalarMultBase(secretKey);
    return {
      publicKey,
      secretKey
    };
  }
  exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
  function generateKeyPair(prng) {
    const seed = (0, random_1.randomBytes)(32, prng);
    const result = generateKeyPairFromSeed(seed);
    (0, wipe_12.wipe)(seed);
    return result;
  }
  exports.generateKeyPair = generateKeyPair;
  function sharedKey(mySecretKey, theirPublicKey, rejectZero = false) {
    if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
      throw new Error("X25519: incorrect secret key length");
    }
    if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
      throw new Error("X25519: incorrect public key length");
    }
    const result = scalarMult(mySecretKey, theirPublicKey);
    if (rejectZero) {
      let zeros2 = 0;
      for (let i3 = 0; i3 < result.length; i3++) {
        zeros2 |= result[i3];
      }
      if (zeros2 === 0) {
        throw new Error("X25519: invalid shared key");
      }
    }
    return result;
  }
  exports.sharedKey = sharedKey;
})(x25519);
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}
function allocUnsafe(size2 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size2));
  }
  return new Uint8Array(size2);
}
function concat(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output2 = allocUnsafe(length2);
  let offset = 0;
  for (const arr of arrays) {
    output2.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output2);
}
function base(ALPHABET2, name2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i3 = 0; i3 < ALPHABET2.length; i3++) {
    var x2 = ALPHABET2.charAt(i3);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i3;
  }
  var BASE2 = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE2) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE2);
  function encode4(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i4 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i4 < length2) && it1 !== -1; it1--, i4++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE2 >>> 0;
        carry = carry / BASE2 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i4;
      pbegin++;
    }
    var it2 = size2 - length2;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe2(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i4 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i4 < length2) && it3 !== -1; it3--, i4++) {
        carry += BASE2 * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i4;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size2 - length2;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j3 = zeroes;
    while (it4 !== size2) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer2 = decodeUnsafe2(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode4,
    decodeUnsafe: decodeUnsafe2,
    decode: decode2
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
const coerce = (o2) => {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
    return o2;
  if (o2 instanceof ArrayBuffer)
    return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const fromString$1 = (str) => new TextEncoder().encode(str);
const toString$1 = (b3) => new TextDecoder().decode(b3);
class Encoder {
  constructor(name2, prefix2, baseEncode) {
    this.name = name2;
    this.prefix = prefix2;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder {
  constructor(name2, prefix2, baseDecode) {
    this.name = name2;
    this.prefix = prefix2;
    if (prefix2.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix2.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
}
class ComposedDecoder {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix2 = input[0];
    const decoder = this.decoders[prefix2];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or = (left, right) => new ComposedDecoder({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec {
  constructor(name2, prefix2, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix2;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name2, prefix2, baseEncode);
    this.decoder = new Decoder(name2, prefix2, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from = ({ name: name2, prefix: prefix2, encode: encode4, decode: decode2 }) => new Codec(name2, prefix2, encode4, decode2);
const baseX = ({ prefix: prefix2, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode4, decode: decode2 } = _brrp__multiformats_scope_baseX(alphabet2, name2);
  return from({
    prefix: prefix2,
    name: name2,
    encode: encode4,
    decode: (text) => coerce(decode2(text))
  });
};
const decode$2 = (string2, alphabet2, bitsPerChar, name2) => {
  const codes = {};
  for (let i3 = 0; i3 < alphabet2.length; ++i3) {
    codes[alphabet2[i3]] = i3;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i3 = 0; i3 < end; ++i3) {
    const value = codes[string2[i3]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$1 = (data2, alphabet2, bitsPerChar) => {
  const pad3 = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i3 = 0; i3 < data2.length; ++i3) {
    buffer2 = buffer2 << 8 | data2[i3];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad3) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648 = ({ name: name2, prefix: prefix2, bitsPerChar, alphabet: alphabet2 }) => {
  return from({
    prefix: prefix2,
    name: name2,
    encode(input) {
      return encode$1(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$2(input, alphabet2, bitsPerChar, name2);
    }
  });
};
const identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString$1(buf),
  decode: (str) => fromString$1(str)
});
const identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity
}, Symbol.toStringTag, { value: "Module" }));
const base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" }));
const base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" }));
const base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" }));
const base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" }));
const base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
const base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
const base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
const base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
const base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
const base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
const base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
const base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
const base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
const base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" }));
const base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" }));
const base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" }));
const base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" }));
const alphabet = Array.from("");
const alphabetBytesToChars = alphabet.reduce((p2, c2, i3) => {
  p2[i3] = c2;
  return p2;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p2, c2, i3) => {
  p2[c2.codePointAt(0)] = i3;
  return p2;
}, []);
function encode3(data2) {
  return data2.reduce((p2, c2) => {
    p2 += alphabetBytesToChars[c2];
    return p2;
  }, "");
}
function decode$1(str) {
  const byts = [];
  for (const char2 of str) {
    const byt = alphabetCharsToBytes[char2.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char2}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji = from({
  prefix: "",
  name: "base256emoji",
  encode: encode3,
  decode: decode$1
});
const base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const bases = {
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$1,
  ...base36$1,
  ...base58,
  ...base64$1,
  ...base256emoji$1
};
function createCodec(name2, prefix2, encode4, decode2) {
  return {
    name: name2,
    prefix: prefix2,
    encoder: {
      name: name2,
      prefix: prefix2,
      encode: encode4
    },
    decoder: { decode: decode2 }
  };
}
const string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
const ascii = createCodec("ascii", "a", (buf) => {
  let string2 = "a";
  for (let i3 = 0; i3 < buf.length; i3++) {
    string2 += String.fromCharCode(buf[i3]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i3 = 0; i3 < str.length; i3++) {
    buf[i3] = str.charCodeAt(i3);
  }
  return buf;
});
const BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function fromString(string2, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
function toString(array, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
var __spreadArray = function(to, from2, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i3 = 0, l2 = from2.length, ar; i3 < l2; i3++) {
      if (ar || !(i3 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i3);
        ar[i3] = from2[i3];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
};
var BrowserInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function BrowserInfo2(name2, version2, os) {
      this.name = name2;
      this.version = version2;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function NodeInfo2(version2) {
      this.version = version2;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function SearchBotDeviceInfo2(name2, version2, os, bot) {
      this.name = name2;
      this.version = version2;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser2 = _a[0], regex2 = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex2.exec(ua2);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match2 = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match2[1] && match2[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os = detectOS(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name2, version2, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name2, version2, os);
}
function detectOS(ua2) {
  for (var ii2 = 0, count = operatingSystemRules.length; ii2 < count; ii2++) {
    var _a = operatingSystemRules[ii2], os = _a[0], regex2 = _a[1];
    var match2 = regex2.exec(ua2);
    if (match2) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output2 = [];
  for (var ii2 = 0; ii2 < count; ii2++) {
    output2.push("0");
  }
  return output2;
}
var cjs$2 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b3) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
    d3.__proto__ = b4;
  } || function(d3, b4) {
    for (var p2 in b4)
      if (b4.hasOwnProperty(p2))
        d3[p2] = b4[p2];
  };
  return extendStatics(d2, b3);
};
function __extends(d2, b3) {
  extendStatics(d2, b3);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s4, i3 = 1, n4 = arguments.length; i3 < n4; i3++) {
      s4 = arguments[i3];
      for (var p2 in s4)
        if (Object.prototype.hasOwnProperty.call(s4, p2))
          t2[p2] = s4[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s4, e2) {
  var t2 = {};
  for (var p2 in s4)
    if (Object.prototype.hasOwnProperty.call(s4, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s4[p2];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s4); i3 < p2.length; i3++) {
      if (e2.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p2[i3]))
        t2[p2[i3]] = s4[p2[i3]];
    }
  return t2;
}
function __decorate(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key2) {
    decorator(target, key2, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body2) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f3, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n4) {
    return function(v2) {
      return step([n4, v2]);
    };
  }
  function step(op) {
    if (f3)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f3 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body2.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f3 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o2, m2, k4, k22) {
  if (k22 === void 0)
    k22 = k4;
  o2[k22] = m2[k4];
}
function __exportStar(m2, exports) {
  for (var p2 in m2)
    if (p2 !== "default" && !exports.hasOwnProperty(p2))
      exports[p2] = m2[p2];
}
function __values(o2) {
  var s4 = typeof Symbol === "function" && Symbol.iterator, m2 = s4 && o2[s4], i3 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i3 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i3++], done: !o2 };
      }
    };
  throw new TypeError(s4 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n4) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i3 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n4 === void 0 || n4-- > 0) && !(r2 = i3.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i3["return"]))
        m2.call(i3);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i3 = 0; i3 < arguments.length; i3++)
    ar = ar.concat(__read(arguments[i3]));
  return ar;
}
function __spreadArrays() {
  for (var s4 = 0, i3 = 0, il2 = arguments.length; i3 < il2; i3++)
    s4 += arguments[i3].length;
  for (var r2 = Array(s4), k4 = 0, i3 = 0; i3 < il2; i3++)
    for (var a2 = arguments[i3], j2 = 0, jl2 = a2.length; j2 < jl2; j2++, k4++)
      r2[k4] = a2[j2];
  return r2;
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i3, q2 = [];
  return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
    return this;
  }, i3;
  function verb(n4) {
    if (g2[n4])
      i3[n4] = function(v2) {
        return new Promise(function(a2, b3) {
          q2.push([n4, v2, a2, b3]) > 1 || resume(n4, v2);
        });
      };
  }
  function resume(n4, v2) {
    try {
      step(g2[n4](v2));
    } catch (e2) {
      settle2(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle2(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle2(f3, v2) {
    if (f3(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i3, p2;
  return i3 = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i3[Symbol.iterator] = function() {
    return this;
  }, i3;
  function verb(n4, f3) {
    i3[n4] = o2[n4] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o2[n4](v2)), done: n4 === "return" } : f3 ? f3(v2) : v2;
    } : f3;
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i3;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
    return this;
  }, i3);
  function verb(n4) {
    i3[n4] = o2[n4] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n4](v2), settle2(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle2(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k4 in mod)
      if (Object.hasOwnProperty.call(mod, k4))
        result[k4] = mod[k4];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
const tslib_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest,
  __spread,
  __spreadArrays,
  __values
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
var utils = {};
var delay = {};
var hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay)
    return delay;
  hasRequiredDelay = 1;
  Object.defineProperty(delay, "__esModule", { value: true });
  delay.delay = void 0;
  function delay$1(timeout) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(true);
      }, timeout);
    });
  }
  delay.delay = delay$1;
  return delay;
}
var convert = {};
var constants = {};
var misc = {};
var hasRequiredMisc;
function requireMisc() {
  if (hasRequiredMisc)
    return misc;
  hasRequiredMisc = 1;
  Object.defineProperty(misc, "__esModule", { value: true });
  misc.ONE_THOUSAND = misc.ONE_HUNDRED = void 0;
  misc.ONE_HUNDRED = 100;
  misc.ONE_THOUSAND = 1e3;
  return misc;
}
var time = {};
var hasRequiredTime;
function requireTime() {
  if (hasRequiredTime)
    return time;
  hasRequiredTime = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0;
    exports.ONE_SECOND = 1;
    exports.FIVE_SECONDS = 5;
    exports.TEN_SECONDS = 10;
    exports.THIRTY_SECONDS = 30;
    exports.SIXTY_SECONDS = 60;
    exports.ONE_MINUTE = exports.SIXTY_SECONDS;
    exports.FIVE_MINUTES = exports.ONE_MINUTE * 5;
    exports.TEN_MINUTES = exports.ONE_MINUTE * 10;
    exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30;
    exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60;
    exports.ONE_HOUR = exports.SIXTY_MINUTES;
    exports.THREE_HOURS = exports.ONE_HOUR * 3;
    exports.SIX_HOURS = exports.ONE_HOUR * 6;
    exports.TWELVE_HOURS = exports.ONE_HOUR * 12;
    exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24;
    exports.ONE_DAY = exports.TWENTY_FOUR_HOURS;
    exports.THREE_DAYS = exports.ONE_DAY * 3;
    exports.FIVE_DAYS = exports.ONE_DAY * 5;
    exports.SEVEN_DAYS = exports.ONE_DAY * 7;
    exports.THIRTY_DAYS = exports.ONE_DAY * 30;
    exports.ONE_WEEK = exports.SEVEN_DAYS;
    exports.TWO_WEEKS = exports.ONE_WEEK * 2;
    exports.THREE_WEEKS = exports.ONE_WEEK * 3;
    exports.FOUR_WEEKS = exports.ONE_WEEK * 4;
    exports.ONE_YEAR = exports.ONE_DAY * 365;
  })(time);
  return time;
}
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants)
    return constants;
  hasRequiredConstants = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0;
    tslib_1.__exportStar(requireMisc(), exports);
    tslib_1.__exportStar(requireTime(), exports);
  })(constants);
  return constants;
}
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert)
    return convert;
  hasRequiredConvert = 1;
  Object.defineProperty(convert, "__esModule", { value: true });
  convert.fromMiliseconds = convert.toMiliseconds = void 0;
  const constants_1 = requireConstants();
  function toMiliseconds(seconds) {
    return seconds * constants_1.ONE_THOUSAND;
  }
  convert.toMiliseconds = toMiliseconds;
  function fromMiliseconds(miliseconds) {
    return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
  }
  convert.fromMiliseconds = fromMiliseconds;
  return convert;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils;
  hasRequiredUtils = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0;
    tslib_1.__exportStar(requireDelay(), exports);
    tslib_1.__exportStar(requireConvert(), exports);
  })(utils);
  return utils;
}
var watch$1 = {};
var hasRequiredWatch$1;
function requireWatch$1() {
  if (hasRequiredWatch$1)
    return watch$1;
  hasRequiredWatch$1 = 1;
  Object.defineProperty(watch$1, "__esModule", { value: true });
  watch$1.Watch = void 0;
  class Watch {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(label) {
      if (this.timestamps.has(label)) {
        throw new Error(`Watch already started for label: ${label}`);
      }
      this.timestamps.set(label, { started: Date.now() });
    }
    stop(label) {
      const timestamp2 = this.get(label);
      if (typeof timestamp2.elapsed !== "undefined") {
        throw new Error(`Watch already stopped for label: ${label}`);
      }
      const elapsed = Date.now() - timestamp2.started;
      this.timestamps.set(label, { started: timestamp2.started, elapsed });
    }
    get(label) {
      const timestamp2 = this.timestamps.get(label);
      if (typeof timestamp2 === "undefined") {
        throw new Error(`No timestamp found for label: ${label}`);
      }
      return timestamp2;
    }
    elapsed(label) {
      const timestamp2 = this.get(label);
      const elapsed = timestamp2.elapsed || Date.now() - timestamp2.started;
      return elapsed;
    }
  }
  watch$1.Watch = Watch;
  watch$1.default = Watch;
  return watch$1;
}
var types = {};
var watch = {};
var hasRequiredWatch;
function requireWatch() {
  if (hasRequiredWatch)
    return watch;
  hasRequiredWatch = 1;
  Object.defineProperty(watch, "__esModule", { value: true });
  watch.IWatch = void 0;
  class IWatch {
  }
  watch.IWatch = IWatch;
  return watch;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes)
    return types;
  hasRequiredTypes = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0;
    tslib_1.__exportStar(requireWatch(), exports);
  })(types);
  return types;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require$$0;
  tslib_1.__exportStar(requireUtils(), exports);
  tslib_1.__exportStar(requireWatch$1(), exports);
  tslib_1.__exportStar(requireTypes(), exports);
  tslib_1.__exportStar(requireConstants(), exports);
})(cjs$2);
var cjs$1 = {};
Object.defineProperty(cjs$1, "__esModule", { value: true });
cjs$1.getLocalStorage = cjs$1.getLocalStorageOrThrow = cjs$1.getCrypto = cjs$1.getCryptoOrThrow = getLocation_1 = cjs$1.getLocation = cjs$1.getLocationOrThrow = getNavigator_1 = cjs$1.getNavigator = cjs$1.getNavigatorOrThrow = getDocument_1 = cjs$1.getDocument = cjs$1.getDocumentOrThrow = cjs$1.getFromWindowOrThrow = cjs$1.getFromWindow = void 0;
function getFromWindow(name2) {
  let res = void 0;
  if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
    res = window[name2];
  }
  return res;
}
cjs$1.getFromWindow = getFromWindow;
function getFromWindowOrThrow(name2) {
  const res = getFromWindow(name2);
  if (!res) {
    throw new Error(`${name2} is not defined in Window`);
  }
  return res;
}
cjs$1.getFromWindowOrThrow = getFromWindowOrThrow;
function getDocumentOrThrow() {
  return getFromWindowOrThrow("document");
}
cjs$1.getDocumentOrThrow = getDocumentOrThrow;
function getDocument() {
  return getFromWindow("document");
}
var getDocument_1 = cjs$1.getDocument = getDocument;
function getNavigatorOrThrow() {
  return getFromWindowOrThrow("navigator");
}
cjs$1.getNavigatorOrThrow = getNavigatorOrThrow;
function getNavigator() {
  return getFromWindow("navigator");
}
var getNavigator_1 = cjs$1.getNavigator = getNavigator;
function getLocationOrThrow() {
  return getFromWindowOrThrow("location");
}
cjs$1.getLocationOrThrow = getLocationOrThrow;
function getLocation() {
  return getFromWindow("location");
}
var getLocation_1 = cjs$1.getLocation = getLocation;
function getCryptoOrThrow() {
  return getFromWindowOrThrow("crypto");
}
cjs$1.getCryptoOrThrow = getCryptoOrThrow;
function getCrypto() {
  return getFromWindow("crypto");
}
cjs$1.getCrypto = getCrypto;
function getLocalStorageOrThrow() {
  return getFromWindowOrThrow("localStorage");
}
cjs$1.getLocalStorageOrThrow = getLocalStorageOrThrow;
function getLocalStorage() {
  return getFromWindow("localStorage");
}
cjs$1.getLocalStorage = getLocalStorage;
var cjs = {};
Object.defineProperty(cjs, "__esModule", { value: true });
var getWindowMetadata_1 = cjs.getWindowMetadata = void 0;
const window_getters_1 = cjs$1;
function getWindowMetadata() {
  let doc;
  let loc;
  try {
    doc = window_getters_1.getDocumentOrThrow();
    loc = window_getters_1.getLocationOrThrow();
  } catch (e2) {
    return null;
  }
  function getIcons() {
    const links = doc.getElementsByTagName("link");
    const icons2 = [];
    for (let i3 = 0; i3 < links.length; i3++) {
      const link = links[i3];
      const rel = link.getAttribute("rel");
      if (rel) {
        if (rel.toLowerCase().indexOf("icon") > -1) {
          const href = link.getAttribute("href");
          if (href) {
            if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
              let absoluteHref = loc.protocol + "//" + loc.host;
              if (href.indexOf("/") === 0) {
                absoluteHref += href;
              } else {
                const path = loc.pathname.split("/");
                path.pop();
                const finalPath = path.join("/");
                absoluteHref += finalPath + "/" + href;
              }
              icons2.push(absoluteHref);
            } else if (href.indexOf("//") === 0) {
              const absoluteUrl = loc.protocol + href;
              icons2.push(absoluteUrl);
            } else {
              icons2.push(href);
            }
          }
        }
      }
    }
    return icons2;
  }
  function getWindowMetadataOfAny(...args) {
    const metaTags = doc.getElementsByTagName("meta");
    for (let i3 = 0; i3 < metaTags.length; i3++) {
      const tag = metaTags[i3];
      const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
        if (attr) {
          return args.includes(attr);
        }
        return false;
      });
      if (attributes.length && attributes) {
        const content = tag.getAttribute("content");
        if (content) {
          return content;
        }
      }
    }
    return "";
  }
  function getName() {
    let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
    if (!name3) {
      name3 = doc.title;
    }
    return name3;
  }
  function getDescription() {
    const description3 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
    return description3;
  }
  const name2 = getName();
  const description2 = getDescription();
  const url = loc.origin;
  const icons = getIcons();
  const meta = {
    description: description2,
    url,
    icons,
    name: name2
  };
  return meta;
}
getWindowMetadata_1 = cjs.getWindowMetadata = getWindowMetadata;
var queryString = {};
var strictUriEncode = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x2) => `%${x2.charCodeAt(0).toString(16).toUpperCase()}`);
var token = "%[a-f0-9]{2}";
var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
var multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(components, split2) {
  try {
    return [decodeURIComponent(components.join(""))];
  } catch (err) {
  }
  if (components.length === 1) {
    return components;
  }
  split2 = split2 || 1;
  var left = components.slice(0, split2);
  var right = components.slice(split2);
  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode(input) {
  try {
    return decodeURIComponent(input);
  } catch (err) {
    var tokens2 = input.match(singleMatcher) || [];
    for (var i3 = 1; i3 < tokens2.length; i3++) {
      input = decodeComponents(tokens2, i3).join("");
      tokens2 = input.match(singleMatcher) || [];
    }
    return input;
  }
}
function customDecodeURIComponent(input) {
  var replaceMap = {
    "%FE%FF": "",
    "%FF%FE": ""
  };
  var match2 = multiMatcher.exec(input);
  while (match2) {
    try {
      replaceMap[match2[0]] = decodeURIComponent(match2[0]);
    } catch (err) {
      var result = decode(match2[0]);
      if (result !== match2[0]) {
        replaceMap[match2[0]] = result;
      }
    }
    match2 = multiMatcher.exec(input);
  }
  replaceMap["%C2"] = "";
  var entries2 = Object.keys(replaceMap);
  for (var i3 = 0; i3 < entries2.length; i3++) {
    var key2 = entries2[i3];
    input = input.replace(new RegExp(key2, "g"), replaceMap[key2]);
  }
  return input;
}
var decodeUriComponent = function(encodedURI) {
  if (typeof encodedURI !== "string") {
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  }
  try {
    encodedURI = encodedURI.replace(/\+/g, " ");
    return decodeURIComponent(encodedURI);
  } catch (err) {
    return customDecodeURIComponent(encodedURI);
  }
};
var splitOnFirst = (string2, separator) => {
  if (!(typeof string2 === "string" && typeof separator === "string")) {
    throw new TypeError("Expected the arguments to be of type `string`");
  }
  if (separator === "") {
    return [string2];
  }
  const separatorIndex = string2.indexOf(separator);
  if (separatorIndex === -1) {
    return [string2];
  }
  return [
    string2.slice(0, separatorIndex),
    string2.slice(separatorIndex + separator.length)
  ];
};
var filterObj = function(obj, predicate) {
  var ret = {};
  var keys = Object.keys(obj);
  var isArr = Array.isArray(predicate);
  for (var i3 = 0; i3 < keys.length; i3++) {
    var key2 = keys[i3];
    var val = obj[key2];
    if (isArr ? predicate.indexOf(key2) !== -1 : predicate(key2, val, obj)) {
      ret[key2] = val;
    }
  }
  return ret;
};
(function(exports) {
  const strictUriEncode$1 = strictUriEncode;
  const decodeComponent = decodeUriComponent;
  const splitOnFirst$1 = splitOnFirst;
  const filterObject = filterObj;
  const isNullOrUndefined = (value) => value === null || value === void 0;
  const encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case "index":
        return (key2) => (result, value) => {
          const index2 = result.length;
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode4(key2, options), "[", index2, "]"].join("")];
          }
          return [
            ...result,
            [encode4(key2, options), "[", encode4(index2, options), "]=", encode4(value, options)].join("")
          ];
        };
      case "bracket":
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode4(key2, options), "[]"].join("")];
          }
          return [...result, [encode4(key2, options), "[]=", encode4(value, options)].join("")];
        };
      case "colon-list-separator":
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode4(key2, options), ":list="].join("")];
          }
          return [...result, [encode4(key2, options), ":list=", encode4(value, options)].join("")];
        };
      case "comma":
      case "separator":
      case "bracket-separator": {
        const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          value = value === null ? "" : value;
          if (result.length === 0) {
            return [[encode4(key2, options), keyValueSep, encode4(value, options)].join("")];
          }
          return [[result, encode4(value, options)].join(options.arrayFormatSeparator)];
        };
      }
      default:
        return (key2) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, encode4(key2, options)];
          }
          return [...result, [encode4(key2, options), "=", encode4(value, options)].join("")];
        };
    }
  }
  function parserForArrayFormat(options) {
    let result;
    switch (options.arrayFormat) {
      case "index":
        return (key2, value, accumulator) => {
          result = /\[(\d*)\]$/.exec(key2);
          key2 = key2.replace(/\[\d*\]$/, "");
          if (!result) {
            accumulator[key2] = value;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = {};
          }
          accumulator[key2][result[1]] = value;
        };
      case "bracket":
        return (key2, value, accumulator) => {
          result = /(\[\])$/.exec(key2);
          key2 = key2.replace(/\[\]$/, "");
          if (!result) {
            accumulator[key2] = value;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = [value];
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value);
        };
      case "colon-list-separator":
        return (key2, value, accumulator) => {
          result = /(:list)$/.exec(key2);
          key2 = key2.replace(/:list$/, "");
          if (!result) {
            accumulator[key2] = value;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = [value];
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value);
        };
      case "comma":
      case "separator":
        return (key2, value, accumulator) => {
          const isArray2 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
          const isEncodedArray = typeof value === "string" && !isArray2 && decode2(value, options).includes(options.arrayFormatSeparator);
          value = isEncodedArray ? decode2(value, options) : value;
          const newValue = isArray2 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
          accumulator[key2] = newValue;
        };
      case "bracket-separator":
        return (key2, value, accumulator) => {
          const isArray2 = /(\[\])$/.test(key2);
          key2 = key2.replace(/\[\]$/, "");
          if (!isArray2) {
            accumulator[key2] = value ? decode2(value, options) : value;
            return;
          }
          const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode2(item, options));
          if (accumulator[key2] === void 0) {
            accumulator[key2] = arrayValue;
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], arrayValue);
        };
      default:
        return (key2, value, accumulator) => {
          if (accumulator[key2] === void 0) {
            accumulator[key2] = value;
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value);
        };
    }
  }
  function validateArrayFormatSeparator(value) {
    if (typeof value !== "string" || value.length !== 1) {
      throw new TypeError("arrayFormatSeparator must be single character string");
    }
  }
  function encode4(value, options) {
    if (options.encode) {
      return options.strict ? strictUriEncode$1(value) : encodeURIComponent(value);
    }
    return value;
  }
  function decode2(value, options) {
    if (options.decode) {
      return decodeComponent(value);
    }
    return value;
  }
  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }
    if (typeof input === "object") {
      return keysSorter(Object.keys(input)).sort((a2, b3) => Number(a2) - Number(b3)).map((key2) => input[key2]);
    }
    return input;
  }
  function removeHash(input) {
    const hashStart = input.indexOf("#");
    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }
    return input;
  }
  function getHash(url) {
    let hash2 = "";
    const hashStart = url.indexOf("#");
    if (hashStart !== -1) {
      hash2 = url.slice(hashStart);
    }
    return hash2;
  }
  function extract2(input) {
    input = removeHash(input);
    const queryStart = input.indexOf("?");
    if (queryStart === -1) {
      return "";
    }
    return input.slice(queryStart + 1);
  }
  function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
      value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
      value = value.toLowerCase() === "true";
    }
    return value;
  }
  function parse2(query, options) {
    options = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: false,
      parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options);
    const ret = /* @__PURE__ */ Object.create(null);
    if (typeof query !== "string") {
      return ret;
    }
    query = query.trim().replace(/^[?#&]/, "");
    if (!query) {
      return ret;
    }
    for (const param of query.split("&")) {
      if (param === "") {
        continue;
      }
      let [key2, value] = splitOnFirst$1(options.decode ? param.replace(/\+/g, " ") : param, "=");
      value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode2(value, options);
      formatter(decode2(key2, options), value, ret);
    }
    for (const key2 of Object.keys(ret)) {
      const value = ret[key2];
      if (typeof value === "object" && value !== null) {
        for (const k4 of Object.keys(value)) {
          value[k4] = parseValue(value[k4], options);
        }
      } else {
        ret[key2] = parseValue(value, options);
      }
    }
    if (options.sort === false) {
      return ret;
    }
    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key2) => {
      const value = ret[key2];
      if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
        result[key2] = keysSorter(value);
      } else {
        result[key2] = value;
      }
      return result;
    }, /* @__PURE__ */ Object.create(null));
  }
  exports.extract = extract2;
  exports.parse = parse2;
  exports.stringify = (object, options) => {
    if (!object) {
      return "";
    }
    options = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const shouldFilter = (key2) => options.skipNull && isNullOrUndefined(object[key2]) || options.skipEmptyString && object[key2] === "";
    const formatter = encoderForArrayFormat(options);
    const objectCopy = {};
    for (const key2 of Object.keys(object)) {
      if (!shouldFilter(key2)) {
        objectCopy[key2] = object[key2];
      }
    }
    const keys = Object.keys(objectCopy);
    if (options.sort !== false) {
      keys.sort(options.sort);
    }
    return keys.map((key2) => {
      const value = object[key2];
      if (value === void 0) {
        return "";
      }
      if (value === null) {
        return encode4(key2, options);
      }
      if (Array.isArray(value)) {
        if (value.length === 0 && options.arrayFormat === "bracket-separator") {
          return encode4(key2, options) + "[]";
        }
        return value.reduce(formatter(key2), []).join("&");
      }
      return encode4(key2, options) + "=" + encode4(value, options);
    }).filter((x2) => x2.length > 0).join("&");
  };
  exports.parseUrl = (url, options) => {
    options = Object.assign({
      decode: true
    }, options);
    const [url_, hash2] = splitOnFirst$1(url, "#");
    return Object.assign(
      {
        url: url_.split("?")[0] || "",
        query: parse2(extract2(url), options)
      },
      options && options.parseFragmentIdentifier && hash2 ? { fragmentIdentifier: decode2(hash2, options) } : {}
    );
  };
  exports.stringifyUrl = (object, options) => {
    options = Object.assign({
      encode: true,
      strict: true,
      [encodeFragmentIdentifier]: true
    }, options);
    const url = removeHash(object.url).split("?")[0] || "";
    const queryFromUrl = exports.extract(object.url);
    const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
    const query = Object.assign(parsedQueryFromUrl, object.query);
    let queryString2 = exports.stringify(query, options);
    if (queryString2) {
      queryString2 = `?${queryString2}`;
    }
    let hash2 = getHash(object.url);
    if (object.fragmentIdentifier) {
      hash2 = `#${options[encodeFragmentIdentifier] ? encode4(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
    }
    return `${url}${queryString2}${hash2}`;
  };
  exports.pick = (input, filter, options) => {
    options = Object.assign({
      parseFragmentIdentifier: true,
      [encodeFragmentIdentifier]: false
    }, options);
    const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
    return exports.stringifyUrl({
      url,
      query: filterObject(query, filter),
      fragmentIdentifier
    }, options);
  };
  exports.exclude = (input, filter, options) => {
    const exclusionFilter = Array.isArray(filter) ? (key2) => !filter.includes(key2) : (key2, value) => !filter(key2, value);
    return exports.pick(input, exclusionFilter, options);
  };
})(queryString);
const RELAY_JSONRPC = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
};
const K = ":";
function ve(e2) {
  const [n4, t2] = e2.split(K);
  return { namespace: n4, reference: t2 };
}
function Un(e2, n4 = []) {
  const t2 = [];
  return Object.keys(e2).forEach((r2) => {
    if (n4.length && !n4.includes(r2))
      return;
    const o2 = e2[r2];
    t2.push(...o2.accounts);
  }), t2;
}
function L3(e2, n4) {
  return e2.includes(":") ? [e2] : n4.chains || [];
}
const J = "base10", p = "base16", F = "base64pad", H3 = "utf8", Q = 0, _ = 1, Dn = 0, Pe = 1, Z = 12, X = 32;
function kn() {
  const e2 = x25519.generateKeyPair();
  return { privateKey: toString(e2.secretKey, p), publicKey: toString(e2.publicKey, p) };
}
function Vn() {
  const e2 = random.randomBytes(X);
  return toString(e2, p);
}
function Mn(e2, n4) {
  const t2 = x25519.sharedKey(fromString(e2, p), fromString(n4, p), true), r2 = new HKDF_1(sha256.SHA256, t2).expand(X);
  return toString(r2, p);
}
function Kn(e2) {
  const n4 = sha256.hash(fromString(e2, p));
  return toString(n4, p);
}
function Ln(e2) {
  const n4 = sha256.hash(fromString(e2, H3));
  return toString(n4, p);
}
function Re(e2) {
  return fromString(`${e2}`, J);
}
function $(e2) {
  return Number(toString(e2, J));
}
function xn(e2) {
  const n4 = Re(typeof e2.type < "u" ? e2.type : Q);
  if ($(n4) === _ && typeof e2.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t2 = typeof e2.senderPublicKey < "u" ? fromString(e2.senderPublicKey, p) : void 0, r2 = typeof e2.iv < "u" ? fromString(e2.iv, p) : random.randomBytes(Z), o2 = new chacha20poly1305.ChaCha20Poly1305(fromString(e2.symKey, p)).seal(r2, fromString(e2.message, H3));
  return Te({ type: n4, sealed: o2, iv: r2, senderPublicKey: t2 });
}
function Fn(e2) {
  const n4 = new chacha20poly1305.ChaCha20Poly1305(fromString(e2.symKey, p)), { sealed: t2, iv: r2 } = ee(e2.encoded), o2 = n4.open(r2, t2);
  if (o2 === null)
    throw new Error("Failed to decrypt");
  return toString(o2, H3);
}
function Te(e2) {
  if ($(e2.type) === _) {
    if (typeof e2.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e2.type, e2.senderPublicKey, e2.iv, e2.sealed]), F);
  }
  return toString(concat([e2.type, e2.iv, e2.sealed]), F);
}
function ee(e2) {
  const n4 = fromString(e2, F), t2 = n4.slice(Dn, Pe), r2 = Pe;
  if ($(t2) === _) {
    const d2 = r2 + X, l2 = d2 + Z, c2 = n4.slice(r2, d2), u2 = n4.slice(d2, l2), a2 = n4.slice(l2);
    return { type: t2, sealed: a2, iv: u2, senderPublicKey: c2 };
  }
  const o2 = r2 + Z, s4 = n4.slice(r2, o2), i3 = n4.slice(o2);
  return { type: t2, sealed: i3, iv: s4 };
}
function Hn(e2, n4) {
  const t2 = ee(e2);
  return Ae({ type: $(t2.type), senderPublicKey: typeof t2.senderPublicKey < "u" ? toString(t2.senderPublicKey, p) : void 0, receiverPublicKey: n4?.receiverPublicKey });
}
function Ae(e2) {
  const n4 = e2?.type || Q;
  if (n4 === _) {
    if (typeof e2?.senderPublicKey > "u")
      throw new Error("missing sender public key");
    if (typeof e2?.receiverPublicKey > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n4, senderPublicKey: e2?.senderPublicKey, receiverPublicKey: e2?.receiverPublicKey };
}
function qn(e2) {
  return e2.type === _ && typeof e2.senderPublicKey == "string" && typeof e2.receiverPublicKey == "string";
}
var Bn = Object.defineProperty, Ue = Object.getOwnPropertySymbols, Gn = Object.prototype.hasOwnProperty, Wn = Object.prototype.propertyIsEnumerable, _e = (e2, n4, t2) => n4 in e2 ? Bn(e2, n4, { enumerable: true, configurable: true, writable: true, value: t2 }) : e2[n4] = t2, Ce = (e2, n4) => {
  for (var t2 in n4 || (n4 = {}))
    Gn.call(n4, t2) && _e(e2, t2, n4[t2]);
  if (Ue)
    for (var t2 of Ue(n4))
      Wn.call(n4, t2) && _e(e2, t2, n4[t2]);
  return e2;
};
const je = "ReactNative", m = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, De = "js";
function te() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function C() {
  return !getDocument_1() && !!getNavigator_1() && navigator.product === je;
}
function D() {
  return !te() && !!getNavigator_1() && !!getDocument_1();
}
function T() {
  return C() ? m.reactNative : te() ? m.node : D() ? m.browser : m.unknown;
}
function Jn() {
  var e2;
  try {
    return C() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e2 = global.Application) == null ? void 0 : e2.applicationId : void 0;
  } catch {
    return;
  }
}
function ke(e2, n4) {
  let t2 = queryString.parse(e2);
  return t2 = Ce(Ce({}, t2), n4), e2 = queryString.stringify(t2), e2;
}
function Qn() {
  return getWindowMetadata_1() || { name: "", description: "", url: "", icons: [""] };
}
function Ve() {
  if (T() === m.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t2, Version: r2 } = global.Platform;
    return [t2, r2].join("-");
  }
  const e2 = detect();
  if (e2 === null)
    return "unknown";
  const n4 = e2.os ? e2.os.replace(" ", "").toLowerCase() : "unknown";
  return e2.type === "browser" ? [n4, e2.name, e2.version].join("-") : [n4, e2.version].join("-");
}
function Me() {
  var e2;
  const n4 = T();
  return n4 === m.browser ? [n4, ((e2 = getLocation_1()) == null ? void 0 : e2.host) || "unknown"].join(":") : n4;
}
function Ke(e2, n4, t2) {
  const r2 = Ve(), o2 = Me();
  return [[e2, n4].join("-"), [De, t2].join("-"), r2, o2].join("/");
}
function Xn({ protocol: e2, version: n4, relayUrl: t2, sdkVersion: r2, auth: o2, projectId: s4, useOnCloseEvent: i3, bundleId: d2 }) {
  const l2 = t2.split("?"), c2 = Ke(e2, n4, r2), u2 = { auth: o2, ua: c2, projectId: s4, useOnCloseEvent: i3 || void 0, origin: d2 || void 0 }, a2 = ke(l2[1] || "", u2);
  return l2[0] + "?" + a2;
}
function O(e2, n4) {
  return e2.filter((t2) => n4.includes(t2)).length === e2.length;
}
function rt(e2) {
  return Object.fromEntries(e2.entries());
}
function ot(e2) {
  return new Map(Object.entries(e2));
}
function at(e2 = cjs$2.FIVE_MINUTES, n4) {
  const t2 = cjs$2.toMiliseconds(e2 || cjs$2.FIVE_MINUTES);
  let r2, o2, s4;
  return { resolve: (i3) => {
    s4 && r2 && (clearTimeout(s4), r2(i3));
  }, reject: (i3) => {
    s4 && o2 && (clearTimeout(s4), o2(i3));
  }, done: () => new Promise((i3, d2) => {
    s4 = setTimeout(() => {
      d2(new Error(n4));
    }, t2), r2 = i3, o2 = d2;
  }) };
}
function ut(e2, n4, t2) {
  return new Promise(async (r2, o2) => {
    const s4 = setTimeout(() => o2(new Error(t2)), n4);
    try {
      const i3 = await e2;
      r2(i3);
    } catch (i3) {
      o2(i3);
    }
    clearTimeout(s4);
  });
}
function re(e2, n4) {
  if (typeof n4 == "string" && n4.startsWith(`${e2}:`))
    return n4;
  if (e2.toLowerCase() === "topic") {
    if (typeof n4 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n4}`;
  } else if (e2.toLowerCase() === "id") {
    if (typeof n4 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n4}`;
  }
  throw new Error(`Unknown expirer target type: ${e2}`);
}
function lt(e2) {
  return re("topic", e2);
}
function dt(e2) {
  return re("id", e2);
}
function ft(e2) {
  const [n4, t2] = e2.split(":"), r2 = { id: void 0, topic: void 0 };
  if (n4 === "topic" && typeof t2 == "string")
    r2.topic = t2;
  else if (n4 === "id" && Number.isInteger(Number(t2)))
    r2.id = Number(t2);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n4}:${t2}`);
  return r2;
}
function pt(e2, n4) {
  return cjs$2.fromMiliseconds((n4 || Date.now()) + cjs$2.toMiliseconds(e2));
}
function mt(e2) {
  return Date.now() >= cjs$2.toMiliseconds(e2);
}
function yt(e2, n4) {
  return `${e2}${n4 ? `:${n4}` : ""}`;
}
function S3(e2 = [], n4 = []) {
  return [.../* @__PURE__ */ new Set([...e2, ...n4])];
}
async function ht({ id: e2, topic: n4, wcDeepLink: t2 }) {
  try {
    if (!t2)
      return;
    const r2 = typeof t2 == "string" ? JSON.parse(t2) : t2;
    let o2 = r2?.href;
    if (typeof o2 != "string")
      return;
    o2.endsWith("/") && (o2 = o2.slice(0, -1));
    const s4 = `${o2}/wc?requestId=${e2}&sessionTopic=${n4}`, i3 = T();
    i3 === m.browser ? s4.startsWith("https://") ? window.open(s4, "_blank", "noreferrer noopener") : window.open(s4, "_self", "noreferrer noopener") : i3 === m.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s4);
  } catch (r2) {
    console.error(r2);
  }
}
async function gt(e2, n4) {
  try {
    return await e2.getItem(n4) || (D() ? localStorage.getItem(n4) : void 0);
  } catch (t2) {
    console.error(t2);
  }
}
const He = "irn";
function vt(e2) {
  return e2?.relay || { protocol: He };
}
function Et(e2) {
  const n4 = RELAY_JSONRPC[e2];
  if (typeof n4 > "u")
    throw new Error(`Relay Protocol not supported: ${e2}`);
  return n4;
}
var bt = Object.defineProperty, qe = Object.getOwnPropertySymbols, Nt = Object.prototype.hasOwnProperty, Ot = Object.prototype.propertyIsEnumerable, Be = (e2, n4, t2) => n4 in e2 ? bt(e2, n4, { enumerable: true, configurable: true, writable: true, value: t2 }) : e2[n4] = t2, St = (e2, n4) => {
  for (var t2 in n4 || (n4 = {}))
    Nt.call(n4, t2) && Be(e2, t2, n4[t2]);
  if (qe)
    for (var t2 of qe(n4))
      Ot.call(n4, t2) && Be(e2, t2, n4[t2]);
  return e2;
};
function Ge(e2, n4 = "-") {
  const t2 = {}, r2 = "relay" + n4;
  return Object.keys(e2).forEach((o2) => {
    if (o2.startsWith(r2)) {
      const s4 = o2.replace(r2, ""), i3 = e2[o2];
      t2[s4] = i3;
    }
  }), t2;
}
function wt(e2) {
  e2 = e2.includes("wc://") ? e2.replace("wc://", "") : e2, e2 = e2.includes("wc:") ? e2.replace("wc:", "") : e2;
  const n4 = e2.indexOf(":"), t2 = e2.indexOf("?") !== -1 ? e2.indexOf("?") : void 0, r2 = e2.substring(0, n4), o2 = e2.substring(n4 + 1, t2).split("@"), s4 = typeof t2 < "u" ? e2.substring(t2) : "", i3 = queryString.parse(s4);
  return { protocol: r2, topic: We(o2[0]), version: parseInt(o2[1], 10), symKey: i3.symKey, relay: Ge(i3) };
}
function We(e2) {
  return e2.startsWith("//") ? e2.substring(2) : e2;
}
function ze(e2, n4 = "-") {
  const t2 = "relay", r2 = {};
  return Object.keys(e2).forEach((o2) => {
    const s4 = t2 + n4 + o2;
    e2[o2] && (r2[s4] = e2[o2]);
  }), r2;
}
function It(e2) {
  return `${e2.protocol}:${e2.topic}@${e2.version}?` + queryString.stringify(St({ symKey: e2.symKey }, ze(e2.relay)));
}
var Pt = Object.defineProperty, Rt = Object.defineProperties, Tt = Object.getOwnPropertyDescriptors, Ye = Object.getOwnPropertySymbols, At = Object.prototype.hasOwnProperty, Ut = Object.prototype.propertyIsEnumerable, Je = (e2, n4, t2) => n4 in e2 ? Pt(e2, n4, { enumerable: true, configurable: true, writable: true, value: t2 }) : e2[n4] = t2, _t = (e2, n4) => {
  for (var t2 in n4 || (n4 = {}))
    At.call(n4, t2) && Je(e2, t2, n4[t2]);
  if (Ye)
    for (var t2 of Ye(n4))
      Ut.call(n4, t2) && Je(e2, t2, n4[t2]);
  return e2;
}, Ct = (e2, n4) => Rt(e2, Tt(n4));
function A(e2) {
  const n4 = [];
  return e2.forEach((t2) => {
    const [r2, o2] = t2.split(":");
    n4.push(`${r2}:${o2}`);
  }), n4;
}
function Qe(e2) {
  const n4 = [];
  return Object.values(e2).forEach((t2) => {
    n4.push(...A(t2.accounts));
  }), n4;
}
function Ze(e2, n4) {
  const t2 = [];
  return Object.values(e2).forEach((r2) => {
    A(r2.accounts).includes(n4) && t2.push(...r2.methods);
  }), t2;
}
function Xe(e2, n4) {
  const t2 = [];
  return Object.values(e2).forEach((r2) => {
    A(r2.accounts).includes(n4) && t2.push(...r2.events);
  }), t2;
}
function jt(e2, n4) {
  const t2 = ln(e2, n4);
  if (t2)
    throw new Error(t2.message);
  const r2 = {};
  for (const [o2, s4] of Object.entries(e2))
    r2[o2] = { methods: s4.methods, events: s4.events, chains: s4.accounts.map((i3) => `${i3.split(":")[0]}:${i3.split(":")[1]}`) };
  return r2;
}
function oe(e2) {
  return e2.includes(":");
}
function en(e2) {
  return oe(e2) ? e2.split(":")[0] : e2;
}
function se(e2) {
  var n4, t2, r2;
  const o2 = {};
  if (!B(e2))
    return o2;
  for (const [s4, i3] of Object.entries(e2)) {
    const d2 = oe(s4) ? [s4] : i3.chains, l2 = i3.methods || [], c2 = i3.events || [], u2 = en(s4);
    o2[u2] = Ct(_t({}, o2[u2]), { chains: S3(d2, (n4 = o2[u2]) == null ? void 0 : n4.chains), methods: S3(l2, (t2 = o2[u2]) == null ? void 0 : t2.methods), events: S3(c2, (r2 = o2[u2]) == null ? void 0 : r2.events) });
  }
  return o2;
}
const nn = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, tn = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N(e2, n4) {
  const { message: t2, code: r2 } = tn[e2];
  return { message: n4 ? `${t2} ${n4}` : t2, code: r2 };
}
function U(e2, n4) {
  const { message: t2, code: r2 } = nn[e2];
  return { message: n4 ? `${t2} ${n4}` : t2, code: r2 };
}
function k3(e2, n4) {
  return Array.isArray(e2) ? typeof n4 < "u" && e2.length ? e2.every(n4) : true : false;
}
function B(e2) {
  return Object.getPrototypeOf(e2) === Object.prototype && Object.keys(e2).length;
}
function w(e2) {
  return typeof e2 > "u";
}
function h3(e2, n4) {
  return n4 && w(e2) ? true : typeof e2 == "string" && !!e2.trim().length;
}
function G(e2, n4) {
  return n4 && w(e2) ? true : typeof e2 == "number" && !isNaN(e2);
}
function Dt(e2, n4) {
  const { requiredNamespaces: t2 } = n4, r2 = Object.keys(e2.namespaces), o2 = Object.keys(t2);
  let s4 = true;
  return O(o2, r2) ? (r2.forEach((i3) => {
    const { accounts: d2, methods: l2, events: c2 } = e2.namespaces[i3], u2 = A(d2), a2 = t2[i3];
    (!O(L3(i3, a2), u2) || !O(a2.methods, l2) || !O(a2.events, c2)) && (s4 = false);
  }), s4) : false;
}
function V3(e2) {
  return h3(e2, false) && e2.includes(":") ? e2.split(":").length === 2 : false;
}
function rn(e2) {
  if (h3(e2, false) && e2.includes(":")) {
    const n4 = e2.split(":");
    if (n4.length === 3) {
      const t2 = n4[0] + ":" + n4[1];
      return !!n4[2] && V3(t2);
    }
  }
  return false;
}
function kt(e2) {
  if (h3(e2, false))
    try {
      return typeof new URL(e2) < "u";
    } catch {
      return false;
    }
  return false;
}
function Vt(e2) {
  var n4;
  return (n4 = e2?.proposer) == null ? void 0 : n4.publicKey;
}
function Mt(e2) {
  return e2?.topic;
}
function Kt(e2, n4) {
  let t2 = null;
  return h3(e2?.publicKey, false) || (t2 = N("MISSING_OR_INVALID", `${n4} controller public key should be a string`)), t2;
}
function ie(e2) {
  let n4 = true;
  return k3(e2) ? e2.length && (n4 = e2.every((t2) => h3(t2, false))) : n4 = false, n4;
}
function on(e2, n4, t2) {
  let r2 = null;
  return k3(n4) && n4.length ? n4.forEach((o2) => {
    r2 || V3(o2) || (r2 = U("UNSUPPORTED_CHAINS", `${t2}, chain ${o2} should be a string and conform to "namespace:chainId" format`));
  }) : V3(e2) || (r2 = U("UNSUPPORTED_CHAINS", `${t2}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r2;
}
function sn(e2, n4, t2) {
  let r2 = null;
  return Object.entries(e2).forEach(([o2, s4]) => {
    if (r2)
      return;
    const i3 = on(o2, L3(o2, s4), `${n4} ${t2}`);
    i3 && (r2 = i3);
  }), r2;
}
function cn(e2, n4) {
  let t2 = null;
  return k3(e2) ? e2.forEach((r2) => {
    t2 || rn(r2) || (t2 = U("UNSUPPORTED_ACCOUNTS", `${n4}, account ${r2} should be a string and conform to "namespace:chainId:address" format`));
  }) : t2 = U("UNSUPPORTED_ACCOUNTS", `${n4}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t2;
}
function an(e2, n4) {
  let t2 = null;
  return Object.values(e2).forEach((r2) => {
    if (t2)
      return;
    const o2 = cn(r2?.accounts, `${n4} namespace`);
    o2 && (t2 = o2);
  }), t2;
}
function un(e2, n4) {
  let t2 = null;
  return ie(e2?.methods) ? ie(e2?.events) || (t2 = U("UNSUPPORTED_EVENTS", `${n4}, events should be an array of strings or empty array for no events`)) : t2 = U("UNSUPPORTED_METHODS", `${n4}, methods should be an array of strings or empty array for no methods`), t2;
}
function ce(e2, n4) {
  let t2 = null;
  return Object.values(e2).forEach((r2) => {
    if (t2)
      return;
    const o2 = un(r2, `${n4}, namespace`);
    o2 && (t2 = o2);
  }), t2;
}
function Lt(e2, n4, t2) {
  let r2 = null;
  if (e2 && B(e2)) {
    const o2 = ce(e2, n4);
    o2 && (r2 = o2);
    const s4 = sn(e2, n4, t2);
    s4 && (r2 = s4);
  } else
    r2 = N("MISSING_OR_INVALID", `${n4}, ${t2} should be an object with data`);
  return r2;
}
function ln(e2, n4) {
  let t2 = null;
  if (e2 && B(e2)) {
    const r2 = ce(e2, n4);
    r2 && (t2 = r2);
    const o2 = an(e2, n4);
    o2 && (t2 = o2);
  } else
    t2 = N("MISSING_OR_INVALID", `${n4}, namespaces should be an object with data`);
  return t2;
}
function dn(e2) {
  return h3(e2.protocol, true);
}
function xt(e2, n4) {
  let t2 = false;
  return n4 && !e2 ? t2 = true : e2 && k3(e2) && e2.length && e2.forEach((r2) => {
    t2 = dn(r2);
  }), t2;
}
function Ft(e2) {
  return typeof e2 == "number";
}
function Ht(e2) {
  return typeof e2 < "u" && typeof e2 !== null;
}
function qt(e2) {
  return !(!e2 || typeof e2 != "object" || !e2.code || !G(e2.code, false) || !e2.message || !h3(e2.message, false));
}
function Bt(e2) {
  return !(w(e2) || !h3(e2.method, false));
}
function Gt(e2) {
  return !(w(e2) || w(e2.result) && w(e2.error) || !G(e2.id, false) || !h3(e2.jsonrpc, false));
}
function Wt(e2) {
  return !(w(e2) || !h3(e2.name, false));
}
function zt(e2, n4) {
  return !(!V3(n4) || !Qe(e2).includes(n4));
}
function Yt(e2, n4, t2) {
  return h3(t2, false) ? Ze(e2, n4).includes(t2) : false;
}
function Jt(e2, n4, t2) {
  return h3(t2, false) ? Xe(e2, n4).includes(t2) : false;
}
function fn(e2, n4, t2) {
  let r2 = null;
  const o2 = Qt(e2), s4 = Zt(n4), i3 = Object.keys(o2), d2 = Object.keys(s4), l2 = pn(Object.keys(e2)), c2 = pn(Object.keys(n4)), u2 = l2.filter((a2) => !c2.includes(a2));
  return u2.length && (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u2.toString()}
      Received: ${Object.keys(n4).toString()}`)), O(i3, d2) || (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces chains don't satisfy required namespaces.
      Required: ${i3.toString()}
      Approved: ${d2.toString()}`)), Object.keys(n4).forEach((a2) => {
    if (!a2.includes(":") || r2)
      return;
    const b3 = A(n4[a2].accounts);
    b3.includes(a2) || (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces accounts don't satisfy namespace accounts for ${a2}
        Required: ${a2}
        Approved: ${b3.toString()}`));
  }), i3.forEach((a2) => {
    r2 || (O(o2[a2].methods, s4[a2].methods) ? O(o2[a2].events, s4[a2].events) || (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces events don't satisfy namespace events for ${a2}`)) : r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces methods don't satisfy namespace methods for ${a2}`));
  }), r2;
}
function Qt(e2) {
  const n4 = {};
  return Object.keys(e2).forEach((t2) => {
    var r2;
    t2.includes(":") ? n4[t2] = e2[t2] : (r2 = e2[t2].chains) == null || r2.forEach((o2) => {
      n4[o2] = { methods: e2[t2].methods, events: e2[t2].events };
    });
  }), n4;
}
function pn(e2) {
  return [...new Set(e2.map((n4) => n4.includes(":") ? n4.split(":")[0] : n4))];
}
function Zt(e2) {
  const n4 = {};
  return Object.keys(e2).forEach((t2) => {
    if (t2.includes(":"))
      n4[t2] = e2[t2];
    else {
      const r2 = A(e2[t2].accounts);
      r2?.forEach((o2) => {
        n4[o2] = { accounts: e2[t2].accounts.filter((s4) => s4.includes(`${o2}:`)), methods: e2[t2].methods, events: e2[t2].events };
      });
    }
  }), n4;
}
function Xt(e2, n4) {
  return G(e2, false) && e2 <= n4.max && e2 >= n4.min;
}
function er() {
  const e2 = T();
  return new Promise((n4) => {
    switch (e2) {
      case m.browser:
        n4(mn());
        break;
      case m.reactNative:
        n4(yn());
        break;
      case m.node:
        n4(hn());
        break;
      default:
        n4(true);
    }
  });
}
function mn() {
  return D() && navigator?.onLine;
}
async function yn() {
  if (C() && typeof global < "u" && global != null && global.NetInfo) {
    const e2 = await (global == null ? void 0 : global.NetInfo.fetch());
    return e2?.isConnected;
  }
  return true;
}
function hn() {
  return true;
}
function nr(e2) {
  switch (T()) {
    case m.browser:
      gn(e2);
      break;
    case m.reactNative:
      vn(e2);
      break;
  }
}
function gn(e2) {
  !C() && D() && (window.addEventListener("online", () => e2(true)), window.addEventListener("offline", () => e2(false)));
}
function vn(e2) {
  C() && typeof global < "u" && global != null && global.NetInfo && global?.NetInfo.addEventListener((n4) => e2(n4?.isConnected));
}
const ae = {};
class tr {
  static get(n4) {
    return ae[n4];
  }
  static set(n4, t2) {
    ae[n4] = t2;
  }
  static delete(n4) {
    delete ae[n4];
  }
}
var NAMESPACE = "eip155";
var STORE_KEY = "store";
var REQUESTED_CHAINS_KEY = "requestedChains";
var ADD_ETH_CHAIN_METHOD = "wallet_addEthereumChain";
var _provider, _initProviderPromise, _createProvider, createProvider_fn, _initProvider, initProvider_fn, _isChainsStale, isChainsStale_fn, _setupListeners, setupListeners_fn, _removeListeners, removeListeners_fn, _setRequestedChainsIds, setRequestedChainsIds_fn, _getRequestedChainsIds, getRequestedChainsIds_fn, _getNamespaceChainsIds, getNamespaceChainsIds_fn, _getNamespaceMethods, getNamespaceMethods_fn;
var WalletConnectConnector = class extends Connector {
  constructor(config2) {
    super({
      ...config2,
      options: { isNewChainsStale: true, ...config2.options }
    });
    __privateAdd$1(this, _createProvider);
    __privateAdd$1(this, _initProvider);
    __privateAdd$1(this, _isChainsStale);
    __privateAdd$1(this, _setupListeners);
    __privateAdd$1(this, _removeListeners);
    __privateAdd$1(this, _setRequestedChainsIds);
    __privateAdd$1(this, _getRequestedChainsIds);
    __privateAdd$1(this, _getNamespaceChainsIds);
    __privateAdd$1(this, _getNamespaceMethods);
    this.id = "walletConnect";
    this.name = "WalletConnect";
    this.ready = true;
    __privateAdd$1(this, _provider, void 0);
    __privateAdd$1(this, _initProviderPromise, void 0);
    this.onAccountsChanged = (accounts) => {
      if (accounts.length === 0)
        this.emit("disconnect");
      else
        this.emit("change", { account: getAddress(accounts[0]) });
    };
    this.onChainChanged = (chainId2) => {
      const id2 = Number(chainId2);
      const unsupported = this.isChainUnsupported(id2);
      this.emit("change", { chain: { id: id2, unsupported } });
    };
    this.onDisconnect = () => {
      __privateMethod$1(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, []);
      this.emit("disconnect");
    };
    this.onDisplayUri = (uri) => {
      this.emit("message", { type: "display_uri", data: uri });
    };
    this.onConnect = () => {
      this.emit("connect", {});
    };
    __privateMethod$1(this, _createProvider, createProvider_fn).call(this);
  }
  async connect({ chainId: chainId2, pairingTopic } = {}) {
    try {
      let targetChainId = chainId2;
      if (!targetChainId) {
        const store = this.storage?.getItem(STORE_KEY);
        const lastUsedChainId = store?.state?.data?.chain?.id;
        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId))
          targetChainId = lastUsedChainId;
        else
          targetChainId = this.chains[0]?.id;
      }
      if (!targetChainId)
        throw new Error("No chains found on connector.");
      const provider = await this.getProvider();
      __privateMethod$1(this, _setupListeners, setupListeners_fn).call(this);
      const isChainsStale = __privateMethod$1(this, _isChainsStale, isChainsStale_fn).call(this);
      if (provider.session && isChainsStale)
        await provider.disconnect();
      if (!provider.session || isChainsStale) {
        const optionalChains = this.chains.filter((chain) => chain.id !== targetChainId).map((optionalChain) => optionalChain.id);
        this.emit("message", { type: "connecting" });
        await provider.connect({
          pairingTopic,
          optionalChains: [targetChainId, ...optionalChains]
        });
        __privateMethod$1(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, this.chains.map(({ id: id22 }) => id22));
      }
      const accounts = await provider.enable();
      const account = getAddress(accounts[0]);
      const id2 = await this.getChainId();
      const unsupported = this.isChainUnsupported(id2);
      return {
        account,
        chain: { id: id2, unsupported }
      };
    } catch (error) {
      if (/user rejected/i.test(error?.message)) {
        throw new UserRejectedRequestError(error);
      }
      throw error;
    }
  }
  async disconnect() {
    const provider = await this.getProvider();
    try {
      await provider.disconnect();
    } catch (error) {
      if (!/No matching key/i.test(error.message))
        throw error;
    } finally {
      __privateMethod$1(this, _removeListeners, removeListeners_fn).call(this);
      __privateMethod$1(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, []);
    }
  }
  async getAccount() {
    const { accounts } = await this.getProvider();
    return getAddress(accounts[0]);
  }
  async getChainId() {
    const { chainId: chainId2 } = await this.getProvider();
    return chainId2;
  }
  async getProvider({ chainId: chainId2 } = {}) {
    if (!__privateGet$1(this, _provider))
      await __privateMethod$1(this, _createProvider, createProvider_fn).call(this);
    if (chainId2)
      await this.switchChain(chainId2);
    return __privateGet$1(this, _provider);
  }
  async getWalletClient({
    chainId: chainId2
  } = {}) {
    const [provider, account] = await Promise.all([
      this.getProvider({ chainId: chainId2 }),
      this.getAccount()
    ]);
    const chain = this.chains.find((x2) => x2.id === chainId2);
    if (!provider)
      throw new Error("provider is required.");
    return createWalletClient({
      account,
      chain,
      transport: custom$1(provider)
    });
  }
  async isAuthorized() {
    try {
      const [account, provider] = await Promise.all([
        this.getAccount(),
        this.getProvider()
      ]);
      const isChainsStale = __privateMethod$1(this, _isChainsStale, isChainsStale_fn).call(this);
      if (!account)
        return false;
      if (isChainsStale && provider.session) {
        try {
          await provider.disconnect();
        } catch {
        }
        return false;
      }
      return true;
    } catch {
      return false;
    }
  }
  async switchChain(chainId2) {
    const chain = this.chains.find((chain2) => chain2.id === chainId2);
    if (!chain)
      throw new SwitchChainError(new Error("chain not found on connector."));
    try {
      const provider = await this.getProvider();
      const namespaceChains = __privateMethod$1(this, _getNamespaceChainsIds, getNamespaceChainsIds_fn).call(this);
      const namespaceMethods = __privateMethod$1(this, _getNamespaceMethods, getNamespaceMethods_fn).call(this);
      const isChainApproved = namespaceChains.includes(chainId2);
      if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {
        await provider.request({
          method: ADD_ETH_CHAIN_METHOD,
          params: [
            {
              chainId: numberToHex(chain.id),
              blockExplorerUrls: [chain.blockExplorers?.default?.url],
              chainName: chain.name,
              nativeCurrency: chain.nativeCurrency,
              rpcUrls: [...chain.rpcUrls.default.http]
            }
          ]
        });
        const requestedChains = __privateMethod$1(this, _getRequestedChainsIds, getRequestedChainsIds_fn).call(this);
        requestedChains.push(chainId2);
        __privateMethod$1(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, requestedChains);
      }
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: numberToHex(chainId2) }]
      });
      return chain;
    } catch (error) {
      const message = typeof error === "string" ? error : error?.message;
      if (/user rejected request/i.test(message)) {
        throw new UserRejectedRequestError(error);
      }
      throw new SwitchChainError(error);
    }
  }
};
_provider = /* @__PURE__ */ new WeakMap();
_initProviderPromise = /* @__PURE__ */ new WeakMap();
_createProvider = /* @__PURE__ */ new WeakSet();
createProvider_fn = async function() {
  if (!__privateGet$1(this, _initProviderPromise) && typeof window !== "undefined") {
    __privateSet$1(this, _initProviderPromise, __privateMethod$1(this, _initProvider, initProvider_fn).call(this));
  }
  return __privateGet$1(this, _initProviderPromise);
};
_initProvider = /* @__PURE__ */ new WeakSet();
initProvider_fn = async function() {
  const { EthereumProvider } = await __vitePreload(() => import("./index.es-5eEELIYv.js"), true ? __vite__mapDeps([]) : void 0);
  const optionalChains = this.chains.map(({ id: id2 }) => id2);
  if (optionalChains.length) {
    const {
      projectId: projectId2,
      showQrModal = true,
      qrModalOptions,
      metadata: metadata2,
      relayUrl
    } = this.options;
    __privateSet$1(this, _provider, await EthereumProvider.init({
      showQrModal,
      qrModalOptions,
      projectId: projectId2,
      optionalChains,
      rpcMap: Object.fromEntries(
        this.chains.map((chain) => [
          chain.id,
          chain.rpcUrls.default.http[0]
        ])
      ),
      metadata: metadata2,
      relayUrl
    }));
  }
};
_isChainsStale = /* @__PURE__ */ new WeakSet();
isChainsStale_fn = function() {
  const namespaceMethods = __privateMethod$1(this, _getNamespaceMethods, getNamespaceMethods_fn).call(this);
  if (namespaceMethods.includes(ADD_ETH_CHAIN_METHOD))
    return false;
  if (!this.options.isNewChainsStale)
    return false;
  const requestedChains = __privateMethod$1(this, _getRequestedChainsIds, getRequestedChainsIds_fn).call(this);
  const connectorChains = this.chains.map(({ id: id2 }) => id2);
  const namespaceChains = __privateMethod$1(this, _getNamespaceChainsIds, getNamespaceChainsIds_fn).call(this);
  if (namespaceChains.length && !namespaceChains.some((id2) => connectorChains.includes(id2)))
    return false;
  return !connectorChains.every((id2) => requestedChains.includes(id2));
};
_setupListeners = /* @__PURE__ */ new WeakSet();
setupListeners_fn = function() {
  if (!__privateGet$1(this, _provider))
    return;
  __privateMethod$1(this, _removeListeners, removeListeners_fn).call(this);
  __privateGet$1(this, _provider).on("accountsChanged", this.onAccountsChanged);
  __privateGet$1(this, _provider).on("chainChanged", this.onChainChanged);
  __privateGet$1(this, _provider).on("disconnect", this.onDisconnect);
  __privateGet$1(this, _provider).on("session_delete", this.onDisconnect);
  __privateGet$1(this, _provider).on("display_uri", this.onDisplayUri);
  __privateGet$1(this, _provider).on("connect", this.onConnect);
};
_removeListeners = /* @__PURE__ */ new WeakSet();
removeListeners_fn = function() {
  if (!__privateGet$1(this, _provider))
    return;
  __privateGet$1(this, _provider).removeListener("accountsChanged", this.onAccountsChanged);
  __privateGet$1(this, _provider).removeListener("chainChanged", this.onChainChanged);
  __privateGet$1(this, _provider).removeListener("disconnect", this.onDisconnect);
  __privateGet$1(this, _provider).removeListener("session_delete", this.onDisconnect);
  __privateGet$1(this, _provider).removeListener("display_uri", this.onDisplayUri);
  __privateGet$1(this, _provider).removeListener("connect", this.onConnect);
};
_setRequestedChainsIds = /* @__PURE__ */ new WeakSet();
setRequestedChainsIds_fn = function(chains2) {
  this.storage?.setItem(REQUESTED_CHAINS_KEY, chains2);
};
_getRequestedChainsIds = /* @__PURE__ */ new WeakSet();
getRequestedChainsIds_fn = function() {
  return this.storage?.getItem(REQUESTED_CHAINS_KEY) ?? [];
};
_getNamespaceChainsIds = /* @__PURE__ */ new WeakSet();
getNamespaceChainsIds_fn = function() {
  if (!__privateGet$1(this, _provider))
    return [];
  const namespaces = __privateGet$1(this, _provider).session?.namespaces;
  if (!namespaces)
    return [];
  const normalizedNamespaces = se(namespaces);
  const chainIds = normalizedNamespaces[NAMESPACE]?.chains?.map(
    (chain) => parseInt(chain.split(":")[1] || "")
  );
  return chainIds ?? [];
};
_getNamespaceMethods = /* @__PURE__ */ new WeakSet();
getNamespaceMethods_fn = function() {
  if (!__privateGet$1(this, _provider))
    return [];
  const namespaces = __privateGet$1(this, _provider).session?.namespaces;
  if (!namespaces)
    return [];
  const normalizedNamespaces = se(namespaces);
  const methods = normalizedNamespaces[NAMESPACE]?.methods;
  return methods ?? [];
};
function publicProvider() {
  return function(chain) {
    if (!chain.rpcUrls.public.http[0])
      return null;
    return {
      chain,
      rpcUrls: chain.rpcUrls.public
    };
  };
}
class EmailConnector extends Connector {
  constructor(config2) {
    super(config2);
    this.id = "w3mEmail";
    this.name = "Web3Modal Email";
    this.ready = true;
    this.provider = {};
    if (typeof window !== "undefined") {
      this.provider = new W3mFrameProvider(config2.options.projectId);
    }
  }
  async getProvider() {
    return Promise.resolve(this.provider);
  }
  async connect(options = {}) {
    const { address, chainId: chainId2 } = await this.provider.connect({ chainId: options.chainId });
    return {
      account: address,
      chain: {
        id: chainId2,
        unsupported: this.isChainUnsupported(1)
      }
    };
  }
  async switchChain(chainId2) {
    try {
      const chain = this.chains.find((c2) => c2.id === chainId2);
      if (!chain) {
        throw new SwitchChainError(new Error("chain not found on connector."));
      }
      await this.provider.switchNetwork(chainId2);
      const unsupported = this.isChainUnsupported(chainId2);
      this.emit("change", { chain: { id: chainId2, unsupported } });
      return chain;
    } catch (error) {
      if (error instanceof Error) {
        throw new SwitchChainError(error);
      }
      throw error;
    }
  }
  async disconnect() {
    await this.provider.disconnect();
  }
  async getAccount() {
    const { address } = await this.provider.connect();
    return address;
  }
  async getChainId() {
    const { chainId: chainId2 } = await this.provider.getChainId();
    return chainId2;
  }
  async getWalletClient() {
    const { address, chainId: chainId2 } = await this.provider.connect();
    return Promise.resolve(createWalletClient({
      account: address,
      chain: { id: chainId2 },
      transport: custom$1(this.provider)
    }));
  }
  async isAuthorized() {
    const { isConnected } = await this.provider.isConnected();
    return isConnected;
  }
  onAccountsChanged() {
  }
  onChainChanged() {
  }
  onDisconnect() {
  }
}
const RPC_URL = CoreHelperUtil.getBlockchainApiUrl();
function walletConnectProvider({ projectId: projectId2 }) {
  return function provider(chain) {
    if (!PresetsUtil.WalletConnectRpcChainIds.includes(chain.id)) {
      return null;
    }
    const baseHttpUrl = `${RPC_URL}/v1/?chainId=${ConstantsUtil.EIP155}:${chain.id}&projectId=${projectId2}`;
    return {
      chain: {
        ...chain,
        rpcUrls: {
          ...chain.rpcUrls,
          default: { http: [baseHttpUrl] }
        }
      },
      rpcUrls: {
        http: [baseHttpUrl]
      }
    };
  };
}
function defaultWagmiConfig({ projectId: projectId2, chains: chains2, metadata: metadata2, enableInjected, enableCoinbase, enableEIP6963, enableEmail, enableWalletConnect }) {
  const { publicClient } = configureChains(chains2, [
    walletConnectProvider({ projectId: projectId2 }),
    publicProvider()
  ]);
  const connectors = [];
  if (enableWalletConnect !== false) {
    connectors.push(new WalletConnectConnector({ chains: chains2, options: { projectId: projectId2, showQrModal: false, metadata: metadata2 } }));
  }
  if (enableInjected !== false) {
    connectors.push(new InjectedConnector({ chains: chains2, options: { shimDisconnect: true } }));
  }
  if (enableEIP6963 !== false) {
    connectors.push(new EIP6963Connector({ chains: chains2 }));
  }
  if (enableCoinbase !== false) {
    connectors.push(new CoinbaseWalletConnector({ chains: chains2, options: { appName: metadata2?.name ?? "Unknown" } }));
  }
  if (enableEmail === true) {
    connectors.push(new EmailConnector({ chains: chains2, options: { projectId: projectId2 } }));
  }
  return createConfig({
    autoConnect: true,
    connectors,
    publicClient
  });
}
let modal = void 0;
function createWeb3Modal(options) {
  if (!modal) {
    modal = new Web3Modal({
      ...options,
      _sdkVersion: `vue-wagmi-${ConstantsUtil.VERSION}`
    });
    getWeb3Modal(modal);
  }
  return modal;
}
const projectId = "05c6fd6b3708f60c6c5dcdd31968eeef";
const metadata = {
  name: "Web3Modal",
  description: "Web3Modal Example",
  url: "http://web3modal.com",
  icons: ["http://avatars.githubusercontent.com/u/37784886"]
};
const chains = [mainnet, arbitrum];
const wagmiConfig = defaultWagmiConfig({ chains, projectId, metadata });
createWeb3Modal({ wagmiConfig, projectId, chains });
const colors = colorTokens();
const Home = () => {
  const [provider, setProvider] = reactExports.useState(void 0);
  const { open, close } = useWeb3Modal();
  const [activeButton, setActiveButton] = reactExports.useState(null);
  const [userAccount, setAccount] = reactExports.useState(null);
  const [wethAmount, setWethAmount2] = reactExports.useState(void 0);
  const [uniAmount, setUniAmount2] = reactExports.useState(void 0);
  const connect2 = async () => {
    open();
  };
  reactExports.useEffect(() => {
    const onLoad = async () => {
      const provider2 = await new Web3Provider$1(window.ethereum);
      setProvider(provider2);
      provider2.send("eth_requestAccounts", []);
      provider2.getSigner();
    };
    onLoad();
    const account = getAccount();
    account !== void 0 ? setAccount(account) : setAccount(null);
  }, [activeButton]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack$1, { py: { xs: 3, sm: 5 }, px: { xs: 3, sm: 10 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button$1,
      {
        sx: { fontSize: 16, fontWeight: "bold" },
        variant: "contained",
        color: "primary",
        onClick: () => {
          connect2();
        },
        children: "Connect Wallet"
      }
    ),
    userAccount !== null ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Typography$1,
      {
        variant: "h1",
        className: "wp-block-heading has-text-align-center custom-animation",
        sx: { marginTop: "20px", fontSize: { xs: 10, sm: 20 }, fontWeight: "bold" },
        color: "#fff",
        textAlign: "center",
        children: userAccount.address
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "none" } }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { mt: 5, container: true, justifyContent: "center", alignItems: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, xs: 12, sm: 6, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        className: "zoom-in-out",
        style: { width: "100%" },
        src: "./trucking-empire-logo.png",
        alt: "Logo"
      }
    ) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Typography$1,
      {
        variant: "h1",
        className: "wp-block-heading has-text-align-center custom-animation",
        sx: { fontSize: { xs: 30, sm: 50 }, fontWeight: "bold" },
        color: "#fff",
        textAlign: "center",
        children: "Trucking Empire Dex"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Stack$1, { mt: 12, justifyContent: "center", alignItems: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Link$1,
      {
        className: "animated-text",
        fontSize: 20,
        color: "secondary",
        href: "mailto:support@truckingempire.io",
        children: "support@truckingempire.io"
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Stack$1,
      {
        sx: {
          border: `5px solid ${colors.yellow[500]}`,
          p: { xs: 2, sm: 4 },
          borderRadius: 2
        },
        mt: 3,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Stack$1,
            {
              flexDirection: "row",
              alignItems: "center",
              justifyContent: { xs: "center", sm: "flex-start" },
              flexWrap: "wrap",
              gap: 2,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$1,
                  {
                    variant: "outlined",
                    sx: {
                      color: colors.yellow[500],
                      fontSize: 20,
                      borderColor: colors.yellow[500],
                      "&:hover": {
                        backgroundColor: colors.yellow[500],
                        color: theme.palette.getContrastText(colors.yellow[500])
                      },
                      width: 140
                    },
                    onClick: () => setActiveButton("swap"),
                    children: "Swap"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$1,
                  {
                    variant: "outlined",
                    sx: {
                      color: colors.yellow[500],
                      fontSize: 20,
                      borderColor: colors.yellow[500],
                      "&:hover": {
                        backgroundColor: colors.yellow[500],
                        color: theme.palette.getContrastText(colors.yellow[500])
                      },
                      width: 140
                    },
                    onClick: () => setActiveButton("liquidity"),
                    children: "Liquidity"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$1,
                  {
                    variant: "outlined",
                    sx: {
                      color: colors.yellow[500],
                      fontSize: 20,
                      borderColor: colors.yellow[500],
                      "&:hover": {
                        backgroundColor: colors.yellow[500],
                        color: theme.palette.getContrastText(colors.yellow[500])
                      },
                      width: 140
                    },
                    onClick: () => setActiveButton("staking"),
                    children: "Staking"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$1,
                  {
                    variant: "outlined",
                    sx: {
                      color: colors.yellow[500],
                      fontSize: 20,
                      borderColor: colors.yellow[500],
                      "&:hover": {
                        backgroundColor: colors.yellow[500],
                        color: theme.palette.getContrastText(colors.yellow[500])
                      },
                      width: 140
                    },
                    onClick: () => setActiveButton("nftMarket"),
                    children: "NFT Market"
                  }
                )
              ]
            }
          ),
          activeButton === "swap" && /* @__PURE__ */ jsxRuntimeExports.jsx(Swap, { user: userAccount.address, balance: wethAmount, unibal: uniAmount, activeButton }),
          activeButton === "liquidity" && /* @__PURE__ */ jsxRuntimeExports.jsx(Liquidity, { user: userAccount }),
          activeButton === "staking" && /* @__PURE__ */ jsxRuntimeExports.jsx(Staking, { user: userAccount, activeButton }),
          activeButton === "nftMarket" && /* @__PURE__ */ jsxRuntimeExports.jsx(NFTMarket, { user: userAccount })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack$1, { py: { xs: 3, sm: 15 }, px: { xs: 3, sm: 10 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Stack$1,
        {
          sx: {
            gap: "20px",
            flexDirection: "row",
            justifyContent: "center"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Link$1,
              {
                color: "secondary",
                href: "https://twitter.com/Trucking_Empire",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "link", src: twitterLogo, alt: "" })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Link$1,
              {
                color: "secondary",
                href: "https://www.instagram.com/truckingempire.io/",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "link", src: instaLogo, alt: "" })
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography$1,
        {
          variant: "h1",
          sx: { fontSize: { xs: 15, sm: 20 }, fontWeight: "thin" },
          color: "#ff6900",
          textAlign: "center",
          children: "Copyright Semi Token Corporation 2023"
        }
      )
    ] })
  ] });
};
function App() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ThemeProvider, { theme, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CssBaseline, { enableColorScheme: true }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Home, {})
  ] }) });
}
client.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(App, {})
);
export {
  $,
  fromString as A,
  BaseError as B,
  toString as C,
  concat as D,
  commonjsGlobal as E,
  getDefaultExportFromCjs as F,
  w as G,
  HttpRequestError as H,
  InvalidAddressError as I,
  kn as J,
  Vn as K,
  Mn as L,
  Mt as M,
  N,
  Kn as O,
  Ae as P,
  qn as Q,
  xn as R,
  Hn as S,
  Fn as T,
  ee as U,
  Vt as V,
  p as W,
  Jn as X,
  ut as Y,
  er as Z,
  __vitePreload as _,
  getEnsAvatar as a,
  Xn as a0,
  nr as a1,
  $g as a2,
  _ as a3,
  pt as a4,
  It as a5,
  wt as a6,
  at as a7,
  yt as a8,
  U as a9,
  fn as aA,
  qt as aB,
  dn as aC,
  Kt as aD,
  zt as aE,
  Bt as aF,
  Yt as aG,
  Xt as aH,
  Gt as aI,
  Wt as aJ,
  Jt as aK,
  Ft as aL,
  fetch$1 as aM,
  en as aN,
  oe as aO,
  S3 as aP,
  ve as aQ,
  Un as aR,
  buffer as aS,
  inherits_browserExports as aT,
  require$$3$1 as aU,
  bnExports as aV,
  __extends as aW,
  mt as aa,
  Ht as ab,
  kt as ac,
  h3 as ad,
  ft as ae,
  lt as af,
  dt as ag,
  C as ah,
  D as ai,
  te as aj,
  rt as ak,
  ot as al,
  Ln as am,
  vt as an,
  Et as ao,
  k3 as ap,
  Qn as aq,
  B as ar,
  jt as as,
  gt as at,
  ht as au,
  Dt as av,
  tr as aw,
  xt as ax,
  Lt as ay,
  ln as az,
  getEnsName as b,
  getEnsResolver as c,
  getEnsText as d,
  snapshot as e,
  getUrl as f,
  getEnsAddress as g,
  stringify as h,
  isAddress as i,
  decodeErrorResult as j,
  call as k,
  labelhash as l,
  concat$1 as m,
  namehash as n,
  encodeAbiParameters as o,
  proxy as p,
  isHex as q,
  browser$1 as r,
  subscribe as s,
  getAugmentedNamespace as t,
  require$$0 as u,
  cjs$2 as v,
  eventsExports as w,
  binary as x,
  wipe$1 as y,
  random as z
};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = []
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
